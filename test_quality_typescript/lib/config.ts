/**
 * Configuration management for Complex CLI Test Tool
 * Generated by goobits-cli
 */

import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

// Custom Exception Classes for Configuration Management
export class ConfigError extends Error {
    public suggestion: string | null;
    public configPath: string | null;

    constructor(message: string, suggestion: string | null = null, configPath: string | null = null) {
        super(message);
        this.name = 'ConfigError';
        this.suggestion = suggestion;
        this.configPath = configPath;
    }
}

export class ConfigFileError extends ConfigError {
    constructor(message: string, configPath: string, suggestion: string | null = null) {
        super(message, suggestion, configPath);
        this.name = 'ConfigFileError';
    }
}

export class ConfigValidationError extends ConfigError {
    public key: string;
    public value: any;

    constructor(message: string, key: string, value: any = null, suggestion: string | null = null) {
        super(message, suggestion);
        this.name = 'ConfigValidationError';
        this.key = key;
        this.value = value;
    }
}

// Try to load optional dependencies
let yaml: any, toml: any;
let HAS_YAML = false;
let HAS_TOML = false;

try {
    yaml = require('js-yaml');
    HAS_YAML = true;
    if (process.env.DEBUG) console.debug('js-yaml library loaded successfully');
} catch (e: any) {
    if (process.env.DEBUG) console.debug('js-yaml library not available:', e.message);
}

try {
    toml = require('@iarna/toml');
    HAS_TOML = true;
    if (process.env.DEBUG) console.debug('@iarna/toml library loaded successfully');
} catch (e: any) {
    if (process.env.DEBUG) console.debug('@iarna/toml library not available:', e.message);
}

// Type definitions
export interface ConfigOptions {
    [key: string]: any;
}

export interface RcFileInstructions {
    scriptPath: string;
    userScriptPath: string;
    installCmd: string;
    userInstallCmd: string;
    reloadCmd: string;
}

export class ConfigManager {
    private packageName: string;
    private configDirName: string;
    private configFileName: string;
    protected _config: ConfigOptions | null;
    protected _configPath: string | null;

    /**
     * Configuration manager for Complex CLI Test Tool
     */
    constructor() {
        this.packageName = 'complex-cli-test';
        this.configDirName = 'complex-cli-test';
        this.configFileName = 'config.json';
        this._config = null;
        this._configPath = null;
    }

    /**
     * Get the configuration directory path based on platform
     */
    getConfigDir(): string {
        const homeDir = os.homedir();
        
        if (process.platform === 'win32') {
            // Windows: Use APPDATA or fallback to home
            const appData = process.env.APPDATA;
            if (appData) {
                return path.join(appData, this.configDirName);
            }
            return path.join(homeDir, this.configDirName);
        } else if (process.platform === 'darwin') {
            // macOS: Use ~/Library/Application Support
            return path.join(homeDir, 'Library', 'Application Support', this.configDirName);
        } else {
            // Linux and others: Use XDG_CONFIG_HOME or ~/.config
            const xdgConfig = process.env.XDG_CONFIG_HOME;
            if (xdgConfig) {
                return path.join(xdgConfig, this.configDirName);
            }
            return path.join(homeDir, '.config', this.configDirName);
        }
    }

    /**
     * Get the full path to the configuration file
     */
    getConfigPath(): string {
        if (!this._configPath) {
            this._configPath = path.join(this.getConfigDir(), this.configFileName);
        }
        return this._configPath;
    }

    /**
     * Ensure the configuration directory exists with enhanced error handling
     */
    ensureConfigDir(): void {
        const configDir = this.getConfigDir();
        try {
            fs.mkdirSync(configDir, { recursive: true });
            if (process.env.DEBUG) console.debug(`Ensured config directory exists: ${configDir}`);
        } catch (error: any) {
            if (error.code === 'EACCES' || error.code === 'EPERM') {
                throw new ConfigFileError(
                    'Permission denied creating configuration directory',
                    configDir,
                    `Ensure you have write permissions for ${path.dirname(configDir)}`
                );
            }
            throw new ConfigFileError(
                `Failed to create configuration directory: ${error.message}`,
                configDir,
                'Check disk space and parent directory permissions'
            );
        }
    }

    /**
     * Load configuration from file with enhanced error handling
     */
    load(): ConfigOptions {
        const configPath = this.getConfigPath();
        
        try {
            if (fs.existsSync(configPath)) {
                try {
                    const data = fs.readFileSync(configPath, 'utf8');
                    this._config = JSON.parse(data);
                    if (process.env.DEBUG) console.debug(`Loaded configuration from ${configPath}`);
                } catch (error: any) {
                    if (error instanceof SyntaxError) {
                        throw new ConfigFileError(
                            `Invalid JSON in configuration file: ${error.message}`,
                            configPath,
                            'Check the JSON syntax in your configuration file'
                        );
                    } else if (error.code === 'EACCES' || error.code === 'EPERM') {
                        throw new ConfigFileError(
                            'Permission denied reading configuration file',
                            configPath,
                            `Ensure you have read permissions for ${configPath}`
                        );
                    } else {
                        throw new ConfigFileError(
                            `Unable to read configuration file: ${error.message}`,
                            configPath,
                            'Ensure the file exists and is readable'
                        );
                    }
                }
            } else {
                // Create default config if file doesn't exist
                this._config = this.getDefaults();
                if (!this.save()) {
                    console.warn('Failed to save default configuration');
                } else {
                    console.info(`Created default configuration at ${configPath}`);
                }
            }
        } catch (error: any) {
            if (error instanceof ConfigError) {
                throw error; // Re-raise our custom errors
            }
            console.error(`Unexpected error loading config: ${error.message}`);
            this._config = this.getDefaults();
        }

        return this._config!;
    }

    /**
     * Save configuration to file with enhanced error handling
     */
    save(): boolean {
        if (this._config === null) {
            console.warn('No configuration to save');
            return false;
        }

        try {
            this.ensureConfigDir();
            const configPath = this.getConfigPath();

            // Validate that config can be serialized
            let jsonData: string;
            try {
                jsonData = JSON.stringify(this._config, null, 2);
            } catch (error: any) {
                throw new ConfigValidationError(
                    `Configuration contains non-serializable data: ${error.message}`,
                    '<root>',
                    null,
                    'Remove or convert non-JSON-serializable values (functions, classes, etc.)'
                );
            }

            // Write to temp file first, then move (atomic operation)
            const tempPath = configPath + '.tmp';
            try {
                fs.writeFileSync(tempPath, jsonData, 'utf8');
                fs.renameSync(tempPath, configPath);
                if (process.env.DEBUG) console.debug(`Saved configuration to ${configPath}`);
                return true;
            } catch (error: any) {
                // Clean up temp file
                try {
                    fs.unlinkSync(tempPath);
                } catch (e) {
                    // Ignore cleanup errors
                }

                if (error.code === 'EACCES' || error.code === 'EPERM') {
                    throw new ConfigFileError(
                        'Permission denied writing configuration file',
                        configPath,
                        `Ensure you have write permissions for ${path.dirname(configPath)}`
                    );
                }
                throw new ConfigFileError(
                    `Failed to write configuration file: ${error.message}`,
                    configPath,
                    'Check disk space and file permissions'
                );
            }
        } catch (error: any) {
            if (error instanceof ConfigError) {
                throw error; // Re-raise our custom errors
            }
            console.error(`Unexpected error saving config: ${error.message}`);
            return false;
        }
    }

    /**
     * Get configuration value by key (supports nested keys with dot notation)
     */
    get<T = any>(key?: string, defaultValue: T | null = null): T {
        if (!this._config) {
            this.load();
        }

        if (!key) {
            return this._config as T;
        }

        // Support nested keys (e.g., 'api.endpoint')
        const keys = key.split('.');
        let value: any = this._config;

        for (const k of keys) {
            if (value && typeof value === 'object' && k in value) {
                value = value[k];
            } else {
                return defaultValue as T;
            }
        }

        return value as T;
    }

    /**
     * Set configuration value by key with validation (supports nested keys with dot notation)
     */
    set(key: string, value: any): boolean {
        if (!key) {
            throw new ConfigValidationError(
                'Configuration key cannot be empty',
                '<empty>',
                null,
                'Provide a valid configuration key'
            );
        }

        if (!this._config) {
            this.load();
        }

        // Validate the value can be serialized
        try {
            JSON.stringify(value);
        } catch (error: any) {
            throw new ConfigValidationError(
                `Configuration value is not JSON serializable: ${error.message}`,
                key,
                String(value),
                'Use only JSON-compatible types (string, number, boolean, array, object)'
            );
        }

        const keys = key.split('.');
        let current: any = this._config;

        // Navigate to the nested location
        for (let i = 0; i < keys.length - 1; i++) {
            const k = keys[i];
            if (!(k in current) || typeof current[k] !== 'object' || current[k] === null) {
                current[k] = {};
            }
            current = current[k];
        }

        // Set the value
        const finalKey = keys[keys.length - 1];
        const oldValue = current[finalKey];
        current[finalKey] = value;

        // Auto-save with rollback on failure
        if (!this.save()) {
            // Rollback the change
            if (oldValue !== undefined) {
                current[finalKey] = oldValue;
            } else {
                delete current[finalKey];
            }
            return false;
        }

        if (process.env.DEBUG) console.debug(`Set configuration ${key} = ${value}`);
        return true;
    }

    /**
     * Delete configuration value by key
     */
    delete(key: string): boolean {
        if (!this._config) {
            this.load();
        }

        const keys = key.split('.');
        let current: any = this._config;

        // Navigate to the parent of the key to delete
        for (let i = 0; i < keys.length - 1; i++) {
            const k = keys[i];
            if (!(k in current) || typeof current[k] !== 'object') {
                return false; // Key doesn't exist
            }
            current = current[k];
        }

        const finalKey = keys[keys.length - 1];
        // Delete the key
        if (finalKey in current) {
            delete current[finalKey];
            // Auto-save
            return this.save();
        }

        return false;
    }

    /**
     * Reset configuration to defaults
     */
    reset(): boolean {
        this._config = this.getDefaults();
        return this.save();
    }

    /**
     * Get default configuration
     */
    getDefaults(): ConfigOptions {
        return {
            version: '1.0.0',
            
            // Add your default configuration here
            
        };
    }

    /**
     * Merge configuration with environment variables
     */
    mergeWithEnv(): void {
        const prefix = 'COMPLEX_CLI_TEST_';

        for (const [key, value] of Object.entries(process.env)) {
            if (key.startsWith(prefix) && value !== undefined) {
                const configKey = key.substring(prefix.length).toLowerCase().replace(/_/g, '.');

                // Try to parse as JSON, fallback to string
                let parsedValue: any;
                try {
                    parsedValue = JSON.parse(value);
                } catch (e) {
                    parsedValue = value;
                }

                this.set(configKey, parsedValue);
            }
        }
    }
}

export class RCConfigLoader extends ConfigManager {
    private rcFileNames: string[];

    /**
     * Configuration loader that supports RC files in multiple formats
     */
    constructor() {
        super();
        this.rcFileNames = [
            `.${this.packageName}rc`,
            `.${this.packageName}rc.json`,
            `.${this.packageName}rc.yaml`,
            `.${this.packageName}rc.yml`,
            `.${this.packageName}rc.toml`,
            `${this.packageName}.config.json`,
            `${this.packageName}.config.yaml`,
            `${this.packageName}.config.yml`,
            `${this.packageName}.config.toml`,
        ];
    }

    /**
     * Find RC file in current directory or parent directories
     */
    findRcFile(startDir: string | null = null): string | null {
        if (!startDir) {
            startDir = process.cwd();
        }

        let currentDir = path.resolve(startDir);
        const searchDirs: string[] = [];

        // Walk up the directory tree
        while (currentDir !== path.dirname(currentDir)) {
            searchDirs.push(currentDir);
            currentDir = path.dirname(currentDir);
        }

        // Add home directory
        searchDirs.push(os.homedir());

        for (const directory of searchDirs) {
            for (const fileName of this.rcFileNames) {
                const filePath = path.join(directory, fileName);
                if (fs.existsSync(filePath) && fs.statSync(filePath).isFile()) {
                    return filePath;
                }
            }
        }

        return null;
    }

    /**
     * Load configuration from RC file
     */
    loadRcFile(rcPath: string | null = null): ConfigOptions | null {
        if (!rcPath) {
            rcPath = this.findRcFile();
        }

        if (!rcPath || !fs.existsSync(rcPath)) {
            return null;
        }

        try {
            const content = fs.readFileSync(rcPath, 'utf8');
            const ext = path.extname(rcPath).toLowerCase();

            if (ext === '.yaml' || ext === '.yml') {
                if (!HAS_YAML) {
                    console.warn(
                        'js-yaml not installed. Install it to use YAML config files: ' +
                        'npm install js-yaml'
                    );
                    return null;
                }
                return yaml.load(content);
            } else if (ext === '.toml') {
                if (!HAS_TOML) {
                    console.warn(
                        '@iarna/toml not available. Install it to use TOML config files: ' +
                        'npm install @iarna/toml'
                    );
                    return null;
                }
                return toml.parse(content);
            } else {
                // Default to JSON
                return JSON.parse(content);
            }
        } catch (error: any) {
            if (error instanceof SyntaxError) {
                throw new ConfigFileError(
                    `Invalid format in RC file: ${error.message}`,
                    rcPath,
                    'Check the file syntax'
                );
            }
            console.error(`Error loading RC file ${rcPath}: ${error.message}`);
            return null;
        }
    }

    /**
     * Enhanced load method that checks RC files first
     */
    load(): ConfigOptions {
        // First try RC file
        const rcConfig = this.loadRcFile();
        if (rcConfig) {
            const defaults = this.getDefaults();
            // Merge defaults with RC config (RC config takes precedence)
            this._config = { ...defaults, ...rcConfig };
            return this._config;
        }

        // Fall back to regular config file
        return super.load();
    }
}

// Create singleton instance
export const configManager = new RCConfigLoader();

/**
 * Get the global configuration manager instance
 */
export function getConfig(): RCConfigLoader {
    return configManager;
}

/**
 * Load and return configuration
 */
export function loadConfig(): ConfigOptions {
    return configManager.load();
}

/**
 * Get a configuration value
 */
export function getConfigValue<T = any>(key: string, defaultValue: T | null = null): T {
    return configManager.get<T>(key, defaultValue);
}

/**
 * Set a configuration value
 */
export function setConfigValue(key: string, value: any): boolean {
    return configManager.set(key, value);
}

// Export constants for checking availability
export { HAS_YAML, HAS_TOML };