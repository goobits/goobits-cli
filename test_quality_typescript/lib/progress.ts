/**
 * Progress and UI helpers for Complex CLI Test Tool
 * Generated by goobits-cli
 */

// Type definitions
export interface SpinnerOptions {
    text?: string;
    color?: string;
    interval?: number;
    spinner?: string | object;
}

export interface ProgressBarOptions {
    total: number;
    width?: number;
    format?: string;
    complete?: string;
    incomplete?: string;
    renderThrottle?: number;
    clearOnComplete?: boolean;
    stopOnComplete?: boolean;
    stream?: NodeJS.WriteStream;
}

export interface TableColumn {
    header: string;
    key: string;
    width?: number;
    align?: 'left' | 'center' | 'right';
}

export interface TableOptions {
    border?: object;
    style?: object;
    colWidths?: number[];
    wordWrap?: boolean;
    colAligns?: string[];
}

// Try to load optional dependencies
let ora: any, cliProgress: any, chalk: any, cliTable3: any;
let HAS_ORA = false;
let HAS_CLI_PROGRESS = false;
let HAS_CHALK = false;
let HAS_CLI_TABLE3 = false;

try {
    ora = require('ora');
    HAS_ORA = true;
    if (process.env.DEBUG) console.debug('ora library loaded successfully');
} catch (e: any) {
    if (process.env.DEBUG) console.debug('ora library not available:', e.message);
}

try {
    cliProgress = require('cli-progress');
    HAS_CLI_PROGRESS = true;
    if (process.env.DEBUG) console.debug('cli-progress library loaded successfully');
} catch (e: any) {
    if (process.env.DEBUG) console.debug('cli-progress library not available:', e.message);
}

try {
    chalk = require('chalk');
    HAS_CHALK = true;
    if (process.env.DEBUG) console.debug('chalk library loaded successfully');
} catch (e: any) {
    if (process.env.DEBUG) console.debug('chalk library not available:', e.message);
}

try {
    cliTable3 = require('cli-table3');
    HAS_CLI_TABLE3 = true;
    if (process.env.DEBUG) console.debug('cli-table3 library loaded successfully');
} catch (e: any) {
    if (process.env.DEBUG) console.debug('cli-table3 library not available:', e.message);
}

export class ProgressHelper {
    private _fallbackEnabled: boolean;

    /**
     * Helper class for progress indication and rich terminal output
     */
    constructor(fallbackEnabled: boolean = false) {
        this._fallbackEnabled = fallbackEnabled;
    }

    /**
     * Enable or disable fallback mode for environments without rich terminal support
     */
    setFallbackEnabled(enabled: boolean): void {
        this._fallbackEnabled = enabled;
    }

    /**
     * Get colored text using chalk or fallback
     */
    colored(text: string, color: string = 'white'): string {
        if (this._fallbackEnabled || !HAS_CHALK) {
            return text;
        }

        try {
            return (chalk as any)[color](text);
        } catch (e) {
            return text;
        }
    }

    /**
     * Format text with multiple colors and styles
     */
    styled(text: string, ...styles: string[]): string {
        if (this._fallbackEnabled || !HAS_CHALK || styles.length === 0) {
            return text;
        }

        try {
            let result = text;
            for (const style of styles) {
                if (typeof (chalk as any)[style] === 'function') {
                    result = (chalk as any)[style](result);
                }
            }
            return result;
        } catch (e) {
            return text;
        }
    }

    /**
     * Create and manage a spinner
     */
    async withSpinner<T>(
        text: string = 'Processing...',
        spinnerType: string = 'dots',
        task: () => Promise<T>
    ): Promise<T> {
        if (this._fallbackEnabled || !HAS_ORA) {
            process.stdout.write(`${text}`);
            try {
                const result = await task();
                console.log(' ‚úì');
                return result;
            } catch (error) {
                console.log(' ‚úó');
                throw error;
            }
        }

        const spinner = ora({
            text,
            spinner: spinnerType,
        }).start();

        try {
            const result = await task();
            spinner.succeed();
            return result;
        } catch (error) {
            spinner.fail();
            throw error;
        }
    }

    /**
     * Create a simple spinner that can be controlled manually
     */
    createSpinner(text: string = 'Loading...', spinnerType: string = 'dots'): any {
        if (this._fallbackEnabled || !HAS_ORA) {
            return {
                start: () => process.stdout.write(text),
                stop: () => console.log(' ‚úì'),
                succeed: (successText?: string) => console.log(` ‚úì${successText ? ' ' + successText : ''}`),
                fail: (failText?: string) => console.log(` ‚úó${failText ? ' ' + failText : ''}`),
                warn: (warnText?: string) => console.log(` ‚ö†${warnText ? ' ' + warnText : ''}`),
                info: (infoText?: string) => console.log(` ‚Ñπ${infoText ? ' ' + infoText : ''}`),
                text: text,
            };
        }

        return ora({
            text,
            spinner: spinnerType,
        });
    }

    /**
     * Create a progress bar
     */
    createProgressBar(options: ProgressBarOptions): any {
        if (this._fallbackEnabled || !HAS_CLI_PROGRESS) {
            let current = 0;
            const total = options.total;
            return {
                start: (startTotal: number, startValue: number) => {
                    current = startValue;
                    console.log(`Progress: ${current}/${total}`);
                },
                update: (value: number) => {
                    current = value;
                    const percent = Math.round((current / total) * 100);
                    process.stdout.write(`\rProgress: ${current}/${total} (${percent}%)`);
                },
                increment: (step: number = 1) => {
                    current += step;
                    const percent = Math.round((current / total) * 100);
                    process.stdout.write(`\rProgress: ${current}/${total} (${percent}%)`);
                },
                stop: () => {
                    console.log('\nCompleted');
                },
            };
        }

        return new cliProgress.SingleBar({
            format: options.format || '{bar} {percentage}% | {value}/{total}',
            barCompleteChar: options.complete || '‚ñà',
            barIncompleteChar: options.incomplete || '‚ñë',
            ...options,
        }, cliProgress.Presets.shades_classic);
    }

    /**
     * Create a multi-progress bar
     */
    createMultiProgressBar(): any {
        if (this._fallbackEnabled || !HAS_CLI_PROGRESS) {
            const bars: any = {};
            return {
                create: (total: number, startValue: number, payload?: any) => {
                    const id = Object.keys(bars).length;
                    bars[id] = { current: startValue, total, payload };
                    return {
                        update: (value: number, newPayload?: any) => {
                            bars[id].current = value;
                            if (newPayload) bars[id].payload = { ...bars[id].payload, ...newPayload };
                            const percent = Math.round((value / total) * 100);
                            console.log(`Task ${id}: ${value}/${total} (${percent}%)`);
                        },
                        increment: (step: number = 1) => {
                            bars[id].current += step;
                            const percent = Math.round((bars[id].current / total) * 100);
                            console.log(`Task ${id}: ${bars[id].current}/${total} (${percent}%)`);
                        },
                        stop: () => {
                            console.log(`Task ${id}: Completed`);
                        },
                    };
                },
                stop: () => {
                    console.log('All tasks completed');
                },
            };
        }

        return new cliProgress.MultiBar({
            format: '{name} |{bar}| {percentage}% | {value}/{total}',
            barCompleteChar: '‚ñà',
            barIncompleteChar: '‚ñë',
            clearOnComplete: false,
            stopOnComplete: true,
            hideCursor: true,
        }, cliProgress.Presets.shades_classic);
    }

    /**
     * Create a table for displaying data
     */
    createTable(headers: string[], options: TableOptions = {}): any {
        if (this._fallbackEnabled || !HAS_CLI_TABLE3) {
            const rows: string[][] = [];
            return {
                push: (row: string[]) => {
                    rows.push(row);
                },
                toString: () => {
                    let result = headers.join('\t') + '\n';
                    result += headers.map(() => '---').join('\t') + '\n';
                    for (const row of rows) {
                        result += row.join('\t') + '\n';
                    }
                    return result;
                },
            };
        }

        const tableOptions = {
            head: headers,
            ...options,
        };

        return new cliTable3(tableOptions);
    }

    /**
     * Create a formatted table with column definitions
     */
    createFormattedTable(columns: TableColumn[], options: TableOptions = {}): any {
        const headers = columns.map(col => col.header);
        const colWidths = columns.map(col => col.width).filter(Boolean) as number[];
        const colAligns = columns.map(col => col.align || 'left');

        const tableOptions = {
            ...options,
            colWidths: colWidths.length > 0 ? colWidths : undefined,
            colAligns,
        };

        return this.createTable(headers, tableOptions);
    }

    /**
     * Print a success message
     */
    success(message: string): void {
        if (this._fallbackEnabled || !HAS_CHALK) {
            console.log(`‚úì ${message}`);
        } else {
            console.log(chalk.green(`‚úì ${message}`));
        }
    }

    /**
     * Print an error message
     */
    error(message: string): void {
        if (this._fallbackEnabled || !HAS_CHALK) {
            console.error(`‚úó ${message}`);
        } else {
            console.error(chalk.red(`‚úó ${message}`));
        }
    }

    /**
     * Print a warning message
     */
    warning(message: string): void {
        if (this._fallbackEnabled || !HAS_CHALK) {
            console.warn(`‚ö† ${message}`);
        } else {
            console.warn(chalk.yellow(`‚ö† ${message}`));
        }
    }

    /**
     * Print an info message
     */
    info(message: string): void {
        if (this._fallbackEnabled || !HAS_CHALK) {
            console.log(`‚Ñπ ${message}`);
        } else {
            console.log(chalk.cyan(`‚Ñπ ${message}`));
        }
    }

    /**
     * Print a debug message (only if DEBUG env var is set)
     */
    debug(message: string): void {
        if (process.env.DEBUG) {
            if (this._fallbackEnabled || !HAS_CHALK) {
                console.debug(`üêõ ${message}`);
            } else {
                console.debug(chalk.gray(`üêõ ${message}`));
            }
        }
    }

    /**
     * Clear the console
     */
    clear(): void {
        if (!this._fallbackEnabled) {
            console.clear();
        }
    }

    /**
     * Print a separator line
     */
    separator(char: string = '‚îÄ', length: number = 50): void {
        console.log(char.repeat(length));
    }

    /**
     * Print text in a box
     */
    box(text: string, padding: number = 1): void {
        const lines = text.split('\n');
        const maxLength = Math.max(...lines.map(line => line.length));
        const totalWidth = maxLength + (padding * 2);
        
        const horizontalBorder = '‚îÄ'.repeat(totalWidth);
        const emptyLine = '‚îÇ' + ' '.repeat(totalWidth) + '‚îÇ';

        console.log('‚îå' + horizontalBorder + '‚îê');
        
        // Top padding
        for (let i = 0; i < padding; i++) {
            console.log(emptyLine);
        }
        
        // Content lines
        for (const line of lines) {
            const paddedLine = ' '.repeat(padding) + line + ' '.repeat(totalWidth - line.length - padding);
            console.log('‚îÇ' + paddedLine + '‚îÇ');
        }
        
        // Bottom padding
        for (let i = 0; i < padding; i++) {
            console.log(emptyLine);
        }
        
        console.log('‚îî' + horizontalBorder + '‚îò');
    }

    /**
     * Format bytes in human readable format
     */
    formatBytes(bytes: number, decimals: number = 2): string {
        if (bytes === 0) return '0 Bytes';

        const k = 1024;
        const dm = decimals < 0 ? 0 : decimals;
        const sizes = ['Bytes', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB', 'ZB', 'YB'];

        const i = Math.floor(Math.log(bytes) / Math.log(k));

        return parseFloat((bytes / Math.pow(k, i)).toFixed(dm)) + ' ' + sizes[i];
    }

    /**
     * Format duration in human readable format
     */
    formatDuration(milliseconds: number): string {
        const seconds = Math.floor(milliseconds / 1000);
        const minutes = Math.floor(seconds / 60);
        const hours = Math.floor(minutes / 60);

        if (hours > 0) {
            return `${hours}h ${minutes % 60}m ${seconds % 60}s`;
        } else if (minutes > 0) {
            return `${minutes}m ${seconds % 60}s`;
        } else {
            return `${seconds}s`;
        }
    }
}

// Default instance
let _defaultProgress: ProgressHelper | null = null;

/**
 * Get a progress helper instance
 */
export function getProgressHelper(): ProgressHelper {
    if (_defaultProgress === null) {
        _defaultProgress = new ProgressHelper();
    }
    return _defaultProgress;
}

/**
 * Create a new spinner with the specified text and type
 */
export function createSpinner(text: string = 'Loading...', spinnerType: string = 'dots'): any {
    return getProgressHelper().createSpinner(text, spinnerType);
}

/**
 * Execute a task with a spinner
 */
export async function withSpinner<T>(
    text: string = 'Processing...',
    spinnerType: string = 'dots',
    task: () => Promise<T>
): Promise<T> {
    return getProgressHelper().withSpinner(text, spinnerType, task);
}

/**
 * Create a progress bar
 */
export function createProgressBar(options: ProgressBarOptions): any {
    return getProgressHelper().createProgressBar(options);
}

/**
 * Create a table for displaying data
 */
export function createTable(headers: string[], options: TableOptions = {}): any {
    return getProgressHelper().createTable(headers, options);
}

/**
 * Print a success message
 */
export function success(message: string): void {
    getProgressHelper().success(message);
}

/**
 * Print an error message
 */
export function error(message: string): void {
    getProgressHelper().error(message);
}

/**
 * Print a warning message
 */
export function warning(message: string): void {
    getProgressHelper().warning(message);
}

/**
 * Print an info message
 */
export function info(message: string): void {
    getProgressHelper().info(message);
}

// Export constants for checking availability
export { HAS_ORA, HAS_CLI_PROGRESS, HAS_CHALK, HAS_CLI_TABLE3 };