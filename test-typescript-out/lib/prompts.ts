/**
 * Interactive prompts for Test TypeScript CLI
 * Generated by goobits-cli
 */

import * as readline from 'readline';
import * as fs from 'fs';
import * as path from 'path';

// Type definitions
export interface PromptOptions {
    message?: string;
    default?: any;
    validate?: (input: any) => boolean | string;
    transform?: (input: any) => any;
    mask?: string;
    choices?: string[] | ChoiceItem[];
    multiple?: boolean;
    min?: number;
    max?: number;
    step?: number;
}

export interface ChoiceItem {
    name: string;
    value: any;
    description?: string;
    disabled?: boolean | string;
}

export interface TextPromptOptions extends PromptOptions {
    placeholder?: string;
    maxLength?: number;
}

export interface NumberPromptOptions extends PromptOptions {
    min?: number;
    max?: number;
    step?: number;
    float?: boolean;
}

export interface SelectPromptOptions extends PromptOptions {
    choices: string[] | ChoiceItem[];
    pageSize?: number;
}

export interface MultiSelectPromptOptions extends PromptOptions {
    choices: string[] | ChoiceItem[];
    pageSize?: number;
    instructions?: string;
}

export interface PathPromptOptions extends PromptOptions {
    type?: 'file' | 'directory' | 'any';
    exists?: boolean;
    create?: boolean;
    extensions?: string[];
}

// Try to load optional dependencies
let inquirer: any, prompts: any;
let HAS_INQUIRER = false;
let HAS_PROMPTS = false;

try {
    inquirer = require('inquirer');
    HAS_INQUIRER = true;
    if (process.env.DEBUG) console.debug('inquirer library loaded successfully');
} catch (e: any) {
    if (process.env.DEBUG) console.debug('inquirer library not available:', e.message);
}

try {
    prompts = require('prompts');
    HAS_PROMPTS = true;
    if (process.env.DEBUG) console.debug('prompts library loaded successfully');
} catch (e: any) {
    if (process.env.DEBUG) console.debug('prompts library not available:', e.message);
}

export class PromptsHelper {
    private _fallbackEnabled: boolean;
    private rl: readline.Interface | null;

    /**
     * Helper class for interactive prompts
     */
    constructor(fallbackEnabled: boolean = false) {
        this._fallbackEnabled = fallbackEnabled;
        this.rl = null;
    }

    /**
     * Enable or disable fallback mode for environments without rich prompt support
     */
    setFallbackEnabled(enabled: boolean): void {
        this._fallbackEnabled = enabled;
    }

    /**
     * Initialize readline interface for fallback prompts
     */
    private initReadline(): readline.Interface {
        if (!this.rl) {
            this.rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout,
            });
        }
        return this.rl;
    }

    /**
     * Close readline interface
     */
    private closeReadline(): void {
        if (this.rl) {
            this.rl.close();
            this.rl = null;
        }
    }

    /**
     * Fallback text input using readline
     */
    private async fallbackInput(message: string, defaultValue?: string, isPassword: boolean = false): Promise<string> {
        return new Promise((resolve) => {
            const rl = this.initReadline();
            const prompt = defaultValue ? `${message} (${defaultValue}): ` : `${message}: `;
            
            if (isPassword) {
                // For password input, we'll just show asterisks (simplified)
                process.stdout.write(prompt);
                let input = '';
                
                const onKeypress = (str: string, key: any) => {
                    if (key.name === 'return') {
                        process.stdout.write('\n');
                        process.stdin.removeListener('keypress', onKeypress);
                        (process.stdin as any).setRawMode(false);
                        resolve(input || defaultValue || '');
                    } else if (key.name === 'backspace') {
                        if (input.length > 0) {
                            input = input.slice(0, -1);
                            process.stdout.write('\b \b');
                        }
                    } else if (str && !key.ctrl) {
                        input += str;
                        process.stdout.write('*');
                    }
                };
                
                (process.stdin as any).setRawMode(true);
                process.stdin.on('keypress', onKeypress);
            } else {
                rl.question(prompt, (answer) => {
                    resolve(answer || defaultValue || '');
                });
            }
        });
    }

    /**
     * Fallback confirmation prompt
     */
    private async fallbackConfirm(message: string, defaultValue: boolean = false): Promise<boolean> {
        const defaultStr = defaultValue ? 'Y/n' : 'y/N';
        const answer = await this.fallbackInput(`${message} (${defaultStr})`);
        
        if (!answer) return defaultValue;
        return answer.toLowerCase().startsWith('y');
    }

    /**
     * Fallback select prompt
     */
    private async fallbackSelect(message: string, choices: string[] | ChoiceItem[]): Promise<any> {
        console.log(message);
        const normalizedChoices = choices.map((choice, index) => {
            if (typeof choice === 'string') {
                return { name: choice, value: choice, index };
            }
            return { ...choice, index };
        });

        normalizedChoices.forEach((choice, index) => {
            console.log(`  ${index + 1}) ${choice.name}${choice.description ? ` - ${choice.description}` : ''}`);
        });

        const answer = await this.fallbackInput('Select option (number)');
        const selectedIndex = parseInt(answer) - 1;
        
        if (selectedIndex >= 0 && selectedIndex < normalizedChoices.length) {
            return normalizedChoices[selectedIndex].value;
        }
        
        return normalizedChoices[0]?.value;
    }

    /**
     * Text input prompt
     */
    async text(message: string, options: TextPromptOptions = {}): Promise<string> {
        if (this._fallbackEnabled || (!HAS_INQUIRER && !HAS_PROMPTS)) {
            const result = await this.fallbackInput(message, options.default);
            
            // Apply validation if provided
            if (options.validate) {
                const validation = options.validate(result);
                if (validation !== true) {
                    console.error(typeof validation === 'string' ? validation : 'Invalid input');
                    return this.text(message, options); // Retry
                }
            }
            
            // Apply transformation if provided
            return options.transform ? options.transform(result) : result;
        }

        if (HAS_PROMPTS) {
            const response = await prompts({
                type: 'text',
                name: 'value',
                message,
                initial: options.default,
                validate: options.validate,
                format: options.transform,
            });
            return response.value;
        }

        if (HAS_INQUIRER) {
            const answers = await inquirer.prompt([{
                type: 'input',
                name: 'value',
                message,
                default: options.default,
                validate: options.validate,
                filter: options.transform,
            }]);
            return answers.value;
        }

        return '';
    }

    /**
     * Password input prompt
     */
    async password(message: string, options: PromptOptions = {}): Promise<string> {
        if (this._fallbackEnabled || (!HAS_INQUIRER && !HAS_PROMPTS)) {
            const result = await this.fallbackInput(message, undefined, true);
            
            // Apply validation if provided
            if (options.validate) {
                const validation = options.validate(result);
                if (validation !== true) {
                    console.error(typeof validation === 'string' ? validation : 'Invalid input');
                    return this.password(message, options); // Retry
                }
            }
            
            return result;
        }

        if (HAS_PROMPTS) {
            const response = await prompts({
                type: 'password',
                name: 'value',
                message,
                validate: options.validate,
            });
            return response.value;
        }

        if (HAS_INQUIRER) {
            const answers = await inquirer.prompt([{
                type: 'password',
                name: 'value',
                message,
                validate: options.validate,
                mask: options.mask || '*',
            }]);
            return answers.value;
        }

        return '';
    }

    /**
     * Confirmation prompt
     */
    async confirm(message: string, defaultValue: boolean = false): Promise<boolean> {
        if (this._fallbackEnabled || (!HAS_INQUIRER && !HAS_PROMPTS)) {
            return this.fallbackConfirm(message, defaultValue);
        }

        if (HAS_PROMPTS) {
            const response = await prompts({
                type: 'confirm',
                name: 'value',
                message,
                initial: defaultValue,
            });
            return response.value;
        }

        if (HAS_INQUIRER) {
            const answers = await inquirer.prompt([{
                type: 'confirm',
                name: 'value',
                message,
                default: defaultValue,
            }]);
            return answers.value;
        }

        return defaultValue;
    }

    /**
     * Select prompt (single choice)
     */
    async select(message: string, choices: string[] | ChoiceItem[], options: SelectPromptOptions = {}): Promise<any> {
        if (this._fallbackEnabled || (!HAS_INQUIRER && !HAS_PROMPTS)) {
            return this.fallbackSelect(message, choices);
        }

        const normalizedChoices = choices.map(choice => {
            if (typeof choice === 'string') {
                return { name: choice, value: choice };
            }
            return choice;
        });

        if (HAS_PROMPTS) {
            const response = await prompts({
                type: 'select',
                name: 'value',
                message,
                choices: normalizedChoices,
                initial: 0,
            });
            return response.value;
        }

        if (HAS_INQUIRER) {
            const answers = await inquirer.prompt([{
                type: 'list',
                name: 'value',
                message,
                choices: normalizedChoices,
                pageSize: options.pageSize || 10,
            }]);
            return answers.value;
        }

        return normalizedChoices[0]?.value;
    }

    /**
     * Multi-select prompt (multiple choices)
     */
    async multiSelect(message: string, choices: string[] | ChoiceItem[], options: MultiSelectPromptOptions = {}): Promise<any[]> {
        if (this._fallbackEnabled || (!HAS_INQUIRER && !HAS_PROMPTS)) {
            console.log(message);
            console.log('Enter comma-separated indices (e.g., 1,3,5):');
            
            const normalizedChoices = choices.map((choice, index) => {
                if (typeof choice === 'string') {
                    return { name: choice, value: choice, index };
                }
                return { ...choice, index };
            });

            normalizedChoices.forEach((choice, index) => {
                console.log(`  ${index + 1}) ${choice.name}${choice.description ? ` - ${choice.description}` : ''}`);
            });

            const answer = await this.fallbackInput('Select options (comma-separated numbers)');
            const indices = answer.split(',').map(s => parseInt(s.trim()) - 1).filter(i => i >= 0 && i < normalizedChoices.length);
            
            return indices.map(i => normalizedChoices[i].value);
        }

        const normalizedChoices = choices.map(choice => {
            if (typeof choice === 'string') {
                return { name: choice, value: choice };
            }
            return choice;
        });

        if (HAS_PROMPTS) {
            const response = await prompts({
                type: 'multiselect',
                name: 'value',
                message,
                choices: normalizedChoices,
                instructions: options.instructions || false,
            });
            return response.value || [];
        }

        if (HAS_INQUIRER) {
            const answers = await inquirer.prompt([{
                type: 'checkbox',
                name: 'value',
                message,
                choices: normalizedChoices,
                pageSize: options.pageSize || 10,
            }]);
            return answers.value || [];
        }

        return [];
    }

    /**
     * Number input prompt
     */
    async number(message: string, options: NumberPromptOptions = {}): Promise<number> {
        const validator = (input: any): boolean | string => {
            const num = options.float ? parseFloat(input) : parseInt(input);
            if (isNaN(num)) {
                return 'Please enter a valid number';
            }
            if (options.min !== undefined && num < options.min) {
                return `Number must be at least ${options.min}`;
            }
            if (options.max !== undefined && num > options.max) {
                return `Number must be at most ${options.max}`;
            }
            if (options.validate) {
                return options.validate(num);
            }
            return true;
        };

        const transformer = (input: any) => {
            const num = options.float ? parseFloat(input) : parseInt(input);
            return isNaN(num) ? input : num;
        };

        if (this._fallbackEnabled || (!HAS_INQUIRER && !HAS_PROMPTS)) {
            const result = await this.fallbackInput(message, options.default?.toString());
            const validation = validator(result);
            if (validation !== true) {
                console.error(typeof validation === 'string' ? validation : 'Invalid input');
                return this.number(message, options); // Retry
            }
            return transformer(result);
        }

        if (HAS_PROMPTS) {
            const response = await prompts({
                type: 'number',
                name: 'value',
                message,
                initial: options.default,
                min: options.min,
                max: options.max,
                validate: validator,
            });
            return response.value;
        }

        if (HAS_INQUIRER) {
            const answers = await inquirer.prompt([{
                type: 'input',
                name: 'value',
                message,
                default: options.default?.toString(),
                validate: validator,
                filter: transformer,
            }]);
            return answers.value;
        }

        return options.default || 0;
    }

    /**
     * Integer input prompt
     */
    async integer(message: string, options: NumberPromptOptions = {}): Promise<number> {
        return this.number(message, { ...options, float: false });
    }

    /**
     * Float input prompt
     */
    async float(message: string, options: NumberPromptOptions = {}): Promise<number> {
        return this.number(message, { ...options, float: true });
    }

    /**
     * Path input prompt with validation
     */
    async path(message: string, options: PathPromptOptions = {}): Promise<string> {
        const validator = (input: string): boolean | string => {
            if (!input) {
                return 'Path cannot be empty';
            }

            const resolvedPath = path.resolve(input);
            const exists = fs.existsSync(resolvedPath);

            if (options.exists === true && !exists) {
                return 'Path does not exist';
            }

            if (options.exists === false && exists) {
                return 'Path already exists';
            }

            if (exists) {
                const stats = fs.statSync(resolvedPath);
                if (options.type === 'file' && !stats.isFile()) {
                    return 'Path must be a file';
                }
                if (options.type === 'directory' && !stats.isDirectory()) {
                    return 'Path must be a directory';
                }
            }

            if (options.extensions && options.extensions.length > 0) {
                const ext = path.extname(resolvedPath).toLowerCase();
                if (!options.extensions.includes(ext)) {
                    return `File must have one of these extensions: ${options.extensions.join(', ')}`;
                }
            }

            if (options.validate) {
                return options.validate(resolvedPath);
            }

            return true;
        };

        const result = await this.text(message, {
            ...options,
            validate: validator,
            transform: (input: string) => path.resolve(input),
        });

        // Create path if requested and it doesn't exist
        if (options.create && !fs.existsSync(result)) {
            if (options.type === 'directory') {
                fs.mkdirSync(result, { recursive: true });
            } else {
                // Create parent directory if it doesn't exist
                const parentDir = path.dirname(result);
                if (!fs.existsSync(parentDir)) {
                    fs.mkdirSync(parentDir, { recursive: true });
                }
            }
        }

        return result;
    }

    /**
     * Clean up resources
     */
    cleanup(): void {
        this.closeReadline();
    }
}

// Default instance
let _defaultPrompts: PromptsHelper | null = null;

/**
 * Get a prompts helper instance
 */
export function getPromptsHelper(): PromptsHelper {
    if (_defaultPrompts === null) {
        _defaultPrompts = new PromptsHelper();
    }
    return _defaultPrompts;
}

/**
 * Text input prompt
 */
export async function text(message: string, options: TextPromptOptions = {}): Promise<string> {
    return getPromptsHelper().text(message, options);
}

/**
 * Password input prompt
 */
export async function password(message: string, options: PromptOptions = {}): Promise<string> {
    return getPromptsHelper().password(message, options);
}

/**
 * Confirmation prompt
 */
export async function confirm(message: string, defaultValue: boolean = false): Promise<boolean> {
    return getPromptsHelper().confirm(message, defaultValue);
}

/**
 * Select prompt (single choice)
 */
export async function select(message: string, choices: string[] | ChoiceItem[], options: SelectPromptOptions = {}): Promise<any> {
    return getPromptsHelper().select(message, choices, options);
}

/**
 * Multi-select prompt (multiple choices)
 */
export async function multiSelect(message: string, choices: string[] | ChoiceItem[], options: MultiSelectPromptOptions = {}): Promise<any[]> {
    return getPromptsHelper().multiSelect(message, choices, options);
}

/**
 * Number input prompt
 */
export async function number(message: string, options: NumberPromptOptions = {}): Promise<number> {
    return getPromptsHelper().number(message, options);
}

/**
 * Integer input prompt
 */
export async function integer(message: string, options: NumberPromptOptions = {}): Promise<number> {
    return getPromptsHelper().integer(message, options);
}

/**
 * Float input prompt
 */
export async function float(message: string, options: NumberPromptOptions = {}): Promise<number> {
    return getPromptsHelper().float(message, options);
}

/**
 * Path input prompt with validation
 */
export async function path(message: string, options: PathPromptOptions = {}): Promise<string> {
    return getPromptsHelper().path(message, options);
}

// Export constants for checking availability
export { HAS_INQUIRER, HAS_PROMPTS };