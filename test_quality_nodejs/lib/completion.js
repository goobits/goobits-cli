/**
 * Shell completion helpers for Complex CLI Test Tool
 * Generated by goobits-cli
 */

const fs = require('fs');
const path = require('path');
const os = require('os');

class CompletionHelper {
    /**
     * Helper class for generating shell completions
     * @param {string} cliName - CLI name
     */
    constructor(cliName = 'complex-cli') {
        this.cliName = cliName;
        this.scriptName = cliName;
    }

    /**
     * Generate bash completion script
     * @returns {string} Bash completion script
     */
    generateBashCompletion() {
        const completionFunc = this.cliName.replace(/-/g, '_');
        return `#!/bin/bash
# Bash completion script for ${this.cliName}
# Generated by goobits-cli

_${completionFunc}_completion() {
    local cur prev opts
    COMPREPLY=()
    cur="\${COMP_WORDS[COMP_CWORD]}"
    prev="\${COMP_WORDS[COMP_CWORD-1]}"
    
    # Get available commands
    if [[ \${COMP_CWORD} -eq 1 ]]; then
        # Top-level commands
        opts="$(${this.scriptName} --help 2>/dev/null | grep -E '^  [a-z]' | awk '{print $1}' | tr '\\n' ' ')"
        opts="$opts --help --version"
    else
        # Subcommands and options
        case "\${COMP_WORDS[1]}" in
            completion)
                case "\${COMP_WORDS[2]}" in
                    generate)
                        opts="bash zsh fish"
                        ;;
                    install)
                        opts="bash zsh fish --user --system"
                        ;;
                    instructions)
                        opts="bash zsh fish"
                        ;;
                    *)
                        opts="generate install instructions --help"
                        ;;
                esac
                ;;
            config)
                case "\${COMP_WORDS[2]}" in
                    get|set|delete)
                        # Could add dynamic config key completion here
                        opts="--help"
                        ;;
                    *)
                        opts="get set reset path --help"
                        ;;
                esac
                ;;
            *)
                opts="--help"
                ;;
        esac
    fi
    
    COMPREPLY=( $(compgen -W "\${opts}" -- "\${cur}") )
    return 0
}

complete -F _${completionFunc}_completion ${this.scriptName}
`;
    }

    /**
     * Generate zsh completion script
     * @returns {string} Zsh completion script
     */
    generateZshCompletion() {
        const completionFunc = this.cliName.replace(/-/g, '_');
        return `#compdef ${this.scriptName}
# Zsh completion script for ${this.cliName}
# Generated by goobits-cli

_${completionFunc}() {
    local context state line
    typeset -A opt_args
    
    _arguments -s -S \\
        '(--help -h){--help,-h}[Show help message]' \\
        '(--version -V){--version,-V}[Show version]' \\
        '1: :->commands' \\
        '*:: :->args' && return 0
    
    case $state in
        (commands)
            local commands
            commands=(
                'help:Show help message'
                'completion:Shell completion management'
                'config:Configuration management'
                'upgrade:Upgrade to latest version'
            )
            _describe 'commands' commands
            ;;
        (args)
            case $words[1] in
                (completion)
                    _arguments -s -S \\
                        '1: :->completion_commands' \\
                        '*:: :->completion_args' && return 0
                    
                    case $state in
                        (completion_commands)
                            local completion_commands
                            completion_commands=(
                                'generate:Generate completion script'
                                'install:Install completion script'
                                'instructions:Show installation instructions'
                            )
                            _describe 'completion commands' completion_commands
                            ;;
                        (completion_args)
                            case $words[2] in
                                (generate|install|instructions)
                                    _arguments -s -S \\
                                        '1: :(bash zsh fish)' \\
                                        '(--help -h){--help,-h}[Show help message]'
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                (config)
                    _arguments -s -S \\
                        '1: :->config_commands' \\
                        '*:: :->config_args' && return 0
                    
                    case $state in
                        (config_commands)
                            local config_commands
                            config_commands=(
                                'get:Get configuration value'
                                'set:Set configuration value'
                                'reset:Reset configuration to defaults'
                                'path:Show configuration file path'
                            )
                            _describe 'config commands' config_commands
                            ;;
                        (config_args)
                            case $words[2] in
                                (get|set|delete)
                                    _arguments -s -S \\
                                        '1: :' \\
                                        '(--help -h){--help,-h}[Show help message]'
                                    ;;
                                (reset|path)
                                    _arguments -s -S \\
                                        '(--help -h){--help,-h}[Show help message]'
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                (help|upgrade)
                    _arguments -s -S \\
                        '(--help -h){--help,-h}[Show help message]'
                    ;;
            esac
            ;;
    esac
}

_${completionFunc} "$@"
`;
    }

    /**
     * Generate fish completion script
     * @returns {string} Fish completion script
     */
    generateFishCompletion() {
        return `# Fish completion script for ${this.cliName}
# Generated by goobits-cli

# Complete main commands
complete -c ${this.scriptName} -n '__fish_use_subcommand' -a 'help' -d 'Show help message'
complete -c ${this.scriptName} -n '__fish_use_subcommand' -a 'completion' -d 'Shell completion management'
complete -c ${this.scriptName} -n '__fish_use_subcommand' -a 'config' -d 'Configuration management'
complete -c ${this.scriptName} -n '__fish_use_subcommand' -a 'upgrade' -d 'Upgrade to latest version'

# Completion subcommands
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion' -a 'generate' -d 'Generate completion script'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion' -a 'install' -d 'Install completion script'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion' -a 'instructions' -d 'Show installation instructions'

# Shell options for completion commands
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion; and __fish_seen_subcommand_from generate install instructions' -a 'bash' -d 'Bash shell'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion; and __fish_seen_subcommand_from generate install instructions' -a 'zsh' -d 'Zsh shell'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion; and __fish_seen_subcommand_from generate install instructions' -a 'fish' -d 'Fish shell'

# Install options
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion; and __fish_seen_subcommand_from install' -l user -d 'Install for current user'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion; and __fish_seen_subcommand_from install' -l system -d 'Install system-wide'

# Config subcommands
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from config' -a 'get' -d 'Get configuration value'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from config' -a 'set' -d 'Set configuration value'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from config' -a 'reset' -d 'Reset configuration to defaults'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from config' -a 'path' -d 'Show configuration file path'

# Upgrade options
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from upgrade' -l check -d 'Check for updates without installing'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from upgrade' -l version -d 'Install specific version'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from upgrade' -l pre -d 'Include pre-release versions'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from upgrade' -l dry-run -d 'Show what would be done'

# Global options
complete -c ${this.scriptName} -s h -l help -d 'Show help message'
complete -c ${this.scriptName} -s V -l version -d 'Show version'
`;
    }

    /**
     * Get installation instructions for completion scripts
     * @param {string} shell - Shell name
     * @returns {Object} Installation instructions
     */
    getCompletionInstallInstructions(shell) {
        const instructions = {
            bash: {
                scriptPath: `/etc/bash_completion.d/${this.cliName}`,
                userScriptPath: `~/.local/share/bash-completion/completions/${this.cliName}`,
                installCmd: `sudo cp completion-script.bash /etc/bash_completion.d/${this.cliName}`,
                userInstallCmd: `mkdir -p ~/.local/share/bash-completion/completions && cp completion-script.bash ~/.local/share/bash-completion/completions/${this.cliName}`,
                reloadCmd: 'source ~/.bashrc',
            },
            zsh: {
                scriptPath: `/usr/share/zsh/site-functions/_${this.cliName}`,
                userScriptPath: `~/.local/share/zsh/site-functions/_${this.cliName}`,
                installCmd: `sudo cp completion-script.zsh /usr/share/zsh/site-functions/_${this.cliName}`,
                userInstallCmd: `mkdir -p ~/.local/share/zsh/site-functions && cp completion-script.zsh ~/.local/share/zsh/site-functions/_${this.cliName}`,
                reloadCmd: 'exec zsh',
            },
            fish: {
                scriptPath: `/usr/share/fish/completions/${this.cliName}.fish`,
                userScriptPath: `~/.config/fish/completions/${this.cliName}.fish`,
                installCmd: `sudo cp completion-script.fish /usr/share/fish/completions/${this.cliName}.fish`,
                userInstallCmd: `mkdir -p ~/.config/fish/completions && cp completion-script.fish ~/.config/fish/completions/${this.cliName}.fish`,
                reloadCmd: 'No reload needed - fish will auto-detect',
            }
        };

        return instructions[shell] || {};
    }

    /**
     * Save completion script to file
     * @param {string} shell - Shell name
     * @param {string} outputDir - Output directory
     * @returns {string} Script file path
     */
    saveCompletionScript(shell, outputDir = null) {
        if (!outputDir) {
            outputDir = process.cwd();
        }

        const generators = {
            bash: () => this.generateBashCompletion(),
            zsh: () => this.generateZshCompletion(),
            fish: () => this.generateFishCompletion(),
        };

        if (!(shell in generators)) {
            throw new Error(`Unsupported shell: ${shell}. Supported: ${Object.keys(generators).join(', ')}`);
        }

        const scriptContent = generators[shell]();
        const scriptFile = path.join(outputDir, `${this.cliName}-completion.${shell}`);

        fs.writeFileSync(scriptFile, scriptContent, 'utf8');
        return scriptFile;
    }

    /**
     * Install completion script for the specified shell
     * @param {string} shell - Shell name
     * @param {boolean} userInstall - Install for user only
     * @returns {Promise<boolean>} Success status
     */
    async installCompletion(shell, userInstall = true) {
        try {
            const generators = {
                bash: () => this.generateBashCompletion(),
                zsh: () => this.generateZshCompletion(),
                fish: () => this.generateFishCompletion(),
            };

            if (!(shell in generators)) {
                throw new Error(`Unsupported shell: ${shell}`);
            }

            const scriptContent = generators[shell]();
            const instructions = this.getCompletionInstallInstructions(shell);

            let scriptPath;
            if (userInstall) {
                scriptPath = instructions.userScriptPath.replace('~', os.homedir());
            } else {
                scriptPath = instructions.scriptPath;
            }

            // Create directory if it doesn't exist
            const scriptDir = path.dirname(scriptPath);
            fs.mkdirSync(scriptDir, { recursive: true });

            // Write the completion script
            fs.writeFileSync(scriptPath, scriptContent, 'utf8');

            return true;
        } catch (error) {
            console.error(`Error installing completion for ${shell}: ${error.message}`);
            return false;
        }
    }
}

// Default instance
let _defaultCompletion = null;

/**
 * Get a completion helper instance
 * @returns {CompletionHelper} Completion helper
 */
function getCompletionHelper() {
    if (_defaultCompletion === null) {
        _defaultCompletion = new CompletionHelper();
    }
    return _defaultCompletion;
}

/**
 * Generate completion script for the specified shell
 * @param {string} shell - Shell name
 * @returns {string} Completion script
 */
function generateCompletionScript(shell) {
    const helper = getCompletionHelper();
    const generators = {
        bash: () => helper.generateBashCompletion(),
        zsh: () => helper.generateZshCompletion(),
        fish: () => helper.generateFishCompletion(),
    };

    if (!(shell in generators)) {
        throw new Error(`Unsupported shell: ${shell}. Supported: ${Object.keys(generators).join(', ')}`);
    }

    return generators[shell]();
}

/**
 * Install completion script for the specified shell
 * @param {string} shell - Shell name
 * @param {boolean} userInstall - Install for user only
 * @returns {Promise<boolean>} Success status
 */
async function installCompletion(shell, userInstall = true) {
    return getCompletionHelper().installCompletion(shell, userInstall);
}

/**
 * Get installation instructions for completion scripts
 * @param {string} shell - Shell name
 * @returns {Object} Installation instructions
 */
function getInstallInstructions(shell) {
    return getCompletionHelper().getCompletionInstallInstructions(shell);
}

module.exports = {
    CompletionHelper,
    getCompletionHelper,
    generateCompletionScript,
    installCompletion,
    getInstallInstructions
};