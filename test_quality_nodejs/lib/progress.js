/**
 * Progress indicators and visual feedback helpers for Complex CLI Test Tool
 * Generated by goobits-cli
 */

const os = require('os');

// Custom Exception Classes for Progress Operations
class ProgressError extends Error {
    constructor(message, suggestion = null) {
        super(message);
        this.name = 'ProgressError';
        this.message = message;
        this.suggestion = suggestion;
    }
}

class DependencyMissingError extends ProgressError {
    constructor(dependency, feature, installCommand = null) {
        const message = `'${dependency}' is required for ${feature} but is not installed`;
        const suggestion = installCommand ? `Install with: ${installCommand}` : `Install the '${dependency}' package`;
        super(message, suggestion);
        this.dependency = dependency;
        this.feature = feature;
        this.installCommand = installCommand;
    }
}

// Try to load optional dependencies
let ora, chalk, cliProgress, cliTable3;
let HAS_ORA = false;
let HAS_CHALK = false;
let HAS_CLI_PROGRESS = false;
let HAS_CLI_TABLE = false;

try {
    ora = require('ora');
    HAS_ORA = true;
    if (process.env.DEBUG) console.debug('Ora library loaded successfully');
} catch (e) {
    if (process.env.DEBUG) console.debug('Ora library not available:', e.message);
    console.info('Progress features will use basic fallbacks. Install \'ora\' for enhanced spinners: npm install ora');
}

try {
    chalk = require('chalk');
    HAS_CHALK = true;
    if (process.env.DEBUG) console.debug('Chalk library loaded successfully');
} catch (e) {
    if (process.env.DEBUG) console.debug('Chalk library not available:', e.message);
}

try {
    cliProgress = require('cli-progress');
    HAS_CLI_PROGRESS = true;
    if (process.env.DEBUG) console.debug('CLI Progress library loaded successfully');
} catch (e) {
    if (process.env.DEBUG) console.debug('CLI Progress library not available:', e.message);
    console.info('Progress bars will use basic fallbacks. Install \'cli-progress\' for enhanced bars: npm install cli-progress');
}

try {
    cliTable3 = require('cli-table3');
    HAS_CLI_TABLE = true;
    if (process.env.DEBUG) console.debug('CLI Table library loaded successfully');
} catch (e) {
    if (process.env.DEBUG) console.debug('CLI Table library not available:', e.message);
}

class ProgressHelper {
    /**
     * Helper class for progress indicators and visual feedback
     */
    constructor() {
        this._fallbackEnabled = !HAS_ORA || !HAS_CHALK;
        this._supportsColor = process.stdout.isTTY && process.stdout.hasColors && process.stdout.hasColors();
        
        if (HAS_ORA && HAS_CHALK) {
            if (process.env.DEBUG) console.debug('Enhanced progress features initialized');
        } else {
            if (process.env.DEBUG) console.debug('Using fallback mode (ora/chalk not available)');
        }
    }

    /**
     * Show a spinner with enhanced error handling
     * @param {string} text - Text to display
     * @param {string} spinnerType - Spinner type ('dots', 'line', etc.)
     * @param {Function} task - Async function to execute
     * @returns {Promise<any>} Result of the task
     */
    async withSpinner(text = 'Processing...', spinnerType = 'dots', task) {
        if (this._fallbackEnabled || !HAS_ORA) {
            process.stdout.write(`${text}`);
            try {
                const result = await task();
                console.log(' ✓');
                return result;
            } catch (error) {
                console.log(' ✗');
                throw error;
            }
        }

        try {
            const spinner = ora({
                text: text,
                spinner: spinnerType,
                color: 'blue'
            }).start();

            try {
                const result = await task();
                spinner.succeed();
                return result;
            } catch (error) {
                spinner.fail();
                throw error;
            }
        } catch (e) {
            console.warn(`Ora spinner failed, falling back to basic output: ${e.message}`);
            // Fallback to basic output
            process.stdout.write(`${text}`);
            try {
                const result = await task();
                console.log(' ✓');
                return result;
            } catch (error) {
                console.log(' ✗');
                throw error;
            }
        }
    }

    /**
     * Create a progress bar context
     * @param {string} description - Description text
     * @param {number} total - Total items (null for indeterminate)
     * @param {boolean} showTime - Show elapsed/remaining time
     * @param {boolean} showPercentage - Show percentage
     * @returns {Object} Progress bar object
     */
    createProgressBar(description = 'Processing...', total = null, showTime = true, showPercentage = true) {
        if (this._fallbackEnabled || !HAS_CLI_PROGRESS) {
            console.log(description);
            
            return {
                _total: total || 100,
                _completed: 0,
                _lastPercentage: -1,
                
                update(advance = 1) {
                    this._completed += advance;
                    if (this._total > 0) {
                        const pct = Math.min(100, (this._completed / this._total) * 100);
                        // Only print if percentage changed significantly
                        if (Math.floor(pct) !== this._lastPercentage) {
                            process.stdout.write(`\rProgress: ${pct.toFixed(1)}%`);
                            this._lastPercentage = Math.floor(pct);
                        }
                    }
                },
                
                start() {
                    // No-op for fallback
                },
                
                stop() {
                    console.log(); // New line
                }
            };
        }

        try {
            const format = showPercentage ? 
                `${description} [{bar}] {percentage}% | {value}/{total}` +
                (showTime ? ' | ETA: {eta}s | Elapsed: {duration}s' : '') :
                `${description} [{bar}] {value}${total ? `/${total}` : ''}` +
                (showTime ? ' | ETA: {eta}s | Elapsed: {duration}s' : '');

            const progressBar = new cliProgress.SingleBar({
                format: format,
                barCompleteChar: '\u2588',
                barIncompleteChar: '\u2591',
                hideCursor: true,
                clearOnComplete: false,
                stopOnComplete: true,
                forceRedraw: true
            });

            return {
                _bar: progressBar,
                _total: total || 100,
                
                update(advance = 1) {
                    this._bar.increment(advance);
                },
                
                start() {
                    this._bar.start(this._total, 0);
                },
                
                stop() {
                    this._bar.stop();
                }
            };
        } catch (e) {
            console.warn(`CLI Progress failed, falling back to basic output: ${e.message}`);
            // Return fallback implementation
            return this.createProgressBar(description, total, showTime, showPercentage);
        }
    }

    /**
     * Simple progress for iterating over items
     * @param {Array} items - Items to iterate over
     * @param {string} description - Description text
     * @returns {AsyncIterator} Async iterator with progress
     */
    async* simpleProgress(items, description = 'Processing...') {
        const total = items.length;
        const progressBar = this.createProgressBar(description, total);
        
        progressBar.start();
        
        try {
            for (const item of items) {
                yield item;
                progressBar.update(1);
            }
        } finally {
            progressBar.stop();
        }
    }

    /**
     * Print a success message with fallback support
     * @param {string} message - Message to print
     */
    printSuccess(message) {
        if (!this._fallbackEnabled && HAS_CHALK) {
            try {
                console.log(chalk.green.bold('✓') + ' ' + message);
                return;
            } catch (e) {
                if (process.env.DEBUG) console.debug(`Chalk success message failed: ${e.message}`);
            }
        }
        console.log(`✓ ${message}`);
    }

    /**
     * Print an error message with fallback support
     * @param {string} message - Message to print
     */
    printError(message) {
        if (!this._fallbackEnabled && HAS_CHALK) {
            try {
                console.error(chalk.red.bold('✗') + ' ' + message);
                return;
            } catch (e) {
                if (process.env.DEBUG) console.debug(`Chalk error message failed: ${e.message}`);
            }
        }
        console.error(`✗ ${message}`);
    }

    /**
     * Print a warning message with fallback support
     * @param {string} message - Message to print
     */
    printWarning(message) {
        if (!this._fallbackEnabled && HAS_CHALK) {
            try {
                console.error(chalk.yellow.bold('⚠') + ' ' + message);
                return;
            } catch (e) {
                if (process.env.DEBUG) console.debug(`Chalk warning message failed: ${e.message}`);
            }
        }
        console.error(`⚠ ${message}`);
    }

    /**
     * Print an info message with fallback support
     * @param {string} message - Message to print
     */
    printInfo(message) {
        if (!this._fallbackEnabled && HAS_CHALK) {
            try {
                console.log(chalk.blue.bold('ℹ') + ' ' + message);
                return;
            } catch (e) {
                if (process.env.DEBUG) console.debug(`Chalk info message failed: ${e.message}`);
            }
        }
        console.log(`ℹ ${message}`);
    }

    /**
     * Create a table for displaying data
     * @param {Array} headers - Table headers
     * @param {Object} options - Table options
     * @returns {Object} Table object
     */
    createTable(headers = [], options = {}) {
        if (!HAS_CLI_TABLE) {
            // Fallback table implementation
            return {
                _headers: headers,
                _rows: [],
                
                push(row) {
                    this._rows.push(row);
                },
                
                toString() {
                    let output = '';
                    if (this._headers.length > 0) {
                        output += this._headers.join('\t') + '\n';
                        output += this._headers.map(() => '---').join('\t') + '\n';
                    }
                    for (const row of this._rows) {
                        output += (Array.isArray(row) ? row : Object.values(row)).join('\t') + '\n';
                    }
                    return output;
                }
            };
        }

        try {
            const tableOptions = {
                head: headers,
                colWidths: options.colWidths || [],
                style: {
                    head: ['cyan'],
                    border: ['grey'],
                    'padding-left': 1,
                    'padding-right': 1
                },
                ...options
            };

            return new cliTable3(tableOptions);
        } catch (e) {
            console.warn(`CLI Table failed, falling back to basic table: ${e.message}`);
            return this.createTable(headers, options);
        }
    }
}

// Default instance
let _defaultProgress = null;

/**
 * Get the default progress helper instance with error handling
 * @returns {ProgressHelper} Progress helper instance
 */
function getProgressHelper() {
    if (_defaultProgress === null) {
        try {
            _defaultProgress = new ProgressHelper();
        } catch (e) {
            console.warn(`Failed to initialize progress helper: ${e.message}`);
            // Create a minimal fallback instance
            _defaultProgress = new ProgressHelper();
        }
    }
    return _defaultProgress;
}

// Convenience functions for common operations

/**
 * Show a spinner
 * @param {string} text - Text to display
 * @param {string} spinnerType - Spinner type
 * @param {Function} task - Task to execute
 * @returns {Promise<any>} Task result
 */
async function withSpinner(text = 'Processing...', spinnerType = 'dots', task) {
    return getProgressHelper().withSpinner(text, spinnerType, task);
}

/**
 * Create a progress bar
 * @param {string} description - Description
 * @param {number} total - Total items
 * @param {boolean} showTime - Show time info
 * @param {boolean} showPercentage - Show percentage
 * @returns {Object} Progress bar
 */
function createProgressBar(description = 'Processing...', total = null, showTime = true, showPercentage = true) {
    return getProgressHelper().createProgressBar(description, total, showTime, showPercentage);
}

/**
 * Simple progress iterator
 * @param {Array} items - Items to iterate
 * @param {string} description - Description
 * @returns {AsyncIterator} Progress iterator
 */
function simpleProgress(items, description = 'Processing...') {
    return getProgressHelper().simpleProgress(items, description);
}

/**
 * Print a success message
 * @param {string} message - Message
 */
function printSuccess(message) {
    getProgressHelper().printSuccess(message);
}

/**
 * Print an error message
 * @param {string} message - Message
 */
function printError(message) {
    getProgressHelper().printError(message);
}

/**
 * Print a warning message
 * @param {string} message - Message
 */
function printWarning(message) {
    getProgressHelper().printWarning(message);
}

/**
 * Print an info message
 * @param {string} message - Message
 */
function printInfo(message) {
    getProgressHelper().printInfo(message);
}

/**
 * Create a table
 * @param {Array} headers - Headers
 * @param {Object} options - Options
 * @returns {Object} Table
 */
function createTable(headers = [], options = {}) {
    return getProgressHelper().createTable(headers, options);
}

// Decorator-like functions
/**
 * Decorator function to add spinner to async functions
 * @param {string} text - Spinner text
 * @param {string} spinnerType - Spinner type
 * @returns {Function} Decorator function
 */
function spinnerDecorator(text = 'Processing...', spinnerType = 'dots') {
    return function(target, propertyName, descriptor) {
        const method = descriptor.value;
        descriptor.value = async function(...args) {
            return withSpinner(text, spinnerType, () => method.apply(this, args));
        };
        return descriptor;
    };
}

module.exports = {
    ProgressHelper,
    ProgressError,
    DependencyMissingError,
    getProgressHelper,
    withSpinner,
    createProgressBar,
    simpleProgress,
    printSuccess,
    printError,
    printWarning,
    printInfo,
    createTable,
    spinnerDecorator,
    
    // Export constants for checking availability
    HAS_ORA,
    HAS_CHALK,
    HAS_CLI_PROGRESS,
    HAS_CLI_TABLE
};