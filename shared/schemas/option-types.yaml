# Option Types Schema
# Defines common option types, validation rules, and environment variable mapping
# Agent B - Operational Patterns

schema_version: "1.0.0"
description: "Universal option type definitions and validation patterns"

# Core Option Types
# Standard types supported across all languages
core_types:
  string:
    description: "Text values with optional constraints"
    default_value: '""'
    constraints:
      min_length: "number"
      max_length: "number"  
      pattern: "regex_string"
      choices: "string[]"
      
    validation:
      empty_allowed: true
      whitespace_handling: "preserve"  # preserve, trim, normalize
      encoding: "utf-8"
      
    language_mapping:
      python: "str"
      nodejs: "String"
      typescript: "string" 
      rust: "String"
      
    examples:
      basic: "--name john"
      with_spaces: '--message "Hello World"'
      from_env: "NAME=john"
      
  integer:
    description: "Whole number values with range validation"
    default_value: 0
    constraints:
      min_value: "number"
      max_value: "number"
      multiple_of: "number"
      
    validation:
      allow_negative: true
      overflow_handling: "error"  # error, clamp, wrap
      
    language_mapping:
      python: "int"
      nodejs: "Number (parseInt)"
      typescript: "number"
      rust: "i32/i64"
      
    examples:
      basic: "--count 5"
      negative: "--offset -10"
      from_env: "COUNT=42"
      
  float:
    description: "Decimal number values with precision handling"
    default_value: 0.0
    constraints:
      min_value: "number"
      max_value: "number"
      precision: "number"
      
    validation:
      allow_infinite: false
      allow_nan: false
      rounding_mode: "half_even"
      
    language_mapping:
      python: "float"
      nodejs: "Number (parseFloat)"
      typescript: "number"
      rust: "f32/f64"
      
    examples:
      basic: "--rate 1.5"
      scientific: "--threshold 1e-6"
      from_env: "RATE=3.14159"
      
  boolean:
    description: "True/false flags and switches"
    default_value: false
    constraints:
      explicit_value: "boolean"  # Require --flag=true vs just --flag
      
    validation:
      true_values: ["true", "yes", "1", "on", "enable"]
      false_values: ["false", "no", "0", "off", "disable"]
      
    language_mapping:
      python: "bool (is_flag=True)"
      nodejs: "Boolean"
      typescript: "boolean"
      rust: "bool"
      
    examples:
      flag_style: "--verbose"
      explicit: "--debug=true"
      from_env: "VERBOSE=1"
      
  array:
    description: "Multiple values of the same type"
    default_value: "[]"
    constraints:
      item_type: "string"         # Type of array elements
      min_items: "number"
      max_items: "number"
      unique_items: "boolean"
      
    validation:
      separator: ","              # For single-arg multiple values
      allow_empty: true
      duplicate_handling: "keep_last"  # keep_first, keep_last, error
      
    language_mapping:
      python: "List[T] or Tuple[T, ...]"
      nodejs: "Array<T>"
      typescript: "T[]"
      rust: "Vec<T>"
      
    examples:
      multiple_args: "--file input1.txt --file input2.txt"
      comma_separated: "--tags tag1,tag2,tag3"
      from_env: "FILES=file1.txt,file2.txt"
      
  choice:
    description: "Enumerated values from a predefined set"
    default_value: "first_choice"
    constraints:
      choices: "string[]"         # Available options (required)
      case_sensitive: "boolean"
      
    validation:
      fuzzy_matching: false       # Allow approximate matches
      suggestion_threshold: 0.8   # Similarity threshold for suggestions
      
    language_mapping:
      python: "click.Choice"
      nodejs: "String with validation"
      typescript: "union literal type"
      rust: "enum"
      
    examples:
      basic: "--format json"
      case_insensitive: "--level DEBUG"
      from_env: "FORMAT=yaml"

# Extended Types  
# More specialized types for specific use cases
extended_types:
  file_path:
    description: "Path to a file with existence and permission checks"
    base_type: "string"
    constraints:
      must_exist: "boolean"
      readable: "boolean"
      writable: "boolean"
      extensions: "string[]"      # Allowed file extensions
      
    validation:
      resolve_relative: true      # Resolve to absolute path
      follow_symlinks: true
      check_permissions: true
      
    examples:
      input: "--config config.yaml"
      output: "--output-file report.json"
      from_env: "CONFIG_FILE=/etc/app/config.yaml"
      
  directory_path:
    description: "Path to a directory with existence and permission checks"
    base_type: "string"
    constraints:
      must_exist: "boolean"
      readable: "boolean"
      writable: "boolean"
      create_if_missing: "boolean"
      
    validation:
      resolve_relative: true
      follow_symlinks: true
      ensure_trailing_slash: false
      
    examples:
      basic: "--output-dir ./results"
      create: "--temp-dir /tmp/myapp"
      from_env: "OUTPUT_DIR=/var/output"
      
  url:
    description: "HTTP/HTTPS URLs with protocol validation"
    base_type: "string"
    constraints:
      schemes: "string[]"         # [http, https, ftp, etc.]
      require_tld: "boolean"
      
    validation:
      check_connectivity: false   # Ping URL during validation
      follow_redirects: true
      timeout_ms: 5000
      
    examples:
      basic: "--api-url https://api.example.com"
      with_auth: "--url https://user:pass@api.com/v1"
      from_env: "API_URL=https://api.staging.com"
      
  email:
    description: "Email address with format validation"
    base_type: "string"
    constraints:
      allow_local: false          # Allow addresses without @domain
      require_mx: false           # Check MX record exists
      
    validation:
      normalize: true             # Convert to lowercase
      check_disposable: false     # Block disposable email providers
      
    examples:
      basic: "--email user@example.com"
      from_env: "ADMIN_EMAIL=admin@company.com"
      
  date:
    description: "Date values with format parsing"
    base_type: "string"
    constraints:
      format: "string"            # ISO8601, MM/DD/YYYY, etc.
      min_date: "string"
      max_date: "string"
      
    validation:
      timezone_handling: "local"  # local, utc, preserve
      
    examples:
      iso: "--start-date 2024-01-15"
      relative: "--since yesterday"
      from_env: "START_DATE=2024-01-01"
      
  duration:
    description: "Time duration with multiple unit support"
    base_type: "string"
    constraints:
      units: ["ms", "s", "m", "h", "d"]
      max_duration: "string"
      
    validation:
      default_unit: "s"           # If no unit specified
      
    examples:
      seconds: "--timeout 30"
      with_unit: "--delay 5m"
      from_env: "TIMEOUT=30s"

# Environment Variable Mapping
env_var_patterns:
  naming_conventions:
    format: "{APP_NAME}_{OPTION_NAME}"
    case_conversion: "upper"      # upper, lower, preserve
    separator_replacement: "_"    # Replace - with _
    
  prefix_patterns:
    global_prefix: "GOOBITS"      # For framework-level options  
    app_prefix: "{APP_NAME}"      # For application-specific options
    command_prefix: "{APP_NAME}_{COMMAND}"  # For command-specific options
    
  value_processing:
    boolean_handling: "string_to_bool"  # Parse "true"/"false" strings
    array_separator: ":"               # PATH-style for arrays
    quote_handling: "preserve"         # preserve, strip, parse
    
  fallback_chain:
    order: ["cli_arg", "env_var", "config_file", "default"]
    override_behavior: "first_wins"    # first_wins, merge, explicit_only
    
  examples:
    basic: "MYAPP_VERBOSE=true"
    array: "MYAPP_FILES=file1.txt:file2.txt" 
    command_specific: "MYAPP_BUILD_OUTPUT_DIR=/tmp/build"

# Validation Rules
validation_rules:
  common_validations:
    required_check:
      description: "Ensure required options are provided"
      applies_to: "all_types"
      error_message: "Required option '{option}' is missing"
      
    type_conversion:
      description: "Convert string input to target type"
      applies_to: "all_types"  
      error_handling: "descriptive_message"
      
    constraint_validation:
      description: "Apply type-specific constraints"
      applies_to: "all_types"
      fail_fast: true             # Stop on first constraint violation
      
    dependency_validation:
      description: "Check option dependencies and conflicts"
      applies_to: "all_types"
      types: ["requires", "conflicts_with", "mutually_exclusive"]
      
  custom_validators:
    pattern: "function(value, context) -> ValidationResult"
    examples:
      port_number: "1 <= value <= 65535"
      positive_number: "value > 0"
      existing_command: "command_exists_in_path(value)"
      
  validation_context:
    available_data:
      - "current_command: string"
      - "all_parsed_options: object"
      - "environment_variables: object"  
      - "config_values: object"
      - "user_input_raw: string"
      
    helper_functions:
      - "file_exists(path: string): boolean"
      - "is_executable(path: string): boolean"
      - "resolve_path(path: string): string"
      - "check_network_connectivity(url: string): boolean"

# Default Value Strategies  
default_strategies:
  static_default:
    description: "Fixed default value specified at definition time"
    examples:
      - "default: 'production'"
      - "default: 8080"
      - "default: true"
      
  dynamic_default:
    description: "Computed default based on runtime context"
    examples:
      - "default_fn: () => process.cwd()"
      - "default_fn: () => os.hostname()"
      - "default_fn: () => new Date().toISOString()"
      
  contextual_default:
    description: "Default depends on other option values"
    examples:
      - "default_depends_on: {env: {production: 'https://api.com', dev: 'http://localhost'}}"
      - "default_depends_on: {format: {json: '.json', yaml: '.yaml'}}"
      
  inherited_default:
    description: "Default inherited from parent command or global option"
    examples:
      - "inherit_from: 'global.verbose'"
      - "inherit_from: 'parent.output_format'"

# Type Coercion Rules
type_coercion:
  string_to_number:
    rules:
      - "Parse integers in base 10 by default"
      - "Support hex (0x), octal (0o), binary (0b) prefixes"
      - "Handle scientific notation for floats"
      - "Reject non-numeric strings"
      
    error_handling: "clear_error_message_with_examples"
    
  string_to_boolean:
    true_patterns: ["true", "yes", "1", "on", "enable", "enabled"]
    false_patterns: ["false", "no", "0", "off", "disable", "disabled"]
    case_sensitivity: false
    error_handling: "suggest_valid_values"
    
  string_to_array:
    default_separator: ","
    escape_handling: "backslash_escape"
    quote_handling: "respect_quotes"
    empty_handling: "empty_array"       # empty_array, single_empty_string, error
    
  path_normalization:
    expand_home: true                   # Convert ~/path to /home/user/path
    resolve_relative: true              # Convert ./path to absolute
    normalize_separators: true          # Use OS-appropriate separators

# Language-Specific Implementation Notes
language_implementation:
  python:
    click_integration:
      - "Use click.Choice for choice types"
      - "Use click.Path for file/directory paths"
      - "Custom types inherit from click.ParamType"
      - "Environment variable support through envvar parameter"
      
    validation_timing: "eager"          # Validate immediately on parse
    error_formatting: "click.echo with colors"
    
  nodejs:
    commander_integration:
      - "Use custom coercion functions"
      - "Implement validation in action handlers"
      - "Environment variables through process.env"
      
    validation_timing: "lazy"           # Validate in command handler
    error_formatting: "chalk for colors"
    async_support: true
    
  typescript:
    type_safety:
      - "Generate TypeScript interfaces for option objects"
      - "Use union types for choice options"
      - "Generic types for arrays"
      
    validation_timing: "compile_and_runtime"
    error_formatting: "typed error objects"
    schema_generation: "automatic from types"
    
  rust:
    clap_integration:
      - "Use clap's built-in types where possible"
      - "Custom types implement FromStr trait"
      - "Derive ValueEnum for choice types"
      
    validation_timing: "eager"
    error_formatting: "structured with suggestions"
    memory_safety: "guaranteed by type system"

# Testing Patterns
testing_requirements:
  type_validation:
    - "Valid inputs for each type"
    - "Invalid inputs with expected errors"
    - "Edge cases (empty, null, very large values)"
    - "Environment variable parsing"
    - "Default value application"
    
  constraint_validation:
    - "Boundary condition testing"
    - "Constraint combination testing" 
    - "Error message quality verification"
    
  cross_platform:
    - "Path handling differences"
    - "Environment variable case sensitivity"
    - "Line ending and encoding differences"

# Integration with Other Systems
integration_points:
  command_structure:
    - "Option types must be compatible with command definitions"
    - "Global options inherit type definitions to subcommands"
    - "Hidden options respect same type validation"
    
  configuration_system:
    - "Config file values use same type coercion"
    - "Config schema generated from option types"
    - "Config validation uses option constraint rules"
    
  completion_system:
    - "Choice options provide completion candidates"
    - "File/directory options enable path completion"
    - "Type information guides completion behavior"
    
  error_handling:
    - "Type validation errors use standard error codes"
    - "Type coercion failures provide helpful suggestions"
    - "Constraint violations include valid range information"

# Migration and Compatibility
migration_strategy:
  from_current_implementation:
    - "Map existing option definitions to standard types"
    - "Preserve current validation behavior"
    - "Gradual migration of complex types"
    
  version_compatibility:
    - "New types are additive only"
    - "Existing type behavior remains unchanged"
    - "Deprecation path for obsolete patterns"
    
  plugin_compatibility:
    - "Plugin options use same type system"
    - "Plugin-defined types register with framework"
    - "Type information available to plugin completion"

# Performance Considerations
performance_optimization:
  validation_caching:
    - "Cache validation results for repeated operations"
    - "Pre-compile regex patterns"
    - "Reuse type conversion functions"
    
  lazy_evaluation:
    - "Defer expensive validations until needed"
    - "Skip unused option validation"
    - "Progressive validation for complex constraints"
    
  memory_efficiency:
    - "Minimize object creation during parsing"
    - "Use efficient data structures for choices"
    - "Pool common validation objects"

# Documentation Requirements  
documentation_standards:
  type_documentation:
    - "Clear description of accepted values"
    - "Examples for each constraint type"
    - "Common error scenarios and solutions"
    
  user_guidance:
    - "Help text generation from type definitions"
    - "Automatic example generation"
    - "Interactive help for complex types"
    
  developer_documentation:
    - "Custom type implementation guide"
    - "Validation function patterns"
    - "Integration with language ecosystems"