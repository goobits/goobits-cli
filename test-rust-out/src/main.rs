//! Generated by goobits-cli

//! 

//! Note: Rust templates are not yet installed.

//! This is a basic CLI structure. To get full functionality,

//! ensure Rust templates are installed in:

//! src/goobits_cli/templates/rust/



use clap::{Arg, ArgMatches, Command};

use std::process;

use anyhow::Result;



mod hooks;



fn main() {

    let app = Command::new("testrust")

        .about("A CLI tool")

        .version("1.2.3")

        .subcommand_required(false)

        .arg_required_else_help(true)

        // Add global options

        .arg(Arg::new("verbose")

            .short('v')

            .long("verbose")

            .help("Enable verbose output")

            .action(clap::ArgAction::SetTrue)

            .global(true))

        .arg(Arg::new("config")

            .short('c')

            .long("config")

            .help("Config file path")

            .value_name("PATH")

            .global(true));

    

    let app = build_cli(app);

    let matches = app.get_matches();

    

    if let Err(e) = handle_command(&matches) {

        eprintln!("Error: {}", e);

        process::exit(1);

    }

}



fn build_cli(app: Command) -> Command {

    let mut app = app;

    

    // Add commands from configuration

    app = app.subcommand(
        Command::new("hello")
            .about("Say hello")
    );
app = app.subcommand(
        Command::new("build")
            .about("Build something")
            .subcommand_required(true)
            .arg_required_else_help(true)
            .subcommand(
                Command::new("project")
                    .about("Build a project")
            )
    );
app = app.subcommand(
        Command::new("serve")
            .about("Start server")
    );

    

    app

}



fn handle_command(matches: &ArgMatches) -> Result<()> {

    match matches.subcommand() {

        Some(("hello", sub_matches)) => {
            let verbose = sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_matches.get_one::<String>("config").map(|s| s.as_str());
            if let Err(e) = hooks::on_hello(verbose, config) {
                eprintln!("Error: {}", e);
                std::process::exit(1);
            }
            Ok(())
        }
        Some(("build", sub_matches)) => {
            match sub_matches.subcommand() {
                Some(("project", sub_sub_matches)) => {
                let verbose = sub_sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_sub_matches.get_one::<String>("config").map(|s| s.as_str());
                if let Err(e) = hooks::on_build_project(verbose, config) {
                    eprintln!("Error: {}", e);
                    std::process::exit(1);
                }
                Ok(())
            }
            _ => {
                eprintln!("Unknown subcommand. Use --help for available options.");
                std::process::exit(1);
            }
            }
        }
        Some(("serve", sub_matches)) => {
            let verbose = sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_matches.get_one::<String>("config").map(|s| s.as_str());
            if let Err(e) = hooks::on_serve(verbose, config) {
                eprintln!("Error: {}", e);
                std::process::exit(1);
            }
            Ok(())
        }

        _ => {

            println!("No command specified. Use --help for available commands.");

            Ok(())

        }

    }

}

