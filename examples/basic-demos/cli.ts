#!/usr/bin/env node
/**
 * Demo TypeScript CLI - A sample TypeScript CLI built with Goobits
 * Generated by Goobits CLI Framework
 */

import { Command } from 'commander';
// Enhanced error handling for TypeScript
class CLIError extends Error {
    public code: number;
    public details?: string;
    
    constructor(message: string, code: number = 1, details?: string) {
        super(message);
        this.name = 'CLIError';
        this.code = code;
        this.details = details;
    }
}

// Hook loading with enhanced error handling
let hooks: any = null;
// Dynamic import for ES modules
const loadHooks = async () => {
    try {
        hooks = await import('./hooks.js');
    } catch (error: any) {
        if (error.code === 'MODULE_NOT_FOUND') {
            console.error('Hook implementation not found. Please create \'src/hooks.ts\' with your command implementations.');
            console.error('See documentation for hook function signatures.');
        } else {
            console.error(`Failed to load hooks: ${error.message}`);
        }
        process.exit(2);
    }
};

// Load hooks at startup
await loadHooks();
// Global error handler
function handleError(error: unknown, context: string = 'Command execution', verbose: boolean = false): never {
    if (error instanceof CLIError) {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.details) {
            console.error('Details:', error.details);
        }
        process.exit(error.code);
    } else if (error instanceof Error) {
        if (error.message.includes('Cannot resolve module') || error.message.includes('MODULE_NOT_FOUND')) {
            console.error('Hook implementation not found.');
            console.error('Please implement the required hook function in src/hooks.ts');
            process.exit(2);
        } else {
            console.error(`${context} failed: ${error.message}`);
            if (verbose && error.stack) {
                console.error('Stack trace:', error.stack);
            }
            process.exit(1);
        }
    } else {
        console.error(`${context} failed: Unknown error`);
        if (verbose) {
            console.error('Error details:', error);
        }
        process.exit(1);
    }
}

const program = new Command();

program
    .name('')
    .description('TypeScript CLI demonstration')
    .version('None')
    .option('-v, --verbose', 'Enable verbose error output and debugging information', false);
// Command hierarchy building for unlimited nesting
const commandMap = new Map<string, any>();// Level 1: greet
const greetCmd = program
    .command('greet')
    .description('Greet someone with style');
greetCmd.argument('name', 'No description');
greetCmd.argument('[message]', 'No description');
greetCmd.option('--style, -s', 'Greeting style', casual);
greetCmd.option('--count, -c', 'Repeat greeting N times', 1);
greetCmd.option('--uppercase, -u', 'Convert to uppercase');
greetCmd.option('--language, -l', 'Language code', en);
greetCmd.action(async (name: string, message: string, options: any) => {
    const globalOpts = program.opts();
    const verbose: boolean = globalOpts.verbose || false;
    
    try {
        const hookName = 'on_greet' as keyof typeof hooks;
        
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${String(hookName)}' not implemented in src/hooks.ts`;
            const details = availableHooks.length > 0 
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.ts';
            throw new CLIError(message, 2, details);
        }
        
        // Execute the hook function with proper error handling
        const args = [name, message];
        const result = await (hooks[hookName] as Function)(...args, options);
        
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command 'greet' failed with exit code ${result}`, result);
        }
        
    } catch (error: unknown) {
        if (error instanceof Error && (error.message.includes('SIGINT') || error.message.includes('interrupted'))) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        
        handleError(error, 'Command execution', verbose);
    }
});
commandMap.set('greet', greetCmd);

// Level 1: info
const infoCmd = program
    .command('info')
    .description('Display system and environment information');
infoCmd.option('--format, -f', 'Output format', text);
infoCmd.option('--verbose, -v', 'Show detailed information');
infoCmd.option('--sections, -s', 'Comma-separated sections to show', all);
infoCmd.action(async (options: any) => {
    const globalOpts = program.opts();
    const verbose: boolean = globalOpts.verbose || false;
    
    try {
        const hookName = 'on_info' as keyof typeof hooks;
        
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${String(hookName)}' not implemented in src/hooks.ts`;
            const details = availableHooks.length > 0 
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.ts';
            throw new CLIError(message, 2, details);
        }
        
        // Execute the hook function with proper error handling
        const args = [];
        const result = await (hooks[hookName] as Function)(...argsoptions);
        
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command 'info' failed with exit code ${result}`, result);
        }
        
    } catch (error: unknown) {
        if (error instanceof Error && (error.message.includes('SIGINT') || error.message.includes('interrupted'))) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        
        handleError(error, 'Command execution', verbose);
    }
});
commandMap.set('info', infoCmd);


program.parse();