"use strict";
/**
 * Progress helper utilities for Demo TypeScript CLI CLI
 * Generated by Goobits CLI Framework
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ProgressBar = void 0;
exports.createProgressBar = createProgressBar;
exports.withProgress = withProgress;
class ProgressBar {
    constructor(options = {}) {
        this.lastRender = '';
        this.options = {
            total: options.total || 100,
            format: options.format || '[:bar] :current/:total :percent :etas',
            clearOnComplete: options.clearOnComplete !== false,
            hideCursor: options.hideCursor !== false,
            fps: options.fps || 10,
            stream: options.stream || process.stderr,
            forceRedraw: options.forceRedraw || false,
        };
        this.state = {
            current: 0,
            total: this.options.total,
            percentage: 0,
            startTime: Date.now(),
            elapsedTime: 0,
        };
        if (this.options.hideCursor) {
            this.options.stream.write('\x1B[?25l');
        }
    }
    update(current) {
        this.state.current = Math.min(current, this.state.total);
        this.state.percentage = this.state.total > 0 ? (this.state.current / this.state.total) * 100 : 0;
        this.state.elapsedTime = Date.now() - this.state.startTime;
        if (this.state.elapsedTime > 0) {
            this.state.rate = this.state.current / (this.state.elapsedTime / 1000);
            if (this.state.rate > 0 && this.state.current < this.state.total) {
                this.state.estimatedTime = (this.state.total - this.state.current) / this.state.rate;
            }
        }
        this.render();
        if (this.state.current >= this.state.total) {
            this.complete();
        }
    }
    increment(step = 1) {
        this.update(this.state.current + step);
    }
    setTotal(total) {
        this.state.total = total;
        this.options.total = total;
    }
    complete() {
        this.state.current = this.state.total;
        this.state.percentage = 100;
        this.render();
        if (this.timer) {
            clearInterval(this.timer);
        }
        if (this.options.clearOnComplete) {
            this.options.stream.clearLine(0);
            this.options.stream.cursorTo(0);
        }
        else {
            this.options.stream.write('\n');
        }
        if (this.options.hideCursor) {
            this.options.stream.write('\x1B[?25h');
        }
    }
    terminate() {
        if (this.timer) {
            clearInterval(this.timer);
        }
        if (this.options.hideCursor) {
            this.options.stream.write('\x1B[?25h');
        }
    }
    render() {
        const rendered = this.format();
        if (rendered === this.lastRender && !this.options.forceRedraw) {
            return;
        }
        this.options.stream.clearLine(0);
        this.options.stream.cursorTo(0);
        this.options.stream.write(rendered);
        this.lastRender = rendered;
    }
    format() {
        let str = this.options.format;
        const barWidth = 40;
        const progress = Math.floor((this.state.percentage / 100) * barWidth);
        const bar = '='.repeat(progress) + ' '.repeat(barWidth - progress);
        str = str.replace(':bar', `[${bar}]`);
        str = str.replace(':current', this.state.current.toString());
        str = str.replace(':total', this.state.total.toString());
        str = str.replace(':percent', `${this.state.percentage.toFixed(1)}%`);
        str = str.replace(':elapsed', this.formatTime(this.state.elapsedTime / 1000));
        str = str.replace(':eta', this.state.estimatedTime ? this.formatTime(this.state.estimatedTime) : 'N/A');
        str = str.replace(':etas', this.state.estimatedTime ? this.formatTime(this.state.estimatedTime) : '');
        str = str.replace(':rate', this.state.rate ? `${this.state.rate.toFixed(2)}/s` : '0/s');
        return str;
    }
    formatTime(seconds) {
        const h = Math.floor(seconds / 3600);
        const m = Math.floor((seconds % 3600) / 60);
        const s = Math.floor(seconds % 60);
        if (h > 0) {
            return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
        }
        return `${m}:${s.toString().padStart(2, '0')}`;
    }
}
exports.ProgressBar = ProgressBar;
function createProgressBar(options) {
    return new ProgressBar(options);
}
function withProgress(total, task, options) {
    const progress = createProgressBar({ ...options, total });
    return task(progress)
        .then(result => {
        progress.complete();
        return result;
    })
        .catch(error => {
        progress.terminate();
        throw error;
    });
}
//# sourceMappingURL=progress.js.map