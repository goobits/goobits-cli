"use strict";
/**
 * Daemon helper utilities for Demo TypeScript CLI CLI
 * Generated by Goobits CLI Framework
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.DaemonManager = void 0;
exports.createDaemon = createDaemon;
exports.startDaemon = startDaemon;
exports.stopDaemon = stopDaemon;
exports.getDaemonStatus = getDaemonStatus;
const fs = __importStar(require("fs"));
const path = __importStar(require("path"));
const os = __importStar(require("os"));
const child_process_1 = require("child_process");
class DaemonManager {
    constructor(options) {
        this.restartCount = 0;
        const defaultPidDir = path.join(os.tmpdir(), 'daemons');
        const defaultLogDir = path.join(os.tmpdir(), 'logs');
        // Ensure directories exist
        if (!fs.existsSync(defaultPidDir)) {
            fs.mkdirSync(defaultPidDir, { recursive: true });
        }
        if (!fs.existsSync(defaultLogDir)) {
            fs.mkdirSync(defaultLogDir, { recursive: true });
        }
        this.options = {
            name: options.name,
            command: options.command,
            args: options.args || [],
            cwd: options.cwd || process.cwd(),
            env: { ...process.env, ...options.env },
            pidFile: options.pidFile || path.join(defaultPidDir, `${options.name}.pid`),
            logFile: options.logFile || path.join(defaultLogDir, `${options.name}.log`),
            errorFile: options.errorFile || path.join(defaultLogDir, `${options.name}.error.log`),
            restartOnCrash: options.restartOnCrash !== false,
            maxRestarts: options.maxRestarts || 5,
            restartDelay: options.restartDelay || 1000,
        };
    }
    async start() {
        if (await this.isRunning()) {
            throw new Error(`Daemon '${this.options.name}' is already running`);
        }
        const logStream = fs.createWriteStream(this.options.logFile, { flags: 'a' });
        const errorStream = fs.createWriteStream(this.options.errorFile, { flags: 'a' });
        this.process = (0, child_process_1.spawn)(this.options.command, this.options.args, {
            cwd: this.options.cwd,
            env: this.options.env,
            detached: true,
            stdio: ['ignore', logStream.fd, errorStream.fd],
        });
        this.startTime = new Date();
        this.restartCount = 0;
        // Unref so parent process can exit
        this.process.unref();
        // Write PID file
        fs.writeFileSync(this.options.pidFile, this.process.pid.toString());
        // Setup process event handlers
        this.process.on('exit', (code, signal) => {
            this.handleProcessExit(code, signal);
        });
        this.process.on('error', (error) => {
            console.error(`Daemon '${this.options.name}' error:`, error);
        });
        // Log startup
        logStream.write(`[${new Date().toISOString()}] Daemon started with PID ${this.process.pid}\n`);
    }
    async stop() {
        const pid = await this.getPid();
        if (!pid) {
            throw new Error(`Daemon '${this.options.name}' is not running`);
        }
        try {
            // Send SIGTERM first
            process.kill(pid, 'SIGTERM');
            // Wait a bit and check if process is still running
            await this.sleep(2000);
            if (this.isProcessRunning(pid)) {
                // Force kill with SIGKILL
                process.kill(pid, 'SIGKILL');
                await this.sleep(1000);
            }
            // Clean up PID file
            if (fs.existsSync(this.options.pidFile)) {
                fs.unlinkSync(this.options.pidFile);
            }
        }
        catch (error) {
            if (error.code === 'ESRCH') {
                // Process doesn't exist, clean up PID file
                if (fs.existsSync(this.options.pidFile)) {
                    fs.unlinkSync(this.options.pidFile);
                }
            }
            else {
                throw error;
            }
        }
    }
    async restart() {
        if (await this.isRunning()) {
            await this.stop();
        }
        // Wait a bit before restarting
        await this.sleep(1000);
        await this.start();
    }
    async status() {
        const pid = await this.getPid();
        const running = pid ? this.isProcessRunning(pid) : false;
        const status = {
            running,
            pid: running ? pid : undefined,
            startTime: this.startTime,
            restarts: this.restartCount,
        };
        if (running && this.startTime) {
            status.uptime = Date.now() - this.startTime.getTime();
        }
        return status;
    }
    async isRunning() {
        const pid = await this.getPid();
        return pid ? this.isProcessRunning(pid) : false;
    }
    async getPid() {
        try {
            if (fs.existsSync(this.options.pidFile)) {
                const pidStr = fs.readFileSync(this.options.pidFile, 'utf8').trim();
                return parseInt(pidStr, 10);
            }
        }
        catch (error) {
            // PID file doesn't exist or is invalid
        }
        return null;
    }
    async logs(tail = 100) {
        try {
            if (fs.existsSync(this.options.logFile)) {
                const content = fs.readFileSync(this.options.logFile, 'utf8');
                const lines = content.split('\n').filter(line => line.trim());
                return lines.slice(-tail).join('\n');
            }
        }
        catch (error) {
            throw new Error(`Failed to read log file: ${error}`);
        }
        return '';
    }
    async errorLogs(tail = 100) {
        try {
            if (fs.existsSync(this.options.errorFile)) {
                const content = fs.readFileSync(this.options.errorFile, 'utf8');
                const lines = content.split('\n').filter(line => line.trim());
                return lines.slice(-tail).join('\n');
            }
        }
        catch (error) {
            throw new Error(`Failed to read error log file: ${error}`);
        }
        return '';
    }
    isProcessRunning(pid) {
        try {
            // Send signal 0 to check if process exists
            process.kill(pid, 0);
            return true;
        }
        catch (error) {
            return false;
        }
    }
    handleProcessExit(code, signal) {
        const logStream = fs.createWriteStream(this.options.logFile, { flags: 'a' });
        logStream.write(`[${new Date().toISOString()}] Process exited with code ${code} and signal ${signal}\n`);
        // Clean up PID file
        if (fs.existsSync(this.options.pidFile)) {
            fs.unlinkSync(this.options.pidFile);
        }
        // Handle restart logic
        if (this.options.restartOnCrash && code !== 0 && this.restartCount < this.options.maxRestarts) {
            this.restartCount++;
            logStream.write(`[${new Date().toISOString()}] Restarting daemon (attempt ${this.restartCount}/${this.options.maxRestarts})\n`);
            setTimeout(() => {
                this.start().catch((error) => {
                    console.error(`Failed to restart daemon: ${error}`);
                });
            }, this.options.restartDelay);
        }
        logStream.end();
    }
    sleep(ms) {
        return new Promise(resolve => setTimeout(resolve, ms));
    }
}
exports.DaemonManager = DaemonManager;
// Convenience functions
function createDaemon(options) {
    return new DaemonManager(options);
}
async function startDaemon(options) {
    const daemon = new DaemonManager(options);
    await daemon.start();
    return daemon;
}
async function stopDaemon(nameOrManager) {
    if (typeof nameOrManager === 'string') {
        const daemon = new DaemonManager({ name: nameOrManager, command: '' });
        await daemon.stop();
    }
    else {
        await nameOrManager.stop();
    }
}
async function getDaemonStatus(nameOrManager) {
    if (typeof nameOrManager === 'string') {
        const daemon = new DaemonManager({ name: nameOrManager, command: '' });
        return await daemon.status();
    }
    else {
        return await nameOrManager.status();
    }
}
//# sourceMappingURL=daemon.js.map