"use strict";
/**
 * Prompts helper utilities for Demo TypeScript CLI CLI
 * Generated by Goobits CLI Framework
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.PromptsHelper = void 0;
exports.input = input;
exports.password = password;
exports.confirm = confirm;
exports.choice = choice;
exports.multiSelect = multiSelect;
const readline = __importStar(require("readline"));
class PromptsHelper {
    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
        });
    }
    async input(options) {
        return new Promise((resolve, reject) => {
            const prompt = this.formatPrompt(options.message, options.defaultValue);
            if (options.mask) {
                this.rl.stdoutMuted = true;
            }
            this.rl.question(prompt, (answer) => {
                if (options.mask) {
                    this.rl.stdoutMuted = false;
                    process.stdout.write('\n');
                }
                const value = answer.trim() || options.defaultValue || '';
                if (options.required && !value) {
                    console.error('This field is required.');
                    return this.input(options).then(resolve).catch(reject);
                }
                if (options.validate) {
                    const validation = options.validate(value);
                    if (validation !== true) {
                        console.error(typeof validation === 'string' ? validation : 'Invalid input.');
                        return this.input(options).then(resolve).catch(reject);
                    }
                }
                const result = options.transform ? options.transform(value) : value;
                resolve(result);
            });
        });
    }
    async password(message, required = true) {
        return this.input({
            message,
            required,
            mask: true,
        });
    }
    async confirm(options) {
        const defaultText = options.defaultValue === undefined ? '' :
            options.defaultValue ? ' (Y/n)' : ' (y/N)';
        const answer = await this.input({
            message: options.message + defaultText,
            defaultValue: options.defaultValue === undefined ? '' :
                options.defaultValue ? 'y' : 'n',
            validate: (input) => /^[yn]$/i.test(input) || 'Please enter y or n',
            transform: (input) => input.toLowerCase(),
        });
        return answer === 'y' || (answer === '' && options.defaultValue === true);
    }
    async choice(options) {
        console.log(options.message);
        options.choices.forEach((choice, index) => {
            const marker = choice.value === options.defaultValue ? '●' : '○';
            const description = choice.description ? ` - ${choice.description}` : '';
            console.log(`  ${marker} ${index + 1}) ${choice.name}${description}`);
        });
        const answer = await this.input({
            message: 'Select an option',
            defaultValue: options.defaultValue ?
                (options.choices.findIndex(c => c.value === options.defaultValue) + 1).toString() : '',
            validate: (input) => {
                const num = parseInt(input, 10);
                return (num >= 1 && num <= options.choices.length) ||
                    `Please enter a number between 1 and ${options.choices.length}`;
            },
        });
        const selectedIndex = parseInt(answer, 10) - 1;
        return options.choices[selectedIndex].value;
    }
    async multiSelect(options) {
        console.log(options.message);
        const selected = new Set();
        // Initialize with pre-selected items
        options.choices.forEach((choice, index) => {
            if (choice.selected) {
                selected.add(index);
            }
        });
        while (true) {
            console.clear();
            console.log(options.message);
            console.log('(Use space to select/deselect, enter to confirm)');
            options.choices.forEach((choice, index) => {
                const marker = selected.has(index) ? '●' : '○';
                const description = choice.description ? ` - ${choice.description}` : '';
                console.log(`  ${marker} ${index + 1}) ${choice.name}${description}`);
            });
            if (options.minRequired && selected.size < options.minRequired) {
                console.log(`\nMinimum ${options.minRequired} selections required.`);
            }
            if (options.maxAllowed && selected.size >= options.maxAllowed) {
                console.log(`\nMaximum ${options.maxAllowed} selections allowed.`);
            }
            const input = await this.input({
                message: 'Toggle selection (number) or press enter to confirm',
                defaultValue: '',
            });
            if (!input) {
                if (options.minRequired && selected.size < options.minRequired) {
                    console.error(`Please select at least ${options.minRequired} options.`);
                    continue;
                }
                break;
            }
            const num = parseInt(input, 10);
            if (num >= 1 && num <= options.choices.length) {
                const index = num - 1;
                if (selected.has(index)) {
                    selected.delete(index);
                }
                else if (!options.maxAllowed || selected.size < options.maxAllowed) {
                    selected.add(index);
                }
                else {
                    console.error(`Maximum ${options.maxAllowed} selections allowed.`);
                }
            }
        }
        return Array.from(selected).map(index => options.choices[index].value);
    }
    async series(prompts) {
        const results = [];
        for (const prompt of prompts) {
            const result = await prompt();
            results.push(result);
        }
        return results;
    }
    close() {
        this.rl.close();
    }
    formatPrompt(message, defaultValue) {
        const suffix = defaultValue ? ` (${defaultValue})` : '';
        return `${message}${suffix}: `;
    }
}
exports.PromptsHelper = PromptsHelper;
// Convenience functions
async function input(options) {
    const prompts = new PromptsHelper();
    try {
        return await prompts.input(options);
    }
    finally {
        prompts.close();
    }
}
async function password(message, required = true) {
    const prompts = new PromptsHelper();
    try {
        return await prompts.password(message, required);
    }
    finally {
        prompts.close();
    }
}
async function confirm(options) {
    const prompts = new PromptsHelper();
    try {
        return await prompts.confirm(options);
    }
    finally {
        prompts.close();
    }
}
async function choice(options) {
    const prompts = new PromptsHelper();
    try {
        return await prompts.choice(options);
    }
    finally {
        prompts.close();
    }
}
async function multiSelect(options) {
    const prompts = new PromptsHelper();
    try {
        return await prompts.multiSelect(options);
    }
    finally {
        prompts.close();
    }
}
//# sourceMappingURL=prompts.js.map