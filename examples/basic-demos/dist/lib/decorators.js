"use strict";
/**
 * TypeScript decorators for Demo TypeScript CLI CLI
 * Generated by Goobits CLI Framework
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.Command = Command;
exports.Option = Option;
exports.Argument = Argument;
exports.Required = Required;
exports.Min = Min;
exports.Max = Max;
exports.Pattern = Pattern;
exports.Validate = Validate;
exports.Cache = Cache;
exports.Time = Time;
exports.Retry = Retry;
exports.Deprecated = Deprecated;
exports.getCommandMetadata = getCommandMetadata;
exports.getOptionsMetadata = getOptionsMetadata;
exports.getArgumentsMetadata = getArgumentsMetadata;
exports.getValidationMetadata = getValidationMetadata;
exports.validateValue = validateValue;
// Command decorator
function Command(metadata) {
    return function (constructor) {
        Reflect.defineMetadata('command', metadata, constructor);
        return constructor;
    };
}
// Option decorator
function Option(name, description, validation) {
    return function (target, propertyKey) {
        const existingOptions = Reflect.getMetadata('options', target) || [];
        existingOptions.push({
            name,
            property: propertyKey,
            description,
            validation,
        });
        Reflect.defineMetadata('options', existingOptions, target);
    };
}
// Argument decorator
function Argument(name, description, validation) {
    return function (target, propertyKey) {
        const existingArgs = Reflect.getMetadata('arguments', target) || [];
        existingArgs.push({
            name,
            property: propertyKey,
            description,
            validation,
        });
        Reflect.defineMetadata('arguments', existingArgs, target);
    };
}
// Validation decorators
function Required(target, propertyKey) {
    const validation = { required: true };
    setValidationMetadata(target, propertyKey, validation);
}
function Min(value) {
    return function (target, propertyKey) {
        const validation = { min: value };
        setValidationMetadata(target, propertyKey, validation);
    };
}
function Max(value) {
    return function (target, propertyKey) {
        const validation = { max: value };
        setValidationMetadata(target, propertyKey, validation);
    };
}
function Pattern(regex) {
    return function (target, propertyKey) {
        const validation = { pattern: regex };
        setValidationMetadata(target, propertyKey, validation);
    };
}
function Validate(validator) {
    return function (target, propertyKey) {
        const validation = { custom: validator };
        setValidationMetadata(target, propertyKey, validation);
    };
}
// Cache decorator for expensive operations
function Cache(metadata = {}) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        const cache = new Map();
        const ttl = metadata.ttl || 60000; // Default 1 minute
        descriptor.value = async function (...args) {
            const key = metadata.key || `${propertyKey}_${JSON.stringify(args)}`;
            const now = Date.now();
            // Check cache
            const cached = cache.get(key);
            if (cached && (now - cached.timestamp) < ttl) {
                return cached.value;
            }
            // Execute original method
            const result = await originalMethod.apply(this, args);
            // Store in cache
            cache.set(key, { value: result, timestamp: now });
            return result;
        };
        return descriptor;
    };
}
// Timing decorator for performance measurement
function Time(label) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = async function (...args) {
            const startLabel = label || `${target.constructor.name}.${propertyKey}`;
            console.time(startLabel);
            try {
                const result = await originalMethod.apply(this, args);
                return result;
            }
            finally {
                console.timeEnd(startLabel);
            }
        };
        return descriptor;
    };
}
// Retry decorator for resilient operations
function Retry(maxAttempts = 3, delay = 1000) {
    return function (target, propertyKey, descriptor) {
        const originalMethod = descriptor.value;
        descriptor.value = async function (...args) {
            let lastError;
            for (let attempt = 1; attempt <= maxAttempts; attempt++) {
                try {
                    return await originalMethod.apply(this, args);
                }
                catch (error) {
                    lastError = error;
                    if (attempt === maxAttempts) {
                        throw lastError;
                    }
                    // Wait before retrying
                    await new Promise(resolve => setTimeout(resolve, delay * attempt));
                }
            }
            throw lastError;
        };
        return descriptor;
    };
}
// Deprecation decorator
function Deprecated(message, since) {
    return function (target, propertyKey, descriptor) {
        const deprecationMessage = message || `${propertyKey} is deprecated`;
        const fullMessage = since ? `${deprecationMessage} (since ${since})` : deprecationMessage;
        if (descriptor) {
            // Method decorator
            const originalMethod = descriptor.value;
            descriptor.value = function (...args) {
                console.warn(`⚠️  ${fullMessage}`);
                return originalMethod.apply(this, args);
            };
        }
        else {
            // Property decorator
            const descriptor = Object.getOwnPropertyDescriptor(target, propertyKey) || {
                value: target[propertyKey],
                writable: true,
                enumerable: true,
                configurable: true,
            };
            const originalValue = descriptor.value;
            let warned = false;
            descriptor.get = function () {
                if (!warned) {
                    console.warn(`⚠️  ${fullMessage}`);
                    warned = true;
                }
                return originalValue;
            };
            Object.defineProperty(target, propertyKey, descriptor);
        }
    };
}
// Utility functions for metadata handling
function setValidationMetadata(target, propertyKey, validation) {
    const existingValidation = Reflect.getMetadata('validation', target, propertyKey) || {};
    const mergedValidation = { ...existingValidation, ...validation };
    Reflect.defineMetadata('validation', mergedValidation, target, propertyKey);
}
function getCommandMetadata(target) {
    return Reflect.getMetadata('command', target);
}
function getOptionsMetadata(target) {
    return Reflect.getMetadata('options', target) || [];
}
function getArgumentsMetadata(target) {
    return Reflect.getMetadata('arguments', target) || [];
}
function getValidationMetadata(target, propertyKey) {
    return Reflect.getMetadata('validation', target, propertyKey);
}
// Validation helper
function validateValue(value, validation) {
    if (validation.required && (value === undefined || value === null || value === '')) {
        return 'This field is required';
    }
    if (value !== undefined && value !== null && value !== '') {
        if (validation.type) {
            const expectedType = validation.type.toLowerCase();
            const actualType = typeof value;
            if (expectedType === 'number' && actualType !== 'number') {
                return `Expected number, got ${actualType}`;
            }
            if (expectedType === 'string' && actualType !== 'string') {
                return `Expected string, got ${actualType}`;
            }
            if (expectedType === 'boolean' && actualType !== 'boolean') {
                return `Expected boolean, got ${actualType}`;
            }
        }
        if (validation.min !== undefined && typeof value === 'number' && value < validation.min) {
            return `Value must be at least ${validation.min}`;
        }
        if (validation.max !== undefined && typeof value === 'number' && value > validation.max) {
            return `Value must be at most ${validation.max}`;
        }
        if (validation.pattern && typeof value === 'string' && !validation.pattern.test(value)) {
            return `Value does not match required pattern`;
        }
        if (validation.custom) {
            const result = validation.custom(value);
            if (result !== true) {
                return typeof result === 'string' ? result : 'Custom validation failed';
            }
        }
    }
    return true;
}
//# sourceMappingURL=decorators.js.map