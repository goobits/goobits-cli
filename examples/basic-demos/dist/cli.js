#!/usr/bin/env node
"use strict";
/**
 * Demo TypeScript CLI - A sample TypeScript CLI built with Goobits
 * Generated by Goobits CLI Framework
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
const commander_1 = require("commander");
// Enhanced error handling for TypeScript
class CLIError extends Error {
    constructor(message, code = 1, details) {
        super(message);
        this.name = 'CLIError';
        this.code = code;
        this.details = details;
    }
}
// Hook loading with enhanced error handling
let hooks = null;
// Dynamic import for ES modules
const loadHooks = async () => {
    try {
        hooks = await Promise.resolve().then(() => __importStar(require('./hooks.js')));
    }
    catch (error) {
        if (error.code === 'MODULE_NOT_FOUND') {
            console.error('Hook implementation not found. Please create \'src/hooks.ts\' with your command implementations.');
            console.error('See documentation for hook function signatures.');
        }
        else {
            console.error(`Failed to load hooks: ${error.message}`);
        }
        process.exit(2);
    }
};
// Load hooks at startup
await loadHooks();
// Global error handler
function handleError(error, context = 'Command execution', verbose = false) {
    if (error instanceof CLIError) {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.details) {
            console.error('Details:', error.details);
        }
        process.exit(error.code);
    }
    else if (error instanceof Error) {
        if (error.message.includes('Cannot resolve module') || error.message.includes('MODULE_NOT_FOUND')) {
            console.error('Hook implementation not found.');
            console.error('Please implement the required hook function in src/hooks.ts');
            process.exit(2);
        }
        else {
            console.error(`${context} failed: ${error.message}`);
            if (verbose && error.stack) {
                console.error('Stack trace:', error.stack);
            }
            process.exit(1);
        }
    }
    else {
        console.error(`${context} failed: Unknown error`);
        if (verbose) {
            console.error('Error details:', error);
        }
        process.exit(1);
    }
}
const program = new commander_1.Command();
program
    .name('')
    .description('TypeScript CLI demonstration')
    .version('').option('-v, --verbose', 'Enable verbose error output and debugging information', false);
program.option('--interactive, -i', 'None');
// Command hierarchy building for unlimited nesting
const commandMap = new Map(); // Level 1: greet
const greetCmd = program
    .command('greet')
    .description('Greet someone with style');
greetCmd.argument('name', 'No description');
greetCmd.argument('[message]', 'No description');
greetCmd.option('--style <value>, -s', 'Greeting style', casual);
greetCmd.option('--count <value>, -c', 'Repeat greeting N times', 1);
greetCmd.option('--uppercase, -u', 'Convert to uppercase');
greetCmd.option('--language <value>, -l', 'Language code', en);
greetCmd.action(async (name, message, options) => {
    const globalOpts = program.opts();
    const verbose = globalOpts.verbose || false;
    try {
        const hookName = 'on_greet';
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${String(hookName)}' not implemented in src/hooks.ts`;
            const details = availableHooks.length > 0
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.ts';
            throw new CLIError(message, 2, details);
        }
        // Execute the hook function with proper error handling
        const args = [name, message];
        const result = await hooks[hookName](...args, options);
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command 'greet' failed with exit code ${result}`, result);
        }
    }
    catch (error) {
        if (error instanceof Error && (error.message.includes('SIGINT') || error.message.includes('interrupted'))) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        handleError(error, 'Command execution', verbose);
    }
});
commandMap.set('greet', greetCmd);
// Level 1: info
const infoCmd = program
    .command('info')
    .description('Display system and environment information');
infoCmd.option('--format <value>, -f', 'Output format', text);
infoCmd.option('--verbose, -v', 'Show detailed information');
infoCmd.option('--sections <value>, -s', 'Comma-separated sections to show', all);
infoCmd.action(async (options) => {
    const globalOpts = program.opts();
    const verbose = globalOpts.verbose || false;
    try {
        const hookName = 'on_info';
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${String(hookName)}' not implemented in src/hooks.ts`;
            const details = availableHooks.length > 0
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.ts';
            throw new CLIError(message, 2, details);
        }
        // Execute the hook function with proper error handling
        const args = [];
        const result = await hooks[hookName](...args, options);
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command 'info' failed with exit code ${result}`, result);
        }
    }
    catch (error) {
        if (error instanceof Error && (error.message.includes('SIGINT') || error.message.includes('interrupted'))) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        handleError(error, 'Command execution', verbose);
    }
});
commandMap.set('info', infoCmd);
program.parse();
//# sourceMappingURL=cli.js.map