#!/usr/bin/env python3
"""
Interactive mode for Demo Python CLI
Generated by Goobits CLI Framework
"""

import cmd
import shlex
import sys
from typing import List, Optional
try:
    from .demo_py_cli import cli
    from .hooks import *  # Import all hook functions
except ImportError:
    # Fallback imports
    from demo_py_cli import cli
    try:
        from hooks import *
    except ImportError:
        pass

class DemopythoncliInteractive(cmd.Cmd):
    """Interactive CLI for Demo Python CLI"""
    
    intro = "Welcome to Demo Python CLI interactive mode. Type 'help' for commands, 'exit' to quit."
    prompt = "demo_py> "
    
    def __init__(self):
        super().__init__()
        self.command_history = []
        
    def do_exit(self, arg):
        """Exit the interactive mode"""
        print("Goodbye!")
        return True
        
    def do_quit(self, arg):
        """Exit the interactive mode"""
        return self.do_exit(arg)
        
    def do_EOF(self, arg):
        """Handle Ctrl+D"""
        print()  # New line after ^D
        return True    
    def do_greet(self, arg):
        """Greet someone with style
        
        Usage: greet NAME [MESSAGE] [--style|-s] [--count|-c] [--uppercase|-u] [--language|-l]        
        Arguments:            NAME: Name to greet            MESSAGE: Custom greeting message (optional)        
        Options:            --style, -s: Greeting style            --count, -c: Repeat greeting N times            --uppercase, -u: Convert to uppercase            --language, -l: Language code        """
        try:
            # Parse arguments
            args = shlex.split(arg)
            
            # Call the hook function if it exists
            hook_name = "on_greet"
            if hook_name in globals():
                hook_func = globals()[hook_name]
                # Parse and validate arguments according to command definition
                import inspect
                sig = inspect.signature(hook_func)
                try:
                    bound_args = sig.bind(*args)
                    bound_args.apply_defaults()
                    hook_func(*bound_args.args, **bound_args.kwargs)
                except TypeError as e:
                    print(f"Error calling {hook_name}: {e}")
                    print(f"Expected signature: {sig}")
            else:
                print(f"Command 'greet' executed successfully")
                print(f"To implement custom behavior, add '{hook_name}' function to hooks.py")
        except Exception as e:
            print(f"Error: {e}")
    
    def complete_greet(self, text, line, begidx, endidx):
        """Tab completion for greet command"""
        # Basic completion for options
        options = ["--style", "-s", "--count", "-c", "--uppercase", "-u", "--language", "-l"]
        return [opt for opt in options if opt.startswith(text)]    
    def do_info(self, arg):
        """Display system and environment information
        
        Usage: info [--format|-f] [--verbose|-v] [--sections|-s]        
        Options:            --format, -f: Output format            --verbose, -v: Show detailed information            --sections, -s: Comma-separated sections to show        """
        try:
            # Parse arguments
            args = shlex.split(arg)
            
            # Call the hook function if it exists
            hook_name = "on_info"
            if hook_name in globals():
                hook_func = globals()[hook_name]
                # Parse and validate arguments according to command definition
                import inspect
                sig = inspect.signature(hook_func)
                try:
                    bound_args = sig.bind(*args)
                    bound_args.apply_defaults()
                    hook_func(*bound_args.args, **bound_args.kwargs)
                except TypeError as e:
                    print(f"Error calling {hook_name}: {e}")
                    print(f"Expected signature: {sig}")
            else:
                print(f"Command 'info' executed successfully")
                print(f"To implement custom behavior, add '{hook_name}' function to hooks.py")
        except Exception as e:
            print(f"Error: {e}")
    
    def complete_info(self, text, line, begidx, endidx):
        """Tab completion for info command"""
        # Basic completion for options
        options = ["--format", "-f", "--verbose", "-v", "--sections", "-s"]
        return [opt for opt in options if opt.startswith(text)]    
    def default(self, line):
        """Handle unknown commands"""
        print(f"Unknown command: {line.split()[0] if line else ''}")
        print("Type 'help' for available commands")
    
    def emptyline(self):
        """Handle empty line (do nothing instead of repeating last command)"""
        pass
    
    def precmd(self, line):
        """Hook before command execution"""
        if line and not line.startswith('help'):
            self.command_history.append(line)
        return line
    
    def postcmd(self, stop, line):
        """Hook after command execution"""
        return stop

def run_interactive():
    """Launch the interactive mode"""
    try:
        DemopythoncliInteractive().cmdloop()
    except KeyboardInterrupt:
        print("\nInterrupted. Use 'exit' to quit.")
        run_interactive()

if __name__ == "__main__":
    run_interactive()