//! ╔══════════════════════════════════════════════════════════════════════════╗
//! ║                           AUTO-GENERATED FILE                               ║
//! ║                                                                              ║
//! ║  Generated by: goobits-cli v1.0.0                                       ║
//! ║  Generated from: rust-example.yaml                 ║
//! ║  Generated on: 2025-08-24 22:14:06               ║
//! ║                                                                              ║
//! ║  ⚠️  DO NOT EDIT THIS FILE MANUALLY                                         ║
//! ║  Changes will be overwritten on next generation                             ║
//! ║                                                                              ║
//! ║  To modify this CLI, edit the source configuration file                     ║
//! ║                                                                              ║
//! ╚══════════════════════════════════════════════════════════════════════════╝
//!
//! demo_rust CLI - Rust Implementation
//! Generated from rust-example.yaml



use clap::{Arg, ArgMatches, Command};

use std::process;

use anyhow::Result;



mod hooks;



fn main() {

    let app = Command::new("demo_rust")

        .about("Rust CLI demonstration")

        .version("1.0.0")

        .subcommand_required(false)

        .arg_required_else_help(true)

        // Add global options

        .arg(Arg::new("verbose")

            .short('v')

            .long("verbose")

            .help("Enable verbose output")

            .action(clap::ArgAction::SetTrue)

            .global(true))

        .arg(Arg::new("config")

            .long("config")

            .help("Config file path")

            .value_name("PATH")

            .global(true));

    

    let app = build_cli(app);

    let matches = app.get_matches();

    

    if let Err(e) = handle_command(&matches) {

        eprintln!("Error: {}", e);

        process::exit(1);

    }

}



fn build_cli(app: Command) -> Command {

    let mut app = app;

    

    // Add commands from configuration

    app = app.subcommand(
        Command::new("greet")
            .about("Greet someone with style")
            .arg(Arg::new("name")
                .help("Name to greet")
                .required(true)
                .value_name("NAME"))
            .arg(Arg::new("message")
                .help("Custom greeting message")
                .required(false)
                .value_name("MESSAGE"))
            .arg(Arg::new("style")
                .help("Greeting style")
                .short('s')
                .long("style")
                .value_name("VALUE"))
            .arg(Arg::new("count")
                .help("Repeat greeting N times")
                .short('c')
                .long("count")
                .value_name("NUMBER"))
            .arg(Arg::new("uppercase")
                .help("Convert to uppercase")
                .short('u')
                .long("uppercase")
                .action(clap::ArgAction::SetTrue))
            .arg(Arg::new("language")
                .help("Language code")
                .short('l')
                .long("language")
                .value_name("VALUE"))
    );
app = app.subcommand(
        Command::new("info")
            .about("Display system and environment information")
            .arg(Arg::new("format")
                .help("Output format")
                .short('f')
                .long("format")
                .value_name("VALUE"))
            .arg(Arg::new("verbose")
                .help("Show detailed information")
                .short('v')
                .long("verbose")
                .action(clap::ArgAction::SetTrue))
            .arg(Arg::new("sections")
                .help("Comma-separated sections to show")
                .short('s')
                .long("sections")
                .value_name("VALUE"))
    );

    

    app

}



fn handle_command(matches: &ArgMatches) -> Result<()> {

    match matches.subcommand() {

        Some(("greet", sub_matches)) => {
            let name = sub_matches.get_one::<String>("name").map(|s| s.as_str()).unwrap_or("");
                let message = sub_matches.get_one::<String>("message").map(|s| s.as_str()).unwrap_or("");
                let style: Option<&str> = sub_matches.get_one::<String>("style").map(|s| s.as_str());
                let count: Option<i32> = sub_matches.get_one::<String>("count")
                    .and_then(|s| s.parse().ok());
                let uppercase = sub_matches.get_flag("uppercase");
                let language: Option<&str> = sub_matches.get_one::<String>("language").map(|s| s.as_str());
                let verbose = sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_matches.get_one::<String>("config").map(|s| s.as_str());
            if let Err(e) = hooks::on_greet(name, message, style, count, uppercase, language, verbose, config) {
                eprintln!("Error: {}", e);
                std::process::exit(1);
            }
            Ok(())
        }
        Some(("info", sub_matches)) => {
            let format: Option<&str> = sub_matches.get_one::<String>("format").map(|s| s.as_str());
                let opt_verbose = sub_matches.get_flag("verbose");
                let sections: Option<&str> = sub_matches.get_one::<String>("sections").map(|s| s.as_str());
                let global_verbose = sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_matches.get_one::<String>("config").map(|s| s.as_str());
            if let Err(e) = hooks::on_info(format, opt_verbose, sections, global_verbose, config) {
                eprintln!("Error: {}", e);
                std::process::exit(1);
            }
            Ok(())
        }

        _ => {

            println!("No command specified. Use --help for available commands.");

            Ok(())

        }

    }

}

