/**
 * CLI tests for Demo TypeScript CLI
 * Generated by Goobits CLI Framework
 */

import { execSync, spawn } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

describe('Demo TypeScript CLI CLI', () => {
  const cliPath = path.join(__dirname, '..', 'bin', 'cli.ts');
  const timeout = 30000; // 30 seconds timeout

  beforeAll(() => {
    // Ensure CLI is built and available
    expect(fs.existsSync(cliPath)).toBe(true);
  });

  describe('Basic functionality', () => {
    test('should display version', () => {
      const result = execSync(`node -r ts-node/register ${cliPath} --version`, { 
        encoding: 'utf8',
        timeout 
      });
      expect(result.trim()).toMatch(/\d+\.\d+\.\d+/);
    });

    test('should display help', () => {
      const result = execSync(`node -r ts-node/register ${cliPath} --help`, { 
        encoding: 'utf8',
        timeout 
      });
      expect(result).toContain('Usage:');
      expect(result).toContain('Options:');
    });

    test('should handle unknown commands gracefully', () => {
      try {
        execSync(`node -r ts-node/register ${cliPath} unknown-command`, { 
          encoding: 'utf8',
          timeout 
        });
        fail('Should have thrown an error');
      } catch (error: any) {
        expect(error.status).not.toBe(0);
        expect(error.stderr || error.stdout).toContain('unknown');
      }
    });
  });  describe('Commands', () => {    describe('greet', () => {
      test('should display help for greet', () => {
        const result = execSync(`node -r ts-node/register ${cliPath} greet --help`, { 
          encoding: 'utf8',
          timeout 
        });
        expect(result).toContain('Greet someone with style');
      });      test('should handle greet options', () => {
        // Test with minimal required options
        const args = ['greet'];        
        // Add --dry-run to avoid side effects in tests
        args.push('--dry-run');
        
        const cmd = `node -r ts-node/register ${cliPath} ${args.join(' ')}`;
        
        try {
          const result = execSync(cmd, { 
            encoding: 'utf8',
            timeout 
          });
          // Command should execute without error
          expect(result).toBeDefined();
        } catch (error: any) {
          // If dry-run isn't supported, that's okay for this test
          if (!error.stderr?.includes('dry-run') && !error.stdout?.includes('dry-run')) {
            throw error;
          }
        }
      });      test('should handle greet arguments', () => {
        const args = ['greet'];        args.push('test-name');        
        const cmd = `node -r ts-node/register ${cliPath} ${args.join(' ')} --help`;
        
        const result = execSync(cmd, { 
          encoding: 'utf8',
          timeout 
        });
        expect(result).toContain('Usage:');
      });    });    describe('info', () => {
      test('should display help for info', () => {
        const result = execSync(`node -r ts-node/register ${cliPath} info --help`, { 
          encoding: 'utf8',
          timeout 
        });
        expect(result).toContain('Display system and environment information');
      });      test('should handle info options', () => {
        // Test with minimal required options
        const args = ['info'];        
        // Add --dry-run to avoid side effects in tests
        args.push('--dry-run');
        
        const cmd = `node -r ts-node/register ${cliPath} ${args.join(' ')}`;
        
        try {
          const result = execSync(cmd, { 
            encoding: 'utf8',
            timeout 
          });
          // Command should execute without error
          expect(result).toBeDefined();
        } catch (error: any) {
          // If dry-run isn't supported, that's okay for this test
          if (!error.stderr?.includes('dry-run') && !error.stdout?.includes('dry-run')) {
            throw error;
          }
        }
      });    });  });
  describe('Global options', () => {
    test('should handle --debug flag', () => {
      const result = execSync(`node -r ts-node/register ${cliPath} --debug --help`, { 
        encoding: 'utf8',
        timeout 
      });
      expect(result).toContain('Usage:');
    });

    test('should handle --verbose flag', () => {
      const result = execSync(`node -r ts-node/register ${cliPath} --verbose --help`, { 
        encoding: 'utf8',
        timeout 
      });
      expect(result).toContain('Usage:');
    });  });

  describe('Error handling', () => {
    test('should handle invalid options gracefully', () => {
      try {
        execSync(`node -r ts-node/register ${cliPath} --invalid-option`, { 
          encoding: 'utf8',
          timeout 
        });
        fail('Should have thrown an error');
      } catch (error: any) {
        expect(error.status).not.toBe(0);
      }
    });

    test('should validate required arguments', () => {      try {
        execSync(`node -r ts-node/register ${cliPath} greet`, { 
          encoding: 'utf8',
          timeout 
        });
        fail('Should have thrown an error for missing required arguments');
      } catch (error: any) {
        expect(error.status).not.toBe(0);
      }    });
  });

  describe('Output format', () => {
    test('should produce clean output', () => {
      const result = execSync(`node -r ts-node/register ${cliPath} --help`, { 
        encoding: 'utf8',
        timeout 
      });
      
      // Check for clean formatting
      expect(result).not.toContain('[object Object]');
      expect(result).not.toContain('undefined');
      expect(result).not.toContain('null');
      
      // Should have proper structure
      expect(result).toMatch(/Usage:\s+/);
    });

    test('should handle JSON output if supported', () => {
      try {
        const result = execSync(`node -r ts-node/register ${cliPath} --format json --help`, { 
          encoding: 'utf8',
          timeout 
        });
        
        // If JSON format is supported, output should be valid JSON
        if (!result.includes('unknown option')) {
          expect(() => JSON.parse(result)).not.toThrow();
        }
      } catch (error: any) {
        // JSON format might not be supported, which is fine
        if (!error.stderr?.includes('unknown option') && !error.stdout?.includes('unknown option')) {
          throw error;
        }
      }
    });
  });

  describe('Performance', () => {
    test('should start up quickly', () => {
      const start = Date.now();
      execSync(`node -r ts-node/register ${cliPath} --version`, { 
        encoding: 'utf8',
        timeout 
      });
      const elapsed = Date.now() - start;
      
      // Should start up in reasonable time (less than 5 seconds)
      expect(elapsed).toBeLessThan(5000);
    });

    test('should handle multiple rapid commands', async () => {
      const promises = Array.from({ length: 5 }, () =>
        new Promise((resolve, reject) => {
          const child = spawn('node', ['-r', 'ts-node/register', cliPath, '--version'], {
            stdio: 'pipe'
          });
          
          let output = '';
          child.stdout?.on('data', (data) => {
            output += data.toString();
          });
          
          child.on('close', (code) => {
            if (code === 0) {
              resolve(output.trim());
            } else {
              reject(new Error(`Command failed with code ${code}`));
            }
          });
          
          child.on('error', reject);
        })
      );

      const results = await Promise.all(promises);
      results.forEach(result => {
        expect(result).toMatch(/\d+\.\d+\.\d+/);
      });
    });
  });

  describe('Integration', () => {
    test('should work with different Node.js versions', () => {
      // This test ensures compatibility across Node.js versions
      const result = execSync(`node -r ts-node/register ${cliPath} --version`, { 
        encoding: 'utf8',
        timeout 
      });
      expect(result.trim()).toMatch(/\d+\.\d+\.\d+/);
    });

    test('should handle different terminal environments', () => {
      // Test with different environment variables that affect CLI behavior
      const envs = [
        { TERM: 'dumb' },
        { NO_COLOR: '1' },
        { FORCE_COLOR: '1' },
        { CI: 'true' }
      ];

      envs.forEach(env => {
        const result = execSync(`node -r ts-node/register ${cliPath} --version`, {
          encoding: 'utf8',
          env: { ...process.env, ...env },
          timeout
        });
        expect(result.trim()).toMatch(/\d+\.\d+\.\d+/);
      });
    });
  });
});

// Helper functions for testing
export function runCLICommand(args: string[], options: { timeout?: number; env?: Record<string, string> } = {}): string {
  const cliPath = path.join(__dirname, '..', 'bin', 'cli.ts');
  const cmd = `node -r ts-node/register ${cliPath} ${args.join(' ')}`;
  
  return execSync(cmd, {
    encoding: 'utf8',
    timeout: options.timeout || 30000,
    env: { ...process.env, ...options.env }
  });
}

export async function runCLICommandAsync(args: string[], options: { timeout?: number; env?: Record<string, string> } = {}): Promise<string> {
  const cliPath = path.join(__dirname, '..', 'bin', 'cli.ts');
  
  return new Promise((resolve, reject) => {
    const child = spawn('node', ['-r', 'ts-node/register', cliPath, ...args], {
      stdio: 'pipe',
      env: { ...process.env, ...options.env }
    });
    
    let output = '';
    let error = '';
    
    child.stdout?.on('data', (data) => {
      output += data.toString();
    });
    
    child.stderr?.on('data', (data) => {
      error += data.toString();
    });
    
    const timeout = setTimeout(() => {
      child.kill();
      reject(new Error(`Command timed out after ${options.timeout || 30000}ms`));
    }, options.timeout || 30000);
    
    child.on('close', (code) => {
      clearTimeout(timeout);
      if (code === 0) {
        resolve(output.trim());
      } else {
        reject(new Error(`Command failed with code ${code}: ${error || output}`));
      }
    });
    
    child.on('error', (err) => {
      clearTimeout(timeout);
      reject(err);
    });
  });
}