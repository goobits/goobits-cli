#!/usr/bin/env node
/**
 * Demo Node.js CLI - A sample Node.js CLI built with Goobits
 * Generated by Goobits CLI Framework
 */

import { Command } from 'commander';

// Hook loading with enhanced error handling
let hooks = null;

const loadHooks = async () => {
    try {
        const hookModule = await import('./hooks.js');
        hooks = hookModule.default || hookModule;
    } catch (error) {
        if (error.code === 'ERR_MODULE_NOT_FOUND') {
            console.error('Hook implementation not found. Please create \'src/hooks.js\' with your command implementations.');
            console.error('See documentation for hook function signatures.');
        } else {
            console.error(`Failed to load hooks: ${error.message}`);
        }
        process.exit(2);
    }
};

// Load hooks at startup
await loadHooks();
// Enhanced error handling for Node.js
class CLIError extends Error {
    constructor(message, code = 1, details = null) {
        super(message);
        this.name = 'CLIError';
        this.code = code;
        this.details = details;
    }
}

// Global error handler
function handleError(error, context = 'Command execution', verbose = false) {
    if (error instanceof CLIError) {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.details) {
            console.error('Details:', error.details);
        }
        process.exit(error.code);
    } else if (error.code === 'MODULE_NOT_FOUND' && error.message.includes('hooks')) {
        console.error('Hook implementation not found.');
        console.error('Please implement the required hook function in src/hooks.js');
        process.exit(2);
    } else {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.stack) {
            console.error('Stack trace:', error.stack);
        }
        process.exit(1);
    }
}

const program = new Command();

program.name('')
program.description('"Node.js CLI demonstration"')
program.version('')    .option('-v, --verbose', 'Enable verbose error output and debugging information', false);program.option(
    '--interactive, -i',
    '"None"');

// Command hierarchy building for unlimited nesting
const commandMap = new Map();// Level 1: greet
const greetCmd = program
    .command('greet')
    .description('"Greet someone with style"');
greetCmd.argument('name', '"No description"');
greetCmd.argument('[message]', '"No description"');
greetCmd.option('--style, -s', '"Greeting style"', "casual");
greetCmd.option('--count, -c', '"Repeat greeting N times"', 1);
greetCmd.option('--uppercase, -u', '"Convert to uppercase"');
greetCmd.option('--language, -l', '"Language code"', "en");
greetCmd.action(async (name, message, options) => {
    const globalOpts = program.opts();
    const verbose = globalOpts.verbose || false;
    
    try {
        const hookName = 'on_greet';
        
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${hookName}' not implemented in src/hooks.js`;
            const details = availableHooks.length > 0 
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.js';
            throw new CLIError(message, 2, details);
        }
        
        // Execute the hook function with proper error handling
        const args = [name, message];
        const result = await hooks[hookName](...args, options);
        
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command 'greet' failed with exit code ${result}`, result);
        }
        
    } catch (error) {
        if (error.code === 'SIGINT' || error.message.includes('interrupted')) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        
        handleError(error, 'Command execution', verbose);
    }
});
commandMap.set('greet', greetCmd);

// Level 1: info
const infoCmd = program
    .command('info')
    .description('"Display system and environment information"');
infoCmd.option('--format, -f', '"Output format"', "text");
infoCmd.option('--verbose, -v', '"Show detailed information"');
infoCmd.option('--sections, -s', '"Comma-separated sections to show"', "all");
infoCmd.action(async (options) => {
    const globalOpts = program.opts();
    const verbose = globalOpts.verbose || false;
    
    try {
        const hookName = 'on_info';
        
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${hookName}' not implemented in src/hooks.js`;
            const details = availableHooks.length > 0 
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.js';
            throw new CLIError(message, 2, details);
        }
        
        // Execute the hook function with proper error handling
        const args = [];
        const result = await hooks[hookName](...argsoptions);
        
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command 'info' failed with exit code ${result}`, result);
        }
        
    } catch (error) {
        if (error.code === 'SIGINT' || error.message.includes('interrupted')) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        
        handleError(error, 'Command execution', verbose);
    }
});
commandMap.set('info', infoCmd);

program.parse();