/**
 * Prompts helper utilities for Demo TypeScript CLI CLI
 * Generated by Goobits CLI Framework
 */

import * as readline from 'readline';

export interface PromptOptions {
  message: string;
  defaultValue?: string;
  required?: boolean;
  validate?: (input: string) => boolean | string;
  transform?: (input: string) => string;
  mask?: boolean;
}

export interface ConfirmOptions {
  message: string;
  defaultValue?: boolean;
}

export interface ChoiceOptions<T = string> {
  message: string;
  choices: Array<{ name: string; value: T; description?: string }>;
  defaultValue?: T;
}

export interface MultiSelectOptions<T = string> {
  message: string;
  choices: Array<{ name: string; value: T; selected?: boolean; description?: string }>;
  minRequired?: number;
  maxAllowed?: number;
}

export class PromptsHelper {
  private rl: readline.Interface;

  constructor() {
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
    });
  }

  public async input(options: PromptOptions): Promise<string> {
    return new Promise((resolve, reject) => {
      const prompt = this.formatPrompt(options.message, options.defaultValue);
      
      if (options.mask) {
        this.rl.stdoutMuted = true;
      }

      this.rl.question(prompt, (answer) => {
        if (options.mask) {
          this.rl.stdoutMuted = false;
          process.stdout.write('\n');
        }

        const value = answer.trim() || options.defaultValue || '';
        
        if (options.required && !value) {
          console.error('This field is required.');
          return this.input(options).then(resolve).catch(reject);
        }

        if (options.validate) {
          const validation = options.validate(value);
          if (validation !== true) {
            console.error(typeof validation === 'string' ? validation : 'Invalid input.');
            return this.input(options).then(resolve).catch(reject);
          }
        }

        const result = options.transform ? options.transform(value) : value;
        resolve(result);
      });
    });
  }

  public async password(message: string, required: boolean = true): Promise<string> {
    return this.input({
      message,
      required,
      mask: true,
    });
  }

  public async confirm(options: ConfirmOptions): Promise<boolean> {
    const defaultText = options.defaultValue === undefined ? '' : 
                       options.defaultValue ? ' (Y/n)' : ' (y/N)';
    
    const answer = await this.input({
      message: options.message + defaultText,
      defaultValue: options.defaultValue === undefined ? '' : 
                   options.defaultValue ? 'y' : 'n',
      validate: (input) => /^[yn]$/i.test(input) || 'Please enter y or n',
      transform: (input) => input.toLowerCase(),
    });

    return answer === 'y' || (answer === '' && options.defaultValue === true);
  }

  public async choice<T = string>(options: ChoiceOptions<T>): Promise<T> {
    console.log(options.message);
    options.choices.forEach((choice, index) => {
      const marker = choice.value === options.defaultValue ? '●' : '○';
      const description = choice.description ? ` - ${choice.description}` : '';
      console.log(`  ${marker} ${index + 1}) ${choice.name}${description}`);
    });

    const answer = await this.input({
      message: 'Select an option',
      defaultValue: options.defaultValue ? 
        (options.choices.findIndex(c => c.value === options.defaultValue) + 1).toString() : '',
      validate: (input) => {
        const num = parseInt(input, 10);
        return (num >= 1 && num <= options.choices.length) || 
               `Please enter a number between 1 and ${options.choices.length}`;
      },
    });

    const selectedIndex = parseInt(answer, 10) - 1;
    return options.choices[selectedIndex].value;
  }

  public async multiSelect<T = string>(options: MultiSelectOptions<T>): Promise<T[]> {
    console.log(options.message);
    const selected = new Set<number>();
    
    // Initialize with pre-selected items
    options.choices.forEach((choice, index) => {
      if (choice.selected) {
        selected.add(index);
      }
    });

    while (true) {
      console.clear();
      console.log(options.message);
      console.log('(Use space to select/deselect, enter to confirm)');
      
      options.choices.forEach((choice, index) => {
        const marker = selected.has(index) ? '●' : '○';
        const description = choice.description ? ` - ${choice.description}` : '';
        console.log(`  ${marker} ${index + 1}) ${choice.name}${description}`);
      });

      if (options.minRequired && selected.size < options.minRequired) {
        console.log(`\nMinimum ${options.minRequired} selections required.`);
      }
      if (options.maxAllowed && selected.size >= options.maxAllowed) {
        console.log(`\nMaximum ${options.maxAllowed} selections allowed.`);
      }

      const input = await this.input({
        message: 'Toggle selection (number) or press enter to confirm',
        defaultValue: '',
      });

      if (!input) {
        if (options.minRequired && selected.size < options.minRequired) {
          console.error(`Please select at least ${options.minRequired} options.`);
          continue;
        }
        break;
      }

      const num = parseInt(input, 10);
      if (num >= 1 && num <= options.choices.length) {
        const index = num - 1;
        if (selected.has(index)) {
          selected.delete(index);
        } else if (!options.maxAllowed || selected.size < options.maxAllowed) {
          selected.add(index);
        } else {
          console.error(`Maximum ${options.maxAllowed} selections allowed.`);
        }
      }
    }

    return Array.from(selected).map(index => options.choices[index].value);
  }

  public async series<T>(prompts: Array<() => Promise<T>>): Promise<T[]> {
    const results: T[] = [];
    
    for (const prompt of prompts) {
      const result = await prompt();
      results.push(result);
    }
    
    return results;
  }

  public close(): void {
    this.rl.close();
  }

  private formatPrompt(message: string, defaultValue?: string): string {
    const suffix = defaultValue ? ` (${defaultValue})` : '';
    return `${message}${suffix}: `;
  }
}

// Convenience functions
export async function input(options: PromptOptions): Promise<string> {
  const prompts = new PromptsHelper();
  try {
    return await prompts.input(options);
  } finally {
    prompts.close();
  }
}

export async function password(message: string, required: boolean = true): Promise<string> {
  const prompts = new PromptsHelper();
  try {
    return await prompts.password(message, required);
  } finally {
    prompts.close();
  }
}

export async function confirm(options: ConfirmOptions): Promise<boolean> {
  const prompts = new PromptsHelper();
  try {
    return await prompts.confirm(options);
  } finally {
    prompts.close();
  }
}

export async function choice<T = string>(options: ChoiceOptions<T>): Promise<T> {
  const prompts = new PromptsHelper();
  try {
    return await prompts.choice(options);
  } finally {
    prompts.close();
  }
}

export async function multiSelect<T = string>(options: MultiSelectOptions<T>): Promise<T[]> {
  const prompts = new PromptsHelper();
  try {
    return await prompts.multiSelect(options);
  } finally {
    prompts.close();
  }
}