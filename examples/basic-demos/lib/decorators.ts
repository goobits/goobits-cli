/**
 * TypeScript decorators for Demo TypeScript CLI CLI
 * Generated by Goobits CLI Framework
 */

export interface CommandMetadata {
  name: string;
  description?: string;
  alias?: string;
  hidden?: boolean;
  examples?: string[];
}

export interface ValidationMetadata {
  required?: boolean;
  type?: string;
  min?: number;
  max?: number;
  pattern?: RegExp;
  custom?: (value: any) => boolean | string;
}

export interface CacheMetadata {
  ttl?: number; // Time to live in milliseconds
  key?: string;
  enabled?: boolean;
}

// Command decorator
export function Command(metadata: CommandMetadata) {
  return function <T extends { new (...args: any[]): {} }>(constructor: T) {
    Reflect.defineMetadata('command', metadata, constructor);
    return constructor;
  };
}

// Option decorator
export function Option(name: string, description?: string, validation?: ValidationMetadata) {
  return function (target: any, propertyKey: string) {
    const existingOptions = Reflect.getMetadata('options', target) || [];
    existingOptions.push({
      name,
      property: propertyKey,
      description,
      validation,
    });
    Reflect.defineMetadata('options', existingOptions, target);
  };
}

// Argument decorator
export function Argument(name: string, description?: string, validation?: ValidationMetadata) {
  return function (target: any, propertyKey: string) {
    const existingArgs = Reflect.getMetadata('arguments', target) || [];
    existingArgs.push({
      name,
      property: propertyKey,
      description,
      validation,
    });
    Reflect.defineMetadata('arguments', existingArgs, target);
  };
}

// Validation decorators
export function Required(target: any, propertyKey: string) {
  const validation: ValidationMetadata = { required: true };
  setValidationMetadata(target, propertyKey, validation);
}

export function Min(value: number) {
  return function (target: any, propertyKey: string) {
    const validation: ValidationMetadata = { min: value };
    setValidationMetadata(target, propertyKey, validation);
  };
}

export function Max(value: number) {
  return function (target: any, propertyKey: string) {
    const validation: ValidationMetadata = { max: value };
    setValidationMetadata(target, propertyKey, validation);
  };
}

export function Pattern(regex: RegExp) {
  return function (target: any, propertyKey: string) {
    const validation: ValidationMetadata = { pattern: regex };
    setValidationMetadata(target, propertyKey, validation);
  };
}

export function Validate(validator: (value: any) => boolean | string) {
  return function (target: any, propertyKey: string) {
    const validation: ValidationMetadata = { custom: validator };
    setValidationMetadata(target, propertyKey, validation);
  };
}

// Cache decorator for expensive operations
export function Cache(metadata: CacheMetadata = {}) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;
    const cache = new Map<string, { value: any; timestamp: number }>();
    const ttl = metadata.ttl || 60000; // Default 1 minute

    descriptor.value = async function (...args: any[]) {
      const key = metadata.key || `${propertyKey}_${JSON.stringify(args)}`;
      const now = Date.now();
      
      // Check cache
      const cached = cache.get(key);
      if (cached && (now - cached.timestamp) < ttl) {
        return cached.value;
      }

      // Execute original method
      const result = await originalMethod.apply(this, args);
      
      // Store in cache
      cache.set(key, { value: result, timestamp: now });
      
      return result;
    };

    return descriptor;
  };
}

// Timing decorator for performance measurement
export function Time(label?: string) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      const startLabel = label || `${target.constructor.name}.${propertyKey}`;
      console.time(startLabel);
      
      try {
        const result = await originalMethod.apply(this, args);
        return result;
      } finally {
        console.timeEnd(startLabel);
      }
    };

    return descriptor;
  };
}

// Retry decorator for resilient operations
export function Retry(maxAttempts: number = 3, delay: number = 1000) {
  return function (target: any, propertyKey: string, descriptor: PropertyDescriptor) {
    const originalMethod = descriptor.value;

    descriptor.value = async function (...args: any[]) {
      let lastError: Error;

      for (let attempt = 1; attempt <= maxAttempts; attempt++) {
        try {
          return await originalMethod.apply(this, args);
        } catch (error) {
          lastError = error as Error;
          
          if (attempt === maxAttempts) {
            throw lastError;
          }

          // Wait before retrying
          await new Promise(resolve => setTimeout(resolve, delay * attempt));
        }
      }

      throw lastError!;
    };

    return descriptor;
  };
}

// Deprecation decorator
export function Deprecated(message?: string, since?: string) {
  return function (target: any, propertyKey: string, descriptor?: PropertyDescriptor) {
    const deprecationMessage = message || `${propertyKey} is deprecated`;
    const fullMessage = since ? `${deprecationMessage} (since ${since})` : deprecationMessage;

    if (descriptor) {
      // Method decorator
      const originalMethod = descriptor.value;
      descriptor.value = function (...args: any[]) {
        console.warn(`⚠️  ${fullMessage}`);
        return originalMethod.apply(this, args);
      };
    } else {
      // Property decorator
      const descriptor = Object.getOwnPropertyDescriptor(target, propertyKey) || {
        value: target[propertyKey],
        writable: true,
        enumerable: true,
        configurable: true,
      };

      const originalValue = descriptor.value;
      let warned = false;

      descriptor.get = function () {
        if (!warned) {
          console.warn(`⚠️  ${fullMessage}`);
          warned = true;
        }
        return originalValue;
      };

      Object.defineProperty(target, propertyKey, descriptor);
    }
  };
}

// Utility functions for metadata handling
function setValidationMetadata(target: any, propertyKey: string, validation: ValidationMetadata) {
  const existingValidation = Reflect.getMetadata('validation', target, propertyKey) || {};
  const mergedValidation = { ...existingValidation, ...validation };
  Reflect.defineMetadata('validation', mergedValidation, target, propertyKey);
}

export function getCommandMetadata(target: any): CommandMetadata | undefined {
  return Reflect.getMetadata('command', target);
}

export function getOptionsMetadata(target: any): any[] {
  return Reflect.getMetadata('options', target) || [];
}

export function getArgumentsMetadata(target: any): any[] {
  return Reflect.getMetadata('arguments', target) || [];
}

export function getValidationMetadata(target: any, propertyKey: string): ValidationMetadata | undefined {
  return Reflect.getMetadata('validation', target, propertyKey);
}

// Validation helper
export function validateValue(value: any, validation: ValidationMetadata): boolean | string {
  if (validation.required && (value === undefined || value === null || value === '')) {
    return 'This field is required';
  }

  if (value !== undefined && value !== null && value !== '') {
    if (validation.type) {
      const expectedType = validation.type.toLowerCase();
      const actualType = typeof value;
      
      if (expectedType === 'number' && actualType !== 'number') {
        return `Expected number, got ${actualType}`;
      }
      if (expectedType === 'string' && actualType !== 'string') {
        return `Expected string, got ${actualType}`;
      }
      if (expectedType === 'boolean' && actualType !== 'boolean') {
        return `Expected boolean, got ${actualType}`;
      }
    }

    if (validation.min !== undefined && typeof value === 'number' && value < validation.min) {
      return `Value must be at least ${validation.min}`;
    }

    if (validation.max !== undefined && typeof value === 'number' && value > validation.max) {
      return `Value must be at most ${validation.max}`;
    }

    if (validation.pattern && typeof value === 'string' && !validation.pattern.test(value)) {
      return `Value does not match required pattern`;
    }

    if (validation.custom) {
      const result = validation.custom(value);
      if (result !== true) {
        return typeof result === 'string' ? result : 'Custom validation failed';
      }
    }
  }

  return true;
}