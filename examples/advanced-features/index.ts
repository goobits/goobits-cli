/**
 * ╔════════════════════════════════════════════════════════════════════════════╗
 * ║                        AUTO-GENERATED FILE                               ║
 * ║  Generated by: goobits-cli v1.0.0                     ║
 * ║  ⚠️  DO NOT EDIT - Changes will be overwritten                           ║
 * ╚════════════════════════════════════════════════════════════════════════════╝
 * 
 * Main CLI implementation for Nested Command Demo
 * Generated from: nested-command-demo.yaml
 */

import { Command } from 'commander';
import chalk from 'chalk';
import * as hooks from './src/hooks.js';

// Simple types for the CLI
interface CommandArgs {
  commandName: string;
  rawArgs?: Record<string, any>;
  [key: string]: any;
}

// Create the main program
const program = new Command();

// Main CLI setup
export function cli(): void {
  program
    .name('demo')
    .description('Demonstration of deep nested command capabilities')
    .version('1.0.0');

  // Define commands from configuration
  program
    .command('simple')
    .description('Simple command that works today')
    .argument('<message>', 'Message to display')
    .option('--verbose', 'Verbose output')
    .action(async (message, options: any) => {
      const args: CommandArgs = {
        commandName: 'simple',
        rawArgs: options,
        message,
      };
      
      try {
        const hookName = 'onSimple';
        if (hooks && typeof hooks[hookName as keyof typeof hooks] === 'function') {
          await (hooks[hookName as keyof typeof hooks] as (args: CommandArgs) => Promise<void>)(args);
        } else {
          console.log(chalk.blue(`Executing simple command...`));
          console.log(`  message:`, message);
          console.log('Options:', options);
        }
      } catch (error) {
        console.error(chalk.red(`Error executing simple:`), error);
        process.exit(1);
      }
    });
  program
    .command('database')
    .description('Database operations')
    .action(async (options: any) => {
      const args: CommandArgs = {
        commandName: 'database',
        rawArgs: options,
      };
      
      try {
        const hookName = 'onDatabase';
        if (hooks && typeof hooks[hookName as keyof typeof hooks] === 'function') {
          await (hooks[hookName as keyof typeof hooks] as (args: CommandArgs) => Promise<void>)(args);
        } else {
          console.log(chalk.blue(`Executing database command...`));
          console.log('Options:', options);
        }
      } catch (error) {
        console.error(chalk.red(`Error executing database:`), error);
        process.exit(1);
      }
    });
  program
    .command('api')
    .description('API management')
    .action(async (options: any) => {
      const args: CommandArgs = {
        commandName: 'api',
        rawArgs: options,
      };
      
      try {
        const hookName = 'onApi';
        if (hooks && typeof hooks[hookName as keyof typeof hooks] === 'function') {
          await (hooks[hookName as keyof typeof hooks] as (args: CommandArgs) => Promise<void>)(args);
        } else {
          console.log(chalk.blue(`Executing api command...`));
          console.log('Options:', options);
        }
      } catch (error) {
        console.error(chalk.red(`Error executing api:`), error);
        process.exit(1);
      }
    });

  // Parse arguments
  program.parse(process.argv);
  
  // Show help if no arguments provided
  if (!process.argv.slice(2).length) {
    program.outputHelp();
  }
}

// Export for use as a module
export default cli;