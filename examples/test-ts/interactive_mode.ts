#!/usr/bin/env node
/**
 * TypeScript Interactive Mode for Test TypeScript
 * Generated by Goobits CLI Framework
 * 
 * Simplified version for reliable compilation
 */

import * as readline from 'readline';
import * as fs from 'fs';
import * as path from 'path';

// Simple type definitions to avoid complex imports
interface SimpleCommandContext {
  readonly commandName: string;
  readonly args: Record<string, unknown>;
  readonly options: Record<string, unknown>;
  readonly globalOptions: Record<string, unknown>;
}

interface SimpleHookRegistry {
  [key: string]: ((context: SimpleCommandContext) => Promise<void> | void) | undefined;
}

// Import hooks with error handling
let hooks: SimpleHookRegistry = {};
try {
  hooks = require('./hooks') || {};
} catch (e) {
  console.warn('Warning: hooks module not found, using empty hooks');
}

// Command interface
interface Command {
  readonly name: string;
  readonly description: string;
  readonly handler: (args: string[]) => Promise<void> | void;
  readonly aliases?: readonly string[];
  readonly examples?: readonly string[];
}

class TesttypescriptInteractive {
  private readonly rl: readline.Interface;
  private readonly commands: Map<string, Command>;
  private readonly commandHistory: string[] = [];

  constructor() {
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: 'testts> ',
      completer: this.completer.bind(this)
    });

    this.commands = new Map();
    this.setupCommands();
    this.setupEventHandlers();
    this.loadCommandHistory();
  }

  private setupCommands(): void {
    // Built-in commands
    this.registerCommand({
      name: 'help',
      description: 'Show available commands',
      handler: this.handleHelp.bind(this),
      aliases: ['?', 'h'],
      examples: ['help', 'help <command>']
    });

    this.registerCommand({
      name: 'exit',
      description: 'Exit interactive mode',
      handler: this.handleExit.bind(this),
      aliases: ['quit', 'q'],
      examples: ['exit', 'quit']
    });

    this.registerCommand({
      name: 'history',
      description: 'Show command history',
      handler: this.handleHistory.bind(this),
      examples: ['history', 'history 10']
    });

    this.registerCommand({
      name: 'clear',
      description: 'Clear the screen',
      handler: this.handleClear.bind(this),
      aliases: ['cls'],
      examples: ['clear']
    });

    // CLI commands from configuration
    this.registerCommand({
      name: 'hello',
      description: 'Say hello',
      handler: this.handleHello.bind(this),
      examples: ['hello <name>']
    });
  }

  private setupEventHandlers(): void {
    this.rl.on('line', this.handleLine.bind(this));
    this.rl.on('close', this.handleClose.bind(this));
    this.rl.on('SIGINT', this.handleSigInt.bind(this));
  }

  private loadCommandHistory(): void {
    const historyFile = path.join(process.cwd(), '.testts_history');
    try {
      if (fs.existsSync(historyFile)) {
        const historyContent = fs.readFileSync(historyFile, 'utf-8');
        const historyLines = historyContent
          .split('\n')
          .filter(line => line.trim())
          .slice(-1000); // Keep last 1000 commands
        
        this.commandHistory.push(...historyLines);
      }
    } catch (error) {
      // Ignore history loading errors
    }
  }

  private saveCommandHistory(): void {
    const historyFile = path.join(process.cwd(), '.testts_history');
    try {
      const historyContent = this.commandHistory.slice(-1000).join('\n') + '\n';
      fs.writeFileSync(historyFile, historyContent);
    } catch (error) {
      // Ignore history saving errors
    }
  }

  start(): void {
    console.log('üöÄ Welcome to Test TypeScript interactive mode');
    console.log('   Type "help" for commands, "exit" to quit');
    console.log();
    this.rl.prompt();
  }

  private registerCommand(command: Command): void {
    this.commands.set(command.name, command);
    
    // Register aliases
    if (command.aliases) {
      command.aliases.forEach(alias => {
        this.commands.set(alias, command);
      });
    }
  }

  private async handleLine(line: string): Promise<void> {
    const trimmed = line.trim();
    if (!trimmed) {
      this.rl.prompt();
      return;
    }

    this.commandHistory.push(trimmed);
    const [commandName, ...args] = this.parseCommandLine(trimmed);

    if (this.commands.has(commandName)) {
      const command = this.commands.get(commandName)!;
      try {
        await command.handler(args);
      } catch (error) {
        console.error(`‚ùå Error executing command '${commandName}':`, (error as Error).message);
      }
    } else {
      console.error(`‚ùå Unknown command: ${commandName}`);
      console.log('üí° Type "help" for available commands');
    }

    this.rl.prompt();
  }

  private parseCommandLine(line: string): string[] {
    // Simple parsing with quote handling
    const args: string[] = [];
    let current = '';
    let inQuotes = false;
    let quoteChar = '';

    for (let i = 0; i < line.length; i++) {
      const char = line[i];
      
      if (!inQuotes && (char === '"' || char === "'")) {
        inQuotes = true;
        quoteChar = char;
      } else if (inQuotes && char === quoteChar) {
        inQuotes = false;
        quoteChar = '';
      } else if (!inQuotes && char === ' ') {
        if (current) {
          args.push(current);
          current = '';
        }
      } else {
        current += char;
      }
    }

    if (current) {
      args.push(current);
    }

    return args;
  }

  private completer(line: string): [string[], string] {
    const commandNames = Array.from(this.commands.keys());
    const hits = commandNames.filter(cmd => cmd.startsWith(line));
    return [hits.length ? hits : commandNames, line];
  }

  private handleClose(): void {
    this.saveCommandHistory();
    console.log('\nüëã Goodbye!');
    process.exit(0);
  }

  private handleSigInt(): void {
    console.log('\nüí° Use "exit" to quit or press Ctrl+C again to force quit');
    this.rl.prompt();
  }

  // Built-in command handlers
  private handleHelp(args: string[]): void {
    if (args.length > 0) {
      const commandName = args[0];
      const command = this.commands.get(commandName);
      
      if (command) {
        console.log(`\nüìñ ${command.name}: ${command.description}`);
        
        if (command.examples) {
          console.log('   Examples:');
          command.examples.forEach(example => console.log(`     ${example}`));
        }
        
        if (command.aliases && command.aliases.length > 0) {
          console.log(`   Aliases: ${command.aliases.join(', ')}`);
        }
      } else {
        console.error(`‚ùå Unknown command: ${commandName}`);
      }
    } else {
      console.log('\nüìö Available commands:');
      
      const uniqueCommands = new Set<Command>();
      this.commands.forEach(command => uniqueCommands.add(command));
      
      Array.from(uniqueCommands)
        .sort((a, b) => a.name.localeCompare(b.name))
        .forEach(command => {
          console.log(`  ${command.name.padEnd(15)} ${command.description}`);
        });
    }
    console.log();
  }

  private handleExit(): void {
    this.rl.close();
  }

  private handleHistory(args: string[]): void {
    const count = args.length > 0 ? parseInt(args[0]) : 20;
    const recentHistory = this.commandHistory.slice(-count);
    
    console.log(`\nüìú Recent command history (last ${recentHistory.length}):`);
    recentHistory.forEach((cmd, index) => {
      const lineNumber = this.commandHistory.length - recentHistory.length + index + 1;
      console.log(`  ${lineNumber.toString().padStart(4)}: ${cmd}`);
    });
    console.log();
  }

  private handleClear(): void {
    console.clear();
    console.log('üöÄ Welcome to Test TypeScript interactive mode');
    console.log('   Type "help" for commands, "exit" to quit');
    console.log();
  }

  // CLI command handlers
  
  private async handleHello(args: string[]): Promise<void> {
    const hookName = 'onHello';
    const hook = hooks[hookName];
    
    if (typeof hook === 'function') {
      try {
        // Create simple context
        const context: SimpleCommandContext = {
          commandName: 'hello',
          args: this.parseArgumentsToObject(args),
          options: this.parseOptionsToObject(args),
          globalOptions: {}
        };
        await hook(context);
      } catch (error) {
        console.error(`‚ùå Error in ${hookName}:`, (error as Error).message);
      }
    } else {
      console.error(`‚ùå Hook function '${hookName}' not implemented`);
    }
  }

  private parseArgumentsToObject(args: string[]): Record<string, unknown> {
    const result: Record<string, unknown> = {};
    
    args.forEach((arg, index) => {
      if (!arg.startsWith('-')) {
        result[`arg${index}`] = arg;
      }
    });
    
    return result;
  }

  private parseOptionsToObject(args: string[]): Record<string, unknown> {
    const result: Record<string, unknown> = {};
    
    for (let i = 0; i < args.length; i++) {
      const arg = args[i];
      if (arg.startsWith('--')) {
        const optionName = arg.slice(2);
        const nextArg = i + 1 < args.length ? args[i + 1] : null;
        
        if (nextArg && !nextArg.startsWith('-')) {
          result[optionName] = nextArg;
          i++; // Skip next argument as it's the value
        } else {
          result[optionName] = true; // Boolean flag
        }
      } else if (arg.startsWith('-') && arg.length === 2) {
        const shortOption = arg.slice(1);
        const nextArg = i + 1 < args.length ? args[i + 1] : null;
        
        if (nextArg && !nextArg.startsWith('-')) {
          result[shortOption] = nextArg;
          i++; // Skip next argument as it's the value
        } else {
          result[shortOption] = true; // Boolean flag
        }
      }
    }
    
    return result;
  }
}

// Main entry point
export function runInteractive(): void {
  const interactive = new TesttypescriptInteractive();
  interactive.start();
}

// Handle direct execution
if (require.main === module) {
  runInteractive();
}