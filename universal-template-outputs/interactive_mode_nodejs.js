#!/usr/bin/env node
/**
 * Interactive mode for Test CLI
 * Generated by Goobits CLI Framework
 */

const readline = require('readline');
const hooks = require('./hooks');

class TestcliInteractive {
    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: 'test-cli> ',
            completer: this.completer.bind(this)
        });
        
        this.commands = {
            'hello': {
                description: 'Say hello',
                handler: this.handleHello.bind(this)
            },
            'help': {
                description: 'Show available commands',
                handler: this.handleHelp.bind(this)
            },
            'exit': {
                description: 'Exit interactive mode',
                handler: this.handleExit.bind(this)
            },
            'quit': {
                description: 'Exit interactive mode',
                handler: this.handleExit.bind(this)
            }
        };
        
        this.commandHistory = [];
    }
    
    start() {
        console.log("Welcome to Test CLI interactive mode. Type 'help' for commands, 'exit' to quit.");
        
        this.rl.prompt();
        
        this.rl.on('line', async (line) => {
            const trimmed = line.trim();
            if (!trimmed) {
                this.rl.prompt();
                return;
            }
            
            this.commandHistory.push(trimmed);
            const [cmd, ...args] = trimmed.split(/\s+/);
            
            if (this.commands[cmd]) {
                try {
                    await this.commands[cmd].handler(args);
                } catch (error) {
                    console.error('Error:', error.message);
                }
            } else {
                console.log(`Unknown command: ${cmd}`);
                console.log("Type 'help' for available commands");
            }
            
            this.rl.prompt();
        });
        
        this.rl.on('close', () => {
            console.log('\nGoodbye!');
            process.exit(0);
        });
    }
    
    completer(line) {
        const completions = Object.keys(this.commands);
        const hits = completions.filter((c) => c.startsWith(line));
        return [hits.length ? hits : completions, line];
    }
    
    handleHelp(args) {
        console.log('\nAvailable commands:');
        for (const [cmd, info] of Object.entries(this.commands)) {
            console.log(`  ${cmd.padEnd(15)} ${info.description}`);
        }
        console.log();
    }
    
    handleExit(args) {
        this.rl.close();
    }
    
    async handleHello(args) {
        const hookName = 'on_hello';
        if (typeof hooks[hookName] === 'function') {
            // TODO: Parse args properly with options
            await hooks[hookName](...args);
        } else {
            console.error(`Hook function '${hookName}' not implemented`);
        }
    }
}

function runInteractive() {
    const interactive = new TestcliInteractive();
    interactive.start();
}

module.exports = { runInteractive };

if (require.main === module) {
    runInteractive();
}