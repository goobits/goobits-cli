"""
Interactive prompts and input helpers for Complex CLI Test Tool
Generated by goobits-cli
"""

import sys
from typing import Any, List, Optional, Union, Callable, Dict
from pathlib import Path

try:
    from rich.prompt import Prompt, Confirm, IntPrompt, FloatPrompt
    from rich.console import Console
    HAS_RICH_PROMPT = True
except ImportError:
    HAS_RICH_PROMPT = False

try:
    import questionary
    HAS_QUESTIONARY = True
except ImportError:
    HAS_QUESTIONARY = False


class PromptsHelper:
    """Helper class for interactive prompts and user input"""
    
    def __init__(self, console: Optional['Console'] = None):
        if HAS_RICH_PROMPT:
            self.console = console or Console()
        else:
            self.console = None
        self.use_questionary = HAS_QUESTIONARY
        self.use_rich = HAS_RICH_PROMPT
    
    def text(
        self,
        message: str,
        default: Optional[str] = None,
        validate: Optional[Callable[[str], Union[bool, str]]] = None
    ) -> str:
        """Prompt for text input"""
        if self.use_questionary:
            return questionary.text(
                message,
                default=default,
                validate=validate
            ).ask()
        elif self.use_rich:
            return Prompt.ask(message, default=default, console=self.console)
        else:
            # Fallback to built-in input
            prompt_text = message
            if default:
                prompt_text += f" [{default}]"
            prompt_text += ": "
            
            result = input(prompt_text).strip()
            return result if result else (default or "")
    
    def password(self, message: str = "Password") -> str:
        """Prompt for password input (hidden)"""
        if self.use_questionary:
            return questionary.password(message).ask()
        elif self.use_rich:
            import getpass
            return getpass.getpass(f"{message}: ")
        else:
            import getpass
            return getpass.getpass(f"{message}: ")
    
    def confirm(
        self,
        message: str,
        default: bool = False
    ) -> bool:
        """Prompt for yes/no confirmation"""
        if self.use_questionary:
            return questionary.confirm(message, default=default).ask()
        elif self.use_rich:
            return Confirm.ask(message, default=default, console=self.console)
        else:
            # Fallback implementation
            default_text = "Y/n" if default else "y/N"
            response = input(f"{message} ({default_text}): ").strip().lower()
            
            if not response:
                return default
            return response in ('y', 'yes', '1', 'true')
    
    def select(
        self,
        message: str,
        choices: List[Union[str, Dict[str, Any]]],
        default: Optional[Union[str, int]] = None
    ) -> str:
        """Prompt for selection from a list of choices"""
        if self.use_questionary:
            return questionary.select(message, choices=choices, default=default).ask()
        else:
            # Fallback implementation
            print(f"\n{message}")
            
            # Handle choice formatting
            formatted_choices = []
            for i, choice in enumerate(choices):
                if isinstance(choice, dict):
                    formatted_choices.append(choice.get('name', str(choice)))
                else:
                    formatted_choices.append(str(choice))
            
            for i, choice in enumerate(formatted_choices):
                marker = ">" if (isinstance(default, int) and i == default) or choice == default else " "
                print(f"  {marker} {i + 1}. {choice}")
            
            while True:
                try:
                    response = input("\nSelect (number): ").strip()
                    if not response and default is not None:
                        if isinstance(default, int):
                            return formatted_choices[default]
                        else:
                            return default
                    
                    index = int(response) - 1
                    if 0 <= index < len(formatted_choices):
                        return formatted_choices[index]
                    else:
                        print(f"Please enter a number between 1 and {len(formatted_choices)}")
                except ValueError:
                    print("Please enter a valid number")
                except KeyboardInterrupt:
                    print("\nCanceled")
                    sys.exit(1)
    
    def multiselect(
        self,
        message: str,
        choices: List[Union[str, Dict[str, Any]]],
        default: Optional[List[str]] = None
    ) -> List[str]:
        """Prompt for multiple selections from a list of choices"""
        if self.use_questionary:
            return questionary.checkbox(message, choices=choices, default=default).ask()
        else:
            # Fallback implementation
            print(f"\n{message}")
            print("(Use space to select, enter to confirm)")
            
            # Handle choice formatting
            formatted_choices = []
            for choice in choices:
                if isinstance(choice, dict):
                    formatted_choices.append(choice.get('name', str(choice)))
                else:
                    formatted_choices.append(str(choice))
            
            selected = set(default or [])
            
            for i, choice in enumerate(formatted_choices):
                marker = "[x]" if choice in selected else "[ ]"
                print(f"  {marker} {i + 1}. {choice}")
            
            print("\nEnter numbers separated by spaces (e.g., '1 3 5'), or 'done' to finish:")
            
            while True:
                try:
                    response = input("Select: ").strip().lower()
                    
                    if response in ('done', 'finish', ''):
                        break
                    
                    # Parse space-separated numbers
                    indices = [int(x) - 1 for x in response.split()]
                    
                    for index in indices:
                        if 0 <= index < len(formatted_choices):
                            choice = formatted_choices[index]
                            if choice in selected:
                                selected.remove(choice)
                                print(f"  Deselected: {choice}")
                            else:
                                selected.add(choice)
                                print(f"  Selected: {choice}")
                        else:
                            print(f"Invalid choice: {index + 1}")
                    
                    print("Current selection:", list(selected))
                    
                except ValueError:
                    print("Please enter valid numbers separated by spaces")
                except KeyboardInterrupt:
                    print("\nCanceled")
                    sys.exit(1)
            
            return list(selected)
    
    def integer(
        self,
        message: str,
        default: Optional[int] = None,
        min_value: Optional[int] = None,
        max_value: Optional[int] = None
    ) -> int:
        """Prompt for integer input"""
        if self.use_questionary:
            def validate_int(val):
                try:
                    num = int(val)
                    if min_value is not None and num < min_value:
                        return f"Value must be at least {min_value}"
                    if max_value is not None and num > max_value:
                        return f"Value must be at most {max_value}"
                    return True
                except ValueError:
                    return "Please enter a valid integer"
            
            return int(questionary.text(
                message,
                default=str(default) if default is not None else None,
                validate=validate_int
            ).ask())
        elif self.use_rich:
            return IntPrompt.ask(message, default=default, console=self.console)
        else:
            # Fallback implementation
            while True:
                try:
                    prompt_text = message
                    if default is not None:
                        prompt_text += f" [{default}]"
                    prompt_text += ": "
                    
                    response = input(prompt_text).strip()
                    if not response and default is not None:
                        return default
                    
                    value = int(response)
                    
                    if min_value is not None and value < min_value:
                        print(f"Value must be at least {min_value}")
                        continue
                    if max_value is not None and value > max_value:
                        print(f"Value must be at most {max_value}")
                        continue
                    
                    return value
                    
                except ValueError:
                    print("Please enter a valid integer")
                except KeyboardInterrupt:
                    print("\nCanceled")
                    sys.exit(1)
    
    def float_input(
        self,
        message: str,
        default: Optional[float] = None,
        min_value: Optional[float] = None,
        max_value: Optional[float] = None
    ) -> float:
        """Prompt for float input"""
        if self.use_rich:
            return FloatPrompt.ask(message, default=default, console=self.console)
        else:
            # Fallback implementation (similar to integer)
            while True:
                try:
                    prompt_text = message
                    if default is not None:
                        prompt_text += f" [{default}]"
                    prompt_text += ": "
                    
                    response = input(prompt_text).strip()
                    if not response and default is not None:
                        return default
                    
                    value = float(response)
                    
                    if min_value is not None and value < min_value:
                        print(f"Value must be at least {min_value}")
                        continue
                    if max_value is not None and value > max_value:
                        print(f"Value must be at most {max_value}")
                        continue
                    
                    return value
                    
                except ValueError:
                    print("Please enter a valid number")
                except KeyboardInterrupt:
                    print("\nCanceled")
                    sys.exit(1)
    
    def path(
        self,
        message: str,
        default: Optional[str] = None,
        exists: bool = False,
        is_dir: bool = False,
        is_file: bool = False
    ) -> Path:
        """Prompt for file/directory path"""
        def validate_path(path_str: str) -> Union[bool, str]:
            try:
                path_obj = Path(path_str).expanduser()
                
                if exists and not path_obj.exists():
                    return f"Path does not exist: {path_obj}"
                
                if is_dir and path_obj.exists() and not path_obj.is_dir():
                    return f"Path is not a directory: {path_obj}"
                
                if is_file and path_obj.exists() and not path_obj.is_file():
                    return f"Path is not a file: {path_obj}"
                
                return True
            except Exception as e:
                return f"Invalid path: {e}"
        
        if self.use_questionary:
            result = questionary.path(
                message,
                default=default,
                validate=validate_path
            ).ask()
        else:
            # Fallback implementation
            while True:
                path_str = self.text(message, default)
                validation_result = validate_path(path_str)
                
                if validation_result is True:
                    result = path_str
                    break
                else:
                    print(validation_result)
        
        return Path(result).expanduser()


# Default instance
_default_prompts = None


def get_prompts_helper() -> PromptsHelper:
    """Get the default prompts helper instance"""
    global _default_prompts
    if _default_prompts is None:
        _default_prompts = PromptsHelper()
    return _default_prompts


# Convenience functions
def text(message: str, default: Optional[str] = None, validate: Optional[Callable] = None) -> str:
    """Prompt for text input"""
    return get_prompts_helper().text(message, default, validate)


def password(message: str = "Password") -> str:
    """Prompt for password input"""
    return get_prompts_helper().password(message)


def confirm(message: str, default: bool = False) -> bool:
    """Prompt for confirmation"""
    return get_prompts_helper().confirm(message, default)


def select(message: str, choices: List[Union[str, Dict]], default: Optional[Union[str, int]] = None) -> str:
    """Prompt for selection from choices"""
    return get_prompts_helper().select(message, choices, default)


def multiselect(message: str, choices: List[Union[str, Dict]], default: Optional[List[str]] = None) -> List[str]:
    """Prompt for multiple selections"""
    return get_prompts_helper().multiselect(message, choices, default)


def integer(message: str, default: Optional[int] = None, min_value: Optional[int] = None, max_value: Optional[int] = None) -> int:
    """Prompt for integer input"""
    return get_prompts_helper().integer(message, default, min_value, max_value)


def float_input(message: str, default: Optional[float] = None, min_value: Optional[float] = None, max_value: Optional[float] = None) -> float:
    """Prompt for float input"""
    return get_prompts_helper().float_input(message, default, min_value, max_value)


def path(message: str, default: Optional[str] = None, exists: bool = False, is_dir: bool = False, is_file: bool = False) -> Path:
    """Prompt for file/directory path"""
    return get_prompts_helper().path(message, default, exists, is_dir, is_file)