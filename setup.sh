#!/bin/bash
# Rust-specific setup script for Test Rust CLI
# Generated by goobits-cli

set -e  # Exit on error

# Configuration
PACKAGE_NAME="test-rust-cli"
COMMAND_NAME="testcli"
DISPLAY_NAME="Test Rust CLI"
VERSION="2.0.0-beta.1"
DESCRIPTION="Test CLI for Rust compilation verification"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check Rust version
check_rust_version() {
    local required_version="1.70.0"
    
    if ! command -v rustc &> /dev/null; then
        log_error "Rust is not installed. Please install Rust ${required_version} or higher."
        log_info "Visit https://rustup.rs/ to install Rust"
        exit 1
    fi
    
    local rust_version=$(rustc --version | cut -d ' ' -f 2)
    local required_major=$(echo "$required_version" | cut -d '.' -f 1)
    local required_minor=$(echo "$required_version" | cut -d '.' -f 2)
    local rust_major=$(echo "$rust_version" | cut -d '.' -f 1)
    local rust_minor=$(echo "$rust_version" | cut -d '.' -f 2)
    
    if [ "$rust_major" -lt "$required_major" ] || ([ "$rust_major" -eq "$required_major" ] && [ "$rust_minor" -lt "$required_minor" ]); then
        log_error "Rust version $rust_version is too old. Please upgrade to Rust ${required_version} or higher."
        log_info "Run: rustup update"
        exit 1
    fi
    
    log_success "Rust version $rust_version detected"
}

# Check Cargo version
check_cargo_version() {
    if ! command -v cargo &> /dev/null; then
        log_error "Cargo is not installed. Please install Cargo (should come with Rust)."
        exit 1
    fi
    
    local cargo_version=$(cargo --version | cut -d ' ' -f 2)
    log_success "Cargo version $cargo_version detected"
}

# Build the Rust project
build_project() {
    local build_mode="$1"
    
    if [ "$build_mode" == "dev" ]; then
        log_info "Building project in development mode..."
        cargo build || {
            log_error "Failed to build project in development mode"
            exit 1
        }
        log_success "Development build completed"
    else
        log_info "Building project in release mode..."
        cargo build --release || {
            log_error "Failed to build project in release mode"
            exit 1
        }
        log_success "Release build completed"
    fi
}

# Install binary to cargo bin directory
install_cargo_bin() {
    log_info "Installing $PACKAGE_NAME using cargo install..."
    
    cargo install --path . || {
        log_error "Failed to install using cargo install"
        return 1
    }
    
    log_success "Installed to cargo bin directory. You can now use '$COMMAND_NAME' from anywhere."
}

# Install globally from crates.io
install_global() {
    log_info "Installing $PACKAGE_NAME globally from crates.io..."
    
    cargo install "$PACKAGE_NAME" || {
        log_warning "Failed to install from crates.io. Package may not be published yet."
        log_info "Try using: ./setup.sh --dev for local development installation"
        return 1
    }
    
    log_success "Installed globally from crates.io. You can now use '$COMMAND_NAME' from anywhere."
}

# Create a development symlink
create_dev_link() {
    local binary_path="target/debug/$COMMAND_NAME"
    local cargo_bin_dir="$HOME/.cargo/bin"
    
    if [ ! -f "$binary_path" ]; then
        log_error "Development binary not found at $binary_path"
        log_info "Run the build first: cargo build"
        return 1
    fi
    
    # Create cargo bin directory if it doesn't exist
    mkdir -p "$cargo_bin_dir"
    
    # Create symlink
    local link_path="$cargo_bin_dir/$COMMAND_NAME"
    if [ -L "$link_path" ]; then
        rm "$link_path"
    elif [ -f "$link_path" ]; then
        log_warning "Existing binary found at $link_path, creating backup"
        mv "$link_path" "${link_path}.bak"
    fi
    
    local full_binary_path=$(pwd)/$binary_path
    ln -s "$full_binary_path" "$link_path" || {
        log_error "Failed to create symlink"
        return 1
    }
    
    log_success "Development link created. You can now use '$COMMAND_NAME' from anywhere."
    log_info "Binary is linked to: $full_binary_path"
}

# Run tests
run_tests() {
    log_info "Running tests..."
    
    cargo test || {
        log_warning "Some tests failed"
        return 1
    }
    
    log_success "All tests passed"
}

# Setup configuration directory
setup_config_dir() {
    local config_dir="$HOME/.config/$PACKAGE_NAME"
    
    if [ ! -d "$config_dir" ]; then
        log_info "Creating configuration directory..."
        mkdir -p "$config_dir"
        log_success "Configuration directory created at $config_dir"
    fi
}

# Generate shell completions
generate_completions() {
    local completions_dir="completions"
    
    if [ ! -d "$completions_dir" ]; then
        mkdir -p "$completions_dir"
    fi
    
    log_info "Generating shell completions..."
    
    # Build first if needed
    if [ ! -f "target/release/$COMMAND_NAME" ] && [ ! -f "target/debug/$COMMAND_NAME" ]; then
        cargo build
    fi
    
    local binary_path="target/debug/$COMMAND_NAME"
    if [ -f "target/release/$COMMAND_NAME" ]; then
        binary_path="target/release/$COMMAND_NAME"
    fi
    
    # Generate completions for different shells
    "$binary_path" --generate bash > "$completions_dir/$COMMAND_NAME.bash" 2>/dev/null || true
    "$binary_path" --generate zsh > "$completions_dir/_$COMMAND_NAME" 2>/dev/null || true
    "$binary_path" --generate fish > "$completions_dir/$COMMAND_NAME.fish" 2>/dev/null || true
    
    if [ -f "$completions_dir/$COMMAND_NAME.bash" ]; then
        log_success "Shell completions generated in $completions_dir/"
        log_info "To enable bash completions, add to your ~/.bashrc:"
        log_info "  source $(pwd)/$completions_dir/$COMMAND_NAME.bash"
    fi
}

# Check for required system dependencies
check_system_deps() {
    local missing_deps=()
    
    # Check for common system dependencies that Rust projects might need
    
}

# Tree progress display
show_tree_progress() {
    local items=("$@")
    local total=${#items[@]}
    
    for i in "${!items[@]}"; do
        local item="${items[$i]}"
        local is_last=$((i == total - 1))
        
        if [ "$is_last" = 1 ]; then
            echo -e "  ${BLUE}└──${NC} $item"
        else
            echo -e "  ${BLUE}├──${NC} $item"
        fi
        
        # Simulate some work
        sleep 0.2
    done
}

# Validate installation
validate_installation() {
    log_info "Validating installation..."
    
    local validation_items=(
        "Checking binary exists"
        "Verifying configuration directory"
        "Testing basic functionality"
        "Validating dependencies"
    )
    
    show_tree_progress "${validation_items[@]}"
    
    # Check if binary exists and is executable
    if ! command -v "$COMMAND_NAME" &> /dev/null; then
        log_error "Binary '$COMMAND_NAME' not found in PATH"
        return 1
    fi
    
    # Check if configuration directory exists
    local config_dir="$HOME/.config/$PACKAGE_NAME"
    if [ ! -d "$config_dir" ]; then
        log_warning "Configuration directory not found at $config_dir"
    fi
    
    # Test basic functionality
    if ! "$COMMAND_NAME" --version &> /dev/null; then
        log_error "Binary '$COMMAND_NAME' failed basic version check"
        return 1
    fi
    
    log_success "Installation validation completed"
    return 0
}

# Uninstall function
uninstall() {
    log_info "Uninstalling $DISPLAY_NAME..."
    
    local uninstall_items=(
        "Removing binary from cargo bin"
        "Cleaning up configuration directory"
        "Removing shell completions"
        "Cleaning up development links"
    )
    
    show_tree_progress "${uninstall_items[@]}"
    
    # Remove cargo-installed binary
    if command -v cargo &> /dev/null; then
        cargo uninstall "$PACKAGE_NAME" 2>/dev/null || log_warning "Package not installed via cargo"
    fi
    
    # Remove development symlink
    local cargo_bin_dir="$HOME/.cargo/bin"
    local link_path="$cargo_bin_dir/$COMMAND_NAME"
    if [ -L "$link_path" ]; then
        rm "$link_path"
        log_success "Removed development symlink"
    fi
    
    # Ask about configuration directory
    echo ""
    read -p "Remove configuration directory ~/.config/$PACKAGE_NAME? [y/N]: " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        rm -rf "$HOME/.config/$PACKAGE_NAME"
        log_success "Configuration directory removed"
    fi
    
    # Ask about shell completions
    echo ""
    read -p "Remove shell completions? [y/N]: " -n 1 -r
    echo ""
    if [[ $REPLY =~ ^[Yy]$ ]]; then
        # Remove common completion locations
        rm -f "$HOME/.local/share/bash-completion/completions/$COMMAND_NAME" 2>/dev/null
        rm -f "$HOME/.local/share/zsh/site-functions/_$COMMAND_NAME" 2>/dev/null
        rm -f "$HOME/.config/fish/completions/$COMMAND_NAME.fish" 2>/dev/null
        log_success "Shell completions removed"
    fi
    
    log_success "Uninstall complete!"
}

# Show installation tree
show_installation_tree() {
    log_info "Installation overview:"
    echo ""
    
    local tree_items=(
        "Prerequisites Check"
        "Build Project"
        "Setup Configuration"
        "Install Binary"
        "Generate Completions"
        "Validate Installation"
    )
    
    for i in "${!tree_items[@]}"; do
        local item="${tree_items[$i]}"
        local is_last=$((i == ${#tree_items[@]} - 1))
        
        if [ "$is_last" = 1 ]; then
            echo -e "  ${GREEN}└──${NC} $item"
        else
            echo -e "  ${GREEN}├──${NC} $item"
        fi
    done
    echo ""
}

# Main setup function
main() {
    echo ""
    echo "Setting up $DISPLAY_NAME..."
    echo "===================================="
    echo ""
    
    # Determine installation mode and options
    local install_mode="release"
    local dev_mode=false
    local run_tests_flag=false
    local generate_completions_flag=false
    local validate_flag=false
    local show_tree_flag=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            install|--install)
                # Default behavior - just continue
                shift
                ;;
            uninstall|--uninstall)
                uninstall
                exit 0
                ;;
            validate|--validate)
                validate_installation
                exit $?
                ;;
            --dev|-d)
                install_mode="dev"
                dev_mode=true
                shift
                ;;
            --global|-g)
                install_global
                setup_config_dir
                exit 0
                ;;
            --test|-t)
                run_tests_flag=true
                shift
                ;;
            --completions|-c)
                generate_completions_flag=true
                shift
                ;;
            --tree)
                show_tree_flag=true
                shift
                ;;
            --help|-h)
                echo "Usage: $0 [COMMAND] [OPTIONS]"
                echo ""
                echo "Commands:"
                echo "  install           Install the CLI (default)"
                echo "  uninstall         Uninstall the CLI and optionally remove config"
                echo "  validate          Validate existing installation"
                echo ""
                echo "Install Options:"
                echo "  --dev, -d         Install in development mode with symlink"
                echo "  --global, -g      Install globally from crates.io"
                echo "  --test, -t        Run tests before installation"
                echo "  --completions, -c Generate shell completions"
                echo "  --tree            Show installation tree overview"
                echo "  --help, -h        Show this help message"
                echo ""
                echo "Examples:"
                echo "  $0                Install in release mode"
                echo "  $0 --dev          Install in development mode"
                echo "  $0 uninstall      Remove the CLI"
                echo "  $0 validate       Check installation"
                echo ""
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                log_info "Use '$0 --help' for usage information"
                exit 1
                ;;
        esac
    done
    
    # Show installation tree if requested
    if [ "$show_tree_flag" = true ]; then
        show_installation_tree
    fi
    
    # Check prerequisites
    log_info "Checking prerequisites..."
    local prereq_items=(
        "Rust toolchain version"
        "Cargo package manager"
        "System dependencies"
    )
    show_tree_progress "${prereq_items[@]}"
    
    check_rust_version
    check_cargo_version
    check_system_deps
    
    # Run tests if requested
    if [ "$run_tests_flag" = true ]; then
        log_info "Running tests..."
        run_tests
    fi
    
    # Build the project
    log_info "Building project..."
    local build_items=(
        "Compiling source code"
        "Linking dependencies"
        "Optimizing binary"
    )
    show_tree_progress "${build_items[@]}"
    build_project "$install_mode"
    
    # Setup configuration directory
    log_info "Setting up configuration..."
    setup_config_dir
    
    # Generate completions if requested
    if [ "$generate_completions_flag" = true ]; then
        log_info "Generating shell completions..."
        local completion_items=(
            "Bash completions"
            "Zsh completions"
            "Fish completions"
        )
        show_tree_progress "${completion_items[@]}"
        generate_completions
    fi
    
    # Install based on mode
    log_info "Installing binary..."
    local install_items=(
        "Installing to cargo bin directory"
        "Creating executable links"
        "Setting up PATH integration"
    )
    show_tree_progress "${install_items[@]}"
    
    if [ "$dev_mode" = true ]; then
        create_dev_link
    else
        install_cargo_bin
    fi
    
    # Validate installation
    validate_flag=true
    if [ "$validate_flag" = true ]; then
        validate_installation
    fi
    
    echo ""
    echo "===================================="
    log_success "Setup complete!"
    echo ""
    
    if [ "$dev_mode" = true ]; then
        echo "Development mode enabled. The CLI is linked to the debug build."
        echo "You can now use: $COMMAND_NAME"
        echo ""
        echo "To rebuild after changes: cargo build"
    else
        echo "Release build installed using cargo install."
        echo "You can now use: $COMMAND_NAME"
        echo ""
        echo "To rebuild: cargo build --release && cargo install --path ."
    fi
    
    echo "Configuration directory: ~/.config/$PACKAGE_NAME"
    
    if [ "$generate_completions_flag" = true ]; then
        echo "Shell completions available in: completions/"
    fi
    
    echo ""
}

# Run main function
main "$@"