//! Generated by goobits-cli

//! 

//! Note: Rust templates are not yet installed.

//! This is a basic CLI structure. To get full functionality,

//! ensure Rust templates are installed in:

//! src/goobits_cli/templates/rust/



use clap::{Arg, ArgMatches, Command};

use std::process;

use anyhow::Result;



mod hooks;



fn main() {

    let app = Command::new("goobits")

        .about("A CLI tool")

        .version("1.0.0")

        .subcommand_required(false)

        .arg_required_else_help(true)

        // Add global options

        .arg(Arg::new("verbose")

            .short('v')

            .long("verbose")

            .help("Enable verbose output")

            .action(clap::ArgAction::SetTrue)

            .global(true))

        .arg(Arg::new("config")

            .short('c')

            .long("config")

            .help("Config file path")

            .value_name("PATH")

            .global(true));

    

    let app = build_cli(app);

    let matches = app.get_matches();

    

    if let Err(e) = handle_command(&matches) {

        eprintln!("Error: {}", e);

        process::exit(1);

    }

}



fn build_cli(app: Command) -> Command {

    let mut app = app;

    

    // Add commands from configuration

    app = app.subcommand(
        Command::new("build")
            .about("Build CLI and setup scripts from goobits.yaml configuration")
            .arg(Arg::new("config_path")
                .help("Path to goobits.yaml file (defaults to ./goobits.yaml)")
                .required(false)
                .value_name("CONFIG_PATH"))
            .arg(Arg::new("output-dir")
                .help("ðŸ“ Output directory (defaults to same directory as config file)")
                .short('o')
                .long("output-dir")
                .value_name("VALUE"))
            .arg(Arg::new("output")
                .help("ðŸ“ Output filename for generated CLI (defaults to 'generated_cli.py')")
                
                .long("output")
                .value_name("VALUE"))
            .arg(Arg::new("backup")
                .help("ðŸ’¾ Create backup files (.bak) when overwriting existing files")
                
                .long("backup")
                .value_name("VALUE"))
            .arg(Arg::new("universal-templates")
                .help("ðŸ§ª Use Universal Template System (experimental)")
                
                .long("universal-templates")
                .value_name("VALUE"))
    );
app = app.subcommand(
        Command::new("init")
            .about("Create initial goobits.yaml template")
            .arg(Arg::new("project_name")
                .help("Name of the project (optional)")
                .required(false)
                .value_name("PROJECT_NAME"))
            .arg(Arg::new("template")
                .help("ðŸŽ¯ Template type")
                .short('t')
                .long("template")
                .value_name("VALUE"))
            .arg(Arg::new("force")
                .help("ðŸ”¥ Overwrite existing goobits.yaml file")
                
                .long("force")
                .value_name("VALUE"))
    );
app = app.subcommand(
        Command::new("serve")
            .about("Serve local PyPI-compatible package index")
            .arg(Arg::new("directory")
                .help("Directory containing packages to serve")
                .required(true)
                .value_name("DIRECTORY"))
            .arg(Arg::new("host")
                .help("ðŸŒ Host to bind the server to")
                
                .long("host")
                .value_name("VALUE"))
            .arg(Arg::new("port")
                .help("ðŸ”Œ Port to run the server on")
                .short('p')
                .long("port")
                .value_name("NUMBER"))
    );

    

    app

}



fn handle_command(matches: &ArgMatches) -> Result<()> {

    match matches.subcommand() {

        Some(("build", sub_matches)) => {
            let config_path = sub_matches.get_one::<String>("config_path").map(|s| s.as_str()).unwrap_or("");
                let output-dir: Option<&str> = sub_matches.get_one::<String>("output-dir").map(|s| s.as_str());
                let output: Option<&str> = sub_matches.get_one::<String>("output").map(|s| s.as_str());
                let backup: Option<&str> = sub_matches.get_one::<String>("backup").map(|s| s.as_str());
                let universal-templates: Option<&str> = sub_matches.get_one::<String>("universal-templates").map(|s| s.as_str());
                let verbose = sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_matches.get_one::<String>("config").map(|s| s.as_str());
            if let Err(e) = hooks::on_build(config_path, output-dir, output, backup, universal-templates, verbose, config) {
                eprintln!("Error: {}", e);
                std::process::exit(1);
            }
            Ok(())
        }
        Some(("init", sub_matches)) => {
            let project_name = sub_matches.get_one::<String>("project_name").map(|s| s.as_str()).unwrap_or("");
                let template: Option<&str> = sub_matches.get_one::<String>("template").map(|s| s.as_str());
                let force: Option<&str> = sub_matches.get_one::<String>("force").map(|s| s.as_str());
                let verbose = sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_matches.get_one::<String>("config").map(|s| s.as_str());
            if let Err(e) = hooks::on_init(project_name, template, force, verbose, config) {
                eprintln!("Error: {}", e);
                std::process::exit(1);
            }
            Ok(())
        }
        Some(("serve", sub_matches)) => {
            let directory = sub_matches.get_one::<String>("directory").map(|s| s.as_str()).unwrap_or("");
                let host: Option<&str> = sub_matches.get_one::<String>("host").map(|s| s.as_str());
                let port: Option<i32> = sub_matches.get_one::<String>("port")
                    .and_then(|s| s.parse().ok());
                let verbose = sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_matches.get_one::<String>("config").map(|s| s.as_str());
            if let Err(e) = hooks::on_serve(directory, host, port, verbose, config) {
                eprintln!("Error: {}", e);
                std::process::exit(1);
            }
            Ok(())
        }

        _ => {

            println!("No command specified. Use --help for available commands.");

            Ok(())

        }

    }

}

