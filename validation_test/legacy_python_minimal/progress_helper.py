"""
Progress indicators and visual feedback helpers for Minimal Test CLI
Generated by goobits-cli
"""

import sys
import time
import logging
from typing import Any, Callable, Optional, Union, Iterator
from contextlib import contextmanager


# Custom Exception Classes for Progress Operations
class ProgressError(Exception):
    """Base exception for progress operations."""
    def __init__(self, message: str, suggestion: Optional[str] = None):
        self.message = message
        self.suggestion = suggestion
        super().__init__(self.message)


class DependencyMissingError(ProgressError):
    """Required dependency is missing."""
    def __init__(self, dependency: str, feature: str, install_command: Optional[str] = None):
        self.dependency = dependency
        self.feature = feature
        self.install_command = install_command
        message = f"'{dependency}' is required for {feature} but is not installed"
        suggestion = f"Install with: {install_command}" if install_command else f"Install the '{dependency}' package"
        super().__init__(message, suggestion)


# Set up logging
logger = logging.getLogger(__name__)

try:
    from rich.progress import (
        Progress, TaskID, BarColumn, TextColumn, TimeRemainingColumn,
        SpinnerColumn, MofNCompleteColumn, TimeElapsedColumn
    )
    from rich.console import Console
    from rich.spinner import Spinner
    HAS_RICH = True
    logger.debug("Rich library loaded successfully")
except ImportError as e:
    HAS_RICH = False
    Progress = None
    TaskID = None
    logger.debug(f"Rich library not available: {e}")
    logger.info("Progress features will use basic fallbacks. Install 'rich' for enhanced display: pip install rich")


class ProgressHelper:
    """Helper class for progress indicators and visual feedback"""
    
    def __init__(self, console: Optional['Console'] = None):
        self._fallback_enabled = not HAS_RICH
        
        if HAS_RICH:
            try:
                self.console = console or Console()
                logger.debug("Rich console initialized")
            except Exception as e:
                logger.warning(f"Failed to initialize Rich console: {e}")
                self.console = None
                self._fallback_enabled = True
        else:
            self.console = None
            logger.debug("Using fallback mode (Rich not available)")
    
    @contextmanager
    def spinner(self, text: str = "Processing...", spinner: str = "dots"):
        """Context manager for showing a spinner with enhanced error handling."""
        if self._fallback_enabled or not self.console:
            print(f"{text}", end="", flush=True)
            try:
                yield None
                print(" ✓")
            except Exception as e:
                print(" ✗")
                raise
            return
        
        try:
            with self.console.status(f"[bold blue]{text}") as status:
                try:
                    status.spinner = spinner
                except Exception as e:
                    logger.debug(f"Failed to set spinner style '{spinner}': {e}")
                    # Continue with default spinner
                yield status
        except Exception as e:
            logger.warning(f"Rich spinner failed, falling back to basic output: {e}")
            # Fallback to basic output
            print(f"{text}", end="", flush=True)
            try:
                yield None
                print(" ✓")
            except Exception as inner_e:
                print(" ✗")
                raise inner_e
    
    @contextmanager  
    def progress_bar(
        self,
        description: str = "Processing...",
        total: Optional[int] = None,
        show_time: bool = True,
        show_percentage: bool = True
    ):
        """Context manager for showing a progress bar with enhanced error handling."""
        if self._fallback_enabled or not self.console:
            print(f"{description}")
            
            class FallbackProgress:
                def __init__(self):
                    self.total = total or 100
                    self.completed = 0
                    self.last_percentage = -1
                
                def update(self, task_id, advance: int = 1):
                    self.completed += advance
                    if self.total > 0:
                        pct = min(100, (self.completed / self.total) * 100)
                        # Only print if percentage changed significantly
                        if int(pct) != self.last_percentage:
                            print(f"\rProgress: {pct:.1f}%", end="", flush=True)
                            self.last_percentage = int(pct)
                
                def add_task(self, description: str, total: Optional[int] = None):
                    return "fallback_task"
            
            progress = FallbackProgress()
            try:
                yield progress, "fallback_task"
            finally:
                print()  # New line
            return
        
        try:
            # Rich progress bar columns
            columns = [
                TextColumn("[bold blue]{task.description}"),
                SpinnerColumn(),
                BarColumn(),
            ]
            
            if show_percentage:
                columns.append(TextColumn("[progress.percentage]{task.percentage:>3.0f}%"))
            
            if total is not None:
                columns.append(MofNCompleteColumn())
            
            if show_time:
                columns.extend([
                    TimeElapsedColumn(),
                    TimeRemainingColumn(),
                ])
            
            with Progress(*columns, console=self.console) as progress:
                task_id = progress.add_task(description, total=total)
                yield progress, task_id
                
        except Exception as e:
            logger.warning(f"Rich progress bar failed, falling back to basic output: {e}")
            # Fallback to simple progress
            print(f"{description}")
            
            class FallbackProgress:
                def __init__(self):
                    self.total = total or 100
                    self.completed = 0
                
                def update(self, task_id, advance: int = 1):
                    self.completed += advance
                    if self.total > 0:
                        pct = (self.completed / self.total) * 100
                        print(f"\rProgress: {pct:.1f}%", end="", flush=True)
                
                def add_task(self, description: str, total: Optional[int] = None):
                    return "fallback_task"
            
            progress = FallbackProgress()
            try:
                yield progress, "fallback_task"
            finally:
                print()  # New line
    
    def simple_progress(self, items: Iterator[Any], description: str = "Processing..."):
        """Simple progress bar for iterating over items"""
        items_list = list(items)
        total = len(items_list)
        
        with self.progress_bar(description, total=total) as (progress, task_id):
            for item in items_list:
                yield item
                progress.update(task_id, advance=1)
    
    def print_success(self, message: str):
        """Print a success message with fallback support."""
        if not self._fallback_enabled and self.console:
            try:
                self.console.print(f"[bold green]✓[/bold green] {message}")
                return
            except Exception as e:
                logger.debug(f"Rich success message failed: {e}")
        print(f"✓ {message}")
    
    def print_error(self, message: str):
        """Print an error message with fallback support."""
        if not self._fallback_enabled and self.console:
            try:
                self.console.print(f"[bold red]✗[/bold red] {message}", err=True)
                return
            except Exception as e:
                logger.debug(f"Rich error message failed: {e}")
        print(f"✗ {message}", file=sys.stderr)
    
    def print_warning(self, message: str):
        """Print a warning message with fallback support."""
        if not self._fallback_enabled and self.console:
            try:
                self.console.print(f"[bold yellow]⚠[/bold yellow] {message}", err=True)
                return
            except Exception as e:
                logger.debug(f"Rich warning message failed: {e}")
        print(f"⚠ {message}", file=sys.stderr)
    
    def print_info(self, message: str):
        """Print an info message with fallback support."""
        if not self._fallback_enabled and self.console:
            try:
                self.console.print(f"[bold blue]ℹ[/bold blue] {message}")
                return
            except Exception as e:
                logger.debug(f"Rich info message failed: {e}")
        print(f"ℹ {message}")


# Default instance
_default_progress = None


def get_progress_helper() -> ProgressHelper:
    """Get the default progress helper instance with error handling."""
    global _default_progress
    if _default_progress is None:
        try:
            _default_progress = ProgressHelper()
        except Exception as e:
            logger.warning(f"Failed to initialize progress helper: {e}")
            # Create a minimal fallback instance
            _default_progress = ProgressHelper(console=None)
    return _default_progress


# Convenience functions
def with_spinner(text: str = "Processing...", spinner: str = "dots"):
    """Decorator for adding a spinner to a function"""
    def decorator(func: Callable):
        def wrapper(*args, **kwargs):
            progress = get_progress_helper()
            with progress.spinner(text, spinner):
                return func(*args, **kwargs)
        return wrapper
    return decorator


def with_progress(description: str = "Processing...", total: Optional[int] = None):
    """Decorator for adding a progress bar to a function"""
    def decorator(func: Callable):
        def wrapper(*args, **kwargs):
            progress = get_progress_helper()
            with progress.progress_bar(description, total) as (prog, task_id):
                # Pass progress and task_id as keyword arguments if function accepts them
                import inspect
                sig = inspect.signature(func)
                if 'progress' in sig.parameters and 'task_id' in sig.parameters:
                    return func(*args, progress=prog, task_id=task_id, **kwargs)
                else:
                    return func(*args, **kwargs)
        return wrapper
    return decorator


# Convenience functions for common operations
def spinner(text: str = "Processing...", spinner: str = "dots"):
    """Get a spinner context manager"""
    return get_progress_helper().spinner(text, spinner)


def progress_bar(
    description: str = "Processing...",
    total: Optional[int] = None,
    show_time: bool = True,
    show_percentage: bool = True
):
    """Get a progress bar context manager"""
    return get_progress_helper().progress_bar(description, total, show_time, show_percentage)


def simple_progress(items: Iterator[Any], description: str = "Processing..."):
    """Get a simple progress iterator"""
    return get_progress_helper().simple_progress(items, description)


def print_success(message: str):
    """Print a success message"""
    get_progress_helper().print_success(message)


def print_error(message: str):
    """Print an error message"""
    get_progress_helper().print_error(message)


def print_warning(message: str):
    """Print a warning message"""
    get_progress_helper().print_warning(message)


def print_info(message: str):
    """Print an info message"""
    get_progress_helper().print_info(message)