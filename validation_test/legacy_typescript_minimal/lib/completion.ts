/**
 * Shell completion helpers for TypeScript Test CLI
 * Generated by goobits-cli
 */

import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

// Type definitions
export interface CompletionInstructions {
    scriptPath: string;
    userScriptPath: string;
    installCmd: string;
    userInstallCmd: string;
    reloadCmd: string;
}

export interface CompletionOptions {
    cliName?: string;
    scriptName?: string;
}

export class CompletionHelper {
    private cliName: string;
    private scriptName: string;

    /**
     * Helper class for generating shell completions
     */
    constructor(options: CompletionOptions = {}) {
        this.cliName = options.cliName || 'typescript-test-cli';
        this.scriptName = options.scriptName || this.cliName;
    }

    /**
     * Generate bash completion script
     */
    generateBashCompletion(): string {
        const completionFunc = this.cliName.replace(/-/g, '_');
        return `#!/bin/bash
# Bash completion script for ${this.cliName}
# Generated by goobits-cli

_${completionFunc}_completion() {
    local cur prev opts
    COMPREPLY=()
    cur="\${COMP_WORDS[COMP_CWORD]}"
    prev="\${COMP_WORDS[COMP_CWORD-1]}"
    
    # Get available commands
    if [[ \${COMP_CWORD} -eq 1 ]]; then
        # Top-level commands
        opts="$(${this.scriptName} --help 2>/dev/null | grep -E '^  [a-z]' | awk '{print $1}' | tr '\\n' ' ')"
        opts="$opts --help --version"
    else
        # Subcommands and options
        case "\${COMP_WORDS[1]}" in
            completion)
                case "\${COMP_WORDS[2]}" in
                    generate)
                        opts="bash zsh fish"
                        ;;
                    install)
                        opts="bash zsh fish --user --system"
                        ;;
                    instructions)
                        opts="bash zsh fish"
                        ;;
                    *)
                        opts="generate install instructions --help"
                        ;;
                esac
                ;;
            config)
                case "\${COMP_WORDS[2]}" in
                    get|set|delete)
                        # Could add dynamic config key completion here
                        opts="--help"
                        ;;
                    *)
                        opts="get set reset path --help"
                        ;;
                esac
                ;;
            *)
                opts="--help"
                ;;
        esac
    fi
    
    COMPREPLY=( $(compgen -W "\${opts}" -- "\${cur}") )
    return 0
}

complete -F _${completionFunc}_completion ${this.scriptName}
`;
    }

    /**
     * Generate zsh completion script
     */
    generateZshCompletion(): string {
        const completionFunc = this.cliName.replace(/-/g, '_');
        return `#compdef ${this.scriptName}
# Zsh completion script for ${this.cliName}
# Generated by goobits-cli

_${completionFunc}() {
    local context state line
    typeset -A opt_args
    
    _arguments -s -S \\\\
        '(--help -h){--help,-h}[Show help message]' \\\\
        '(--version -V){--version,-V}[Show version]' \\\\
        '1: :->commands' \\\\
        '*:: :->args' && return 0
    
    case $state in
        (commands)
            local commands
            commands=(
                'help:Show help message'
                'completion:Shell completion management'
                'config:Configuration management'
                'upgrade:Upgrade to latest version'
            )
            _describe 'commands' commands
            ;;
        (args)
            case $words[1] in
                (completion)
                    _arguments -s -S \\\\
                        '1: :->completion_commands' \\\\
                        '*:: :->completion_args' && return 0
                    
                    case $state in
                        (completion_commands)
                            local completion_commands
                            completion_commands=(
                                'generate:Generate completion script'
                                'install:Install completion script'
                                'instructions:Show installation instructions'
                            )
                            _describe 'completion commands' completion_commands
                            ;;
                        (completion_args)
                            case $words[2] in
                                (generate|install|instructions)
                                    _arguments -s -S \\\\
                                        '1: :(bash zsh fish)' \\\\
                                        '(--help -h){--help,-h}[Show help message]'
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                (config)
                    _arguments -s -S \\\\
                        '1: :->config_commands' \\\\
                        '*:: :->config_args' && return 0
                    
                    case $state in
                        (config_commands)
                            local config_commands
                            config_commands=(
                                'get:Get configuration value'
                                'set:Set configuration value'
                                'reset:Reset configuration to defaults'
                                'path:Show configuration file path'
                            )
                            _describe 'config commands' config_commands
                            ;;
                        (config_args)
                            case $words[2] in
                                (get|set|delete)
                                    _arguments -s -S \\\\
                                        '1: :' \\\\
                                        '(--help -h){--help,-h}[Show help message]'
                                    ;;
                                (reset|path)
                                    _arguments -s -S \\\\
                                        '(--help -h){--help,-h}[Show help message]'
                                    ;;
                            esac
                            ;;
                    esac
                    ;;
                (help|upgrade)
                    _arguments -s -S \\\\
                        '(--help -h){--help,-h}[Show help message]'
                    ;;
            esac
            ;;
    esac
}

_${completionFunc} "$@"
`;
    }

    /**
     * Generate fish completion script
     */
    generateFishCompletion(): string {
        return `# Fish completion script for ${this.cliName}
# Generated by goobits-cli

# Complete main commands
complete -c ${this.scriptName} -n '__fish_use_subcommand' -a 'help' -d 'Show help message'
complete -c ${this.scriptName} -n '__fish_use_subcommand' -a 'completion' -d 'Shell completion management'
complete -c ${this.scriptName} -n '__fish_use_subcommand' -a 'config' -d 'Configuration management'
complete -c ${this.scriptName} -n '__fish_use_subcommand' -a 'upgrade' -d 'Upgrade to latest version'

# Completion subcommands
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion' -a 'generate' -d 'Generate completion script'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion' -a 'install' -d 'Install completion script'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion' -a 'instructions' -d 'Show installation instructions'

# Shell options for completion commands
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion; and __fish_seen_subcommand_from generate install instructions' -a 'bash' -d 'Bash shell'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion; and __fish_seen_subcommand_from generate install instructions' -a 'zsh' -d 'Zsh shell'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion; and __fish_seen_subcommand_from generate install instructions' -a 'fish' -d 'Fish shell'

# Install options
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion; and __fish_seen_subcommand_from install' -l user -d 'Install for current user'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from completion; and __fish_seen_subcommand_from install' -l system -d 'Install system-wide'

# Config subcommands
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from config' -a 'get' -d 'Get configuration value'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from config' -a 'set' -d 'Set configuration value'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from config' -a 'reset' -d 'Reset configuration to defaults'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from config' -a 'path' -d 'Show configuration file path'

# Upgrade options
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from upgrade' -l check -d 'Check for updates without installing'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from upgrade' -l version -d 'Install specific version'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from upgrade' -l pre -d 'Include pre-release versions'
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from upgrade' -l dry-run -d 'Show what would be done'

# Global options
complete -c ${this.scriptName} -s h -l help -d 'Show help message'
complete -c ${this.scriptName} -s V -l version -d 'Show version'
`;
    }

    /**
     * Get installation instructions for completion scripts
     */
    getCompletionInstallInstructions(shell: string): CompletionInstructions | null {
        const instructions: Record<string, CompletionInstructions> = {
            bash: {
                scriptPath: `/etc/bash_completion.d/${this.cliName}`,
                userScriptPath: `~/.local/share/bash-completion/completions/${this.cliName}`,
                installCmd: `sudo cp completion-script.bash /etc/bash_completion.d/${this.cliName}`,
                userInstallCmd: `mkdir -p ~/.local/share/bash-completion/completions && cp completion-script.bash ~/.local/share/bash-completion/completions/${this.cliName}`,
                reloadCmd: 'source ~/.bashrc',
            },
            zsh: {
                scriptPath: `/usr/share/zsh/site-functions/_${this.cliName}`,
                userScriptPath: `~/.local/share/zsh/site-functions/_${this.cliName}`,
                installCmd: `sudo cp completion-script.zsh /usr/share/zsh/site-functions/_${this.cliName}`,
                userInstallCmd: `mkdir -p ~/.local/share/zsh/site-functions && cp completion-script.zsh ~/.local/share/zsh/site-functions/_${this.cliName}`,
                reloadCmd: 'exec zsh',
            },
            fish: {
                scriptPath: `/usr/share/fish/completions/${this.cliName}.fish`,
                userScriptPath: `~/.config/fish/completions/${this.cliName}.fish`,
                installCmd: `sudo cp completion-script.fish /usr/share/fish/completions/${this.cliName}.fish`,
                userInstallCmd: `mkdir -p ~/.config/fish/completions && cp completion-script.fish ~/.config/fish/completions/${this.cliName}.fish`,
                reloadCmd: 'No reload needed - fish will auto-detect',
            }
        };

        return instructions[shell] || null;
    }

    /**
     * Save completion script to file
     */
    saveCompletionScript(shell: string, outputDir?: string): string {
        if (!outputDir) {
            outputDir = process.cwd();
        }

        const generators: Record<string, () => string> = {
            bash: () => this.generateBashCompletion(),
            zsh: () => this.generateZshCompletion(),
            fish: () => this.generateFishCompletion(),
        };

        if (!(shell in generators)) {
            throw new Error(`Unsupported shell: ${shell}. Supported: ${Object.keys(generators).join(', ')}`);
        }

        const scriptContent = generators[shell]();
        const scriptFile = path.join(outputDir, `${this.cliName}-completion.${shell}`);

        fs.writeFileSync(scriptFile, scriptContent, 'utf8');
        return scriptFile;
    }

    /**
     * Install completion script for the specified shell
     */
    async installCompletion(shell: string, userInstall: boolean = true): Promise<boolean> {
        try {
            const generators: Record<string, () => string> = {
                bash: () => this.generateBashCompletion(),
                zsh: () => this.generateZshCompletion(),
                fish: () => this.generateFishCompletion(),
            };

            if (!(shell in generators)) {
                throw new Error(`Unsupported shell: ${shell}`);
            }

            const scriptContent = generators[shell]();
            const instructions = this.getCompletionInstallInstructions(shell);
            
            if (!instructions) {
                throw new Error(`No installation instructions available for ${shell}`);
            }

            let scriptPath: string;
            if (userInstall) {
                scriptPath = instructions.userScriptPath.replace('~', os.homedir());
            } else {
                scriptPath = instructions.scriptPath;
            }

            // Create directory if it doesn't exist
            const scriptDir = path.dirname(scriptPath);
            fs.mkdirSync(scriptDir, { recursive: true });

            // Write the completion script
            fs.writeFileSync(scriptPath, scriptContent, 'utf8');

            return true;
        } catch (error: any) {
            console.error(`Error installing completion for ${shell}: ${error.message}`);
            return false;
        }
    }

    /**
     * Generate completion script for the specified shell
     */
    generateCompletionScript(shell: string): string {
        const generators: Record<string, () => string> = {
            bash: () => this.generateBashCompletion(),
            zsh: () => this.generateZshCompletion(),
            fish: () => this.generateFishCompletion(),
        };

        if (!(shell in generators)) {
            throw new Error(`Unsupported shell: ${shell}. Supported: ${Object.keys(generators).join(', ')}`);
        }

        return generators[shell]();
    }
}

// Default instance
let _defaultCompletion: CompletionHelper | null = null;

/**
 * Get a completion helper instance
 */
export function getCompletionHelper(): CompletionHelper {
    if (_defaultCompletion === null) {
        _defaultCompletion = new CompletionHelper();
    }
    return _defaultCompletion;
}

/**
 * Generate completion script for the specified shell
 */
export function generateCompletionScript(shell: string): string {
    return getCompletionHelper().generateCompletionScript(shell);
}

/**
 * Install completion script for the specified shell
 */
export async function installCompletion(shell: string, userInstall: boolean = true): Promise<boolean> {
    return getCompletionHelper().installCompletion(shell, userInstall);
}

/**
 * Get installation instructions for completion scripts
 */
export function getInstallInstructions(shell: string): CompletionInstructions | null {
    return getCompletionHelper().getCompletionInstallInstructions(shell);
}

/**
 * Save completion script to file
 */
export function saveCompletionScript(shell: string, outputDir?: string): string {
    return getCompletionHelper().saveCompletionScript(shell, outputDir);
}