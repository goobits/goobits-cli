/**
 * Interactive prompts and input helpers for NodeJS Test CLI
 * Generated by goobits-cli
 */

const path = require('path');
const fs = require('fs');

// Try to load optional dependencies
let inquirer, prompts;
let HAS_INQUIRER = false;
let HAS_PROMPTS = false;

try {
    inquirer = require('inquirer');
    HAS_INQUIRER = true;
    if (process.env.DEBUG) console.debug('Inquirer library loaded successfully');
} catch (e) {
    if (process.env.DEBUG) console.debug('Inquirer library not available:', e.message);
}

try {
    prompts = require('prompts');
    HAS_PROMPTS = true;
    if (process.env.DEBUG) console.debug('Prompts library loaded successfully');
} catch (e) {
    if (process.env.DEBUG) console.debug('Prompts library not available:', e.message);
    console.info('Interactive prompts will use basic fallbacks. Install \'inquirer\' or \'prompts\' for enhanced features: npm install inquirer');
}

class PromptsHelper {
    /**
     * Helper class for interactive prompts and user input
     */
    constructor() {
        this.useInquirer = HAS_INQUIRER;
        this.usePrompts = HAS_PROMPTS;
        
        if (this.useInquirer || this.usePrompts) {
            if (process.env.DEBUG) console.debug('Enhanced prompt features initialized');
        } else {
            if (process.env.DEBUG) console.debug('Using fallback mode (inquirer/prompts not available)');
        }
    }

    /**
     * Prompt for text input
     * @param {string} message - Prompt message
     * @param {string} defaultValue - Default value
     * @param {Function} validate - Validation function
     * @returns {Promise<string>} User input
     */
    async text(message, defaultValue = null, validate = null) {
        if (this.useInquirer) {
            const question = {
                type: 'input',
                name: 'value',
                message: message,
                validate: validate || undefined
            };
            
            if (defaultValue !== null) {
                question.default = defaultValue;
            }
            
            const answers = await inquirer.prompt([question]);
            return answers.value;
        } else if (this.usePrompts) {
            const response = await prompts({
                type: 'text',
                name: 'value',
                message: message,
                initial: defaultValue,
                validate: validate
            });
            
            return response.value || '';
        } else {
            // Fallback to readline
            const readline = require('readline');
            const rl = readline.createInterface({
                input: process.stdin,
                output: process.stdout
            });
            
            return new Promise((resolve) => {
                const promptText = defaultValue ? `${message} [${defaultValue}]: ` : `${message}: `;
                
                rl.question(promptText, (answer) => {
                    rl.close();
                    resolve(answer.trim() || defaultValue || '');
                });
            });
        }
    }

    /**
     * Prompt for password input (hidden)
     * @param {string} message - Prompt message
     * @returns {Promise<string>} Password input
     */
    async password(message = 'Password') {
        if (this.useInquirer) {
            const answers = await inquirer.prompt([{
                type: 'password',
                name: 'value',
                message: message
            }]);
            return answers.value;
        } else if (this.usePrompts) {
            const response = await prompts({
                type: 'password',
                name: 'value',
                message: message
            });
            return response.value || '';
        } else {
            // Fallback using process.stdin with hidden input
            process.stdout.write(`${message}: `);
            process.stdin.setRawMode(true);
            
            return new Promise((resolve) => {
                let password = '';
                
                const onData = (char) => {
                    const charStr = char.toString('utf8');
                    
                    switch (charStr) {
                        case '\n':
                        case '\r':
                        case '\u0004': // Ctrl+D (end of transmission)
                            process.stdin.setRawMode(false);
                            process.stdin.removeListener('data', onData);
                            process.stdout.write('\n');
                            resolve(password);
                            break;
                        case '\u0003': // Ctrl+C
                            process.stdout.write('\n');
                            process.exit(1);
                            break;
                        case '\u007f': // Backspace
                            if (password.length > 0) {
                                password = password.slice(0, -1);
                                process.stdout.write('\b \b');
                            }
                            break;
                        default:
                            password += charStr;
                            process.stdout.write('*');
                            break;
                    }
                };
                
                process.stdin.on('data', onData);
            });
        }
    }

    /**
     * Prompt for yes/no confirmation
     * @param {string} message - Prompt message
     * @param {boolean} defaultValue - Default value
     * @returns {Promise<boolean>} Confirmation result
     */
    async confirm(message, defaultValue = false) {
        if (this.useInquirer) {
            const answers = await inquirer.prompt([{
                type: 'confirm',
                name: 'value',
                message: message,
                default: defaultValue
            }]);
            return answers.value;
        } else if (this.usePrompts) {
            const response = await prompts({
                type: 'confirm',
                name: 'value',
                message: message,
                initial: defaultValue
            });
            return response.value !== undefined ? response.value : false;
        } else {
            // Fallback implementation
            const defaultText = defaultValue ? 'Y/n' : 'y/N';
            const answer = await this.text(`${message} (${defaultText})`);
            
            if (!answer.trim()) {
                return defaultValue;
            }
            return ['y', 'yes', '1', 'true'].includes(answer.toLowerCase());
        }
    }

    /**
     * Prompt for selection from a list of choices
     * @param {string} message - Prompt message
     * @param {Array} choices - List of choices
     * @param {string|number} defaultValue - Default choice
     * @returns {Promise<string>} Selected choice
     */
    async select(message, choices, defaultValue = null) {
        if (this.useInquirer) {
            const question = {
                type: 'list',
                name: 'value',
                message: message,
                choices: choices
            };
            
            if (defaultValue !== null) {
                question.default = defaultValue;
            }
            
            const answers = await inquirer.prompt([question]);
            return answers.value;
        } else if (this.usePrompts) {
            const promptChoices = choices.map((choice, index) => {
                if (typeof choice === 'object' && choice.name) {
                    return { title: choice.name, value: choice.value || choice.name };
                }
                return { title: choice, value: choice };
            });
            
            const response = await prompts({
                type: 'select',
                name: 'value',
                message: message,
                choices: promptChoices,
                initial: typeof defaultValue === 'number' ? defaultValue : 0
            });
            
            return response.value;
        } else {
            // Fallback implementation
            console.log(`\n${message}`);
            
            const formattedChoices = choices.map((choice, index) => {
                if (typeof choice === 'object' && choice.name) {
                    return choice.name;
                }
                return String(choice);
            });
            
            formattedChoices.forEach((choice, index) => {
                const isDefault = (typeof defaultValue === 'number' && index === defaultValue) ||
                                choice === defaultValue;
                const marker = isDefault ? '>' : ' ';
                console.log(`  ${marker} ${index + 1}. ${choice}`);
            });
            
            while (true) {
                try {
                    const response = await this.text('\nSelect (number)');
                    
                    if (!response && defaultValue !== null) {
                        if (typeof defaultValue === 'number') {
                            return formattedChoices[defaultValue];
                        } else {
                            return defaultValue;
                        }
                    }
                    
                    const index = parseInt(response) - 1;
                    if (index >= 0 && index < formattedChoices.length) {
                        return formattedChoices[index];
                    } else {
                        console.log(`Please enter a number between 1 and ${formattedChoices.length}`);
                    }
                } catch (error) {
                    console.log('Please enter a valid number');
                }
            }
        }
    }

    /**
     * Prompt for multiple selections from a list of choices
     * @param {string} message - Prompt message
     * @param {Array} choices - List of choices
     * @param {Array} defaultValue - Default selections
     * @returns {Promise<Array>} Selected choices
     */
    async multiselect(message, choices, defaultValue = []) {
        if (this.useInquirer) {
            const answers = await inquirer.prompt([{
                type: 'checkbox',
                name: 'value',
                message: message,
                choices: choices,
                default: defaultValue
            }]);
            return answers.value;
        } else if (this.usePrompts) {
            const promptChoices = choices.map((choice) => {
                if (typeof choice === 'object' && choice.name) {
                    return { 
                        title: choice.name, 
                        value: choice.value || choice.name,
                        selected: defaultValue.includes(choice.value || choice.name)
                    };
                }
                return { 
                    title: choice, 
                    value: choice,
                    selected: defaultValue.includes(choice)
                };
            });
            
            const response = await prompts({
                type: 'multiselect',
                name: 'value',
                message: message,
                choices: promptChoices
            });
            
            return response.value || [];
        } else {
            // Fallback implementation
            console.log(`\n${message}`);
            console.log('(Use space-separated numbers to toggle selection)');
            
            const formattedChoices = choices.map((choice) => {
                if (typeof choice === 'object' && choice.name) {
                    return choice.name;
                }
                return String(choice);
            });
            
            const selected = new Set(defaultValue || []);
            
            const displayChoices = () => {
                formattedChoices.forEach((choice, index) => {
                    const marker = selected.has(choice) ? '[x]' : '[ ]';
                    console.log(`  ${marker} ${index + 1}. ${choice}`);
                });
            };
            
            displayChoices();
            console.log('\nEnter numbers separated by spaces (e.g., \'1 3 5\'), or press Enter to finish:');
            
            while (true) {
                try {
                    const response = await this.text('Select');
                    
                    if (!response.trim()) {
                        break;
                    }
                    
                    const indices = response.split(/\s+/).map(x => parseInt(x) - 1);
                    
                    for (const index of indices) {
                        if (index >= 0 && index < formattedChoices.length) {
                            const choice = formattedChoices[index];
                            if (selected.has(choice)) {
                                selected.delete(choice);
                                console.log(`  Deselected: ${choice}`);
                            } else {
                                selected.add(choice);
                                console.log(`  Selected: ${choice}`);
                            }
                        } else {
                            console.log(`Invalid choice: ${index + 1}`);
                        }
                    }
                    
                    console.log('Current selection:', Array.from(selected));
                    
                } catch (error) {
                    console.log('Please enter valid numbers separated by spaces');
                }
            }
            
            return Array.from(selected);
        }
    }

    /**
     * Prompt for integer input
     * @param {string} message - Prompt message
     * @param {number} defaultValue - Default value
     * @param {number} minValue - Minimum value
     * @param {number} maxValue - Maximum value
     * @returns {Promise<number>} Integer input
     */
    async integer(message, defaultValue = null, minValue = null, maxValue = null) {
        const validate = (input) => {
            const num = parseInt(input);
            if (isNaN(num)) {
                return 'Please enter a valid integer';
            }
            if (minValue !== null && num < minValue) {
                return `Value must be at least ${minValue}`;
            }
            if (maxValue !== null && num > maxValue) {
                return `Value must be at most ${maxValue}`;
            }
            return true;
        };

        if (this.useInquirer) {
            const question = {
                type: 'input',
                name: 'value',
                message: message,
                validate: validate,
                filter: (input) => parseInt(input)
            };
            
            if (defaultValue !== null) {
                question.default = String(defaultValue);
            }
            
            const answers = await inquirer.prompt([question]);
            return answers.value;
        } else if (this.usePrompts) {
            const response = await prompts({
                type: 'number',
                name: 'value',
                message: message,
                initial: defaultValue,
                validate: validate
            });
            
            return response.value;
        } else {
            // Fallback implementation
            while (true) {
                try {
                    const promptText = defaultValue !== null ? `${message} [${defaultValue}]` : message;
                    const response = await this.text(promptText);
                    
                    if (!response && defaultValue !== null) {
                        return defaultValue;
                    }
                    
                    const value = parseInt(response);
                    const validation = validate(response);
                    
                    if (validation === true) {
                        return value;
                    } else {
                        console.log(validation);
                    }
                } catch (error) {
                    console.log('Please enter a valid integer');
                }
            }
        }
    }

    /**
     * Prompt for float input
     * @param {string} message - Prompt message
     * @param {number} defaultValue - Default value
     * @param {number} minValue - Minimum value
     * @param {number} maxValue - Maximum value
     * @returns {Promise<number>} Float input
     */
    async floatInput(message, defaultValue = null, minValue = null, maxValue = null) {
        const validate = (input) => {
            const num = parseFloat(input);
            if (isNaN(num)) {
                return 'Please enter a valid number';
            }
            if (minValue !== null && num < minValue) {
                return `Value must be at least ${minValue}`;
            }
            if (maxValue !== null && num > maxValue) {
                return `Value must be at most ${maxValue}`;
            }
            return true;
        };

        if (this.useInquirer) {
            const question = {
                type: 'input',
                name: 'value',
                message: message,
                validate: validate,
                filter: (input) => parseFloat(input)
            };
            
            if (defaultValue !== null) {
                question.default = String(defaultValue);
            }
            
            const answers = await inquirer.prompt([question]);
            return answers.value;
        } else if (this.usePrompts) {
            const response = await prompts({
                type: 'number',
                name: 'value',
                message: message,
                initial: defaultValue,
                validate: validate
            });
            
            return response.value;
        } else {
            // Fallback implementation (similar to integer)
            while (true) {
                try {
                    const promptText = defaultValue !== null ? `${message} [${defaultValue}]` : message;
                    const response = await this.text(promptText);
                    
                    if (!response && defaultValue !== null) {
                        return defaultValue;
                    }
                    
                    const value = parseFloat(response);
                    const validation = validate(response);
                    
                    if (validation === true) {
                        return value;
                    } else {
                        console.log(validation);
                    }
                } catch (error) {
                    console.log('Please enter a valid number');
                }
            }
        }
    }

    /**
     * Prompt for file/directory path
     * @param {string} message - Prompt message
     * @param {string} defaultValue - Default path
     * @param {boolean} exists - Path must exist
     * @param {boolean} isDir - Path must be directory
     * @param {boolean} isFile - Path must be file
     * @returns {Promise<string>} Path input
     */
    async path(message, defaultValue = null, exists = false, isDir = false, isFile = false) {
        const validatePath = (pathStr) => {
            try {
                const resolvedPath = path.resolve(pathStr.replace('~', require('os').homedir()));
                
                if (exists && !fs.existsSync(resolvedPath)) {
                    return `Path does not exist: ${resolvedPath}`;
                }
                
                if (isDir && fs.existsSync(resolvedPath) && !fs.statSync(resolvedPath).isDirectory()) {
                    return `Path is not a directory: ${resolvedPath}`;
                }
                
                if (isFile && fs.existsSync(resolvedPath) && !fs.statSync(resolvedPath).isFile()) {
                    return `Path is not a file: ${resolvedPath}`;
                }
                
                return true;
            } catch (error) {
                return `Invalid path: ${error.message}`;
            }
        };

        if (this.useInquirer) {
            const question = {
                type: 'input',
                name: 'value',
                message: message,
                validate: validatePath
            };
            
            if (defaultValue !== null) {
                question.default = defaultValue;
            }
            
            const answers = await inquirer.prompt([question]);
            return path.resolve(answers.value.replace('~', require('os').homedir()));
        } else {
            // Fallback implementation
            while (true) {
                const pathStr = await this.text(message, defaultValue);
                const validation = validatePath(pathStr);
                
                if (validation === true) {
                    return path.resolve(pathStr.replace('~', require('os').homedir()));
                } else {
                    console.log(validation);
                }
            }
        }
    }
}

// Default instance
let _defaultPrompts = null;

/**
 * Get the default prompts helper instance
 * @returns {PromptsHelper} Prompts helper instance
 */
function getPromptsHelper() {
    if (_defaultPrompts === null) {
        _defaultPrompts = new PromptsHelper();
    }
    return _defaultPrompts;
}

// Convenience functions
async function text(message, defaultValue = null, validate = null) {
    return getPromptsHelper().text(message, defaultValue, validate);
}

async function password(message = 'Password') {
    return getPromptsHelper().password(message);
}

async function confirm(message, defaultValue = false) {
    return getPromptsHelper().confirm(message, defaultValue);
}

async function select(message, choices, defaultValue = null) {
    return getPromptsHelper().select(message, choices, defaultValue);
}

async function multiselect(message, choices, defaultValue = []) {
    return getPromptsHelper().multiselect(message, choices, defaultValue);
}

async function integer(message, defaultValue = null, minValue = null, maxValue = null) {
    return getPromptsHelper().integer(message, defaultValue, minValue, maxValue);
}

async function floatInput(message, defaultValue = null, minValue = null, maxValue = null) {
    return getPromptsHelper().floatInput(message, defaultValue, minValue, maxValue);
}

async function pathInput(message, defaultValue = null, exists = false, isDir = false, isFile = false) {
    return getPromptsHelper().path(message, defaultValue, exists, isDir, isFile);
}

module.exports = {
    PromptsHelper,
    getPromptsHelper,
    text,
    password,
    confirm,
    select,
    multiselect,
    integer,
    floatInput,
    pathInput,
    
    // Export constants for checking availability
    HAS_INQUIRER,
    HAS_PROMPTS
};