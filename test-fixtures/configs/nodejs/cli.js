#!/usr/bin/env node
/**
 * Test Node.js CLI - Testing Node.js generation
 * Generated by Goobits CLI Framework
 */

// Minimal Commander.js setup for simple CLIs
import { Command } from 'commander';

// Hook loading with enhanced error handling
let hooks = null;

const loadHooks = async () => {
    try {
        const hookModule = await import('./src/hooks.js');
        hooks = hookModule.default || hookModule;
    } catch (error) {
        if (error.code === 'ERR_MODULE_NOT_FOUND') {
            console.error('Hook implementation not found. Please create \'src/hooks.js\' with your command implementations.');
            console.error('See documentation for hook function signatures.');
        } else {
            console.error(`Failed to load hooks: ${error.message}`);
        }
        process.exit(2);
    }
};

// Load hooks at startup
await loadHooks();
// Enhanced error handling for Node.js
class CLIError extends Error {
    constructor(message, code = 1, details = null) {
        super(message);
        this.name = 'CLIError';
        this.code = code;
        this.details = details;
    }
}

// Global error handler
function handleError(error, context = 'Command execution', verbose = false) {
    if (error instanceof CLIError) {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.details) {
            console.error('Details:', error.details);
        }
        process.exit(error.code);
    } else if (error.code === 'MODULE_NOT_FOUND' && error.message.includes('hooks')) {
        console.error('Hook implementation not found.');
        console.error('Please implement the required hook function in src/hooks.js');
        process.exit(2);
    } else {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.stack) {
            console.error('Stack trace:', error.stack);
        }
        process.exit(1);
    }
}

const program = new Command();

program.name('')
program.description('"Test Node.js CLI"')
program.version('1.0.0')    .option('-v, --verbose', 'Enable verbose error output and debugging information', false);program.option(
    '--interactive, -i',
    '"None"');

// Command hierarchy building for unlimited nesting
const commandMap = new Map();// Level 1: hello
const helloCmd = program
    .command('hello')
    .description('"Say hello"');
helloCmd.action(async (options) => {
    const globalOpts = program.opts();
    const verbose = globalOpts.verbose || false;
    
    try {
        const hookName = 'on_hello';
        
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${hookName}' not implemented in src/hooks.js`;
            const details = availableHooks.length > 0 
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.js';
            throw new CLIError(message, 2, details);
        }
        
        // Execute the hook function with proper error handling
        const args = [];
        const result = await hooks[hookName](...args, options);
        
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command 'hello' failed with exit code ${result}`, result);
        }
        
    } catch (error) {
        if (error.code === 'SIGINT' || error.message.includes('interrupted')) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        
        handleError(error, 'Command execution', verbose);
    }
});
commandMap.set('hello', helloCmd);

// Level 1: build
const buildCmd = program
    .command('build')
    .description('"Build something"');
commandMap.set('build', buildCmd);

// Level 2: build project
const build_projectCmd = commandMap.get('build')
    .command('project')
    .description('"Build a project"');
build_projectCmd.action(async (options) => {
    const globalOpts = program.opts();
    const verbose = globalOpts.verbose || false;
    
    try {
        const hookName = 'on_build_project';
        
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${hookName}' not implemented in src/hooks.js`;
            const details = availableHooks.length > 0 
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.js';
            throw new CLIError(message, 2, details);
        }
        
        // Execute the hook function with proper error handling
        const args = [];
        const result = await hooks[hookName](...args, options);
        
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command 'build project' failed with exit code ${result}`, result);
        }
        
    } catch (error) {
        if (error.code === 'SIGINT' || error.message.includes('interrupted')) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        
        handleError(error, 'Command execution', verbose);
    }
});
commandMap.set('build/project', build_projectCmd);

// Level 1: serve
const serveCmd = program
    .command('serve')
    .description('"Start server"');
serveCmd.action(async (options) => {
    const globalOpts = program.opts();
    const verbose = globalOpts.verbose || false;
    
    try {
        const hookName = 'on_serve';
        
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${hookName}' not implemented in src/hooks.js`;
            const details = availableHooks.length > 0 
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.js';
            throw new CLIError(message, 2, details);
        }
        
        // Execute the hook function with proper error handling
        const args = [];
        const result = await hooks[hookName](...args, options);
        
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command 'serve' failed with exit code ${result}`, result);
        }
        
    } catch (error) {
        if (error.code === 'SIGINT' || error.message.includes('interrupted')) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        
        handleError(error, 'Command execution', verbose);
    }
});
commandMap.set('serve', serveCmd);

// Main CLI function for module export
export function cli() {
    program.parse();
}

// If this is the main module, run the CLI
if (import.meta.url === `file://${process.argv[1]}`) {
    cli();
}