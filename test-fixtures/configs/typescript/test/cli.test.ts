/**
 * CLI tests for Test TypeScript CLI
 * Generated by Goobits CLI Framework
 */

import { execSync, spawn } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';

describe('Test TypeScript CLI CLI', () => {
  const cliPath = path.join(__dirname, '..', 'bin', 'cli.ts');
  const timeout = 30000; // 30 seconds timeout

  beforeAll(() => {
    // Ensure CLI is built and available
    expect(fs.existsSync(cliPath)).toBe(true);
  });

  describe('Basic functionality', () => {
    test('should display version', () => {
      const result = execSync(`node -r ts-node/register ${cliPath} --version`, { 
        encoding: 'utf8',
        timeout 
      });
      expect(result.trim()).toMatch(/\d+\.\d+\.\d+/);
    });

    test('should display help', () => {
      const result = execSync(`node -r ts-node/register ${cliPath} --help`, { 
        encoding: 'utf8',
        timeout 
      });
      expect(result).toContain('Usage:');
      expect(result).toContain('Options:');
    });

    test('should handle unknown commands gracefully', () => {
      try {
        execSync(`node -r ts-node/register ${cliPath} unknown-command`, { 
          encoding: 'utf8',
          timeout 
        });
        fail('Should have thrown an error');
      } catch (error: any) {
        expect(error.status).not.toBe(0);
        expect(error.stderr || error.stdout).toContain('unknown');
      }
    });
  });  describe('Commands', () => {    describe('hello', () => {
      test('should display help for hello', () => {
        const result = execSync(`node -r ts-node/register ${cliPath} hello --help`, { 
          encoding: 'utf8',
          timeout 
        });
        expect(result).toContain('Say hello');
      });    });    describe('build', () => {
      test('should display help for build', () => {
        const result = execSync(`node -r ts-node/register ${cliPath} build --help`, { 
          encoding: 'utf8',
          timeout 
        });
        expect(result).toContain('Build something');
      });    });    describe('serve', () => {
      test('should display help for serve', () => {
        const result = execSync(`node -r ts-node/register ${cliPath} serve --help`, { 
          encoding: 'utf8',
          timeout 
        });
        expect(result).toContain('Start server');
      });    });  });
  describe('Global options', () => {
    test('should handle --debug flag', () => {
      const result = execSync(`node -r ts-node/register ${cliPath} --debug --help`, { 
        encoding: 'utf8',
        timeout 
      });
      expect(result).toContain('Usage:');
    });

    test('should handle --verbose flag', () => {
      const result = execSync(`node -r ts-node/register ${cliPath} --verbose --help`, { 
        encoding: 'utf8',
        timeout 
      });
      expect(result).toContain('Usage:');
    });  });

  describe('Error handling', () => {
    test('should handle invalid options gracefully', () => {
      try {
        execSync(`node -r ts-node/register ${cliPath} --invalid-option`, { 
          encoding: 'utf8',
          timeout 
        });
        fail('Should have thrown an error');
      } catch (error: any) {
        expect(error.status).not.toBe(0);
      }
    });

    test('should validate required arguments', () => {    });
  });

  describe('Output format', () => {
    test('should produce clean output', () => {
      const result = execSync(`node -r ts-node/register ${cliPath} --help`, { 
        encoding: 'utf8',
        timeout 
      });
      
      // Check for clean formatting
      expect(result).not.toContain('[object Object]');
      expect(result).not.toContain('undefined');
      expect(result).not.toContain('null');
      
      // Should have proper structure
      expect(result).toMatch(/Usage:\s+/);
    });

    test('should handle JSON output if supported', () => {
      try {
        const result = execSync(`node -r ts-node/register ${cliPath} --format json --help`, { 
          encoding: 'utf8',
          timeout 
        });
        
        // If JSON format is supported, output should be valid JSON
        if (!result.includes('unknown option')) {
          expect(() => JSON.parse(result)).not.toThrow();
        }
      } catch (error: any) {
        // JSON format might not be supported, which is fine
        if (!error.stderr?.includes('unknown option') && !error.stdout?.includes('unknown option')) {
          throw error;
        }
      }
    });
  });

  describe('Performance', () => {
    test('should start up quickly', () => {
      const start = Date.now();
      execSync(`node -r ts-node/register ${cliPath} --version`, { 
        encoding: 'utf8',
        timeout 
      });
      const elapsed = Date.now() - start;
      
      // Should start up in reasonable time (less than 5 seconds)
      expect(elapsed).toBeLessThan(5000);
    });

    test('should handle multiple rapid commands', async () => {
      const promises = Array.from({ length: 5 }, () =>
        new Promise((resolve, reject) => {
          const child = spawn('node', ['-r', 'ts-node/register', cliPath, '--version'], {
            stdio: 'pipe'
          });
          
          let output = '';
          child.stdout?.on('data', (data) => {
            output += data.toString();
          });
          
          child.on('close', (code) => {
            if (code === 0) {
              resolve(output.trim());
            } else {
              reject(new Error(`Command failed with code ${code}`));
            }
          });
          
          child.on('error', reject);
        })
      );

      const results = await Promise.all(promises);
      results.forEach(result => {
        expect(result).toMatch(/\d+\.\d+\.\d+/);
      });
    });
  });

  describe('Integration', () => {
    test('should work with different Node.js versions', () => {
      // This test ensures compatibility across Node.js versions
      const result = execSync(`node -r ts-node/register ${cliPath} --version`, { 
        encoding: 'utf8',
        timeout 
      });
      expect(result.trim()).toMatch(/\d+\.\d+\.\d+/);
    });

    test('should handle different terminal environments', () => {
      // Test with different environment variables that affect CLI behavior
      const envs = [
        { TERM: 'dumb' },
        { NO_COLOR: '1' },
        { FORCE_COLOR: '1' },
        { CI: 'true' }
      ];

      envs.forEach(env => {
        const result = execSync(`node -r ts-node/register ${cliPath} --version`, {
          encoding: 'utf8',
          env: { ...process.env, ...env },
          timeout
        });
        expect(result.trim()).toMatch(/\d+\.\d+\.\d+/);
      });
    });
  });
});

// Helper functions for testing
export function runCLICommand(args: string[], options: { timeout?: number; env?: Record<string, string> } = {}): string {
  const cliPath = path.join(__dirname, '..', 'bin', 'cli.ts');
  const cmd = `node -r ts-node/register ${cliPath} ${args.join(' ')}`;
  
  return execSync(cmd, {
    encoding: 'utf8',
    timeout: options.timeout || 30000,
    env: { ...process.env, ...options.env }
  });
}

export async function runCLICommandAsync(args: string[], options: { timeout?: number; env?: Record<string, string> } = {}): Promise<string> {
  const cliPath = path.join(__dirname, '..', 'bin', 'cli.ts');
  
  return new Promise((resolve, reject) => {
    const child = spawn('node', ['-r', 'ts-node/register', cliPath, ...args], {
      stdio: 'pipe',
      env: { ...process.env, ...options.env }
    });
    
    let output = '';
    let error = '';
    
    child.stdout?.on('data', (data) => {
      output += data.toString();
    });
    
    child.stderr?.on('data', (data) => {
      error += data.toString();
    });
    
    const timeout = setTimeout(() => {
      child.kill();
      reject(new Error(`Command timed out after ${options.timeout || 30000}ms`));
    }, options.timeout || 30000);
    
    child.on('close', (code) => {
      clearTimeout(timeout);
      if (code === 0) {
        resolve(output.trim());
      } else {
        reject(new Error(`Command failed with code ${code}: ${error || output}`));
      }
    });
    
    child.on('error', (err) => {
      clearTimeout(timeout);
      reject(err);
    });
  });
}