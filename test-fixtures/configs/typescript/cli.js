#!/usr/bin/env node
"use strict";
/**
 * Test TypeScript CLI - Testing TypeScript generation
 * Generated by Goobits CLI Framework v
 *
 * This is a consolidated TypeScript CLI file with all utilities embedded.
 * Generated from:
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        if (typeof b !== "function" && b !== null)
            throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
    return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (g && (g = 0, op[0] && (_ = 0)), _) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
var commander_1 = require("commander");
var chalk_1 = require("chalk");
var ora_1 = require("ora");
var fs_1 = require("fs");
var path_1 = require("path");
var os_1 = require("os");
var js_yaml_1 = require("js-yaml");
var async_hooks_1 = require("async_hooks");
var winston = require("winston");
// ============================================================================
// EMBEDDED CONFIGURATION MANAGER
// ============================================================================
var ConfigManager = /** @class */ (function () {
    function ConfigManager(configFile) {
        if (configFile === void 0) { configFile = null; }
        this.configFile = configFile || this._getDefaultConfigPath();
        this.config = {
            debug: false,
            outputFormat: 'text'
        };
        this.loadConfig();
    }
    ConfigManager.prototype._getDefaultConfigPath = function () {
        var configDir = (0, path_1.join)((0, os_1.homedir)(), '.config', 'testts');
        if (!(0, fs_1.existsSync)(configDir)) {
            (0, fs_1.mkdirSync)(configDir, { recursive: true });
        }
        return (0, path_1.join)(configDir, 'config.yaml');
    };
    ConfigManager.prototype.loadConfig = function () {
        if ((0, fs_1.existsSync)(this.configFile)) {
            try {
                var content = (0, fs_1.readFileSync)(this.configFile, 'utf8');
                var loaded = js_yaml_1.default.load(content) || {};
                this.config = __assign(__assign({}, this.config), loaded);
            }
            catch (error) {
                console.warn("Warning: Failed to load config from ".concat(this.configFile, ": ").concat(error.message));
            }
        }
        // Environment variable overrides
        for (var _i = 0, _a = Object.keys(this.config); _i < _a.length; _i++) {
            var key = _a[_i];
            var envKey = "TESTTS_".concat(key.toUpperCase());
            if (process.env[envKey]) {
                var value = process.env[envKey];
                this.config[key] = value === 'true' ? true :
                    value === 'false' ? false :
                        isNaN(Number(value)) ? value : Number(value);
            }
        }
    };
    ConfigManager.prototype.saveConfig = function () {
        try {
            var content = js_yaml_1.default.dump(this.config, { indent: 2 });
            (0, fs_1.writeFileSync)(this.configFile, content, 'utf8');
            return true;
        }
        catch (error) {
            console.error("Failed to save config: ".concat(error.message));
            return false;
        }
    };
    ConfigManager.prototype.get = function (key, defaultValue) {
        return (this.config[key] !== undefined ? this.config[key] : defaultValue);
    };
    ConfigManager.prototype.set = function (key, value) {
        this.config[key] = value;
    };
    ConfigManager.prototype.update = function (updates) {
        this.config = __assign(__assign({}, this.config), updates);
    };
    return ConfigManager;
}());
// ============================================================================
// EMBEDDED ERROR HANDLER
// ============================================================================
var ExitCode;
(function (ExitCode) {
    ExitCode[ExitCode["SUCCESS"] = 0] = "SUCCESS";
    ExitCode[ExitCode["GENERAL_ERROR"] = 1] = "GENERAL_ERROR";
    ExitCode[ExitCode["USAGE_ERROR"] = 2] = "USAGE_ERROR";
    ExitCode[ExitCode["CONFIG_ERROR"] = 3] = "CONFIG_ERROR";
    ExitCode[ExitCode["NETWORK_ERROR"] = 4] = "NETWORK_ERROR";
    ExitCode[ExitCode["PERMISSION_ERROR"] = 5] = "PERMISSION_ERROR";
    ExitCode[ExitCode["FILE_NOT_FOUND"] = 6] = "FILE_NOT_FOUND";
})(ExitCode || (ExitCode = {}));
var CliError = /** @class */ (function (_super) {
    __extends(CliError, _super);
    function CliError(message, exitCode, details) {
        if (exitCode === void 0) { exitCode = ExitCode.GENERAL_ERROR; }
        if (details === void 0) { details = {}; }
        var _this = _super.call(this, message) || this;
        _this.name = 'CliError';
        _this.exitCode = exitCode;
        _this.details = details;
        Error.captureStackTrace(_this, CliError);
        return _this;
    }
    return CliError;
}(Error));
var ErrorHandlerImpl = /** @class */ (function () {
    function ErrorHandlerImpl(options) {
        if (options === void 0) { options = {}; }
        this.debug = options.debug || false;
        this.verbose = options.verbose || options.debug || false;
    }
    ErrorHandlerImpl.prototype.handleError = function (error, context) {
        if (context === void 0) { context = null; }
        if (this.isCliError(error)) {
            this._handleCliError(error, context);
        }
        else {
            this._handleUnexpectedError(error, context);
        }
    };
    ErrorHandlerImpl.prototype.isCliError = function (error) {
        return error && typeof error.exitCode === 'number' && error.details !== undefined;
    };
    ErrorHandlerImpl.prototype._handleCliError = function (error, context) {
        var message = chalk_1.default.red("Error: ".concat(error.message));
        if (context) {
            message = "".concat(context, ": ").concat(message);
        }
        console.error(message);
        if (this.verbose && Object.keys(error.details).length > 0) {
            console.error('Additional details:');
            for (var _i = 0, _a = Object.entries(error.details); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], value = _b[1];
                console.error("  ".concat(key, ": ").concat(value));
            }
        }
        if (this.verbose) {
            console.error(error.stack);
        }
        process.exit(error.exitCode);
    };
    ErrorHandlerImpl.prototype._handleUnexpectedError = function (error, context) {
        var message = chalk_1.default.red("Unexpected error: ".concat(error.message));
        if (context) {
            message = "".concat(context, ": ").concat(message);
        }
        console.error(message);
        if (this.verbose) {
            console.error(error.stack);
        }
        else {
            console.error(chalk_1.default.gray('Run with --verbose for more details'));
        }
        process.exit(ExitCode.GENERAL_ERROR);
    };
    ErrorHandlerImpl.prototype.warn = function (message, details) {
        if (details === void 0) { details = {}; }
        console.error(chalk_1.default.yellow("Warning: ".concat(message)));
        if (this.verbose && Object.keys(details).length > 0) {
            for (var _i = 0, _a = Object.entries(details); _i < _a.length; _i++) {
                var _b = _a[_i], key = _b[0], value = _b[1];
                console.error("  ".concat(key, ": ").concat(value));
            }
        }
    };
    return ErrorHandlerImpl;
}());
// ============================================================================
// EMBEDDED LOGGER
// ============================================================================
var contextStorage = new async_hooks_1.AsyncLocalStorage();
var structuredFormatter = winston.format.printf(function (_a) {
    var timestamp = _a.timestamp, level = _a.level, message = _a.message, meta = __rest(_a, ["timestamp", "level", "message"]);
    var context = contextStorage.getStore() || {};
    var environment = process.env.ENVIRONMENT || 'development';
    var isProduction = environment.toLowerCase() === 'production';
    var logData = __assign({ timestamp: timestamp, level: level, message: message }, meta);
    if (Object.keys(context).length > 0) {
        logData.context = context;
    }
    if (isProduction) {
        return JSON.stringify(logData);
    }
    else {
        var contextStr = Object.keys(context).length > 0
            ? " [".concat(Object.entries(context).map(function (_a) {
                var k = _a[0], v = _a[1];
                return "".concat(k, "=").concat(v);
            }).join(', '), "]")
            : '';
        var extraFields = Object.keys(meta).filter(function (key) {
            return !['timestamp', 'level', 'message', 'context'].includes(key);
        });
        var extraStr = extraFields.length > 0
            ? " ".concat(JSON.stringify(extraFields.reduce(function (acc, key) {
                var _a;
                return (__assign(__assign({}, acc), (_a = {}, _a[key] = meta[key], _a)));
            }, {})))
            : '';
        return "".concat(timestamp, " ").concat(level.toUpperCase().padEnd(8), " Test TypeScript CLI.").concat(message).concat(contextStr).concat(extraStr);
    }
});
var logger = null;
function setupLogging() {
    var logLevel = process.env.LOG_LEVEL || 'info';
    var logOutput = process.env.LOG_OUTPUT || 'stdout';
    var transports = [];
    if (logOutput === 'stderr') {
        transports.push(new winston.transports.Console({
            stderrLevels: ['error', 'warn', 'info', 'debug'],
            format: winston.format.combine(winston.format.timestamp(), structuredFormatter)
        }));
    }
    else if (logOutput.startsWith('file:')) {
        var logFile = logOutput.substring(5);
        var logDir = (0, path_1.dirname)(logFile);
        if (!(0, fs_1.existsSync)(logDir)) {
            (0, fs_1.mkdirSync)(logDir, { recursive: true });
        }
        transports.push(new winston.transports.File({
            filename: logFile,
            format: winston.format.combine(winston.format.timestamp(), structuredFormatter)
        }));
    }
    else {
        transports.push(new winston.transports.Console({
            level: 'info',
            stderrLevels: ['error', 'warn'],
            format: winston.format.combine(winston.format.timestamp(), structuredFormatter)
        }));
    }
    logger = winston.createLogger({
        level: logLevel,
        transports: transports,
        exitOnError: false
    });
    logger.info("Logging initialized: level=".concat(logLevel, ", output=").concat(logOutput));
}
function getLogger(name) {
    if (name === void 0) { name = 'main'; }
    if (!logger) {
        setupLogging();
    }
    return {
        debug: function (message, meta) {
            if (meta === void 0) { meta = {}; }
            return logger.debug(message, __assign({ module: name }, meta));
        },
        info: function (message, meta) {
            if (meta === void 0) { meta = {}; }
            return logger.info(message, __assign({ module: name }, meta));
        },
        warn: function (message, meta) {
            if (meta === void 0) { meta = {}; }
            return logger.warn(message, __assign({ module: name }, meta));
        },
        error: function (message, meta) {
            if (meta === void 0) { meta = {}; }
            return logger.error(message, __assign({ module: name }, meta));
        }
    };
}
// ============================================================================
// EMBEDDED PROGRESS UTILITIES
// ============================================================================
var ProgressManager = /** @class */ (function () {
    function ProgressManager() {
        this.spinner = null;
    }
    ProgressManager.prototype.start = function (text) {
        this.spinner = (0, ora_1.default)(text).start();
    };
    ProgressManager.prototype.update = function (text) {
        if (this.spinner) {
            this.spinner.text = text;
        }
    };
    ProgressManager.prototype.succeed = function (text) {
        if (this.spinner) {
            this.spinner.succeed(text);
            this.spinner = null;
        }
    };
    ProgressManager.prototype.fail = function (text) {
        if (this.spinner) {
            this.spinner.fail(text);
            this.spinner = null;
        }
    };
    ProgressManager.prototype.stop = function () {
        if (this.spinner) {
            this.spinner.stop();
            this.spinner = null;
        }
    };
    return ProgressManager;
}());
// ============================================================================
// EMBEDDED COMPLETION ENGINE
// ============================================================================
function generateCompletion(program, shell) {
    if (shell === void 0) { shell = 'bash'; }
    var commands = [];
    function extractCommands(cmd, prefix) {
        if (prefix === void 0) { prefix = ''; }
        var name = prefix ? "".concat(prefix, " ").concat(cmd.name()) : cmd.name();
        commands.push(name);
        cmd.commands.forEach(function (subCmd) {
            extractCommands(subCmd, name);
        });
    }
    extractCommands(program);
    if (shell === 'bash') {
        return "#!/bin/bash\n_testts_completions() {\n    local cur prev commands\n    cur=\"${COMP_WORDS[COMP_CWORD]}\"\n    prev=\"${COMP_WORDS[COMP_CWORD-1]}\"\n    commands=\"".concat(commands.join(' '), "\"\n    \n    if [[ ${COMP_CWORD} -eq 1 ]]; then\n        COMPREPLY=( $(compgen -W \"${commands}\" -- ${cur}) )\n    fi\n}\n\ncomplete -F _testts_completions testts");
    }
    return '# Completion not implemented for this shell';
}
// ============================================================================
// HOOK SYSTEM
// ============================================================================
var hooks = null;
function loadHooks() {
    return __awaiter(this, void 0, void 0, function () {
        var hookModule, error_1;
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0:
                    _a.trys.push([0, 2, , 3]);
                    return [4 /*yield*/, Promise.resolve().then(function () { return require('./src/hooks.js'); })];
                case 1:
                    hookModule = _a.sent();
                    hooks = hookModule;
                    return [3 /*break*/, 3];
                case 2:
                    error_1 = _a.sent();
                    if (error_1.code === 'ERR_MODULE_NOT_FOUND') {
                        console.error(chalk_1.default.red('Hook implementation not found.'));
                        console.error('Please create \'src/hooks.ts\' with your command implementations.');
                        console.error('Example:');
                        console.error(chalk_1.default.gray("\nexport async function onBuild(args: any): Promise<void> {\n    console.log('Build command:', args);\n}\n            "));
                    }
                    else {
                        console.error(chalk_1.default.red("Failed to load hooks: ".concat(error_1.message)));
                    }
                    process.exit(2);
                    return [3 /*break*/, 3];
                case 3: return [2 /*return*/];
            }
        });
    });
}
// ============================================================================
// CLI SETUP
// ============================================================================
// Initialize components
var configManager = new ConfigManager();
var errorHandler = new ErrorHandlerImpl({
    verbose: configManager.get('verbose', false),
    debug: configManager.get('debug', false)
});
var log = getLogger('cli');
var progress = new ProgressManager();
// Create main program
var program = new commander_1.Command();
program
    .name('testts')
    .description('A test CLI for TypeScript generation')
    .version('1.0.0');
// Global options
// Commands - use processed commander structure
// Simple command: hello
program
    .command('hello')
    .description('Say hello').action(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return __awaiter(void 0, void 0, void 0, function () {
        var hookName, error_2;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 6, , 7]);
                    if (!!hooks) return [3 /*break*/, 2];
                    return [4 /*yield*/, loadHooks()];
                case 1:
                    _b.sent();
                    _b.label = 2;
                case 2:
                    hookName = 'on_hello';
                    if (!(hooks && typeof hooks[hookName] === 'function')) return [3 /*break*/, 4];
                    return [4 /*yield*/, (_a = hooks)[hookName].apply(_a, args)];
                case 3:
                    _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    console.error(chalk_1.default.red("Hook function '".concat(hookName, "' not found in src/hooks.ts")));
                    process.exit(1);
                    _b.label = 5;
                case 5: return [3 /*break*/, 7];
                case 6:
                    error_2 = _b.sent();
                    errorHandler.handleError(error_2, 'hello command');
                    return [3 /*break*/, 7];
                case 7: return [2 /*return*/];
            }
        });
    });
});
// Command with subcommands: build
var buildCommand = program
    .command('build')
    .description('Build something').action(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return __awaiter(void 0, void 0, void 0, function () {
        var hookName, error_3;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 6, , 7]);
                    if (!!hooks) return [3 /*break*/, 2];
                    return [4 /*yield*/, loadHooks()];
                case 1:
                    _b.sent();
                    _b.label = 2;
                case 2:
                    hookName = 'on_build';
                    if (!(hooks && typeof hooks[hookName] === 'function')) return [3 /*break*/, 4];
                    return [4 /*yield*/, (_a = hooks)[hookName].apply(_a, args)];
                case 3:
                    _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    console.error(chalk_1.default.red("Hook function '".concat(hookName, "' not found in src/hooks.ts")));
                    process.exit(1);
                    _b.label = 5;
                case 5: return [3 /*break*/, 7];
                case 6:
                    error_3 = _b.sent();
                    errorHandler.handleError(error_3, 'build command');
                    return [3 /*break*/, 7];
                case 7: return [2 /*return*/];
            }
        });
    });
});
// Add subcommands
buildCommand
    .command('project')
    .description('Build a project')
    .action(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return __awaiter(void 0, void 0, void 0, function () {
        var hookName, error_4;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 6, , 7]);
                    if (!!hooks) return [3 /*break*/, 2];
                    return [4 /*yield*/, loadHooks()];
                case 1:
                    _b.sent();
                    _b.label = 2;
                case 2:
                    hookName = 'on_project';
                    if (!(hooks && typeof hooks[hookName] === 'function')) return [3 /*break*/, 4];
                    return [4 /*yield*/, (_a = hooks)[hookName].apply(_a, args)];
                case 3:
                    _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    console.error(chalk_1.default.red("Hook function '".concat(hookName, "' not found in src/hooks.ts")));
                    process.exit(1);
                    _b.label = 5;
                case 5: return [3 /*break*/, 7];
                case 6:
                    error_4 = _b.sent();
                    errorHandler.handleError(error_4, 'project command');
                    return [3 /*break*/, 7];
                case 7: return [2 /*return*/];
            }
        });
    });
});
// Simple command: serve
program
    .command('serve')
    .description('Start server').action(function () {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    return __awaiter(void 0, void 0, void 0, function () {
        var hookName, error_5;
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    _b.trys.push([0, 6, , 7]);
                    if (!!hooks) return [3 /*break*/, 2];
                    return [4 /*yield*/, loadHooks()];
                case 1:
                    _b.sent();
                    _b.label = 2;
                case 2:
                    hookName = 'on_serve';
                    if (!(hooks && typeof hooks[hookName] === 'function')) return [3 /*break*/, 4];
                    return [4 /*yield*/, (_a = hooks)[hookName].apply(_a, args)];
                case 3:
                    _b.sent();
                    return [3 /*break*/, 5];
                case 4:
                    console.error(chalk_1.default.red("Hook function '".concat(hookName, "' not found in src/hooks.ts")));
                    process.exit(1);
                    _b.label = 5;
                case 5: return [3 /*break*/, 7];
                case 6:
                    error_5 = _b.sent();
                    errorHandler.handleError(error_5, 'serve command');
                    return [3 /*break*/, 7];
                case 7: return [2 /*return*/];
            }
        });
    });
});
// Interactive mode support
// Error handlers
process.on('SIGINT', function () {
    console.error(chalk_1.default.yellow('\nOperation cancelled by user'));
    process.exit(ExitCode.GENERAL_ERROR);
});
process.on('uncaughtException', function (error) {
    console.error(chalk_1.default.red('Uncaught Exception:'), error);
    process.exit(ExitCode.GENERAL_ERROR);
});
process.on('unhandledRejection', function (reason, promise) {
    console.error(chalk_1.default.red('Unhandled Rejection at:'), promise, 'reason:', reason);
    process.exit(ExitCode.GENERAL_ERROR);
});
// Parse arguments
program.parse(process.argv);
