



//! Structured logging infrastructure for test-production-debug.
//! 
//! This module provides structured logging with context management and error handling.
//! Environment variables:
//! - LOG_LEVEL: Set logging level (debug, info, warn, error) - default: info
//! - LOG_OUTPUT: Set output destination (stdout, stderr, file:<path>) - default: stdout
//! - ENVIRONMENT: Set environment (production/development) - affects format

use std::collections::HashMap;
use std::env;
use std::fs::OpenOptions;
use std::io::{self, Write};
use std::path::Path;
use std::sync::Mutex;
use std::thread_local;

use serde_json::{json, Value};
use chrono::{DateTime, Utc};

/// Log levels supported by the logger
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum LogLevel {
    Debug = 0,
    Info = 1,
    Warn = 2,
    Error = 3,
}

impl std::fmt::Display for LogLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LogLevel::Debug => write!(f, "DEBUG"),
            LogLevel::Info => write!(f, "INFO"),
            LogLevel::Warn => write!(f, "WARN"),
            LogLevel::Error => write!(f, "ERROR"),
        }
    }
}

impl std::str::FromStr for LogLevel {
    type Err = String;
    
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "debug" => Ok(LogLevel::Debug),
            "info" => Ok(LogLevel::Info),
            "warn" => Ok(LogLevel::Warn),
            "error" => Ok(LogLevel::Error),
            _ => Err(format!("Invalid log level: {}", s)),
        }
    }
}

/// Log context type for structured logging
pub type LogContext = HashMap<String, Value>;

/// Thread-local storage for context
thread_local! {
    static LOG_CONTEXT: std::cell::RefCell<LogContext> = std::cell::RefCell::new(HashMap::new());
}

/// Logger configuration
pub struct LoggerConfig {
    pub level: LogLevel,
    pub output: LogOutput,
    pub environment: String,
}

/// Log output destinations
#[derive(Debug, Clone)]
pub enum LogOutput {
    Stdout,
    Stderr,
    File(String),
}

impl std::str::FromStr for LogOutput {
    type Err = String;
    
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "stdout" => Ok(LogOutput::Stdout),
            "stderr" => Ok(LogOutput::Stderr),
            path if path.starts_with("file:") => {
                Ok(LogOutput::File(path[5..].to_string()))
            }
            _ => Err(format!("Invalid log output: {}", s)),
        }
    }
}

/// Global logger instance
static LOGGER: std::sync::OnceLock<Mutex<Logger>> = std::sync::OnceLock::new();

/// Main logger struct
pub struct Logger {
    config: LoggerConfig,
    file_handle: Option<std::fs::File>,
}

impl Logger {
    /// Create a new logger with the given configuration
    pub fn new(config: LoggerConfig) -> io::Result<Self> {
        let file_handle = match &config.output {
            LogOutput::File(path) => {
                // Ensure parent directory exists
                if let Some(parent) = Path::new(path).parent() {
                    std::fs::create_dir_all(parent)?;
                }
                Some(OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(path)?)
            }
            _ => None,
        };
        
        Ok(Logger {
            config,
            file_handle,
        })
    }
    
    /// Log a message with the given level
    pub fn log(&mut self, level: LogLevel, module: &str, message: &str, extra: Option<&LogContext>) -> io::Result<()> {
        // Check if we should log this level
        if level < self.config.level {
            return Ok(());
        }
        
        let timestamp = Utc::now();
        let context = get_context();
        let is_production = self.config.environment.to_lowercase() == "production" 
            || self.config.environment.to_lowercase() == "prod";
        
        let log_entry = if is_production {
            // JSON format for production
            let mut log_data = json!({
                "timestamp": timestamp.to_rfc3339(),
                "level": level.to_string(),
                "module": module,
                "message": message,
            });
            
            // Add context if available
            if !context.is_empty() {
                log_data["context"] = json!(context);
            }
            
            // Add extra fields if provided
            if let Some(extra_fields) = extra {
                for (key, value) in extra_fields {
                    log_data[key] = value.clone();
                }
            }
            
            serde_json::to_string(&log_data).unwrap_or_else(|_| "Failed to serialize log data".to_string())
        } else {
            // Human-readable format for development
            let context_str = if !context.is_empty() {
                let ctx_parts: Vec<String> = context.iter()
                    .map(|(k, v)| format!("{}={}", k, v))
                    .collect();
                format!(" [{}]", ctx_parts.join(", "))
            } else {
                String::new()
            };
            
            let extra_str = if let Some(extra_fields) = extra {
                if !extra_fields.is_empty() {
                    format!(" {}", serde_json::to_string(extra_fields).unwrap_or_default())
                } else {
                    String::new()
                }
            } else {
                String::new()
            };
            
            format!("{} {:8} test-production-debug.{}.{}{}{}\n",
                timestamp.format("%Y-%m-%d %H:%M:%S%.3f"),
                level.to_string(),
                module,
                message,
                context_str,
                extra_str
            )
        };
        
        // Write to appropriate output
        match &self.config.output {
            LogOutput::Stdout => {
                if level >= LogLevel::Warn {
                    // Warnings and errors to stderr for container compatibility
                    io::stderr().write_all(log_entry.as_bytes())?;
                    io::stderr().write_all(b"\n")?;
                } else {
                    // Info and debug to stdout
                    io::stdout().write_all(log_entry.as_bytes())?;
                    io::stdout().write_all(b"\n")?;
                }
            }
            LogOutput::Stderr => {
                io::stderr().write_all(log_entry.as_bytes())?;
                io::stderr().write_all(b"\n")?;
            }
            LogOutput::File(_) => {
                if let Some(ref mut file) = self.file_handle {
                    file.write_all(log_entry.as_bytes())?;
                    file.write_all(b"\n")?;
                    file.flush()?;
                }
            }
        }
        
        Ok(())
    }
}

/// Initialize structured logging for test-production-debug.
/// 
/// Environment Variables:
/// - LOG_LEVEL: Set logging level (debug, info, warn, error) - default: info
/// - LOG_OUTPUT: Set output destination (stdout, stderr, file:<path>) - default: stdout
/// - ENVIRONMENT: Set environment (production/development) - affects format
pub fn setup_logging() -> io::Result<()> {
    let log_level = env::var("LOG_LEVEL")
        .unwrap_or_else(|_| "info".to_string())
        .parse()
        .unwrap_or_else(|err| {
            eprintln!("Warning: Invalid LOG_LEVEL, using info: {}", err);
            LogLevel::Info
        });
    
    let log_output = env::var("LOG_OUTPUT")
        .unwrap_or_else(|_| "stdout".to_string())
        .parse()
        .unwrap_or_else(|err| {
            eprintln!("Warning: Invalid LOG_OUTPUT, using stdout: {}", err);
            LogOutput::Stdout
        });
    
    let environment = env::var("ENVIRONMENT").unwrap_or_else(|_| "development".to_string());
    
    // Create startup message before moving log_output
    let startup_context = json!({
        "level": log_level.to_string(),
        "output": format!("{:?}", log_output),
        "environment": environment
    });
    let startup_map: HashMap<String, Value> = startup_context.as_object().unwrap().clone().into_iter().collect();
    
    let config = LoggerConfig {
        level: log_level,
        output: log_output,
        environment: environment.clone(),
    };
    
    let logger = Logger::new(config)?;
    LOGGER.set(Mutex::new(logger)).map_err(|_| {
        io::Error::new(io::ErrorKind::AlreadyExists, "Logger already initialized")
    })?;
    
    // Log startup message
    info("logger", "Logging initialized", Some(&startup_map));
    
    Ok(())
}

/// Get a logger function for the specified module
pub fn get_logger(module_name: &str) -> impl Fn(LogLevel, &str, Option<&LogContext>) + '_ {
    move |level: LogLevel, message: &str, extra: Option<&LogContext>| {
        if let Some(logger_mutex) = LOGGER.get() {
            if let Ok(mut logger) = logger_mutex.lock() {
                if let Err(e) = logger.log(level, module_name, message, extra) {
                    eprintln!("Failed to write log: {}", e);
                }
            }
        }
    }
}

/// Log a debug message
pub fn debug(module: &str, message: &str, extra: Option<&LogContext>) {
    if let Some(logger_mutex) = LOGGER.get() {
        if let Ok(mut logger) = logger_mutex.lock() {
            let _ = logger.log(LogLevel::Debug, module, message, extra);
        }
    }
}

/// Log an info message
pub fn info(module: &str, message: &str, extra: Option<&LogContext>) {
    if let Some(logger_mutex) = LOGGER.get() {
        if let Ok(mut logger) = logger_mutex.lock() {
            let _ = logger.log(LogLevel::Info, module, message, extra);
        }
    }
}

/// Log a warning message
pub fn warn(module: &str, message: &str, extra: Option<&LogContext>) {
    if let Some(logger_mutex) = LOGGER.get() {
        if let Ok(mut logger) = logger_mutex.lock() {
            let _ = logger.log(LogLevel::Warn, module, message, extra);
        }
    }
}

/// Log an error message
pub fn error(module: &str, message: &str, extra: Option<&LogContext>) {
    if let Some(logger_mutex) = LOGGER.get() {
        if let Ok(mut logger) = logger_mutex.lock() {
            let _ = logger.log(LogLevel::Error, module, message, extra);
        }
    }
}

/// Set logging context variables that will be included in all log messages within the current thread.
/// 
/// # Arguments
/// * `context_data` - Key-value pairs to add to logging context
/// 
/// # Examples
/// ```rust
/// use std::collections::HashMap;
/// use serde_json::json;
/// 
/// let mut context = HashMap::new();
/// context.insert("operation_id".to_string(), json!("op_123"));
/// context.insert("user".to_string(), json!("admin"));
/// set_context(context);
/// 
/// info("main", "Operation started", None); // Will include context automatically
/// ```
pub fn set_context(context_data: LogContext) {
    LOG_CONTEXT.with(|ctx| {
        let mut current_context = ctx.borrow_mut();
        current_context.clear();
        for (key, value) in context_data {
            current_context.insert(key, value);
        }
    });
}

/// Clear all logging context variables
pub fn clear_context() {
    LOG_CONTEXT.with(|ctx| {
        ctx.borrow_mut().clear();
    });
}

/// Update existing context with new values
/// 
/// # Arguments
/// * `context_data` - Key-value pairs to update in logging context
pub fn update_context(context_data: LogContext) {
    LOG_CONTEXT.with(|ctx| {
        let mut current_context = ctx.borrow_mut();
        for (key, value) in context_data {
            current_context.insert(key, value);
        }
    });
}

/// Get current logging context
pub fn get_context() -> LogContext {
    LOG_CONTEXT.with(|ctx| ctx.borrow().clone())
}

/// Remove specific keys from logging context
/// 
/// # Arguments
/// * `keys` - Context keys to remove
pub fn remove_context_keys(keys: &[&str]) {
    LOG_CONTEXT.with(|ctx| {
        let mut current_context = ctx.borrow_mut();
        for key in keys {
            current_context.remove(*key);
        }
    });
}

/// Create a command context for logging
pub fn create_command_context(command: &str, args: &[&str]) -> LogContext {
    let mut context = HashMap::new();
    context.insert("command".to_string(), json!(command));
    if !args.is_empty() {
        context.insert("args".to_string(), json!(args));
    }
    context
}

/// Log an error with context
pub fn log_error(context: &str, err: &anyhow::Error) {
    error(context, &format!("{:#}", err), None);
}

/// Convenience macro for logging with automatic module detection
#[macro_export]
macro_rules! log {
    (debug, $msg:expr) => {
        debug(module_path!(), $msg, None)
    };
    (debug, $msg:expr, $extra:expr) => {
        debug(module_path!(), $msg, Some($extra))
    };
    (info, $msg:expr) => {
        info(module_path!(), $msg, None)
    };
    (info, $msg:expr, $extra:expr) => {
        info(module_path!(), $msg, Some($extra))
    };
    (warn, $msg:expr) => {
        warn(module_path!(), $msg, None)
    };
    (warn, $msg:expr, $extra:expr) => {
        warn(module_path!(), $msg, Some($extra))
    };
    (error, $msg:expr) => {
        error(module_path!(), $msg, None)
    };
    (error, $msg:expr, $extra:expr) => {
        error(module_path!(), $msg, Some($extra))
    };
}
