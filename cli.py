#!/usr/bin/env python3
"""
Goobits CLI Framework - Build professional command-line tools with YAML configuration
Generated by Goobits CLI Framework
"""

import click
import sys
from typing import Any
from pathlib import Path
import importlib.util

try:
    from .hooks import *  # Import all hook functions
except ImportError:
    # Hooks not implemented yet
    pass

def start_interactive_mode(ctx, param, value):
    """Callback for --interactive option."""
    if not value or ctx.resilient_parsing:
        return
    
    try:
        # Try to import interactive mode module
        # Get the directory where this CLI script is located
        cli_dir = Path(__file__).parent
        interactive_file = cli_dir / "enhanced_interactive_mode.py"
        
        if interactive_file.exists():
            spec = importlib.util.spec_from_file_location("enhanced_interactive_mode", interactive_file)
            interactive_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(interactive_module)
            interactive_module.start_enhanced_interactive()
            # If we get here, interactive mode completed successfully, exit cleanly
            sys.exit(0)
        else:
            click.echo("‚ùå Interactive mode not available. enhanced_interactive_mode.py not found.")
            ctx.exit(1)
    except SystemExit:
        # Interactive mode exited, let it pass through
        sys.exit(0)
    except Exception as e:
        click.echo(f"‚ùå Error starting interactive mode: {e}")
        ctx.exit(1)
@click.group(
    name="Goobits CLI",
    help="Transform simple YAML configuration into rich terminal applications with setup scripts, dependency management, and cross-platform compatibility.",
    context_settings={"help_option_names": ["-h", "--help"]}
)
@click.version_option(version="1.2.0")
@click.option(
    "--verbose", "-v",
    help="Enable verbose output with detailed error messages and stack traces",
    is_flag=True,)
@click.option(
    "--interactive", "-i",
    help="Launch interactive mode",
    is_flag=True,
    is_eager=True,
    callback=start_interactive_mode)

def cli(verbose, interactive):
    """Transform simple YAML configuration into rich terminal applications with setup scripts, dependency management, and cross-platform compatibility."""
    pass
@cli.command(name="build", help="Build CLI and setup scripts from goobits.yaml configuration")
@click.argument("config_path", required=False)
@click.option(
    "--output-dir", "-o",
    help="üìÅ Output directory (defaults to same directory as config file)",)
@click.option(
    "--output",
    help="üìù Output filename for generated CLI (defaults to 'generated_cli.py')",)
@click.option(
    "--backup",
    help="üíæ Create backup files (.bak) when overwriting existing files",
    is_flag=True,)
@click.option(
    "--universal-templates",
    help="üß™ Use Universal Template System (experimental)",
    is_flag=True,)

def build_command(config_path, output_dir, output, backup, universal_templates):
    """Build CLI and setup scripts from goobits.yaml configuration"""
    try:
        # Initialize error handler with verbose flag from global options
        from .errors import ErrorHandler, set_error_handler
        ctx = click.get_current_context()
        verbose_flag = ctx.find_root().params.get('verbose', False)
        error_handler = ErrorHandler(verbose=verbose_flag)
        set_error_handler(error_handler)

        # Call the hook function if it exists
        hook_name = "on_build"
        if hook_name in globals():
            hook_func = globals()[hook_name]
            hook_func(config_path, output_dir, output, backup, universal_templates)
        else:
            click.echo(f"Hook function '{hook_name}' not implemented")
            sys.exit(1)
    except Exception as e:
        # Use error handler for proper verbose output
        try:
            from .errors import get_error_handler
            error_handler = get_error_handler()
            error_handler.handle_error(e, "Command execution")
        except ImportError:
            click.echo(f"Error: {e}", err=True)
            # Try to get verbose flag again for fallback
            try:
                ctx = click.get_current_context()
                verbose_fallback = ctx.find_root().params.get('verbose', False)
                if verbose_fallback:
                    import traceback
                    traceback.print_exc()
            except:
                pass
            sys.exit(1)
@cli.command(name="init", help="Create initial goobits.yaml template")
@click.argument("project_name", required=False)
@click.option(
    "--template", "-t",
    help="üéØ Template type",    default='basic',)
@click.option(
    "--force",
    help="üî• Overwrite existing goobits.yaml file",
    is_flag=True,)

def init_command(project_name, template, force):
    """Create initial goobits.yaml template"""
    try:
        # Initialize error handler with verbose flag from global options
        from .errors import ErrorHandler, set_error_handler
        ctx = click.get_current_context()
        verbose_flag = ctx.find_root().params.get('verbose', False)
        error_handler = ErrorHandler(verbose=verbose_flag)
        set_error_handler(error_handler)

        # Call the hook function if it exists
        hook_name = "on_init"
        if hook_name in globals():
            hook_func = globals()[hook_name]
            hook_func(project_name, template, force)
        else:
            click.echo(f"Hook function '{hook_name}' not implemented")
            sys.exit(1)
    except Exception as e:
        # Use error handler for proper verbose output
        try:
            from .errors import get_error_handler
            error_handler = get_error_handler()
            error_handler.handle_error(e, "Command execution")
        except ImportError:
            click.echo(f"Error: {e}", err=True)
            # Try to get verbose flag again for fallback
            try:
                ctx = click.get_current_context()
                verbose_fallback = ctx.find_root().params.get('verbose', False)
                if verbose_fallback:
                    import traceback
                    traceback.print_exc()
            except:
                pass
            sys.exit(1)
@cli.command(name="serve", help="Serve local PyPI-compatible package index")
@click.argument("directory")
@click.option(
    "--host",
    help="üåç Host to bind the server to",    default='localhost',)
@click.option(
    "--port", "-p",
    help="üîå Port to run the server on",    default=8080,)

def serve_command(directory, host, port):
    """Serve local PyPI-compatible package index"""
    try:
        # Initialize error handler with verbose flag from global options
        from .errors import ErrorHandler, set_error_handler
        ctx = click.get_current_context()
        verbose_flag = ctx.find_root().params.get('verbose', False)
        error_handler = ErrorHandler(verbose=verbose_flag)
        set_error_handler(error_handler)

        # Call the hook function if it exists
        hook_name = "on_serve"
        if hook_name in globals():
            hook_func = globals()[hook_name]
            hook_func(directory, host, port)
        else:
            click.echo(f"Hook function '{hook_name}' not implemented")
            sys.exit(1)
    except Exception as e:
        # Use error handler for proper verbose output
        try:
            from .errors import get_error_handler
            error_handler = get_error_handler()
            error_handler.handle_error(e, "Command execution")
        except ImportError:
            click.echo(f"Error: {e}", err=True)
            # Try to get verbose flag again for fallback
            try:
                ctx = click.get_current_context()
                verbose_fallback = ctx.find_root().params.get('verbose', False)
                if verbose_fallback:
                    import traceback
                    traceback.print_exc()
            except:
                pass
            sys.exit(1)
if __name__ == "__main__":
    cli()