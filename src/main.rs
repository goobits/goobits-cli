//! Generated by goobits-cli

//! 

//! Note: Rust templates are not yet installed.

//! This is a basic CLI structure. To get full functionality,

//! ensure Rust templates are installed in:

//! src/goobits_cli/templates/rust/



use clap::{Arg, ArgMatches, Command};

use std::process;

use anyhow::Result;



mod hooks;



fn main() {

    let app = Command::new("nodejstestcli")

        .about("A CLI tool")

        .version("1.2.3")

        .subcommand_required(false)

        .arg_required_else_help(true)

        // Add global options

        .arg(Arg::new("verbose")

            .short('v')

            .long("verbose")

            .help("Enable verbose output")

            .action(clap::ArgAction::SetTrue)

            .global(true))

        .arg(Arg::new("config")

            .short('c')

            .long("config")

            .help("Config file path")

            .value_name("PATH")

            .global(true));

    

    let app = build_cli(app);

    let matches = app.get_matches();

    

    if let Err(e) = handle_command(&matches) {

        eprintln!("Error: {}", e);

        process::exit(1);

    }

}



fn build_cli(app: Command) -> Command {

    let mut app = app;

    

    // Add commands from configuration

    app = app.subcommand(
        Command::new("init")
            .about("Initialize a new project")
            .arg(Arg::new("name")
                .help("Project name")
                .required(true)
                .value_name("NAME"))
            .arg(Arg::new("template")
                .help("Project template to use")
                .short('t')
                .long("template")
                .value_name("VALUE"))
            .arg(Arg::new("skip-install")
                .help("Skip npm install")
                
                .long("skip-install")
                .value_name("VALUE"))
    );
app = app.subcommand(
        Command::new("deploy")
            .about("Deploy the application")
            .arg(Arg::new("environment")
                .help("Target environment (dev, staging, prod)")
                .required(true)
                .value_name("ENVIRONMENT"))
            .arg(Arg::new("force")
                .help("Force deployment without confirmation")
                .short('f')
                .long("force")
                .value_name("VALUE"))
            .arg(Arg::new("dry-run")
                .help("Simulate deployment without making changes")
                
                .long("dry-run")
                .value_name("VALUE"))
    );
app = app.subcommand(
        Command::new("server")
            .about("Server management commands")
            .subcommand_required(true)
            .arg_required_else_help(true)
            .subcommand(
                Command::new("start")
                    .about("Start the server")
                    .arg(Arg::new("port")
                        .help("Port to listen on")
                        .short('p')
                        .long("port")
                        .value_name("NUMBER"))
                    .arg(Arg::new("daemon")
                        .help("Run as daemon")
                        .short('d')
                        .long("daemon")
                        .value_name("VALUE"))
            )
            .subcommand(
                Command::new("stop")
                    .about("Stop the server")
                    .arg(Arg::new("graceful")
                        .help("Graceful shutdown")
                        
                        .long("graceful")
                        .value_name("VALUE"))
            )
            .subcommand(
                Command::new("restart")
                    .about("Restart the server")
                    .arg(Arg::new("service")
                        .help("Service name to restart")
                        .required(false)
                        .value_name("SERVICE"))
            )
    );
app = app.subcommand(
        Command::new("database")
            .about("Database operations")
            .subcommand_required(true)
            .arg_required_else_help(true)
            .subcommand(
                Command::new("migrate")
                    .about("Run database migrations")
                    .arg(Arg::new("direction")
                        .help("Migration direction (up/down)")
                        
                        .long("direction")
                        .value_name("VALUE"))
                    .arg(Arg::new("steps")
                        .help("Number of migrations to run")
                        
                        .long("steps")
                        .value_name("NUMBER"))
            )
            .subcommand(
                Command::new("seed")
                    .about("Seed the database")
                    .arg(Arg::new("dataset")
                        .help("Dataset to seed")
                        .required(false)
                        .value_name("DATASET"))
                    .arg(Arg::new("truncate")
                        .help("Truncate tables before seeding")
                        
                        .long("truncate")
                        .value_name("VALUE"))
            )
            .subcommand(
                Command::new("backup")
                    .about("Backup the database")
                    .arg(Arg::new("output")
                        .help("Output file path")
                        .short('o')
                        .long("output")
                        .value_name("VALUE"))
                    .arg(Arg::new("compress")
                        .help("Compress the backup")
                        
                        .long("compress")
                        .value_name("VALUE"))
            )
    );
app = app.subcommand(
        Command::new("test")
            .about("Run tests")
            .arg(Arg::new("pattern")
                .help("Test file pattern")
                .required(false)
                .value_name("PATTERN"))
            .arg(Arg::new("coverage")
                .help("Generate coverage report")
                
                .long("coverage")
                .value_name("VALUE"))
            .arg(Arg::new("watch")
                .help("Watch files for changes")
                .short('w')
                .long("watch")
                .value_name("VALUE"))
            .arg(Arg::new("bail")
                .help("Stop on first test failure")
                
                .long("bail")
                .value_name("VALUE"))
    );

    

    app

}



fn handle_command(matches: &ArgMatches) -> Result<()> {

    match matches.subcommand() {

        Some(("init", sub_matches)) => {
            let name = sub_matches.get_one::<String>("name").map(|s| s.as_str()).unwrap_or("");
                let template: Option<&str> = sub_matches.get_one::<String>("template").map(|s| s.as_str());
                let skip-install: Option<&str> = sub_matches.get_one::<String>("skip-install").map(|s| s.as_str());
                let verbose = sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_matches.get_one::<String>("config").map(|s| s.as_str());
            if let Err(e) = hooks::on_init(name, template, skip-install, verbose, config) {
                eprintln!("Error: {}", e);
                std::process::exit(1);
            }
            Ok(())
        }
        Some(("deploy", sub_matches)) => {
            let environment = sub_matches.get_one::<String>("environment").map(|s| s.as_str()).unwrap_or("");
                let force: Option<&str> = sub_matches.get_one::<String>("force").map(|s| s.as_str());
                let dry-run: Option<&str> = sub_matches.get_one::<String>("dry-run").map(|s| s.as_str());
                let verbose = sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_matches.get_one::<String>("config").map(|s| s.as_str());
            if let Err(e) = hooks::on_deploy(environment, force, dry-run, verbose, config) {
                eprintln!("Error: {}", e);
                std::process::exit(1);
            }
            Ok(())
        }
        Some(("server", sub_matches)) => {
            match sub_matches.subcommand() {
                Some(("start", sub_sub_matches)) => {
                let port: Option<i32> = sub_sub_matches.get_one::<String>("port")
                    .and_then(|s| s.parse().ok());
                let daemon: Option<&str> = sub_sub_matches.get_one::<String>("daemon").map(|s| s.as_str());
                let verbose = sub_sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_sub_matches.get_one::<String>("config").map(|s| s.as_str());
                if let Err(e) = hooks::on_server_start(port, daemon, verbose, config) {
                    eprintln!("Error: {}", e);
                    std::process::exit(1);
                }
                Ok(())
            }
            Some(("stop", sub_sub_matches)) => {
                let graceful: Option<&str> = sub_sub_matches.get_one::<String>("graceful").map(|s| s.as_str());
                let verbose = sub_sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_sub_matches.get_one::<String>("config").map(|s| s.as_str());
                if let Err(e) = hooks::on_server_stop(graceful, verbose, config) {
                    eprintln!("Error: {}", e);
                    std::process::exit(1);
                }
                Ok(())
            }
            Some(("restart", sub_sub_matches)) => {
                let service = sub_sub_matches.get_one::<String>("service").map(|s| s.as_str()).unwrap_or("");
                let verbose = sub_sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_sub_matches.get_one::<String>("config").map(|s| s.as_str());
                if let Err(e) = hooks::on_server_restart(service, verbose, config) {
                    eprintln!("Error: {}", e);
                    std::process::exit(1);
                }
                Ok(())
            }
            _ => {
                eprintln!("Unknown subcommand. Use --help for available options.");
                std::process::exit(1);
            }
            }
        }
        Some(("database", sub_matches)) => {
            match sub_matches.subcommand() {
                Some(("migrate", sub_sub_matches)) => {
                let direction: Option<&str> = sub_sub_matches.get_one::<String>("direction").map(|s| s.as_str());
                let steps: Option<i32> = sub_sub_matches.get_one::<String>("steps")
                    .and_then(|s| s.parse().ok());
                let verbose = sub_sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_sub_matches.get_one::<String>("config").map(|s| s.as_str());
                if let Err(e) = hooks::on_database_migrate(direction, steps, verbose, config) {
                    eprintln!("Error: {}", e);
                    std::process::exit(1);
                }
                Ok(())
            }
            Some(("seed", sub_sub_matches)) => {
                let dataset = sub_sub_matches.get_one::<String>("dataset").map(|s| s.as_str()).unwrap_or("");
                let truncate: Option<&str> = sub_sub_matches.get_one::<String>("truncate").map(|s| s.as_str());
                let verbose = sub_sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_sub_matches.get_one::<String>("config").map(|s| s.as_str());
                if let Err(e) = hooks::on_database_seed(dataset, truncate, verbose, config) {
                    eprintln!("Error: {}", e);
                    std::process::exit(1);
                }
                Ok(())
            }
            Some(("backup", sub_sub_matches)) => {
                let output: Option<&str> = sub_sub_matches.get_one::<String>("output").map(|s| s.as_str());
                let compress: Option<&str> = sub_sub_matches.get_one::<String>("compress").map(|s| s.as_str());
                let verbose = sub_sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_sub_matches.get_one::<String>("config").map(|s| s.as_str());
                if let Err(e) = hooks::on_database_backup(output, compress, verbose, config) {
                    eprintln!("Error: {}", e);
                    std::process::exit(1);
                }
                Ok(())
            }
            _ => {
                eprintln!("Unknown subcommand. Use --help for available options.");
                std::process::exit(1);
            }
            }
        }
        Some(("test", sub_matches)) => {
            let pattern = sub_matches.get_one::<String>("pattern").map(|s| s.as_str()).unwrap_or("");
                let coverage: Option<&str> = sub_matches.get_one::<String>("coverage").map(|s| s.as_str());
                let watch: Option<&str> = sub_matches.get_one::<String>("watch").map(|s| s.as_str());
                let bail: Option<&str> = sub_matches.get_one::<String>("bail").map(|s| s.as_str());
                let verbose = sub_matches.get_flag("verbose");
                let config: Option<&str> = sub_matches.get_one::<String>("config").map(|s| s.as_str());
            if let Err(e) = hooks::on_test(pattern, coverage, watch, bail, verbose, config) {
                eprintln!("Error: {}", e);
                std::process::exit(1);
            }
            Ok(())
        }

        _ => {

            println!("No command specified. Use --help for available commands.");

            Ok(())

        }

    }

}

