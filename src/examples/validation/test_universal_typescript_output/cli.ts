#!/usr/bin/env node
/**
 * Test Universal CLI - A test CLI for validating Universal Template System functionality
 * Generated by Goobits CLI Framework
 */

import { Command } from 'commander';
// Enhanced error handling for TypeScript
class CLIError extends Error {
    public code: number;
    public details?: string;
    
    constructor(message: string, code: number = 1, details?: string) {
        super(message);
        this.name = 'CLIError';
        this.code = code;
        this.details = details;
    }
}

// Hook loading with enhanced error handling
let hooks: any = null;
// Dynamic import for ES modules
const loadHooks = async () => {
    try {
        hooks = await import('./hooks.js');
    } catch (error: any) {
        if (error.code === 'MODULE_NOT_FOUND') {
            console.error('Hook implementation not found. Please create \'src/hooks.ts\' with your command implementations.');
            console.error('See documentation for hook function signatures.');
        } else {
            console.error(`Failed to load hooks: ${error.message}`);
        }
        process.exit(2);
    }
};

// Load hooks at startup
await loadHooks();
// Global error handler
function handleError(error: unknown, context: string = 'Command execution', verbose: boolean = false): never {
    if (error instanceof CLIError) {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.details) {
            console.error('Details:', error.details);
        }
        process.exit(error.code);
    } else if (error instanceof Error) {
        if (error.message.includes('Cannot resolve module') || error.message.includes('MODULE_NOT_FOUND')) {
            console.error('Hook implementation not found.');
            console.error('Please implement the required hook function in src/hooks.ts');
            process.exit(2);
        } else {
            console.error(`${context} failed: ${error.message}`);
            if (verbose && error.stack) {
                console.error('Stack trace:', error.stack);
            }
            process.exit(1);
        }
    } else {
        console.error(`${context} failed: Unknown error`);
        if (verbose) {
            console.error('Error details:', error);
        }
        process.exit(1);
    }
}

const program = new Command();

program
    .name('')
    .description('Test CLI for universal template validation')
    .version('1.0.0');
// Command hierarchy building for unlimited nesting
const commandMap = new Map<string, any>();// Level 1: hello
const helloCmd = program
    .command('hello')
    .description('Say hello to someone');
helloCmd.argument('name', 'No description');
helloCmd.option('--greeting <value>, -g', 'Custom greeting message', Hello);
helloCmd.action(async (name: string, options: any) => {
    const globalOpts = program.opts();
    const verbose: boolean = globalOpts.verbose || false;
    
    try {
        const hookName = 'on_hello' as keyof typeof hooks;
        
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${String(hookName)}' not implemented in src/hooks.ts`;
            const details = availableHooks.length > 0 
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.ts';
            throw new CLIError(message, 2, details);
        }
        
        // Execute the hook function with proper error handling
        const args = [name];
        const result = await (hooks[hookName] as Function)(...args, options);
        
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command 'hello' failed with exit code ${result}`, result);
        }
        
    } catch (error: unknown) {
        if (error instanceof Error && (error.message.includes('SIGINT') || error.message.includes('interrupted'))) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        
        handleError(error, 'Command execution', verbose);
    }
});
commandMap.set('hello', helloCmd);


program.parse();