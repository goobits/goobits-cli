/*!
Interactive prompts and input helpers for Test Rust CLI
Generated by goobits-cli
*/

use std::path::{Path, PathBuf};
use std::io::{self, Write};
use dialoguer::{
    Confirm, Input, Select, MultiSelect, Password, FuzzySelect,
    Editor, Sort, theme::ColorfulTheme, Completion
};
use console::{style, Term};

// Custom Error Types for Prompt Operations
#[derive(Debug, thiserror::Error)]
pub enum PromptError {
    #[error("Prompt operation failed: {message}")]
    OperationFailed { message: String },
    
    #[error("User cancelled the operation")]
    UserCancelled,
    
    #[error("Invalid input: {input}")]
    InvalidInput { input: String },
    
    #[error("IO error during prompt: {source}")]
    IoError {
        #[from]
        source: io::Error,
    },
}

/// Helper for creating interactive prompts and user input
pub struct PromptsHelper {
    theme: ColorfulTheme,
    term: Term,
}

impl Default for PromptsHelper {
    fn default() -> Self {
        Self::new()
    }
}

impl PromptsHelper {
    /// Create a new prompts helper with default theme
    pub fn new() -> Self {
        Self {
            theme: ColorfulTheme::default(),
            term: Term::stderr(),
        }
    }
    
    /// Create a new prompts helper with custom theme
    pub fn with_theme(theme: ColorfulTheme) -> Self {
        Self {
            theme,
            term: Term::stderr(),
        }
    }
    
    /// Prompt for text input
    pub fn text(&self, message: &str) -> Result<String, PromptError> {
        Input::with_theme(&self.theme)
            .with_prompt(message)
            .interact_text()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Text input failed: {}", e),
                },
            })
    }
    
    /// Prompt for text input with default value
    pub fn text_with_default(&self, message: &str, default: &str) -> Result<String, PromptError> {
        Input::with_theme(&self.theme)
            .with_prompt(message)
            .default(default.to_string())
            .interact_text()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Text input failed: {}", e),
                },
            })
    }
    
    /// Prompt for text input with validation
    pub fn text_with_validation<F>(&self, message: &str, validator: F) -> Result<String, PromptError>
    where
        F: Fn(&String) -> Result<(), String> + 'static,
    {
        Input::with_theme(&self.theme)
            .with_prompt(message)
            .validate_with(validator)
            .interact_text()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Text input failed: {}", e),
                },
            })
    }
    
    /// Prompt for password input (hidden)
    pub fn password(&self, message: &str) -> Result<String, PromptError> {
        Password::with_theme(&self.theme)
            .with_prompt(message)
            .interact()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Password input failed: {}", e),
                },
            })
    }
    
    /// Prompt for password with confirmation
    pub fn password_with_confirmation(&self, message: &str) -> Result<String, PromptError> {
        Password::with_theme(&self.theme)
            .with_prompt(message)
            .with_confirmation("Confirm password", "Passwords don't match")
            .interact()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Password input failed: {}", e),
                },
            })
    }
    
    /// Prompt for yes/no confirmation
    pub fn confirm(&self, message: &str) -> Result<bool, PromptError> {
        Confirm::with_theme(&self.theme)
            .with_prompt(message)
            .interact()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Confirmation failed: {}", e),
                },
            })
    }
    
    /// Prompt for confirmation with default value
    pub fn confirm_with_default(&self, message: &str, default: bool) -> Result<bool, PromptError> {
        Confirm::with_theme(&self.theme)
            .with_prompt(message)
            .default(default)
            .interact()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Confirmation failed: {}", e),
                },
            })
    }
    
    /// Prompt for single selection from a list
    pub fn select<T: ToString>(&self, message: &str, items: &[T]) -> Result<usize, PromptError> {
        if items.is_empty() {
            return Err(PromptError::InvalidInput {
                input: "Empty selection list".to_string(),
            });
        }
        
        Select::with_theme(&self.theme)
            .with_prompt(message)
            .items(items)
            .interact()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Selection failed: {}", e),
                },
            })
    }
    
    /// Prompt for single selection with default
    pub fn select_with_default<T: ToString>(&self, message: &str, items: &[T], default: usize) -> Result<usize, PromptError> {
        if items.is_empty() {
            return Err(PromptError::InvalidInput {
                input: "Empty selection list".to_string(),
            });
        }
        
        if default >= items.len() {
            return Err(PromptError::InvalidInput {
                input: format!("Default index {} out of range for {} items", default, items.len()),
            });
        }
        
        Select::with_theme(&self.theme)
            .with_prompt(message)
            .items(items)
            .default(default)
            .interact()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Selection failed: {}", e),
                },
            })
    }
    
    /// Prompt for fuzzy search selection
    pub fn fuzzy_select<T: ToString>(&self, message: &str, items: &[T]) -> Result<usize, PromptError> {
        if items.is_empty() {
            return Err(PromptError::InvalidInput {
                input: "Empty selection list".to_string(),
            });
        }
        
        FuzzySelect::with_theme(&self.theme)
            .with_prompt(message)
            .items(items)
            .interact()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Fuzzy selection failed: {}", e),
                },
            })
    }
    
    /// Prompt for multiple selections
    pub fn multiselect<T: ToString>(&self, message: &str, items: &[T]) -> Result<Vec<usize>, PromptError> {
        if items.is_empty() {
            return Err(PromptError::InvalidInput {
                input: "Empty selection list".to_string(),
            });
        }
        
        MultiSelect::with_theme(&self.theme)
            .with_prompt(message)
            .items(items)
            .interact()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Multi-selection failed: {}", e),
                },
            })
    }
    
    /// Prompt for multiple selections with defaults
    pub fn multiselect_with_defaults<T: ToString>(&self, message: &str, items: &[T], defaults: &[bool]) -> Result<Vec<usize>, PromptError> {
        if items.is_empty() {
            return Err(PromptError::InvalidInput {
                input: "Empty selection list".to_string(),
            });
        }
        
        if defaults.len() != items.len() {
            return Err(PromptError::InvalidInput {
                input: format!("Defaults length {} doesn't match items length {}", defaults.len(), items.len()),
            });
        }
        
        MultiSelect::with_theme(&self.theme)
            .with_prompt(message)
            .items(items)
            .defaults(defaults)
            .interact()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Multi-selection failed: {}", e),
                },
            })
    }
    
    /// Prompt for sorting items
    pub fn sort<T: ToString + Clone>(&self, message: &str, items: &[T]) -> Result<Vec<usize>, PromptError> {
        if items.is_empty() {
            return Err(PromptError::InvalidInput {
                input: "Empty sort list".to_string(),
            });
        }
        
        Sort::with_theme(&self.theme)
            .with_prompt(message)
            .items(items)
            .interact()
            .map_err(|e| match e.kind() {
                io::ErrorKind::Interrupted => PromptError::UserCancelled,
                _ => PromptError::OperationFailed {
                    message: format!("Sort failed: {}", e),
                },
            })
    }
    
    /// Prompt for editor input
    pub fn editor(&self, message: &str) -> Result<String, PromptError> {
        Editor::new()
            .edit(message)
            .map_err(|e| PromptError::OperationFailed {
                message: format!("Editor failed: {}", e),
            })?
            .ok_or_else(|| PromptError::UserCancelled)
    }
    
    /// Prompt for editor input with extension
    pub fn editor_with_extension(&self, message: &str, extension: &str) -> Result<String, PromptError> {
        Editor::new()
            .extension(extension)
            .edit(message)
            .map_err(|e| PromptError::OperationFailed {
                message: format!("Editor failed: {}", e),
            })?
            .ok_or_else(|| PromptError::UserCancelled)
    }
    
    /// Prompt for integer input
    pub fn integer(&self, message: &str) -> Result<i64, PromptError> {
        self.text_with_validation(message, |input: &String| {
            input.parse::<i64>()
                .map(|_| ())
                .map_err(|_| "Please enter a valid integer".to_string())
        })?
        .parse::<i64>()
        .map_err(|e| PromptError::OperationFailed {
            message: format!("Integer parsing failed: {}", e),
        })
    }
    
    /// Prompt for integer input with range validation
    pub fn integer_with_range(&self, message: &str, min: i64, max: i64) -> Result<i64, PromptError> {
        self.text_with_validation(message, move |input: &String| {
            match input.parse::<i64>() {
                Ok(n) if n >= min && n <= max => Ok(()),
                Ok(n) => Err(format!("Value must be between {} and {}, got {}", min, max, n)),
                Err(_) => Err("Please enter a valid integer".to_string()),
            }
        })?
        .parse::<i64>()
        .map_err(|e| PromptError::OperationFailed {
            message: format!("Integer parsing failed: {}", e),
        })
    }
    
    /// Prompt for float input
    pub fn float(&self, message: &str) -> Result<f64, PromptError> {
        self.text_with_validation(message, |input: &String| {
            input.parse::<f64>()
                .map(|_| ())
                .map_err(|_| "Please enter a valid number".to_string())
        })?
        .parse::<f64>()
        .map_err(|e| PromptError::OperationFailed {
            message: format!("Float parsing failed: {}", e),
        })
    }
    
    /// Prompt for file path with validation
    pub fn file_path(&self, message: &str, must_exist: bool) -> Result<PathBuf, PromptError> {
        self.text_with_validation(message, move |input: &String| {
            let path = Path::new(input);
            if must_exist && !path.exists() {
                Err(format!("File does not exist: {}", input))
            } else if must_exist && !path.is_file() {
                Err(format!("Path is not a file: {}", input))
            } else {
                Ok(())
            }
        })
        .map(|s| PathBuf::from(s))
    }
    
    /// Prompt for directory path with validation
    pub fn directory_path(&self, message: &str, must_exist: bool) -> Result<PathBuf, PromptError> {
        self.text_with_validation(message, move |input: &String| {
            let path = Path::new(input);
            if must_exist && !path.exists() {
                Err(format!("Directory does not exist: {}", input))
            } else if must_exist && !path.is_dir() {
                Err(format!("Path is not a directory: {}", input))
            } else {
                Ok(())
            }
        })
        .map(|s| PathBuf::from(s))
    }
    
    /// Display an informational message
    pub fn info(&self, message: &str) {
        let _ = self.term.write_line(&format!("{} {}", 
            style("ℹ").blue().bold(), 
            message
        ));
    }
    
    /// Display a warning message
    pub fn warning(&self, message: &str) {
        let _ = self.term.write_line(&format!("{} {}", 
            style("⚠").yellow().bold(), 
            message
        ));
    }
    
    /// Display an error message
    pub fn error(&self, message: &str) {
        let _ = self.term.write_line(&format!("{} {}", 
            style("✗").red().bold(), 
            message
        ));
    }
    
    /// Display a success message
    pub fn success(&self, message: &str) {
        let _ = self.term.write_line(&format!("{} {}", 
            style("✓").green().bold(), 
            message
        ));
    }
    
    /// Clear the terminal screen
    pub fn clear(&self) {
        let _ = self.term.clear_screen();
    }
    
    /// Pause for user input (press any key to continue)
    pub fn pause(&self, message: &str) -> Result<(), PromptError> {
        let _ = self.term.write_line(message);
        let _ = self.term.read_char().map_err(PromptError::IoError)?;
        Ok(())
    }
}

/// Convenience functions using a default prompts helper
pub mod prompts {
    use super::*;
    use std::sync::OnceLock;
    
    static PROMPTS_HELPER: OnceLock<PromptsHelper> = OnceLock::new();
    
    fn get_helper() -> &'static PromptsHelper {
        PROMPTS_HELPER.get_or_init(|| PromptsHelper::new())
    }
    
    /// Prompt for text input
    pub fn text(message: &str) -> Result<String, PromptError> {
        get_helper().text(message)
    }
    
    /// Prompt for text input with default value
    pub fn text_with_default(message: &str, default: &str) -> Result<String, PromptError> {
        get_helper().text_with_default(message, default)
    }
    
    /// Prompt for password input
    pub fn password(message: &str) -> Result<String, PromptError> {
        get_helper().password(message)
    }
    
    /// Prompt for confirmation
    pub fn confirm(message: &str) -> Result<bool, PromptError> {
        get_helper().confirm(message)
    }
    
    /// Prompt for confirmation with default
    pub fn confirm_with_default(message: &str, default: bool) -> Result<bool, PromptError> {
        get_helper().confirm_with_default(message, default)
    }
    
    /// Prompt for selection
    pub fn select<T: ToString>(message: &str, items: &[T]) -> Result<usize, PromptError> {
        get_helper().select(message, items)
    }
    
    /// Prompt for multiple selections
    pub fn multiselect<T: ToString>(message: &str, items: &[T]) -> Result<Vec<usize>, PromptError> {
        get_helper().multiselect(message, items)
    }
    
    /// Prompt for integer input
    pub fn integer(message: &str) -> Result<i64, PromptError> {
        get_helper().integer(message)
    }
    
    /// Prompt for float input
    pub fn float(message: &str) -> Result<f64, PromptError> {
        get_helper().float(message)
    }
    
    /// Prompt for file path
    pub fn file_path(message: &str, must_exist: bool) -> Result<PathBuf, PromptError> {
        get_helper().file_path(message, must_exist)
    }
    
    /// Prompt for directory path
    pub fn directory_path(message: &str, must_exist: bool) -> Result<PathBuf, PromptError> {
        get_helper().directory_path(message, must_exist)
    }
    
    /// Display info message
    pub fn info(message: &str) {
        get_helper().info(message)
    }
    
    /// Display warning message
    pub fn warning(message: &str) {
        get_helper().warning(message)
    }
    
    /// Display error message
    pub fn error(message: &str) {
        get_helper().error(message)
    }
    
    /// Display success message
    pub fn success(message: &str) {
        get_helper().success(message)
    }
}

/// Completion provider for file paths
pub struct FilePathCompletion {
    current_dir: PathBuf,
}

impl FilePathCompletion {
    pub fn new() -> Self {
        Self {
            current_dir: std::env::current_dir().unwrap_or_else(|_| PathBuf::from(".")),
        }
    }
}

impl Default for FilePathCompletion {
    fn default() -> Self {
        Self::new()
    }
}

impl Completion for FilePathCompletion {
    fn get(&self, input: &str) -> Option<String> {
        let path = if input.is_empty() {
            &self.current_dir
        } else {
            Path::new(input)
        };
        
        if let Some(parent) = path.parent() {
            if let Ok(entries) = std::fs::read_dir(parent) {
                let partial_name = path.file_name()
                    .and_then(|n| n.to_str())
                    .unwrap_or("");
                
                for entry in entries.flatten() {
                    if let Some(name) = entry.file_name().to_str() {
                        if name.starts_with(partial_name) {
                            let full_path = parent.join(name);
                            return Some(full_path.to_string_lossy().to_string());
                        }
                    }
                }
            }
        }
        
        None
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_prompts_helper_creation() {
        let helper = PromptsHelper::new();
        // Just test that it creates without panicking
        assert!(true);
    }
    
    #[test]
    fn test_file_path_completion() {
        let completion = FilePathCompletion::new();
        // Test that completion can be created
        assert!(true);
    }
    
    #[test]
    fn test_prompt_error_display() {
        let error = PromptError::UserCancelled;
        assert_eq!(error.to_string(), "User cancelled the operation");
        
        let error = PromptError::InvalidInput {
            input: "test".to_string(),
        };
        assert_eq!(error.to_string(), "Invalid input: test");
    }
}