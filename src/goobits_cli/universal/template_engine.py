"""
Universal Template Engine for Goobits CLI Framework

This module provides the core engine for generating CLI implementations
across multiple programming languages using a unified template system.
"""

from abc import ABC, abstractmethod
from pathlib import Path
from typing import Dict, Any, List, Optional
import jinja2
import re
from ..schemas import GoobitsConfigSchema

# Import performance optimization components
try:
    from .performance.cache import TemplateCache
    from .performance.lazy_loader import LazyLoader
    PERFORMANCE_AVAILABLE = True
except ImportError:
    PERFORMANCE_AVAILABLE = False
    # Create placeholder classes for when performance features aren't available
    class TemplateCache:
        def __init__(self, *args, **kwargs):
            pass
    class LazyLoader:
        def __init__(self, *args, **kwargs):
            pass


class LanguageRenderer(ABC):
    """
    Abstract base class for language-specific renderers.
    
    Each supported language (Python, Node.js, TypeScript, Rust) must
    implement this interface to provide language-specific rendering logic.
    """
    
    @property
    @abstractmethod
    def language(self) -> str:
        """Return the language name (e.g., 'python', 'nodejs', 'typescript', 'rust')"""
        pass
    
    @property
    @abstractmethod
    def file_extensions(self) -> Dict[str, str]:
        """Return mapping of component types to file extensions for this language"""
        pass
    
    @abstractmethod
    def get_template_context(self, ir: Dict[str, Any]) -> Dict[str, Any]:
        """
        Transform the intermediate representation into language-specific template context.
        
        Args:
            ir: Intermediate representation generated by UniversalTemplateEngine
            
        Returns:
            Language-specific template context for rendering
        """
        pass
    
    @abstractmethod
    def get_custom_filters(self) -> Dict[str, callable]:
        """
        Return custom Jinja2 filters specific to this language.
        
        Returns:
            Dictionary mapping filter names to filter functions
        """
        pass
    
    @abstractmethod
    def render_component(self, component_name: str, template_content: str, 
                        context: Dict[str, Any]) -> str:
        """
        Render a specific component template for this language.
        
        Args:
            component_name: Name of the component being rendered
            template_content: The universal template content
            context: Language-specific template context
            
        Returns:
            Rendered template content for this language
        """
        pass
    
    @abstractmethod
    def get_output_structure(self, ir: Dict[str, Any]) -> Dict[str, str]:
        """
        Define the output file structure for this language.
        
        Args:
            ir: Intermediate representation
            
        Returns:
            Dictionary mapping component names to output file paths
        """
        pass


class ComponentRegistry:
    """
    Registry for managing universal component templates.
    
    This class handles loading, caching, and providing access to
    universal component templates from the components/ directory.
    """
    
    def __init__(self, components_dir: Optional[Path] = None):
        """
        Initialize the component registry.
        
        Args:
            components_dir: Path to components directory, defaults to built-in components
        """
        self.components_dir = components_dir or Path(__file__).parent / "components"
        self._components: Dict[str, str] = {}
        self._metadata: Dict[str, Any] = {}
        self._dependencies: Dict[str, List[str]] = {}
        self.auto_reload: bool = True
        self.validation_enabled: bool = True
        self._loader = jinja2.FileSystemLoader(str(self.components_dir))
        self._env = jinja2.Environment(loader=self._loader)
        
        # Add custom filters that templates expect
        self._env.filters['snake_case'] = self._snake_case_filter
        self._env.filters['camelCase'] = self._camel_case_filter
        
    def load_components(self) -> None:
        """Load all component templates from the components directory."""
        if not self.components_dir.exists():
            # Handle missing directory gracefully for testing
            return
            
        # Load components from current directory
        for template_file in self.components_dir.glob("*.j2"):
            component_name = template_file.stem
            self._components[component_name] = template_file.read_text(encoding='utf-8')
        
        # Load components from subdirectories
        for subdir in self.components_dir.iterdir():
            if subdir.is_dir():
                for template_file in subdir.glob("*.j2"):
                    # Use relative path as component name
                    component_name = f"{subdir.name}/{template_file.stem}"
                    self._components[component_name] = template_file.read_text(encoding='utf-8')
    
    def get_component(self, name: str) -> str:
        """
        Get a component template by name.
        
        Args:
            name: Component name (without .j2 extension)
            
        Returns:
            Template content as string
            
        Raises:
            KeyError: If component is not found
        """
        if name not in self._components:
            # Try to load component on-demand
            component_file = self.components_dir / f"{name}.j2"
            
            # Handle subdirectory components
            if '/' in name:
                parts = name.split('/')
                component_file = self.components_dir
                for part in parts[:-1]:
                    component_file = component_file / part
                component_file = component_file / f"{parts[-1]}.j2"
            
            if component_file.exists():
                self._components[name] = component_file.read_text(encoding='utf-8')
            else:
                raise KeyError(f"Component '{name}' not found")
                
        return self._components[name]
    
    def list_components(self) -> List[str]:
        """
        List all available component names.
        
        Returns:
            List of component names
        """
        return list(self._components.keys())
    
    def has_component(self, name: str) -> bool:
        """
        Check if a component exists.
        
        Args:
            name: Component name
            
        Returns:
            True if component exists, False otherwise
        """
        if name in self._components:
            return True
        
        # Check main directory
        component_file = self.components_dir / f"{name}.j2"
        if component_file.exists():
            return True
        
        # Check subdirectories
        if '/' in name:
            parts = name.split('/')
            component_file = self.components_dir
            for part in parts[:-1]:
                component_file = component_file / part
            component_file = component_file / f"{parts[-1]}.j2"
            return component_file.exists()
        
        return False
    
    def _snake_case_filter(self, name: str) -> str:
        """Convert name to snake_case."""
        # Replace hyphens with underscores
        name = name.replace("-", "_")
        
        # Convert CamelCase to snake_case
        name = re.sub(r'([A-Z]+)([A-Z][a-z])', r'\1_\2', name)
        name = re.sub(r'([a-z\d])([A-Z])', r'\1_\2', name)
        
        # Convert to lowercase and clean up
        name = name.lower()
        name = re.sub(r'_+', '_', name)  # Remove multiple underscores
        name = name.strip('_')  # Remove leading/trailing underscores
        
        return name
    
    def _camel_case_filter(self, text: str) -> str:
        """Convert text to camelCase."""
        if not text:
            return text
        words = re.split(r'[-_\s]+', text.lower())
        return words[0] + ''.join(word.capitalize() for word in words[1:])
    
    def component_exists(self, name: str) -> bool:
        """
        Check if a component exists (alias for has_component for test compatibility).
        
        Args:
            name: Component name
            
        Returns:
            True if component exists, False otherwise
        """
        return self.has_component(name)
    
    def reload_component(self, name: str) -> bool:
        """
        Reload a specific component from disk.
        
        Args:
            name: Component name to reload
            
        Returns:
            True if component was successfully reloaded, False otherwise
            
        Raises:
            KeyError: If component doesn't exist
        """
        component_file = self.components_dir / f"{name}.j2"
        
        # Handle subdirectory components
        if '/' in name:
            parts = name.split('/')
            component_file = self.components_dir
            for part in parts[:-1]:
                component_file = component_file / part
            component_file = component_file / f"{parts[-1]}.j2"
        
        if not component_file.exists():
            raise KeyError(f"Component '{name}' not found")
        
        try:
            content = component_file.read_text(encoding='utf-8')
            self._components[name] = content
            
            # Update metadata if tracking
            if name in self._metadata:
                class ComponentMetadata:
                    def __init__(self, name, path, loaded_at, size, dependencies):
                        self.name = name
                        self.path = path
                        self.loaded_at = loaded_at
                        self.size = size
                        self.dependencies = dependencies
                    
                    def is_stale(self):
                        """Check if component has been modified since loading"""
                        try:
                            current_mtime = self.path.stat().st_mtime
                            return current_mtime > self.loaded_at
                        except (OSError, AttributeError):
                            return True
                
                metadata = ComponentMetadata(
                    name=name,
                    path=component_file,
                    loaded_at=component_file.stat().st_mtime,
                    size=len(content),
                    dependencies=self._extract_template_dependencies(content)
                )
                self._metadata[name] = metadata
            
            return True
        except Exception:
            return False
    
    def clear(self) -> None:
        """
        Clear all loaded components and metadata.
        """
        self._components.clear()
        self._metadata.clear()
        self._dependencies.clear()
    
    def get_component_metadata(self, name: str) -> Optional[Any]:
        """
        Get metadata for a specific component.
        
        Args:
            name: Component name
            
        Returns:
            Component metadata object or None if not found
        """
        if name not in self._metadata and self.has_component(name):
            # Generate metadata on demand
            component_path = name.replace('/', '\\') if '/' in name else name
            component_file = self.components_dir / f"{name}.j2"
            
            # Handle subdirectory components
            if '/' in name:
                parts = name.split('/')
                component_file = self.components_dir
                for part in parts[:-1]:
                    component_file = component_file / part
                component_file = component_file / f"{parts[-1]}.j2"
            
            if component_file.exists():
                try:
                    content = self.get_component(name)
                    # Create a metadata object with name attribute and is_stale method
                    class ComponentMetadata:
                        def __init__(self, name, path, loaded_at, size, dependencies):
                            self.name = name
                            self.path = path
                            self.loaded_at = loaded_at
                            self.size = size
                            self.dependencies = dependencies
                        
                        def is_stale(self):
                            """Check if component has been modified since loading"""
                            try:
                                current_mtime = self.path.stat().st_mtime
                                return current_mtime > self.loaded_at
                            except (OSError, AttributeError):
                                return True
                    
                    metadata = ComponentMetadata(
                        name=name,
                        path=component_file,
                        loaded_at=component_file.stat().st_mtime,
                        size=len(content),
                        dependencies=self._extract_template_dependencies(content)
                    )
                    self._metadata[name] = metadata
                except Exception:
                    return None
        
        return self._metadata.get(name)
    
    def get_dependencies(self, name: str) -> List[str]:
        """
        Get dependencies for a component.
        
        Args:
            name: Component name
            
        Returns:
            List of dependency names
        """
        if name not in self._dependencies and self.has_component(name):
            try:
                content = self.get_component(name)
                self._dependencies[name] = self._extract_template_dependencies(content)
            except Exception:
                return []
        
        return self._dependencies.get(name, [])
    
    def get_component_dependencies(self, name: str) -> List[str]:
        """
        Get dependencies for a component (alias for get_dependencies).
        
        Args:
            name: Component name
            
        Returns:
            List of dependency names
        """
        return self.get_dependencies(name)
    
    def _extract_template_dependencies(self, content: str) -> List[str]:
        """
        Extract template dependencies from content.
        
        This looks for Jinja2 include/extends statements and other dependency patterns.
        
        Args:
            content: Template content
            
        Returns:
            List of dependency names
        """
        dependencies = []
        
        # Simple regex patterns for common dependency types
        import re
        
        # Look for {% include "component_name" %}
        include_pattern = r'{%\s*include\s+["\']([^"\'\']+)["\']\s*%}'
        includes = re.findall(include_pattern, content)
        dependencies.extend(includes)
        
        # Look for {% extends "component_name" %}
        extends_pattern = r'{%\s*extends\s+["\']([^"\'\']+)["\']\s*%}'
        extends = re.findall(extends_pattern, content)
        dependencies.extend(extends)
        
        # Look for custom dependency comments (multiple patterns)
        # Example: {# depends: component1, component2 #}
        comment_pattern = r'{#\s*depends:\s*([^#]+)\s*#}'
        comment_deps = re.findall(comment_pattern, content, re.IGNORECASE)
        for deps in comment_deps:
            dependencies.extend([dep.strip() for dep in deps.split(',')])
        
        # Look for Dependencies: pattern
        # Example: {# Dependencies: base.j2, utils.j2 #}
        deps_pattern = r'{#\s*Dependencies:\s*([^#]+)\s*#}'
        deps_matches = re.findall(deps_pattern, content, re.IGNORECASE)
        for deps in deps_matches:
            # Remove .j2 extensions and clean up
            clean_deps = [dep.strip().replace('.j2', '') for dep in deps.split(',')]
            dependencies.extend(clean_deps)
        
        # Remove duplicates and empty strings
        return list(filter(None, set(dependencies)))


class UniversalTemplateEngine:
    """
    Main engine for the Universal Template System.
    
    This class orchestrates the entire process of converting a Goobits
    configuration into language-specific CLI implementations using
    universal component templates with performance optimizations.
    """
    
    def __init__(self, components_dir: Optional[Path] = None, 
                 template_cache: Optional[TemplateCache] = None,
                 enable_lazy_loading: bool = True):
        """
        Initialize the universal template engine.
        
        Args:
            components_dir: Path to components directory, defaults to built-in components
            template_cache: Optional template cache for performance optimization
            enable_lazy_loading: Whether to enable lazy loading of components
        """
        self.component_registry = ComponentRegistry(components_dir)
        self.renderers: Dict[str, LanguageRenderer] = {}
        
        # Performance optimization components
        if PERFORMANCE_AVAILABLE and template_cache is not None:
            self.template_cache = template_cache
            self.performance_enabled = True
        else:
            self.template_cache = None
            self.performance_enabled = False
        
        # Lazy loading setup
        if enable_lazy_loading and PERFORMANCE_AVAILABLE:
            self.lazy_loader = LazyLoader()
            self._register_lazy_components()
        else:
            self.lazy_loader = None
            # Load components immediately if no lazy loading
            self.component_registry.load_components()
    
    def _register_lazy_components(self):
        """Register components for lazy loading"""
        if not self.lazy_loader:
            return
        
        # Register component loading
        self.lazy_loader.register(
            "component_registry",
            lambda: self._load_component_registry(),
            dependencies=[]
        )
        
        # Register renderer components
        for language in ["python", "nodejs", "typescript", "rust"]:
            self.lazy_loader.register(
                f"{language}_renderer",
                lambda lang=language: self._create_renderer(lang),
                dependencies=["component_registry"]
            )
    
    def _load_component_registry(self):
        """Load component registry (for lazy loading)"""
        self.component_registry.load_components()
        return self.component_registry
    
    def _create_renderer(self, language: str):
        """Create a renderer for the specified language (for lazy loading)"""
        # This would normally import and create the appropriate renderer
        # For now, return a placeholder
        return None
    
    def register_renderer(self, renderer: LanguageRenderer) -> None:
        """
        Register a language-specific renderer.
        
        Args:
            renderer: Language renderer implementation
            
        Raises:
            ValueError: If renderer is None or invalid
        """
        if renderer is None:
            raise ValueError("Renderer cannot be None")
        
        if not isinstance(renderer, LanguageRenderer):
            raise ValueError(f"Renderer must implement LanguageRenderer interface, got {type(renderer)}")
        
        language = renderer.language
        if not language:
            raise ValueError("Renderer must provide a non-empty language name")
        
        self.renderers[language] = renderer
        print(f"ðŸ“ Registered {language} renderer for Universal Template System")
    
    def get_renderer(self, language: str) -> LanguageRenderer:
        """
        Get a registered language renderer.
        
        Args:
            language: Target programming language
            
        Returns:
            Language renderer implementation
            
        Raises:
            ValueError: If no renderer is registered for the language
        """
        if language not in self.renderers:
            available = list(self.renderers.keys())
            raise ValueError(
                f"No renderer registered for language '{language}'. "
                f"Available renderers: {available if available else 'none'}"
            )
        
        return self.renderers[language]
    
    def create_intermediate_representation(self, config: GoobitsConfigSchema) -> Dict[str, Any]:
        """
        Create intermediate representation from Goobits configuration.
        
        This is a public interface for the internal _build_intermediate_representation method.
        
        Args:
            config: Validated Goobits configuration
            
        Returns:
            Intermediate representation as dictionary
            
        Raises:
            ValueError: If config is None or invalid
        """
        if config is None:
            raise ValueError("Configuration cannot be None")
        
        return self._build_intermediate_representation(config)
    
    def generate_cli(self, config: GoobitsConfigSchema, language: str, 
                    output_dir: Path) -> Dict[str, str]:
        """
        Generate a complete CLI implementation for the specified language.
        
        Args:
            config: Validated Goobits configuration
            language: Target programming language
            output_dir: Directory to write generated files
            
        Returns:
            Dictionary mapping output file paths to generated content
            
        Raises:
            ValueError: If language renderer is not registered or config is invalid
            FileNotFoundError: If component templates are missing
            RuntimeError: If generation fails
        """
        if not config:
            raise ValueError("Configuration cannot be None or empty")
        
        if not language:
            raise ValueError("Language cannot be None or empty")
        
        if language not in self.renderers:
            available = list(self.renderers.keys())
            raise ValueError(
                f"No renderer registered for language '{language}'. "
                f"Available renderers: {available if available else 'none'}"
            )
        
        renderer = self.renderers[language]
        
        print(f"ðŸš€ Generating {language} CLI using Universal Template System")
        
        # Use lazy loading if available
        if self.lazy_loader:
            # Ensure component registry is loaded
            self.lazy_loader.get_component("component_registry")
        
        # Build intermediate representation (with caching if available)
        ir_cache_key = f"ir_{hash(str(config.model_dump()))}"
        
        if self.performance_enabled and self.template_cache:
            # Try to get cached IR
            cached_ir = self.template_cache._cache.get(ir_cache_key)
            if cached_ir:
                ir = cached_ir
            else:
                ir = self._build_intermediate_representation(config)
                # Cache the IR for future use
                self.template_cache._cache.put(ir_cache_key, ir, ttl=300)  # 5 min cache
        else:
            ir = self._build_intermediate_representation(config)
        
        # Get language-specific context
        context = renderer.get_template_context(ir)
        
        # Get output structure
        output_structure = renderer.get_output_structure(ir)
        
        # Render all components with error handling and performance optimization
        generated_files = {}
        failed_components = []
        
        for component_name, output_path in output_structure.items():
            try:
                if self.component_registry.has_component(component_name):
                    # Use cached template if available
                    if self.performance_enabled and self.template_cache:
                        template_path = self.component_registry.components_dir / f"{component_name}.j2"
                        if template_path.exists():
                            rendered_content = self.template_cache.render_template(
                                template_path, context
                            )
                            if rendered_content is not None:
                                full_output_path = output_dir / output_path
                                generated_files[str(full_output_path)] = rendered_content
                                continue
                    
                    # Fallback to regular rendering
                    template_content = self.component_registry.get_component(component_name)
                    rendered_content = renderer.render_component(
                        component_name, template_content, context
                    )
                    
                    full_output_path = output_dir / output_path
                    generated_files[str(full_output_path)] = rendered_content
                else:
                    print(f"âš ï¸  Component '{component_name}' not found, skipping")
                    failed_components.append(component_name)
                    
            except Exception as e:
                print(f"âŒ Failed to render component '{component_name}': {e}")
                failed_components.append(component_name)
        
        # Report generation results
        print(f"âœ… Generated {len(generated_files)} files for {language}")
        if failed_components:
            print(f"âš ï¸  Skipped {len(failed_components)} components: {', '.join(failed_components)}")
        
        if not generated_files:
            raise RuntimeError(
                f"No files were successfully generated for {language}. "
                f"Check that component templates exist and are valid."
            )
        
        return generated_files
    
    def _build_intermediate_representation(self, config: GoobitsConfigSchema) -> Dict[str, Any]:
        """
        Convert Goobits configuration to intermediate representation.
        
        This method extracts and normalizes all information from the configuration
        into a language-agnostic format that can be consumed by any renderer.
        
        Args:
            config: Validated Goobits configuration
            
        Returns:
            Intermediate representation as dictionary
        """
        # Extract CLI schema information
        cli_schema = self._extract_config_schema(config.cli)
        
        ir = {
            "project": {
                "name": getattr(config, 'display_name', config.command_name),
                "description": config.description,
                "version": getattr(config.cli, 'version', '1.0.0') if config.cli else '1.0.0',
                "author": getattr(config, "author", ""),
                "license": getattr(config, "license", ""),
                "package_name": config.package_name,
                "command_name": config.command_name,
            },
            "cli": cli_schema,
            "installation": {
                "pypi_name": getattr(config.installation, "pypi_name", config.package_name),
                "development_path": getattr(config.installation, "development_path", "."),
                "extras": getattr(config.installation, "extras", {}).model_dump() if hasattr(getattr(config.installation, "extras", {}), 'model_dump') else getattr(config.installation, "extras", {}).dict() if hasattr(getattr(config.installation, "extras", {}), 'dict') else {},
            },
            "dependencies": self._extract_dependencies(config),
            "metadata": {
                "generated_at": "{{ timestamp }}",  # Will be replaced during rendering
                "generator_version": "{{ version }}",  # Will be replaced during rendering
                "source_config": config.model_dump(),
            }
        }
        
        return ir
    
    def _extract_config_schema(self, cli_config: Any) -> Dict[str, Any]:
        """
        Extract normalized CLI schema from configuration.
        
        Args:
            cli_config: CLI configuration section
            
        Returns:
            Normalized CLI schema
        """
        schema = {
            "root_command": {
                "name": cli_config.name,
                "description": getattr(cli_config, 'description', cli_config.tagline),
                "version": getattr(cli_config, 'version', '1.0.0'),
                "arguments": [],
                "options": [],
                "subcommands": [],
            },
            "commands": {},
            "global_options": [],
            "completion": {
                "enabled": True,  # Default to enabled
                "shells": ["bash", "zsh", "fish"],
            }
        }
        
        # Extract arguments (CLI root rarely has arguments in current schema)
        if hasattr(cli_config, 'args') and cli_config.args:
            for arg in cli_config.args:
                schema["root_command"]["arguments"].append({
                    "name": arg.name,
                    "description": arg.desc,
                    "type": getattr(arg, "type", "string"),
                    "required": getattr(arg, "required", True),
                    "multiple": getattr(arg, "nargs", None) == "*",
                })
        
        # Extract options
        if hasattr(cli_config, 'options') and cli_config.options:
            for opt in cli_config.options:
                option_data = {
                    "name": opt.name,
                    "short": getattr(opt, "short", None),
                    "description": opt.desc,
                    "type": getattr(opt, "type", "str"),
                    "default": getattr(opt, "default", None),
                    "required": False,  # Global options typically not required
                    "multiple": getattr(opt, "multiple", False),
                }
                schema["root_command"]["options"].append(option_data)
        
        # Extract subcommands
        if hasattr(cli_config, 'commands') and cli_config.commands:
            for cmd_name, cmd in cli_config.commands.items():
                command_data = {
                    "name": cmd_name,
                    "description": cmd.desc,  # Note: CLISchema uses 'desc' not 'description'
                    "arguments": [],
                    "options": [],
                    "subcommands": [],
                    "hook_name": f"on_{cmd_name.replace('-', '_')}",
                }
                
                # Extract command arguments
                if hasattr(cmd, 'args') and cmd.args:
                    for arg in cmd.args:
                        command_data["arguments"].append({
                            "name": arg.name,
                            "description": arg.desc,  # Note: ArgumentSchema uses 'desc'
                            "type": getattr(arg, "type", "string"),
                            "required": getattr(arg, "required", True),
                            "multiple": getattr(arg, "nargs", None) == "*",
                        })
                
                # Extract command options
                if hasattr(cmd, 'options') and cmd.options:
                    for opt in cmd.options:
                        command_data["options"].append({
                            "name": opt.name,
                            "short": getattr(opt, "short", None),
                            "description": opt.desc,  # Note: OptionSchema uses 'desc'
                            "type": getattr(opt, "type", "str"),
                            "default": getattr(opt, "default", None),
                            "required": False,  # Options are typically not required
                            "multiple": getattr(opt, "multiple", False),
                        })
                
                # Handle nested subcommands recursively
                if hasattr(cmd, 'subcommands') and cmd.subcommands:
                    command_data["subcommands"] = self._extract_subcommands_dict(cmd.subcommands)
                
                schema["root_command"]["subcommands"].append(command_data)
                schema["commands"][cmd_name] = command_data
        
        return schema
    
    def _extract_subcommands_dict(self, commands: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Extract subcommands from dictionary format (used by CLISchema).
        
        Args:
            commands: Dictionary of command configurations
            
        Returns:
            List of normalized subcommand schemas
        """
        subcommands = []
        for cmd_name, cmd in commands.items():
            command_data = {
                "name": cmd_name,
                "description": cmd.desc,
                "arguments": [],
                "options": [],
                "subcommands": [],
                "hook_name": f"on_{cmd_name.replace('-', '_')}",
            }
            
            # Extract arguments and options similar to main commands
            if hasattr(cmd, 'args') and cmd.args:
                for arg in cmd.args:
                    command_data["arguments"].append({
                        "name": arg.name,
                        "description": arg.desc,
                        "type": getattr(arg, "type", "string"),
                        "required": getattr(arg, "required", True),
                        "multiple": getattr(arg, "nargs", None) == "*",
                    })
            
            if hasattr(cmd, 'options') and cmd.options:
                for opt in cmd.options:
                    command_data["options"].append({
                        "name": opt.name,
                        "short": getattr(opt, "short", None),
                        "description": opt.desc,
                        "type": getattr(opt, "type", "str"),
                        "default": getattr(opt, "default", None),
                        "required": False,
                        "multiple": getattr(opt, "multiple", False),
                    })
            
            # Recursively handle nested subcommands
            if hasattr(cmd, 'subcommands') and cmd.subcommands:
                command_data["subcommands"] = self._extract_subcommands_dict(cmd.subcommands)
            
            subcommands.append(command_data)
        
        return subcommands
    
    def _extract_subcommands(self, commands: List[Any]) -> List[Dict[str, Any]]:
        """
        Recursively extract subcommands.
        
        Args:
            commands: List of command configurations
            
        Returns:
            List of normalized subcommand schemas
        """
        subcommands = []
        for cmd in commands:
            command_data = {
                "name": cmd.name,
                "description": cmd.description,
                "arguments": [],
                "options": [],
                "subcommands": [],
                "hook_name": f"on_{cmd.name.replace('-', '_')}",
            }
            
            # Extract arguments and options similar to main commands
            if hasattr(cmd, 'arguments') and cmd.arguments:
                for arg in cmd.arguments:
                    command_data["arguments"].append({
                        "name": arg.name,
                        "description": arg.description,
                        "type": getattr(arg, "type", "string"),
                        "required": getattr(arg, "required", True),
                        "multiple": getattr(arg, "multiple", False),
                    })
            
            if hasattr(cmd, 'options') and cmd.options:
                for opt in cmd.options:
                    command_data["options"].append({
                        "name": opt.name,
                        "short": getattr(opt, "short", None),
                        "description": opt.description,
                        "type": getattr(opt, "type", "string"),
                        "default": getattr(opt, "default", None),
                        "required": getattr(opt, "required", False),
                        "multiple": getattr(opt, "multiple", False),
                    })
            
            # Recursively handle nested subcommands
            if hasattr(cmd, 'commands') and cmd.commands:
                command_data["subcommands"] = self._extract_subcommands(cmd.commands)
            
            subcommands.append(command_data)
        
        return subcommands
    
    def _extract_dependencies(self, config: GoobitsConfigSchema) -> Dict[str, List[str]]:
        """
        Extract and normalize dependency information.
        
        Args:
            config: Goobits configuration
            
        Returns:
            Normalized dependencies by type
        """
        dependencies = {
            "python": [],
            "system": [],
            "npm": [],
            "rust": [],
        }
        
        # Extract from dependencies section
        if hasattr(config, 'dependencies') and config.dependencies:
            # Handle required dependencies
            if config.dependencies.required:
                for dep in config.dependencies.required:
                    if hasattr(dep, 'name'):  # DependencyItem object
                        dependencies["python"].append(dep.name)
                    else:  # String
                        dependencies["python"].append(dep)
            
            # Handle optional dependencies  
            if config.dependencies.optional:
                for dep in config.dependencies.optional:
                    if hasattr(dep, 'name'):  # DependencyItem object
                        dependencies["python"].append(dep.name)
                    else:  # String
                        dependencies["python"].append(dep)
        
        # Extract from installation extras
        if hasattr(config, 'installation') and config.installation:
            extras = getattr(config.installation, 'extras', {})
            if isinstance(extras, dict):
                dependencies["python"].extend(extras.get("python", []))
                dependencies["system"].extend(extras.get("apt", []))
                dependencies["npm"].extend(extras.get("npm", []))
                dependencies["rust"].extend(extras.get("cargo", []))
        
        # Extract Rust crates
        if hasattr(config, 'rust_crates') and config.rust_crates:
            dependencies["rust"].extend(config.rust_crates.keys())
        
        return dependencies