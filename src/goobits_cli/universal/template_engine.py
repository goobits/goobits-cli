"""

Universal Template Engine for Goobits CLI Framework



This module provides the core engine for generating CLI implementations

across multiple programming languages using a unified template system.

"""



from abc import ABC, abstractmethod

from pathlib import Path

from typing import Dict, Any, List, Optional

import jinja2


import time

from .component_registry import ComponentRegistry
from .command_hierarchy import CommandFlattener, HierarchyBuilder

# Lazy import for heavy Pydantic schemas
_config_schema = None

def _get_config_schema():
    """Lazy load GoobitsConfigSchema to avoid Pydantic import overhead."""
    global _config_schema
    if _config_schema is None:
        from ..schemas import GoobitsConfigSchema
        _config_schema = GoobitsConfigSchema
    return _config_schema


# Import shared _safe_to_dict function
from ..generators import _safe_to_dict


def _safe_get_attr(obj: Any, attr: str, default: Any = "") -> Any:
    """
    Safely get an attribute from an object or dict.
    
    This handles cases where the object might be:
    - A Pydantic model with attributes
    - A plain dictionary with keys
    - None or other types
    
    Args:
        obj: Object to get attribute from
        attr: Attribute name to get
        default: Default value if attribute not found
        
    Returns:
        Attribute value or default
    """
    if obj is None:
        return default
    
    # If it's a dictionary, use dict access
    if isinstance(obj, dict):
        return obj.get(attr, default)
    
    # If it's an object with attributes, use getattr
    if hasattr(obj, attr):
        return getattr(obj, attr, default)
    
    # If it's a dict-like object that doesn't respond to hasattr properly
    try:
        return obj[attr] if attr in obj else default
    except (TypeError, KeyError):
        pass
    
    return default



# Import performance optimization components

try:

    from .performance.cache import TemplateCache

    from .performance.lazy_loader import LazyLoader

    PERFORMANCE_AVAILABLE = True

except ImportError:

    PERFORMANCE_AVAILABLE = False

    # Create placeholder classes for when performance features aren't available

    class TemplateCache:

        def __init__(self, *args, **kwargs):

            pass

    class LazyLoader:

        def __init__(self, *args, **kwargs):

            pass





class LanguageRenderer(ABC):

    """

    Abstract base class for language-specific renderers.

    

    Each supported language (Python, Node.js, TypeScript, Rust) must

    implement this interface to provide language-specific rendering logic.

    """

    

    @property

    @abstractmethod

    def language(self) -> str:

        """Return the language name (e.g., 'python', 'nodejs', 'typescript', 'rust')"""

        pass

    

    @property

    @abstractmethod

    def file_extensions(self) -> Dict[str, str]:

        """Return mapping of component types to file extensions for this language"""

        pass

    

    @abstractmethod

    def get_template_context(self, ir: Dict[str, Any]) -> Dict[str, Any]:

        """

        Transform the intermediate representation into language-specific template context.

        

        Args:

            ir: Intermediate representation generated by UniversalTemplateEngine

            

        Returns:

            Language-specific template context for rendering

        """

        pass

    

    @abstractmethod

    def get_custom_filters(self) -> Dict[str, callable]:

        """

        Return custom Jinja2 filters specific to this language.

        

        Returns:

            Dictionary mapping filter names to filter functions

        """

        pass

    def _set_language_context(self, ir: Dict[str, Any]) -> Dict[str, Any]:
        """
        Helper method to set language context from IR, ensuring consistent language setting.
        
        Args:
            ir: Intermediate representation dictionary
            
        Returns:
            Context dictionary with language field set to this renderer's language
        """
        context = ir.copy()
        context['language'] = self.language
        return context

    

    @abstractmethod

    def render_component(self, component_name: str, template_content: str, 

                        context: Dict[str, Any]) -> str:

        """

        Render a specific component template for this language.

        

        Args:

            component_name: Name of the component being rendered

            template_content: The universal template content

            context: Language-specific template context

            

        Returns:

            Rendered template content for this language

        """

        pass

    

    @abstractmethod

    def get_output_structure(self, ir: Dict[str, Any]) -> Dict[str, str]:

        """

        Define the output file structure for this language.

        

        Args:

            ir: Intermediate representation

            

        Returns:

            Dictionary mapping component names to output file paths

        """

        pass










class UniversalTemplateEngine:

    """

    Main engine for the Universal Template System.

    

    This class orchestrates the entire process of converting a Goobits

    configuration into language-specific CLI implementations using

    universal component templates with performance optimizations.

    """

    

    def __init__(self, template_dir: Optional[Path] = None, 

                 template_cache: Optional[TemplateCache] = None,

                 enable_lazy_loading: bool = True,

                 test_mode: bool = False):

        """

        Initialize the universal template engine.

        

        Args:

            template_dir: Path to templates directory (alias for components_dir for backward compatibility)

            template_cache: Optional template cache for performance optimization

            enable_lazy_loading: Whether to enable lazy loading of components

            test_mode: When True, disables performance optimizations and caching for testing

        """

        # Validate template directory exists

        if template_dir is not None and not template_dir.exists():

            raise ValueError(f"Template directory does not exist: {template_dir}")

        

        # For backward compatibility, support both template_dir and components_dir

        self.template_dir = template_dir

        self.component_registry = ComponentRegistry(template_dir)

        self.renderers: Dict[str, LanguageRenderer] = {}

        

        # Lazy initialization for Jinja environment
        self._jinja_env = None
        self._jinja_initialized = False

        # Store test mode for cache bypass

        self.test_mode = test_mode

        

        # Performance optimization components

        if PERFORMANCE_AVAILABLE and not test_mode:

            if template_cache is not None:

                self.template_cache = template_cache

            else:

                # Create default template cache when performance is available

                self.template_cache = TemplateCache()

            self.performance_enabled = True

        else:

            self.template_cache = None

            self.performance_enabled = False

        

        # Lazy loading setup

        if enable_lazy_loading and PERFORMANCE_AVAILABLE:

            self.lazy_loader = LazyLoader()

            self._register_lazy_components()

        else:

            self.lazy_loader = None

            # Load components immediately if no lazy loading

            self.component_registry.load_components()

    def _get_jinja_env(self):
        """Lazy load Jinja2 environment to avoid import overhead."""
        if not self._jinja_initialized:
            if self.template_dir:
                self._jinja_env = jinja2.Environment(
                    loader=jinja2.FileSystemLoader(str(self.template_dir), encoding='utf-8'),
                    autoescape=False,
                    trim_blocks=True,
                    lstrip_blocks=True,
                    # Enable optimized Unicode handling
                    finalize=lambda x: x if x is not None else ''
                )
            else:
                self._jinja_env = jinja2.Environment(
                    autoescape=False,
                    trim_blocks=True,
                    lstrip_blocks=True,
                    # Enable optimized Unicode handling
                    finalize=lambda x: x if x is not None else ''
                )
            self._jinja_initialized = True
        return self._jinja_env

    @property
    def jinja_env(self):
        """Get the Jinja2 environment, initializing it if necessary."""
        return self._get_jinja_env()

    def _register_lazy_components(self):

        """Register components for lazy loading"""

        if not self.lazy_loader:

            return

        

        # Register component loading

        self.lazy_loader.register(

            "component_registry",

            lambda: self._load_component_registry(),

            dependencies=[]

        )

        

        # Register renderer components

        for language in ["python", "nodejs", "typescript", "rust"]:

            self.lazy_loader.register(

                f"{language}_renderer",

                lambda lang=language: self._create_renderer(lang),

                dependencies=["component_registry"]

            )

    

    def _load_component_registry(self):

        """Load component registry (for lazy loading)"""

        self.component_registry.load_components()

        return self.component_registry

    

    def _create_renderer(self, language: str):

        """Create a renderer for the specified language (for lazy loading)"""

        # This would normally import and create the appropriate renderer

        # For now, return a placeholder

        return None

    

    def register_renderer(self, language: str, renderer: LanguageRenderer) -> None:

        """

        Register a language-specific renderer.

        

        Args:

            language: Language name (for backward compatibility with test signature)

            renderer: Language renderer implementation

            

        Raises:

            ValueError: If renderer is None or invalid

        """

        if renderer is None:

            raise ValueError("Renderer cannot be None")

        

        if not isinstance(renderer, LanguageRenderer):

            raise ValueError(f"Renderer must implement LanguageRenderer interface, got {type(renderer)}")

        

        # Use the provided language or fall back to renderer's language

        lang_name = language or renderer.language

        if not lang_name:

            raise ValueError("Language name must be provided")

        

        self.renderers[lang_name] = renderer

        # Registered renderer (debug info only, not user-facing)

    

    def get_renderer(self, language: str) -> LanguageRenderer:

        """

        Get a registered language renderer.

        

        Args:

            language: Target programming language

            

        Returns:

            Language renderer implementation

            

        Raises:

            ValueError: If no renderer is registered for the language

        """

        if language not in self.renderers:

            available = list(self.renderers.keys())

            raise ValueError(

                f"No renderer registered for language '{language}'. "

                f"Available renderers: {available if available else 'none'}"

            )

        

        return self.renderers[language]

    

    def create_intermediate_representation(self, config, config_filename: str = "goobits.yaml") -> Dict[str, Any]:

        """

        Create intermediate representation from Goobits configuration.

        

        This is a public interface for the internal _build_intermediate_representation method.

        

        Args:

            config: Validated Goobits configuration

            config_filename: Name of the configuration file (for source attribution)

            

        Returns:

            Intermediate representation as dictionary

            

        Raises:

            ValueError: If config is None or invalid

        """

        if config is None:

            raise ValueError("Configuration cannot be None")

        

        return self._build_intermediate_representation(config, config_filename)

    

    def render(self, config, language: str) -> Dict[str, Any]:

        """

        Render a configuration using the specified language renderer.

        

        Args:

            config: Validated Goobits configuration

            language: Target programming language

            

        Returns:

            Dictionary containing rendered files and metadata

            

        Raises:

            ValueError: If language renderer is not registered

        """

        start_time = time.time()

        

        if language not in self.renderers:

            available = list(self.renderers.keys())

            raise ValueError(

                f"No renderer registered for language '{language}'. "

                f"Available renderers: {available if available else 'none'}"

            )

        

        renderer = self.renderers[language]

        

        # Build intermediate representation

        ir = self.create_intermediate_representation(config)

        

        # Get language-specific context

        context = renderer.get_template_context(ir)

        

        # Get output structure from renderer

        output_structure = renderer.get_output_structure(ir)

        

        # Actually render components using templates

        rendered_files = {}

        template_count = 0

        

        for component_name, output_filename in output_structure.items():

            try:

                # Check if component exists

                if self.component_registry.has_component(component_name):

                    # Get template content

                    template_content = self.component_registry.get_component(component_name)

                    

                    # Render using the renderer

                    rendered_content = renderer.render_component(

                        component_name, template_content, context

                    )

                    

                    rendered_files[output_filename] = rendered_content

                    template_count += 1

                else:

                    # Component not found - use placeholder or skip

                    rendered_files[output_filename] = f"// Component '{component_name}' not found"

                    

            except Exception as e:

                # Handle template rendering errors gracefully

                rendered_files[output_filename] = f"// Error rendering {component_name}: {e}"

        

        render_time = time.time() - start_time

        

        result = {

            "files": rendered_files,

            "metadata": {

                "language": language,

                "template_count": template_count,

                "render_time": render_time

            }

        }

        

        return result

    

    def generate_cli(self, config, language: str, 

                    output_dir: Path, consolidate: bool = False, 
                    config_filename: str = "goobits.yaml") -> Dict[str, str]:

        """

        Generate a complete CLI implementation for the specified language.

        

        Args:

            config: Validated Goobits configuration

            language: Target programming language

            output_dir: Directory to write generated files

            consolidate: Whether to consolidate multiple files into single file

            config_filename: Name of the configuration file (for source attribution)

            

        Returns:

            Dictionary mapping output file paths to generated content

            

        Raises:

            ValueError: If language renderer is not registered or config is invalid

            FileNotFoundError: If component templates are missing

            RuntimeError: If generation fails

        """

        if not config:

            raise ValueError("Configuration cannot be None or empty")

        

        if not language:

            raise ValueError("Language cannot be None or empty")

        

        if language not in self.renderers:

            available = list(self.renderers.keys())

            raise ValueError(

                f"No renderer registered for language '{language}'. "

                f"Available renderers: {available if available else 'none'}"

            )

        

        renderer = self.renderers[language]

        

        import typer
        typer.echo(f"ðŸš€ Generating {language} CLI using Universal Template System")

        

        # Use lazy loading if available

        if self.lazy_loader:

            # Ensure component registry is loaded

            self.lazy_loader.get_component("component_registry")

        

        # Build intermediate representation (with caching if available)

        config_dict = _safe_to_dict(config)
        ir_cache_key = f"ir_{hash(str(config_dict))}"

        

        if self.performance_enabled and self.template_cache and not self.test_mode:

            # Try to get cached IR

            cached_ir = self.template_cache._cache.get(ir_cache_key)

            if cached_ir:

                ir = cached_ir

            else:

                ir = self._build_intermediate_representation(config, config_filename)

                # Cache the IR for future use

                self.template_cache._cache.put(ir_cache_key, ir, ttl=300)  # 5 min cache

        else:

            ir = self._build_intermediate_representation(config, config_filename)

        

        # Get language-specific context

        context = renderer.get_template_context(ir)

        # Add consolidation mode flag to context
        context['consolidation_mode'] = consolidate

        

        # Get output structure

        output_structure = renderer.get_output_structure(ir)

        

        # Render all components with error handling and performance optimization

        generated_files = {}

        failed_components = []

        

        for component_name, output_path in output_structure.items():

            try:

                if self.component_registry.has_component(component_name):

                    # Use cached template if available and not in test mode

                    if self.performance_enabled and self.template_cache and not self.test_mode:

                        template_path = self.component_registry.components_dir / f"{component_name}.j2"

                        if template_path.exists():

                            rendered_content = self.template_cache.render_template(

                                template_path, context

                            )

                            if rendered_content is not None:

                                full_output_path = output_dir / output_path

                                generated_files[str(full_output_path)] = rendered_content

                                continue

                    

                    # Fallback to regular rendering

                    template_content = self.component_registry.get_component(component_name)

                    rendered_content = renderer.render_component(

                        component_name, template_content, context

                    )

                    

                    full_output_path = output_dir / output_path

                    generated_files[str(full_output_path)] = rendered_content

                else:

                    typer.echo(f"âš ï¸  Component '{component_name}' not found, skipping", err=True)

                    failed_components.append(component_name)

                    

            except Exception as e:

                typer.echo(f"âŒ Failed to render component '{component_name}': {e}", err=True)

                failed_components.append(component_name)

        

        # Report generation results

        typer.echo(f"âœ… Generated {len(generated_files)} files for {language}")

        if failed_components:

            typer.echo(f"âš ï¸  Skipped {len(failed_components)} components: {', '.join(failed_components)}", err=True)

        

        # Only raise error if all components failed AND we expected at least some components

        # If all components are simply missing (not found), treat as graceful handling

        if not generated_files and failed_components and len(failed_components) == len(output_structure):

            # All requested components were missing/failed - this may be intentional for testing

            typer.echo(f"â„¹ï¸  No files generated - all {len(failed_components)} requested components unavailable", err=True)

        elif not generated_files and failed_components:

            # Some components failed with errors (not just missing)

            raise RuntimeError(

                f"No files were successfully generated for {language}. "

                f"Check that component templates exist and are valid."

            )

        

        # Apply consolidation if requested and supported
        if consolidate and language == "python" and generated_files:
            # Check if renderer supports consolidation
            if hasattr(renderer, 'consolidate_files'):
                import typer
                typer.echo("ðŸ”„ Consolidating files using Pinliner...")
                try:
                    generated_files = renderer.consolidate_files(generated_files, output_dir)
                    typer.echo(f"âœ… Consolidation completed: {len(generated_files)} files total")
                except Exception as e:
                    typer.echo(f"âš ï¸  Consolidation failed: {e}", err=True)
                    # Continue with original files if consolidation fails
            else:
                typer.echo(f"âš ï¸  Consolidation not supported for {language}", err=True)
        
        return generated_files

    

    def _build_intermediate_representation(self, config, config_filename: str = "goobits.yaml") -> Dict[str, Any]:

        """

        Convert Goobits configuration to intermediate representation.

        

        This method extracts and normalizes all information from the configuration

        into a language-agnostic format that can be consumed by any renderer.

        

        Args:

            config: Validated Goobits configuration

            

        Returns:

            Intermediate representation as dictionary

        """

        # Extract CLI schema information

        # Convert config to dict for safe access
        config_dict = _safe_to_dict(config)
        
        cli_config = config_dict.get('cli', {})
        cli_schema = self._extract_config_schema(cli_config)

        

        ir = {

            "project": {

                "name": _safe_get_attr(config, 'display_name', _safe_get_attr(config, 'command_name')),

                "description": _safe_get_attr(config, "description"),

                "version": (lambda v: v if v is not None else '1.0.0')(_safe_get_attr(_safe_get_attr(config, 'cli', {}), 'version', '1.0.0')) if _safe_get_attr(config, 'cli') else '1.0.0',

                "author": _safe_get_attr(config, "author"),

                "license": _safe_get_attr(config, "license"),

                "package_name": _safe_get_attr(config, "package_name"),

                "command_name": _safe_get_attr(config, "command_name"),

                "cli_output_path": _safe_get_attr(config, "cli_output_path"),

                "cli_hooks": _safe_get_attr(config, "cli_hooks"),

                "hooks_path": _safe_get_attr(config, "hooks_path"),

            },

            "cli": cli_schema,

            "installation": {

                "pypi_name": _safe_get_attr(_safe_get_attr(config, "installation", {}), "pypi_name", _safe_get_attr(config, "package_name")),

                "development_path": _safe_get_attr(_safe_get_attr(config, "installation", {}), "development_path", "."),

                "extras": _safe_to_dict(_safe_get_attr(_safe_get_attr(config, "installation", {}), "extras", {})),

            },

            "dependencies": self._extract_dependencies(config),

            "metadata": {

                "generated_at": "{{ timestamp }}",  # Will be replaced during rendering

                "generator_version": "{{ version }}",  # Will be replaced during rendering

                "source_config": _safe_to_dict(config),

                "config_filename": config_filename,

            }

        }

        

        return ir

    

    def _extract_config_schema(self, cli_config: Any) -> Dict[str, Any]:

        """

        Extract normalized CLI schema from configuration.

        

        Args:

            cli_config: CLI configuration section

            

        Returns:

            Normalized CLI schema

        """
        # Convert cli_config to dict for safe access
        cli_dict = _safe_to_dict(cli_config)

        schema = {

            "root_command": {

                "name": cli_dict.get('name', ''),

                "description": cli_dict.get('description', cli_dict.get('tagline', '')),

                "version": (lambda v: v if v is not None else '1.0.0')(cli_dict.get('version', '1.0.0')),

                "arguments": [],

                "options": [],

                "subcommands": [],

            },

            "commands": {},

            "global_options": [],

            "completion": {

                "enabled": True,  # Default to enabled

                "shells": ["bash", "zsh", "fish"],

            },

            # Preserve custom help sections
            "tagline": _safe_get_attr(cli_config, 'tagline', _safe_get_attr(cli_config, 'description', 'No description')),
            "description": _safe_get_attr(cli_config, 'description', 'No description'),
            "header_sections": _safe_get_attr(cli_config, 'header_sections', []),
            "footer_note": _safe_get_attr(cli_config, 'footer_note'),
            "version": _safe_get_attr(cli_config, 'version', '1.0.0'),

        }

        

        # Extract arguments (CLI root rarely has arguments in current schema)

        if 'args' in cli_dict and cli_dict['args']:

            for arg in cli_dict['args']:

                schema["root_command"]["arguments"].append({

                    "name": _safe_get_attr(arg, "name"),

                    "description": _safe_get_attr(arg, "desc"),

                    "type": _safe_get_attr(arg, "type", "string"),

                    "required": _safe_get_attr(arg, "required", True),

                    "multiple": _safe_get_attr(arg, "nargs") == "*",

                    "nargs": _safe_get_attr(arg, "nargs"),

                })

        

        # Extract options

        if 'options' in cli_dict and cli_dict['options']:

            for opt in cli_dict['options']:

                option_data = {

                    "name": _safe_get_attr(opt, "name"),

                    "short": _safe_get_attr(opt, "short"),

                    "description": _safe_get_attr(opt, "desc"),

                    "type": _safe_get_attr(opt, "type", "str"),

                    "default": _safe_get_attr(opt, "default"),

                    "required": False,  # Global options typically not required

                    "multiple": _safe_get_attr(opt, "multiple", False),

                }

                schema["root_command"]["options"].append(option_data)

        

        # Extract subcommands

        if 'commands' in cli_dict and cli_dict['commands']:
            commands = cli_dict['commands']
            
            if isinstance(commands, dict):
                # Old format: {"hello": {...}}
                for cmd_name, cmd in commands.items():
                    cmd_dict = _safe_to_dict(cmd)
                    
                    command_data = {
                        "name": cmd_name,
                        "description": cmd_dict.get('description', cmd_dict.get('desc', '')),
                        "arguments": [],
                        "options": [],
                        "subcommands": [],
                        "hook_name": f"on_{cmd_name.replace('-', '_')}",
                    }
                    
                    # Extract command arguments
                    if 'args' in cmd_dict and cmd_dict['args']:
                        for arg in cmd_dict['args']:
                            arg_dict = _safe_to_dict(arg)
                            command_data["arguments"].append({
                                "name": arg_dict.get("name", ""),
                                "description": arg_dict.get("desc", arg_dict.get("description", "")),
                                "type": arg_dict.get("type", "string"),
                                "required": arg_dict.get("required", False),
                                "default": arg_dict.get("default"),
                            })
                    
                    # Extract command options
                    if 'options' in cmd_dict and cmd_dict['options']:
                        for opt in cmd_dict['options']:
                            opt_dict = _safe_to_dict(opt)
                            command_data["options"].append({
                                "name": opt_dict.get("name", ""),
                                "description": opt_dict.get("desc", opt_dict.get("description", "")),
                                "type": opt_dict.get("type", "string"),
                                "required": opt_dict.get("required", False),
                                "short": opt_dict.get("short"),
                                "default": opt_dict.get("default"),
                                "multiple": opt_dict.get("multiple", False),
                            })
                    
                    # Handle nested subcommands
                    if 'subcommands' in cmd_dict and cmd_dict['subcommands']:
                        command_data["subcommands"] = self._extract_subcommands_dict(cmd_dict['subcommands'])
                    
                    schema["root_command"]["subcommands"].append(command_data)
                    schema["commands"][cmd_name] = command_data
                    
            elif isinstance(commands, list):
                # New format: [{"name": "hello", ...}]
                for cmd in commands:
                    cmd_dict = _safe_to_dict(cmd)
                    cmd_name = cmd_dict.get('name', 'unknown')

                    command_data = {

                        "name": cmd_name,

                        "description": cmd_dict.get('description', cmd_dict.get('desc', '')),

                        "arguments": [],

                        "options": [],

                        "subcommands": [],

                        "hook_name": f"on_{cmd_name.replace('-', '_')}",

                    }

                    

                    # Extract command arguments

                    if 'args' in cmd_dict and cmd_dict['args']:

                        for arg in cmd_dict['args']:

                            command_data["arguments"].append({

                                "name": _safe_get_attr(arg, "name"),

                                "description": _safe_get_attr(arg, "desc"),  # Note: ArgumentSchema uses 'desc'

                                "type": _safe_get_attr(arg, "type", "string"),

                                "required": _safe_get_attr(arg, "required", True),

                                "multiple": _safe_get_attr(arg, "nargs") == "*",

                                "nargs": _safe_get_attr(arg, "nargs"),

                            })

                    

                    # Extract command options

                    if 'options' in cmd_dict and cmd_dict['options']:

                        for opt in cmd_dict['options']:

                            command_data["options"].append({

                                "name": _safe_get_attr(opt, "name"),

                                "short": _safe_get_attr(opt, "short"),

                                "description": _safe_get_attr(opt, "desc"),  # Note: OptionSchema uses 'desc'

                                "type": _safe_get_attr(opt, "type", "str"),

                                "default": _safe_get_attr(opt, "default"),

                                "required": False,  # Options are typically not required

                                "multiple": _safe_get_attr(opt, "multiple", False),

                            })

                    

                    # Handle nested subcommands recursively

                    if 'subcommands' in cmd_dict and cmd_dict['subcommands']:

                        command_data["subcommands"] = self._extract_subcommands_dict(cmd_dict['subcommands'])

                    

                    schema["root_command"]["subcommands"].append(command_data)

                    schema["commands"][cmd_name] = command_data

        

        # NEW: Build command hierarchy for nested command support
        if schema["commands"]:
            flattener = CommandFlattener()
            hierarchy_builder = HierarchyBuilder()
            
            # Extract flat commands from nested structure
            flat_commands = flattener.flatten_commands(schema["commands"])
            
            # Build hierarchical structure for template rendering
            command_hierarchy = hierarchy_builder.build_hierarchy(flat_commands)
            
            # Add hierarchy to schema for template access
            schema["command_hierarchy"] = {
                "groups": [self._serialize_command_group(group) for group in command_hierarchy.groups],
                "leaves": [self._serialize_flat_command(leaf) for leaf in command_hierarchy.leaves],
                "max_depth": command_hierarchy.max_depth,
                "flat_commands": [self._serialize_flat_command(cmd) for cmd in flat_commands]
            }
        else:
            schema["command_hierarchy"] = {
                "groups": [],
                "leaves": [],
                "max_depth": 0,
                "flat_commands": []
            }

        return schema

    def _serialize_command_group(self, group) -> Dict[str, Any]:
        """Serialize CommandGroup for template rendering."""
        return {
            "name": group.name,
            "path": group.path,
            "description": group.description,
            "arguments": group.arguments,
            "options": group.options,
            "hook_name": group.hook_name,
            "subcommands": [self._serialize_command_node(node) for node in group.subcommands],
            "depth": group.depth,
            "parent_path": group.path[:-1] if group.path else [],
            "click_decorator": self._get_click_decorator(group.path)
        }
    
    def _serialize_flat_command(self, command) -> Dict[str, Any]:
        """Serialize FlatCommand for template rendering."""
        return {
            "name": command.name,
            "path": command.path,
            "description": command.description,
            "arguments": command.arguments,
            "options": command.options,
            "hook_name": command.hook_name,
            "is_group": command.is_group,
            "parent_path": command.parent_path,
            "depth": command.depth,
            "click_decorator": self._get_click_decorator(command.path)
        }
    
    def _serialize_command_node(self, node) -> Dict[str, Any]:
        """Serialize CommandNode for template rendering."""
        return {
            "command": self._serialize_flat_command(node.command),
            "children": [self._serialize_command_node(child) for child in node.children],
            "is_leaf": node.is_leaf
        }
    
    def _get_click_decorator(self, command_path: List[str]) -> str:
        """Generate Click decorator for command path."""
        if len(command_path) <= 1:
            return "main"
        else:
            parent_path = command_path[:-1]
            return ".".join(parent_path).replace('-', '_')

    

    def _extract_subcommands_dict(self, commands: Dict[str, Any]) -> List[Dict[str, Any]]:

        """

        Extract subcommands from dictionary format (used by CLISchema).

        

        Args:

            commands: Dictionary of command configurations

            

        Returns:

            List of normalized subcommand schemas

        """

        subcommands = []

        for cmd_name, cmd in commands.items():

            command_data = {

                "name": cmd_name,

                "description": _safe_get_attr(cmd, "desc"),

                "arguments": [],

                "options": [],

                "subcommands": [],

                "hook_name": f"on_{cmd_name.replace('-', '_')}",

            }

            

            # Extract arguments and options similar to main commands
            # Handle both dict and object cases
            if isinstance(cmd, dict):
                # Subcommands come as dictionaries
                args = cmd.get('args', [])
                options = cmd.get('options', [])
            else:
                # Main commands come as objects
                args = getattr(cmd, 'args', []) if hasattr(cmd, 'args') else []
                options = getattr(cmd, 'options', []) if hasattr(cmd, 'options') else []

            if args:
                for arg in args:
                    # Handle both dict and object arg formats
                    if isinstance(arg, dict):
                        arg_name = arg.get('name')
                        arg_desc = arg.get('desc', '')
                        arg_type = arg.get('type', 'string')
                        arg_required = arg.get('required', True)
                        arg_nargs = arg.get('nargs')
                    else:
                        arg_name = _safe_get_attr(arg, "name")
                        arg_desc = _safe_get_attr(arg, "desc")
                        arg_type = _safe_get_attr(arg, "type", "string")
                        arg_required = _safe_get_attr(arg, "required", True)
                        arg_nargs = _safe_get_attr(arg, "nargs")

                    command_data["arguments"].append({
                        "name": arg_name,
                        "description": arg_desc,
                        "type": arg_type,
                        "required": arg_required,
                        "multiple": arg_nargs == "*",
                        "nargs": arg_nargs,
                    })

            

            # Options handling (already extracted above for dict case)
            if not isinstance(cmd, dict) and hasattr(cmd, 'options') and cmd.options:
                options = cmd.options
            
            if options:

                for opt in options:
                    # Handle both dict and object option formats
                    if isinstance(opt, dict):
                        opt_name = opt.get('name')
                        opt_short = opt.get('short')
                        opt_desc = opt.get('desc', '')
                        opt_type = opt.get('type', 'str')
                        opt_default = opt.get('default')
                        opt_multiple = opt.get('multiple', False)
                    else:
                        opt_name = _safe_get_attr(opt, "name")
                        opt_short = _safe_get_attr(opt, "short")
                        opt_desc = _safe_get_attr(opt, "desc")
                        opt_type = _safe_get_attr(opt, "type", "str")
                        opt_default = _safe_get_attr(opt, "default")
                        opt_multiple = _safe_get_attr(opt, "multiple", False)

                    command_data["options"].append({
                        "name": opt_name,
                        "short": opt_short,
                        "description": opt_desc,
                        "type": opt_type,
                        "default": opt_default,
                        "required": False,
                        "multiple": opt_multiple,
                    })

            

            # Recursively handle nested subcommands
            if isinstance(cmd, dict):
                nested_subcommands = cmd.get('subcommands')
            else:
                nested_subcommands = getattr(cmd, 'subcommands', None) if hasattr(cmd, 'subcommands') else None

            if nested_subcommands:

                command_data["subcommands"] = self._extract_subcommands_dict(nested_subcommands)

            

            subcommands.append(command_data)

        

        return subcommands

    

    def _extract_subcommands(self, commands: List[Any]) -> List[Dict[str, Any]]:

        """

        Recursively extract subcommands.

        

        Args:

            commands: List of command configurations

            

        Returns:

            List of normalized subcommand schemas

        """

        subcommands = []

        for cmd in commands:

            command_data = {

                "name": _safe_get_attr(cmd, "name"),

                "description": _safe_get_attr(cmd, "description"),

                "arguments": [],

                "options": [],

                "subcommands": [],

                "hook_name": f"on_{_safe_get_attr(cmd, 'name', '').replace('-', '_')}",

            }

            

            # Extract arguments and options similar to main commands

            if hasattr(cmd, 'arguments') and cmd.arguments:

                for arg in cmd.arguments:

                    command_data["arguments"].append({

                        "name": _safe_get_attr(arg, "name"),

                        "description": _safe_get_attr(arg, "description"),

                        "type": _safe_get_attr(arg, "type", "string"),

                        "required": _safe_get_attr(arg, "required", True),

                        "multiple": _safe_get_attr(arg, "multiple", False),

                    })

            

            # Options handling (already extracted above for dict case)
            if not isinstance(cmd, dict) and hasattr(cmd, 'options') and cmd.options:
                options = cmd.options
            
            if options:

                for opt in options:

                    command_data["options"].append({

                        "name": _safe_get_attr(opt, "name"),

                        "short": _safe_get_attr(opt, "short"),

                        "description": _safe_get_attr(opt, "description"),

                        "type": _safe_get_attr(opt, "type", "string"),

                        "default": _safe_get_attr(opt, "default"),

                        "required": _safe_get_attr(opt, "required", False),

                        "multiple": _safe_get_attr(opt, "multiple", False),

                    })

            

            # Recursively handle nested subcommands

            if hasattr(cmd, 'commands') and cmd.commands:

                command_data["subcommands"] = self._extract_subcommands(cmd.commands)

            

            subcommands.append(command_data)

        

        return subcommands

    

    def _extract_dependencies(self, config) -> Dict[str, List[str]]:

        """

        Extract and normalize dependency information.

        

        Args:

            config: Goobits configuration

            

        Returns:

            Normalized dependencies by type

        """

        dependencies = {

            "python": [],

            "system": [],

            "npm": [],

            "rust": [],

        }

        

        # Extract from dependencies section

        dependencies_obj = _safe_get_attr(config, 'dependencies')
        if dependencies_obj:

            # Handle required dependencies

            if _safe_get_attr(dependencies_obj, 'required'):

                for dep in _safe_get_attr(dependencies_obj, 'required', []):

                    if hasattr(dep, 'name'):  # DependencyItem object
                        dep_name = _safe_get_attr(dep, "name")
                        dep_type = _safe_get_attr(dep, "type", "python")
                        
                        # Only add to Python dependencies if it's not a system command
                        if dep_type != "command":
                            dependencies["python"].append(dep_name)
                        else:
                            # System commands go to system dependencies
                            dependencies["system"].append(dep_name)

                    else:  # String
                        # Assume strings are Python dependencies
                        dependencies["python"].append(dep)

            

            # Handle optional dependencies  

            if _safe_get_attr(dependencies_obj, 'optional'):

                for dep in _safe_get_attr(dependencies_obj, 'optional', []):

                    if hasattr(dep, 'name'):  # DependencyItem object
                        dep_name = _safe_get_attr(dep, "name")
                        dep_type = _safe_get_attr(dep, "type", "python")
                        
                        # Only add to Python dependencies if it's not a system command
                        if dep_type != "command":
                            dependencies["python"].append(dep_name)
                        else:
                            # System commands go to system dependencies
                            dependencies["system"].append(dep_name)

                    else:  # String
                        # Assume strings are Python dependencies
                        dependencies["python"].append(dep)

        

        # Extract from installation extras

        installation_obj = _safe_get_attr(config, 'installation')
        if installation_obj:

            extras_obj = _safe_get_attr(installation_obj, 'extras')
            
            if extras_obj:
                # Convert Pydantic model to dict if necessary
                extras = _safe_to_dict(extras_obj)

                # Python extras from installation.extras.python are meant for optional-dependencies
                # NOT for main dependencies. Skip adding them to main dependencies to avoid
                # pip install errors like "No matching distribution found for dev"
                python_extras = extras.get("python", [])
                # NOTE: These are handled separately in pyproject.toml template as optional-dependencies
                
                apt_extras = extras.get("apt", [])
                if apt_extras:
                    dependencies["system"].extend(apt_extras)

                npm_extras = extras.get("npm", [])
                if npm_extras:
                    dependencies["npm"].extend(npm_extras)

                cargo_extras = extras.get("cargo", [])
                if cargo_extras:
                    dependencies["rust"].extend(cargo_extras)

        

        # Extract Rust crates

        if hasattr(config, 'rust_crates') and config.rust_crates:

            dependencies["rust"].extend(config.rust_crates.keys())

        

        return dependencies