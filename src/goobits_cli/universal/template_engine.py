"""
Universal Template Engine for Goobits CLI Framework

This module provides the core engine for generating CLI implementations
across multiple programming languages using a unified template system.
"""

from abc import ABC, abstractmethod
from pathlib import Path
from typing import Dict, Any, List, Optional
import jinja2
from ..schemas import GoobitsConfigSchema

# Import performance optimization components
try:
    from .performance.cache import TemplateCache
    from .performance.lazy_loader import LazyLoader
    PERFORMANCE_AVAILABLE = True
except ImportError:
    PERFORMANCE_AVAILABLE = False
    # Create placeholder classes for when performance features aren't available
    class TemplateCache:
        def __init__(self, *args, **kwargs):
            pass
    class LazyLoader:
        def __init__(self, *args, **kwargs):
            pass


class LanguageRenderer(ABC):
    """
    Abstract base class for language-specific renderers.
    
    Each supported language (Python, Node.js, TypeScript, Rust) must
    implement this interface to provide language-specific rendering logic.
    """
    
    @property
    @abstractmethod
    def language(self) -> str:
        """Return the language name (e.g., 'python', 'nodejs', 'typescript', 'rust')"""
        pass
    
    @property
    @abstractmethod
    def file_extensions(self) -> Dict[str, str]:
        """Return mapping of component types to file extensions for this language"""
        pass
    
    @abstractmethod
    def get_template_context(self, ir: Dict[str, Any]) -> Dict[str, Any]:
        """
        Transform the intermediate representation into language-specific template context.
        
        Args:
            ir: Intermediate representation generated by UniversalTemplateEngine
            
        Returns:
            Language-specific template context for rendering
        """
        pass
    
    @abstractmethod
    def get_custom_filters(self) -> Dict[str, callable]:
        """
        Return custom Jinja2 filters specific to this language.
        
        Returns:
            Dictionary mapping filter names to filter functions
        """
        pass
    
    @abstractmethod
    def render_component(self, component_name: str, template_content: str, 
                        context: Dict[str, Any]) -> str:
        """
        Render a specific component template for this language.
        
        Args:
            component_name: Name of the component being rendered
            template_content: The universal template content
            context: Language-specific template context
            
        Returns:
            Rendered template content for this language
        """
        pass
    
    @abstractmethod
    def get_output_structure(self, ir: Dict[str, Any]) -> Dict[str, str]:
        """
        Define the output file structure for this language.
        
        Args:
            ir: Intermediate representation
            
        Returns:
            Dictionary mapping component names to output file paths
        """
        pass


class ComponentRegistry:
    """
    Registry for managing universal component templates.
    
    This class handles loading, caching, and providing access to
    universal component templates from the components/ directory.
    """
    
    def __init__(self, components_dir: Optional[Path] = None):
        """
        Initialize the component registry.
        
        Args:
            components_dir: Path to components directory, defaults to built-in components
        """
        self.components_dir = components_dir or Path(__file__).parent / "components"
        self._components: Dict[str, str] = {}
        self._loader = jinja2.FileSystemLoader(str(self.components_dir))
        self._env = jinja2.Environment(loader=self._loader)
        
    def load_components(self) -> None:
        """Load all component templates from the components directory."""
        if not self.components_dir.exists():
            raise FileNotFoundError(f"Components directory not found: {self.components_dir}")
            
        for template_file in self.components_dir.glob("*.j2"):
            component_name = template_file.stem
            self._components[component_name] = template_file.read_text(encoding='utf-8')
    
    def get_component(self, name: str) -> str:
        """
        Get a component template by name.
        
        Args:
            name: Component name (without .j2 extension)
            
        Returns:
            Template content as string
            
        Raises:
            KeyError: If component is not found
        """
        if name not in self._components:
            # Try to load component on-demand
            component_file = self.components_dir / f"{name}.j2"
            if component_file.exists():
                self._components[name] = component_file.read_text(encoding='utf-8')
            else:
                raise KeyError(f"Component '{name}' not found")
                
        return self._components[name]
    
    def list_components(self) -> List[str]:
        """
        List all available component names.
        
        Returns:
            List of component names
        """
        return list(self._components.keys())
    
    def has_component(self, name: str) -> bool:
        """
        Check if a component exists.
        
        Args:
            name: Component name
            
        Returns:
            True if component exists, False otherwise
        """
        return name in self._components or (self.components_dir / f"{name}.j2").exists()


class UniversalTemplateEngine:
    """
    Main engine for the Universal Template System.
    
    This class orchestrates the entire process of converting a Goobits
    configuration into language-specific CLI implementations using
    universal component templates with performance optimizations.
    """
    
    def __init__(self, components_dir: Optional[Path] = None, 
                 template_cache: Optional[TemplateCache] = None,
                 enable_lazy_loading: bool = True):
        """
        Initialize the universal template engine.
        
        Args:
            components_dir: Path to components directory, defaults to built-in components
            template_cache: Optional template cache for performance optimization
            enable_lazy_loading: Whether to enable lazy loading of components
        """
        self.component_registry = ComponentRegistry(components_dir)
        self.renderers: Dict[str, LanguageRenderer] = {}
        
        # Performance optimization components
        if PERFORMANCE_AVAILABLE and template_cache is not None:
            self.template_cache = template_cache
            self.performance_enabled = True
        else:
            self.template_cache = None
            self.performance_enabled = False
        
        # Lazy loading setup
        if enable_lazy_loading and PERFORMANCE_AVAILABLE:
            self.lazy_loader = LazyLoader()
            self._register_lazy_components()
        else:
            self.lazy_loader = None
            # Load components immediately if no lazy loading
            self.component_registry.load_components()
    
    def _register_lazy_components(self):
        """Register components for lazy loading"""
        if not self.lazy_loader:
            return
        
        # Register component loading
        self.lazy_loader.register(
            "component_registry",
            lambda: self._load_component_registry(),
            dependencies=[]
        )
        
        # Register renderer components
        for language in ["python", "nodejs", "typescript", "rust"]:
            self.lazy_loader.register(
                f"{language}_renderer",
                lambda lang=language: self._create_renderer(lang),
                dependencies=["component_registry"]
            )
    
    def _load_component_registry(self):
        """Load component registry (for lazy loading)"""
        self.component_registry.load_components()
        return self.component_registry
    
    def _create_renderer(self, language: str):
        """Create a renderer for the specified language (for lazy loading)"""
        # This would normally import and create the appropriate renderer
        # For now, return a placeholder
        return None
    
    def register_renderer(self, renderer: LanguageRenderer) -> None:
        """
        Register a language-specific renderer.
        
        Args:
            renderer: Language renderer implementation
        """
        self.renderers[renderer.language] = renderer
    
    def generate_cli(self, config: GoobitsConfigSchema, language: str, 
                    output_dir: Path) -> Dict[str, str]:
        """
        Generate a complete CLI implementation for the specified language.
        
        Args:
            config: Validated Goobits configuration
            language: Target programming language
            output_dir: Directory to write generated files
            
        Returns:
            Dictionary mapping output file paths to generated content
            
        Raises:
            ValueError: If language renderer is not registered
        """
        if language not in self.renderers:
            raise ValueError(f"No renderer registered for language: {language}")
        
        renderer = self.renderers[language]
        
        # Use lazy loading if available
        if self.lazy_loader:
            # Ensure component registry is loaded
            self.lazy_loader.get_component("component_registry")
        
        # Build intermediate representation (with caching if available)
        ir_cache_key = f"ir_{hash(str(config.model_dump()))}"
        
        if self.performance_enabled and self.template_cache:
            # Try to get cached IR
            cached_ir = self.template_cache._cache.get(ir_cache_key)
            if cached_ir:
                ir = cached_ir
            else:
                ir = self._build_intermediate_representation(config)
                # Cache the IR for future use
                self.template_cache._cache.put(ir_cache_key, ir, ttl=300)  # 5 min cache
        else:
            ir = self._build_intermediate_representation(config)
        
        # Get language-specific context
        context = renderer.get_template_context(ir)
        
        # Get output structure
        output_structure = renderer.get_output_structure(ir)
        
        # Render all components with performance optimization
        generated_files = {}
        for component_name, output_path in output_structure.items():
            if self.component_registry.has_component(component_name):
                # Use cached template if available
                if self.performance_enabled and self.template_cache:
                    template_path = self.component_registry.components_dir / f"{component_name}.j2"
                    if template_path.exists():
                        rendered_content = self.template_cache.render_template(
                            template_path, context
                        )
                        if rendered_content is not None:
                            full_output_path = output_dir / output_path
                            generated_files[str(full_output_path)] = rendered_content
                            continue
                
                # Fallback to regular rendering
                template_content = self.component_registry.get_component(component_name)
                rendered_content = renderer.render_component(
                    component_name, template_content, context
                )
                
                full_output_path = output_dir / output_path
                generated_files[str(full_output_path)] = rendered_content
        
        return generated_files
    
    def _build_intermediate_representation(self, config: GoobitsConfigSchema) -> Dict[str, Any]:
        """
        Convert Goobits configuration to intermediate representation.
        
        This method extracts and normalizes all information from the configuration
        into a language-agnostic format that can be consumed by any renderer.
        
        Args:
            config: Validated Goobits configuration
            
        Returns:
            Intermediate representation as dictionary
        """
        # Extract CLI schema information
        cli_schema = self._extract_config_schema(config.cli)
        
        ir = {
            "project": {
                "name": getattr(config, 'display_name', config.command_name),
                "description": config.description,
                "version": getattr(config.cli, 'version', '1.0.0') if config.cli else '1.0.0',
                "author": getattr(config, "author", ""),
                "license": getattr(config, "license", ""),
                "package_name": config.package_name,
                "command_name": config.command_name,
            },
            "cli": cli_schema,
            "installation": {
                "pypi_name": getattr(config.installation, "pypi_name", config.package_name),
                "development_path": getattr(config.installation, "development_path", "."),
                "extras": getattr(config.installation, "extras", {}).model_dump() if hasattr(getattr(config.installation, "extras", {}), 'model_dump') else getattr(config.installation, "extras", {}).dict() if hasattr(getattr(config.installation, "extras", {}), 'dict') else {},
            },
            "dependencies": self._extract_dependencies(config),
            "metadata": {
                "generated_at": "{{ timestamp }}",  # Will be replaced during rendering
                "generator_version": "{{ version }}",  # Will be replaced during rendering
                "source_config": config.model_dump(),
            }
        }
        
        return ir
    
    def _extract_config_schema(self, cli_config: Any) -> Dict[str, Any]:
        """
        Extract normalized CLI schema from configuration.
        
        Args:
            cli_config: CLI configuration section
            
        Returns:
            Normalized CLI schema
        """
        schema = {
            "root_command": {
                "name": cli_config.name,
                "description": getattr(cli_config, 'description', cli_config.tagline),
                "version": getattr(cli_config, 'version', '1.0.0'),
                "arguments": [],
                "options": [],
                "subcommands": [],
            },
            "commands": {},
            "global_options": [],
            "completion": {
                "enabled": True,  # Default to enabled
                "shells": ["bash", "zsh", "fish"],
            }
        }
        
        # Extract arguments (CLI root rarely has arguments in current schema)
        if hasattr(cli_config, 'args') and cli_config.args:
            for arg in cli_config.args:
                schema["root_command"]["arguments"].append({
                    "name": arg.name,
                    "description": arg.desc,
                    "type": getattr(arg, "type", "string"),
                    "required": getattr(arg, "required", True),
                    "multiple": getattr(arg, "nargs", None) == "*",
                })
        
        # Extract options
        if hasattr(cli_config, 'options') and cli_config.options:
            for opt in cli_config.options:
                option_data = {
                    "name": opt.name,
                    "short": getattr(opt, "short", None),
                    "description": opt.desc,
                    "type": getattr(opt, "type", "str"),
                    "default": getattr(opt, "default", None),
                    "required": False,  # Global options typically not required
                    "multiple": getattr(opt, "multiple", False),
                }
                schema["root_command"]["options"].append(option_data)
        
        # Extract subcommands
        if hasattr(cli_config, 'commands') and cli_config.commands:
            for cmd_name, cmd in cli_config.commands.items():
                command_data = {
                    "name": cmd_name,
                    "description": cmd.desc,  # Note: CLISchema uses 'desc' not 'description'
                    "arguments": [],
                    "options": [],
                    "subcommands": [],
                    "hook_name": f"on_{cmd_name.replace('-', '_')}",
                }
                
                # Extract command arguments
                if hasattr(cmd, 'args') and cmd.args:
                    for arg in cmd.args:
                        command_data["arguments"].append({
                            "name": arg.name,
                            "description": arg.desc,  # Note: ArgumentSchema uses 'desc'
                            "type": getattr(arg, "type", "string"),
                            "required": getattr(arg, "required", True),
                            "multiple": getattr(arg, "nargs", None) == "*",
                        })
                
                # Extract command options
                if hasattr(cmd, 'options') and cmd.options:
                    for opt in cmd.options:
                        command_data["options"].append({
                            "name": opt.name,
                            "short": getattr(opt, "short", None),
                            "description": opt.desc,  # Note: OptionSchema uses 'desc'
                            "type": getattr(opt, "type", "str"),
                            "default": getattr(opt, "default", None),
                            "required": False,  # Options are typically not required
                            "multiple": getattr(opt, "multiple", False),
                        })
                
                # Handle nested subcommands recursively
                if hasattr(cmd, 'subcommands') and cmd.subcommands:
                    command_data["subcommands"] = self._extract_subcommands_dict(cmd.subcommands)
                
                schema["root_command"]["subcommands"].append(command_data)
                schema["commands"][cmd_name] = command_data
        
        return schema
    
    def _extract_subcommands_dict(self, commands: Dict[str, Any]) -> List[Dict[str, Any]]:
        """
        Extract subcommands from dictionary format (used by CLISchema).
        
        Args:
            commands: Dictionary of command configurations
            
        Returns:
            List of normalized subcommand schemas
        """
        subcommands = []
        for cmd_name, cmd in commands.items():
            command_data = {
                "name": cmd_name,
                "description": cmd.desc,
                "arguments": [],
                "options": [],
                "subcommands": [],
                "hook_name": f"on_{cmd_name.replace('-', '_')}",
            }
            
            # Extract arguments and options similar to main commands
            if hasattr(cmd, 'args') and cmd.args:
                for arg in cmd.args:
                    command_data["arguments"].append({
                        "name": arg.name,
                        "description": arg.desc,
                        "type": getattr(arg, "type", "string"),
                        "required": getattr(arg, "required", True),
                        "multiple": getattr(arg, "nargs", None) == "*",
                    })
            
            if hasattr(cmd, 'options') and cmd.options:
                for opt in cmd.options:
                    command_data["options"].append({
                        "name": opt.name,
                        "short": getattr(opt, "short", None),
                        "description": opt.desc,
                        "type": getattr(opt, "type", "str"),
                        "default": getattr(opt, "default", None),
                        "required": False,
                        "multiple": getattr(opt, "multiple", False),
                    })
            
            # Recursively handle nested subcommands
            if hasattr(cmd, 'subcommands') and cmd.subcommands:
                command_data["subcommands"] = self._extract_subcommands_dict(cmd.subcommands)
            
            subcommands.append(command_data)
        
        return subcommands
    
    def _extract_subcommands(self, commands: List[Any]) -> List[Dict[str, Any]]:
        """
        Recursively extract subcommands.
        
        Args:
            commands: List of command configurations
            
        Returns:
            List of normalized subcommand schemas
        """
        subcommands = []
        for cmd in commands:
            command_data = {
                "name": cmd.name,
                "description": cmd.description,
                "arguments": [],
                "options": [],
                "subcommands": [],
                "hook_name": f"on_{cmd.name.replace('-', '_')}",
            }
            
            # Extract arguments and options similar to main commands
            if hasattr(cmd, 'arguments') and cmd.arguments:
                for arg in cmd.arguments:
                    command_data["arguments"].append({
                        "name": arg.name,
                        "description": arg.description,
                        "type": getattr(arg, "type", "string"),
                        "required": getattr(arg, "required", True),
                        "multiple": getattr(arg, "multiple", False),
                    })
            
            if hasattr(cmd, 'options') and cmd.options:
                for opt in cmd.options:
                    command_data["options"].append({
                        "name": opt.name,
                        "short": getattr(opt, "short", None),
                        "description": opt.description,
                        "type": getattr(opt, "type", "string"),
                        "default": getattr(opt, "default", None),
                        "required": getattr(opt, "required", False),
                        "multiple": getattr(opt, "multiple", False),
                    })
            
            # Recursively handle nested subcommands
            if hasattr(cmd, 'commands') and cmd.commands:
                command_data["subcommands"] = self._extract_subcommands(cmd.commands)
            
            subcommands.append(command_data)
        
        return subcommands
    
    def _extract_dependencies(self, config: GoobitsConfigSchema) -> Dict[str, List[str]]:
        """
        Extract and normalize dependency information.
        
        Args:
            config: Goobits configuration
            
        Returns:
            Normalized dependencies by type
        """
        dependencies = {
            "python": [],
            "system": [],
            "npm": [],
            "rust": [],
        }
        
        # Extract from dependencies section
        if hasattr(config, 'dependencies') and config.dependencies:
            # Handle required dependencies
            if config.dependencies.required:
                for dep in config.dependencies.required:
                    if hasattr(dep, 'name'):  # DependencyItem object
                        dependencies["python"].append(dep.name)
                    else:  # String
                        dependencies["python"].append(dep)
            
            # Handle optional dependencies  
            if config.dependencies.optional:
                for dep in config.dependencies.optional:
                    if hasattr(dep, 'name'):  # DependencyItem object
                        dependencies["python"].append(dep.name)
                    else:  # String
                        dependencies["python"].append(dep)
        
        # Extract from installation extras
        if hasattr(config, 'installation') and config.installation:
            extras = getattr(config.installation, 'extras', {})
            if isinstance(extras, dict):
                dependencies["python"].extend(extras.get("python", []))
                dependencies["system"].extend(extras.get("apt", []))
                dependencies["npm"].extend(extras.get("npm", []))
                dependencies["rust"].extend(extras.get("cargo", []))
        
        # Extract Rust crates
        if hasattr(config, 'rust_crates') and config.rust_crates:
            dependencies["rust"].extend(config.rust_crates.keys())
        
        return dependencies