#!/usr/bin/env python3
"""
Interactive mode for Goobits CLI Framework
Generated by Goobits CLI Framework
"""

import cmd
import shlex
import sys
from typing import List, Optional
try:
    from .goobits_cli import cli
    from .hooks import *  # Import all hook functions
except ImportError:
    # Fallback imports
    from goobits_cli import cli
    try:
        from hooks import *
    except ImportError:
        pass

class GoobitscliframeworkInteractive(cmd.Cmd):
    """Interactive CLI for Goobits CLI Framework"""
    
    intro = "Welcome to Goobits CLI Framework interactive mode. Type 'help' for commands, 'exit' to quit."
    prompt = "Goobits CLI> "
    
    def __init__(self):
        super().__init__()
        self.command_history = []
        
    def do_exit(self, arg):
        """Exit the interactive mode"""
        print("Goodbye!")
        return True
        
    def do_quit(self, arg):
        """Exit the interactive mode"""
        return self.do_exit(arg)
        
    def do_EOF(self, arg):
        """Handle Ctrl+D"""
        print()  # New line after ^D
        return True    
    def do_build(self, arg):
        """Build CLI and setup scripts from goobits.yaml configuration
        
        Usage: build [CONFIG_PATH] [--output-dir|-o] [--output] [--backup]        
        Arguments:            CONFIG_PATH: Path to goobits.yaml file (defaults to ./goobits.yaml) (optional)        
        Options:            --output-dir, -o: üìÅ Output directory (defaults to same directory as config file)            --output: üìù Output filename for generated CLI (defaults to 'generated_cli.py')            --backup: üíæ Create backup files (.bak) when overwriting existing files        """
        try:
            # Parse arguments
            args = shlex.split(arg)
            
            # Call the hook function if it exists
            hook_name = "on_build"
            if hook_name in globals():
                hook_func = globals()[hook_name]
                # Parse and validate arguments according to command definition
                import inspect
                sig = inspect.signature(hook_func)
                try:
                    bound_args = sig.bind(*args)
                    bound_args.apply_defaults()
                    hook_func(*bound_args.args, **bound_args.kwargs)
                except TypeError as e:
                    print(f"Error calling {hook_name}: {e}")
                    print(f"Expected signature: {sig}")
            else:
                print(f"Command 'build' executed successfully")
                print(f"To implement custom behavior, add '{hook_name}' function to hooks.py")
        except Exception as e:
            print(f"Error: {e}")
    
    def complete_build(self, text, line, begidx, endidx):
        """Tab completion for build command"""
        # Basic completion for options
        options = ["--output-dir", "-o", "--output", "--backup"]
        return [opt for opt in options if opt.startswith(text)]    
    def do_init(self, arg):
        """Create initial goobits.yaml template
        
        Usage: init [PROJECT_NAME] [--template|-t] [--force]        
        Arguments:            PROJECT_NAME: Name of the project (optional) (optional)        
        Options:            --template, -t: üéØ Template type            --force: üî• Overwrite existing goobits.yaml file        """
        try:
            # Parse arguments
            args = shlex.split(arg)
            
            # Call the hook function if it exists
            hook_name = "on_init"
            if hook_name in globals():
                hook_func = globals()[hook_name]
                # Parse and validate arguments according to command definition
                import inspect
                sig = inspect.signature(hook_func)
                try:
                    bound_args = sig.bind(*args)
                    bound_args.apply_defaults()
                    hook_func(*bound_args.args, **bound_args.kwargs)
                except TypeError as e:
                    print(f"Error calling {hook_name}: {e}")
                    print(f"Expected signature: {sig}")
            else:
                print(f"Command 'init' executed successfully")
                print(f"To implement custom behavior, add '{hook_name}' function to hooks.py")
        except Exception as e:
            print(f"Error: {e}")
    
    def complete_init(self, text, line, begidx, endidx):
        """Tab completion for init command"""
        # Basic completion for options
        options = ["--template", "-t", "--force"]
        return [opt for opt in options if opt.startswith(text)]    
    def do_serve(self, arg):
        """Serve local PyPI-compatible package index
        
        Usage: serve DIRECTORY [--host] [--port|-p]        
        Arguments:            DIRECTORY: Directory containing packages to serve        
        Options:            --host: üåç Host to bind the server to            --port, -p: üîå Port to run the server on        """
        try:
            # Parse arguments
            args = shlex.split(arg)
            
            # Call the hook function if it exists
            hook_name = "on_serve"
            if hook_name in globals():
                hook_func = globals()[hook_name]
                # Parse and validate arguments according to command definition
                import inspect
                sig = inspect.signature(hook_func)
                try:
                    bound_args = sig.bind(*args)
                    bound_args.apply_defaults()
                    hook_func(*bound_args.args, **bound_args.kwargs)
                except TypeError as e:
                    print(f"Error calling {hook_name}: {e}")
                    print(f"Expected signature: {sig}")
            else:
                print(f"Command 'serve' executed successfully")
                print(f"To implement custom behavior, add '{hook_name}' function to hooks.py")
        except Exception as e:
            print(f"Error: {e}")
    
    def complete_serve(self, text, line, begidx, endidx):
        """Tab completion for serve command"""
        # Basic completion for options
        options = ["--host", "--port", "-p"]
        return [opt for opt in options if opt.startswith(text)]    
    def default(self, line):
        """Handle unknown commands"""
        print(f"Unknown command: {line.split()[0] if line else ''}")
        print("Type 'help' for available commands")
    
    def emptyline(self):
        """Handle empty line (do nothing instead of repeating last command)"""
        pass
    
    def precmd(self, line):
        """Hook before command execution"""
        if line and not line.startswith('help'):
            self.command_history.append(line)
        return line
    
    def postcmd(self, stop, line):
        """Hook after command execution"""
        return stop

def run_interactive():
    """Launch the interactive mode"""
    try:
        GoobitscliframeworkInteractive().cmdloop()
    except KeyboardInterrupt:
        print("\nInterrupted. Use 'exit' to quit.")
        run_interactive()

if __name__ == "__main__":
    run_interactive()