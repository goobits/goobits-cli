// Node.js Plugin Template for Goobits CLI Framework
// Generated from: {{ source_config }}

/**
 * {{ plugin_name }} - {{ plugin_description }}
 * 
 * A Goobits CLI plugin that provides {{ plugin_type }} functionality.
 * @author {{ plugin_author }}
 * @version {{ plugin_version }}
 */

const { Command } = require('commander');
const path = require('path');
const fs = require('fs').promises;

// Plugin metadata
const PLUGIN_INFO = {
    name: '{{ plugin_name }}',
    version: '{{ plugin_version }}',
    description: '{{ plugin_description }}',
    author: '{{ plugin_author }}',
    pluginType: '{{ plugin_type }}',
    language: 'nodejs'
};

// Plugin configuration
const PLUGIN_CONFIG = {
    enabled: true,
    priority: {{ plugin_priority | default(50) }},
    dependencies: {{ plugin_dependencies | tojson }},
    settings: {{ plugin_settings | default({}) | tojson }}
};

/**
 * Main plugin class for {{ plugin_name }}.
 */
class {{ plugin_name | title }}Plugin {
    constructor() {
        this.enabled = PLUGIN_CONFIG.enabled;
        this.priority = PLUGIN_CONFIG.priority;
        this.settings = PLUGIN_CONFIG.settings;
        
        console.log(`Initialized plugin: ${PLUGIN_INFO.name} v${PLUGIN_INFO.version}`);
    }

    /**
     * Activate the plugin.
     * @returns {Promise<boolean>} True if activation successful
     */
    async activate() {
        try {
            console.log(`Activating plugin: ${PLUGIN_INFO.name}`);
            
            {% if plugin_type == 'command' %}
            // Register commands
            await this._registerCommands();
            {% elif plugin_type == 'completion' %}
            // Register completion providers
            await this._registerCompletionProviders();
            {% elif plugin_type == 'hook' %}
            // Register lifecycle hooks
            await this._registerHooks();
            {% elif plugin_type == 'formatter' %}
            // Register output formatters
            await this._registerFormatters();
            {% elif plugin_type == 'validator' %}
            // Register input validators
            await this._registerValidators();
            {% endif %}
            
            this.enabled = true;
            return true;
            
        } catch (error) {
            console.error(`Error activating plugin ${PLUGIN_INFO.name}:`, error);
            return false;
        }
    }

    /**
     * Deactivate the plugin.
     * @returns {Promise<boolean>} True if deactivation successful
     */
    async deactivate() {
        try {
            console.log(`Deactivating plugin: ${PLUGIN_INFO.name}`);
            
            {% if plugin_type == 'command' %}
            // Unregister commands
            await this._unregisterCommands();
            {% elif plugin_type == 'completion' %}
            // Unregister completion providers
            await this._unregisterCompletionProviders();
            {% elif plugin_type == 'hook' %}
            // Unregister lifecycle hooks
            await this._unregisterHooks();
            {% elif plugin_type == 'formatter' %}
            // Unregister output formatters
            await this._unregisterFormatters();
            {% elif plugin_type == 'validator' %}
            // Unregister input validators
            await this._unregisterValidators();
            {% endif %}
            
            this.enabled = false;
            return true;
            
        } catch (error) {
            console.error(`Error deactivating plugin ${PLUGIN_INFO.name}:`, error);
            return false;
        }
    }

    {% if plugin_type == 'command' %}
    /**
     * Register plugin commands.
     * @private
     */
    async _registerCommands() {
        // Example command registration using Commander.js
        const command = new Command('{{ plugin_name }}');
        
        command
            .description('{{ plugin_description }}')
            .option('-v, --verbose', 'Enable verbose output')
            .argument('[args...]', 'Additional arguments')
            .action(async (args, options) => {
                if (options.verbose) {
                    console.log(`Executing ${PLUGIN_INFO.name} with args:`, args);
                }
                
                // Plugin command logic here
                const result = await this._executeCommand(args, options);
                
                if (result) {
                    console.log(`✅ ${PLUGIN_INFO.name} completed successfully`);
                } else {
                    console.error(`❌ ${PLUGIN_INFO.name} failed`);
                    process.exit(1);
                }
            });
        
        // Register the command with the CLI
        // This would integrate with the main CLI command registration system
    }

    /**
     * Unregister plugin commands.
     * @private
     */
    async _unregisterCommands() {
        // Unregister commands from the CLI system
    }

    /**
     * Execute the main plugin command logic.
     * @param {string[]} args - Command arguments
     * @param {Object} options - Command options
     * @returns {Promise<boolean>} True if execution successful
     */
    async _executeCommand(args, options = {}) {
        try {
            console.log(`Executing ${PLUGIN_INFO.name} command`);
            
            // Example implementation
            if (args && args.length > 0) {
                console.log(`Processing arguments:`, args);
            }
            
            // Implement your plugin's main functionality here
            
            return true;
            
        } catch (error) {
            console.error(`Error executing ${PLUGIN_INFO.name} command:`, error);
            return false;
        }
    }

    {% elif plugin_type == 'completion' %}
    /**
     * Register completion providers.
     * @private
     */
    async _registerCompletionProviders() {
        // Register completion providers with the completion system
        const provider = new {{ plugin_name | title }}CompletionProvider();
        
        // This would integrate with the completion registry
        // completionRegistry.registerProvider(provider);
    }

    /**
     * Unregister completion providers.
     * @private
     */
    async _unregisterCompletionProviders() {
        // Remove providers from completion registry
    }

    {% elif plugin_type == 'hook' %}
    /**
     * Register lifecycle hooks.
     * @private
     */
    async _registerHooks() {
        // Register hooks with the CLI lifecycle system
    }

    /**
     * Unregister lifecycle hooks.
     * @private
     */
    async _unregisterHooks() {
        // Remove hooks from the lifecycle system
    }

    {% elif plugin_type == 'formatter' %}
    /**
     * Register output formatters.
     * @private
     */
    async _registerFormatters() {
        // Register formatters with the output system
    }

    /**
     * Unregister output formatters.
     * @private
     */
    async _unregisterFormatters() {
        // Remove formatters from the output system
    }

    {% elif plugin_type == 'validator' %}
    /**
     * Register input validators.
     * @private
     */
    async _registerValidators() {
        // Register validators with the input system
    }

    /**
     * Unregister input validators.
     * @private
     */
    async _unregisterValidators() {
        // Remove validators from the input system
    }
    {% endif %}
}

{% if plugin_type == 'completion' %}
/**
 * Completion provider for {{ plugin_name }}.
 */
class {{ plugin_name | title }}CompletionProvider {
    constructor(priority = 50) {
        this.priority = priority;
        this.enabled = true;
    }

    /**
     * Check if this provider can handle the current context.
     * @param {Object} context - Completion context
     * @returns {boolean} True if provider can handle context
     */
    canProvide(context) {
        // Implement your completion logic here
        return context.currentCommand.includes('{{ plugin_name }}');
    }

    /**
     * Provide completion suggestions.
     * @param {Object} context - Completion context
     * @returns {Promise<string[]>} Array of completion suggestions
     */
    async provideCompletions(context) {
        const completions = [];

        // Implement your completion suggestions here
        if (context.currentWord) {
            // Example: provide completions based on current word
            const sampleCompletions = ['option1', 'option2', 'option3'];
            completions.push(...sampleCompletions.filter(c => 
                c.startsWith(context.currentWord)
            ));
        }

        return completions;
    }

    /**
     * Get provider priority.
     * @returns {number} Provider priority
     */
    getPriority() {
        return this.priority;
    }

    /**
     * Check if provider is enabled.
     * @returns {boolean} True if provider is enabled
     */
    isEnabled() {
        return this.enabled;
    }
}
{% endif %}

/**
 * Get plugin information.
 * @returns {Object} Plugin information
 */
function getPluginInfo() {
    return { ...PLUGIN_INFO };
}

/**
 * Create and return plugin instance.
 * @returns {{{ plugin_name | title }}Plugin} Plugin instance
 */
function createPlugin() {
    return new {{ plugin_name | title }}Plugin();
}

/**
 * Activate the plugin (entry point for plugin system).
 * @returns {Promise<boolean>} True if activation successful
 */
async function activatePlugin() {
    const plugin = createPlugin();
    return await plugin.activate();
}

/**
 * Deactivate the plugin (entry point for plugin system).
 * @returns {Promise<boolean>} True if deactivation successful
 */
async function deactivatePlugin() {
    const plugin = createPlugin();
    return await plugin.deactivate();
}

// Export plugin components
module.exports = {
    {{ plugin_name | title }}Plugin,
    {% if plugin_type == 'completion' %}
    {{ plugin_name | title }}CompletionProvider,
    {% endif %}
    getPluginInfo,
    createPlugin,
    activatePlugin,
    deactivatePlugin,
    PLUGIN_INFO,
    PLUGIN_CONFIG
};

// Test the plugin if run directly
if (require.main === module) {
    (async () => {
        const plugin = createPlugin();
        console.log('Plugin:', plugin);
        console.log('Info:', getPluginInfo());
        console.log('Activate:', await plugin.activate());
        console.log('Deactivate:', await plugin.deactivate());
    })().catch(console.error);
}