// TypeScript Plugin Template for Goobits CLI Framework
// Generated from: {{ source_config }}

/**
 * {{ plugin_name }} - {{ plugin_description }}
 * 
 * A Goobits CLI plugin that provides {{ plugin_type }} functionality.
 * @author {{ plugin_author }}
 * @version {{ plugin_version }}
 */

import { Command } from 'commander';
import * as path from 'path';
import { promises as fs } from 'fs';

// Plugin metadata interface
interface PluginInfo {
    name: string;
    version: string;
    description: string;
    author: string;
    pluginType: PluginType;
    language: string;
}

// Plugin configuration interface
interface PluginConfig {
    enabled: boolean;
    priority: number;
    dependencies: string[];
    settings: Record<string, any>;
}

// Plugin type enumeration
type PluginType = 'command' | 'completion' | 'hook' | 'formatter' | 'validator' | 'integration';

{% if plugin_type == 'completion' %}
// Completion context interface
interface CompletionContext {
    currentCommand: string;
    currentWord: string;
    args: string[];
    cwd: string;
    env: Record<string, string>;
    history: string[];
    availableCommands: Set<string>;
    availableOptions: Set<string>;
    metadata: Record<string, any>;
    language: string;
    config: Record<string, any>;
}

// Completion provider interface
interface CompletionProvider {
    priority: number;
    enabled: boolean;
    canProvide(context: CompletionContext): boolean;
    provideCompletions(context: CompletionContext): Promise<string[]>;
    getPriority(): number;
    isEnabled(): boolean;
}
{% endif %}

// Plugin metadata
const PLUGIN_INFO: PluginInfo = {
    name: '{{ plugin_name }}',
    version: '{{ plugin_version }}',
    description: '{{ plugin_description }}',
    author: '{{ plugin_author }}',
    pluginType: '{{ plugin_type }}' as PluginType,
    language: 'typescript'
};

// Plugin configuration
const PLUGIN_CONFIG: PluginConfig = {
    enabled: true,
    priority: {{ plugin_priority | default(50) }},
    dependencies: {{ plugin_dependencies | tojson }},
    settings: {{ plugin_settings | default({}) | tojson }}
};

/**
 * Main plugin class for {{ plugin_name }}.
 */
export class {{ plugin_name | title }}Plugin {
    private enabled: boolean;
    private priority: number;
    private settings: Record<string, any>;

    constructor() {
        this.enabled = PLUGIN_CONFIG.enabled;
        this.priority = PLUGIN_CONFIG.priority;
        this.settings = PLUGIN_CONFIG.settings;
        
        console.log(`Initialized plugin: ${PLUGIN_INFO.name} v${PLUGIN_INFO.version}`);
    }

    /**
     * Activate the plugin.
     * @returns Promise<boolean> True if activation successful
     */
    async activate(): Promise<boolean> {
        try {
            console.log(`Activating plugin: ${PLUGIN_INFO.name}`);
            
            {% if plugin_type == 'command' %}
            // Register commands
            await this.registerCommands();
            {% elif plugin_type == 'completion' %}
            // Register completion providers
            await this.registerCompletionProviders();
            {% elif plugin_type == 'hook' %}
            // Register lifecycle hooks
            await this.registerHooks();
            {% elif plugin_type == 'formatter' %}
            // Register output formatters
            await this.registerFormatters();
            {% elif plugin_type == 'validator' %}
            // Register input validators
            await this.registerValidators();
            {% endif %}
            
            this.enabled = true;
            return true;
            
        } catch (error) {
            console.error(`Error activating plugin ${PLUGIN_INFO.name}:`, error);
            return false;
        }
    }

    /**
     * Deactivate the plugin.
     * @returns Promise<boolean> True if deactivation successful
     */
    async deactivate(): Promise<boolean> {
        try {
            console.log(`Deactivating plugin: ${PLUGIN_INFO.name}`);
            
            {% if plugin_type == 'command' %}
            // Unregister commands
            await this.unregisterCommands();
            {% elif plugin_type == 'completion' %}
            // Unregister completion providers
            await this.unregisterCompletionProviders();
            {% elif plugin_type == 'hook' %}
            // Unregister lifecycle hooks
            await this.unregisterHooks();
            {% elif plugin_type == 'formatter' %}
            // Unregister output formatters
            await this.unregisterFormatters();
            {% elif plugin_type == 'validator' %}
            // Unregister input validators
            await this.unregisterValidators();
            {% endif %}
            
            this.enabled = false;
            return true;
            
        } catch (error) {
            console.error(`Error deactivating plugin ${PLUGIN_INFO.name}:`, error);
            return false;
        }
    }

    {% if plugin_type == 'command' %}
    /**
     * Register plugin commands.
     */
    private async registerCommands(): Promise<void> {
        // Example command registration using Commander.js with TypeScript
        const command = new Command('{{ plugin_name }}');
        
        command
            .description('{{ plugin_description }}')
            .option('-v, --verbose', 'Enable verbose output')
            .argument('[args...]', 'Additional arguments')
            .action(async (args: string[], options: { verbose?: boolean }) => {
                if (options.verbose) {
                    console.log(`Executing ${PLUGIN_INFO.name} with args:`, args);
                }
                
                // Plugin command logic here
                const result = await this.executeCommand(args, options);
                
                if (result) {
                    console.log(`✅ ${PLUGIN_INFO.name} completed successfully`);
                } else {
                    console.error(`❌ ${PLUGIN_INFO.name} failed`);
                    process.exit(1);
                }
            });
        
        // Register the command with the CLI
        // This would integrate with the main CLI command registration system
    }

    /**
     * Unregister plugin commands.
     */
    private async unregisterCommands(): Promise<void> {
        // Unregister commands from the CLI system
    }

    /**
     * Execute the main plugin command logic.
     * @param args Command arguments
     * @param options Command options
     * @returns Promise<boolean> True if execution successful
     */
    private async executeCommand(
        args: string[], 
        options: Record<string, any> = {}
    ): Promise<boolean> {
        try {
            console.log(`Executing ${PLUGIN_INFO.name} command`);
            
            // Example implementation
            if (args && args.length > 0) {
                console.log(`Processing arguments:`, args);
            }
            
            // Implement your plugin's main functionality here
            
            return true;
            
        } catch (error) {
            console.error(`Error executing ${PLUGIN_INFO.name} command:`, error);
            return false;
        }
    }

    {% elif plugin_type == 'completion' %}
    /**
     * Register completion providers.
     */
    private async registerCompletionProviders(): Promise<void> {
        // Register completion providers with the completion system
        const provider = new {{ plugin_name | title }}CompletionProvider();
        
        // This would integrate with the completion registry
        // completionRegistry.registerProvider(provider);
    }

    /**
     * Unregister completion providers.
     */
    private async unregisterCompletionProviders(): Promise<void> {
        // Remove providers from completion registry
    }

    {% elif plugin_type == 'hook' %}
    /**
     * Register lifecycle hooks.
     */
    private async registerHooks(): Promise<void> {
        // Register hooks with the CLI lifecycle system
    }

    /**
     * Unregister lifecycle hooks.
     */
    private async unregisterHooks(): Promise<void> {
        // Remove hooks from the lifecycle system
    }

    {% elif plugin_type == 'formatter' %}
    /**
     * Register output formatters.
     */
    private async registerFormatters(): Promise<void> {
        // Register formatters with the output system
    }

    /**
     * Unregister output formatters.
     */
    private async unregisterFormatters(): Promise<void> {
        // Remove formatters from the output system
    }

    {% elif plugin_type == 'validator' %}
    /**
     * Register input validators.
     */
    private async registerValidators(): Promise<void> {
        // Register validators with the input system
    }

    /**
     * Unregister input validators.
     */
    private async unregisterValidators(): Promise<void> {
        // Remove validators from the input system
    }
    {% endif %}

    /**
     * Check if plugin is enabled.
     */
    public isEnabled(): boolean {
        return this.enabled;
    }

    /**
     * Get plugin priority.
     */
    public getPriority(): number {
        return this.priority;
    }

    /**
     * Get plugin settings.
     */
    public getSettings(): Record<string, any> {
        return { ...this.settings };
    }
}

{% if plugin_type == 'completion' %}
/**
 * Completion provider for {{ plugin_name }}.
 */
export class {{ plugin_name | title }}CompletionProvider implements CompletionProvider {
    public priority: number;
    public enabled: boolean;

    constructor(priority: number = 50) {
        this.priority = priority;
        this.enabled = true;
    }

    /**
     * Check if this provider can handle the current context.
     * @param context Completion context
     * @returns True if provider can handle context
     */
    canProvide(context: CompletionContext): boolean {
        // Implement your completion logic here
        return context.currentCommand.includes('{{ plugin_name }}');
    }

    /**
     * Provide completion suggestions.
     * @param context Completion context
     * @returns Array of completion suggestions
     */
    async provideCompletions(context: CompletionContext): Promise<string[]> {
        const completions: string[] = [];

        // Implement your completion suggestions here
        if (context.currentWord) {
            // Example: provide completions based on current word
            const sampleCompletions = ['option1', 'option2', 'option3'];
            completions.push(...sampleCompletions.filter(c => 
                c.startsWith(context.currentWord)
            ));
        }

        return completions;
    }

    /**
     * Get provider priority.
     * @returns Provider priority
     */
    getPriority(): number {
        return this.priority;
    }

    /**
     * Check if provider is enabled.
     * @returns True if provider is enabled
     */
    isEnabled(): boolean {
        return this.enabled;
    }
}
{% endif %}

/**
 * Get plugin information.
 * @returns Plugin information
 */
export function getPluginInfo(): PluginInfo {
    return { ...PLUGIN_INFO };
}

/**
 * Create and return plugin instance.
 * @returns Plugin instance
 */
export function createPlugin(): {{ plugin_name | title }}Plugin {
    return new {{ plugin_name | title }}Plugin();
}

/**
 * Activate the plugin (entry point for plugin system).
 * @returns Promise<boolean> True if activation successful
 */
export async function activatePlugin(): Promise<boolean> {
    const plugin = createPlugin();
    return await plugin.activate();
}

/**
 * Deactivate the plugin (entry point for plugin system).
 * @returns Promise<boolean> True if deactivation successful
 */
export async function deactivatePlugin(): Promise<boolean> {
    const plugin = createPlugin();
    return await plugin.deactivate();
}

// Export constants
export { PLUGIN_INFO, PLUGIN_CONFIG };

// Test the plugin if run directly
if (require.main === module) {
    (async () => {
        const plugin = createPlugin();
        console.log('Plugin:', plugin);
        console.log('Info:', getPluginInfo());
        console.log('Activate:', await plugin.activate());
        console.log('Deactivate:', await plugin.deactivate());
    })().catch(console.error);
}