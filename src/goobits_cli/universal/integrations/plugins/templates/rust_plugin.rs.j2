// Rust Plugin Template for Goobits CLI Framework
// Generated from: {{ source_config }}

//! {{ plugin_name }} - {{ plugin_description }}
//! 
//! A Goobits CLI plugin that provides {{ plugin_type }} functionality.
//! 
//! Author: {{ plugin_author }}
//! Version: {{ plugin_version }}

use std::collections::{HashMap, HashSet};
use std::sync::{Arc, Mutex};
use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use log::{info, error, debug};
use clap::{Command, Arg, ArgMatches};

/// Plugin type enumeration
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(rename_all = "lowercase")]
pub enum PluginType {
    Command,
    Completion,
    Hook,
    Formatter,
    Validator,
    Integration,
}

/// Plugin information structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginInfo {
    pub name: String,
    pub version: String,
    pub description: String,
    pub author: String,
    pub plugin_type: PluginType,
    pub language: String,
}

/// Plugin configuration structure
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PluginConfig {
    pub enabled: bool,
    pub priority: u32,
    pub dependencies: Vec<String>,
    pub settings: HashMap<String, serde_json::Value>,
}

{% if plugin_type == 'completion' %}
/// Completion context structure
#[derive(Debug, Clone)]
pub struct CompletionContext {
    pub current_command: String,
    pub current_word: String,
    pub args: Vec<String>,
    pub cwd: std::path::PathBuf,
    pub env: HashMap<String, String>,
    pub history: Vec<String>,
    pub available_commands: HashSet<String>,
    pub available_options: HashSet<String>,
    pub metadata: HashMap<String, serde_json::Value>,
    pub language: String,
    pub config: HashMap<String, serde_json::Value>,
}

/// Completion provider trait
#[async_trait]
pub trait CompletionProvider: Send + Sync {
    fn priority(&self) -> u32;
    fn enabled(&self) -> bool;
    fn can_provide(&self, context: &CompletionContext) -> bool;
    async fn provide_completions(&self, context: &CompletionContext) -> Result<Vec<String>, Box<dyn std::error::Error>>;
}
{% endif %}

/// Plugin trait for all plugin types
#[async_trait]
pub trait Plugin: Send + Sync {
    async fn activate(&mut self) -> Result<bool, Box<dyn std::error::Error>>;
    async fn deactivate(&mut self) -> Result<bool, Box<dyn std::error::Error>>;
    fn is_enabled(&self) -> bool;
    fn get_priority(&self) -> u32;
    fn get_info(&self) -> &PluginInfo;
}

/// Plugin metadata constants
pub const PLUGIN_INFO: PluginInfo = PluginInfo {
    name: "{{ plugin_name }}".to_string(),
    version: "{{ plugin_version }}".to_string(),
    description: "{{ plugin_description }}".to_string(),
    author: "{{ plugin_author }}".to_string(),
    plugin_type: PluginType::{{ plugin_type | title }},
    language: "rust".to_string(),
};

/// Plugin configuration constants
pub const PLUGIN_CONFIG: PluginConfig = PluginConfig {
    enabled: true,
    priority: {{ plugin_priority | default(50) }},
    dependencies: vec![{% for dep in plugin_dependencies %}"{{ dep }}".to_string(){% if not loop.last %}, {% endif %}{% endfor %}],
    settings: HashMap::new(),
};

/// Main plugin structure for {{ plugin_name }}
#[derive(Debug)]
pub struct {{ plugin_name | title }}Plugin {
    enabled: bool,
    priority: u32,
    settings: HashMap<String, serde_json::Value>,
}

impl {{ plugin_name | title }}Plugin {
    /// Create a new instance of the plugin
    pub fn new() -> Self {
        info!("Initialized plugin: {} v{}", PLUGIN_INFO.name, PLUGIN_INFO.version);
        
        Self {
            enabled: PLUGIN_CONFIG.enabled,
            priority: PLUGIN_CONFIG.priority,
            settings: PLUGIN_CONFIG.settings.clone(),
        }
    }

    {% if plugin_type == 'command' %}
    /// Register plugin commands
    async fn register_commands(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Example command registration using Clap
        let command = Command::new("{{ plugin_name }}")
            .about("{{ plugin_description }}")
            .arg(Arg::new("verbose")
                .short('v')
                .long("verbose")
                .help("Enable verbose output")
                .action(clap::ArgAction::SetTrue))
            .arg(Arg::new("args")
                .help("Additional arguments")
                .num_args(0..));
        
        // Register the command with the CLI
        // This would integrate with the main CLI command registration system
        debug!("Registered command: {{ plugin_name }}");
        
        Ok(())
    }

    /// Unregister plugin commands
    async fn unregister_commands(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Unregister commands from the CLI system
        debug!("Unregistered commands for plugin: {}", PLUGIN_INFO.name);
        Ok(())
    }

    /// Execute the main plugin command logic
    pub async fn execute_command(&self, matches: &ArgMatches) -> Result<bool, Box<dyn std::error::Error>> {
        info!("Executing {} command", PLUGIN_INFO.name);
        
        // Handle verbose flag
        let verbose = matches.get_flag("verbose");
        if verbose {
            debug!("Verbose mode enabled");
        }
        
        // Handle additional arguments
        if let Some(args) = matches.get_many::<String>("args") {
            let args: Vec<&str> = args.collect();
            info!("Processing arguments: {:?}", args);
        }
        
        // Implement your plugin's main functionality here
        
        Ok(true)
    }

    {% elif plugin_type == 'completion' %}
    /// Register completion providers
    async fn register_completion_providers(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Register completion providers with the completion system
        let provider = {{ plugin_name | title }}CompletionProvider::new(self.priority);
        
        // This would integrate with the completion registry
        // completion_registry.register_provider(Box::new(provider))?;
        debug!("Registered completion provider for plugin: {}", PLUGIN_INFO.name);
        
        Ok(())
    }

    /// Unregister completion providers
    async fn unregister_completion_providers(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Remove providers from completion registry
        debug!("Unregistered completion providers for plugin: {}", PLUGIN_INFO.name);
        Ok(())
    }

    {% elif plugin_type == 'hook' %}
    /// Register lifecycle hooks
    async fn register_hooks(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Register hooks with the CLI lifecycle system
        debug!("Registered hooks for plugin: {}", PLUGIN_INFO.name);
        Ok(())
    }

    /// Unregister lifecycle hooks
    async fn unregister_hooks(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Remove hooks from the lifecycle system
        debug!("Unregistered hooks for plugin: {}", PLUGIN_INFO.name);
        Ok(())
    }

    {% elif plugin_type == 'formatter' %}
    /// Register output formatters
    async fn register_formatters(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Register formatters with the output system
        debug!("Registered formatters for plugin: {}", PLUGIN_INFO.name);
        Ok(())
    }

    /// Unregister output formatters
    async fn unregister_formatters(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Remove formatters from the output system
        debug!("Unregistered formatters for plugin: {}", PLUGIN_INFO.name);
        Ok(())
    }

    {% elif plugin_type == 'validator' %}
    /// Register input validators
    async fn register_validators(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Register validators with the input system
        debug!("Registered validators for plugin: {}", PLUGIN_INFO.name);
        Ok(())
    }

    /// Unregister input validators
    async fn unregister_validators(&self) -> Result<(), Box<dyn std::error::Error>> {
        // Remove validators from the input system
        debug!("Unregistered validators for plugin: {}", PLUGIN_INFO.name);
        Ok(())
    }
    {% endif %}
}

impl Default for {{ plugin_name | title }}Plugin {
    fn default() -> Self {
        Self::new()
    }
}

#[async_trait]
impl Plugin for {{ plugin_name | title }}Plugin {
    /// Activate the plugin
    async fn activate(&mut self) -> Result<bool, Box<dyn std::error::Error>> {
        info!("Activating plugin: {}", PLUGIN_INFO.name);
        
        {% if plugin_type == 'command' %}
        // Register commands
        self.register_commands().await?;
        {% elif plugin_type == 'completion' %}
        // Register completion providers
        self.register_completion_providers().await?;
        {% elif plugin_type == 'hook' %}
        // Register lifecycle hooks
        self.register_hooks().await?;
        {% elif plugin_type == 'formatter' %}
        // Register output formatters
        self.register_formatters().await?;
        {% elif plugin_type == 'validator' %}
        // Register input validators
        self.register_validators().await?;
        {% endif %}
        
        self.enabled = true;
        Ok(true)
    }

    /// Deactivate the plugin
    async fn deactivate(&mut self) -> Result<bool, Box<dyn std::error::Error>> {
        info!("Deactivating plugin: {}", PLUGIN_INFO.name);
        
        {% if plugin_type == 'command' %}
        // Unregister commands
        self.unregister_commands().await?;
        {% elif plugin_type == 'completion' %}
        // Unregister completion providers
        self.unregister_completion_providers().await?;
        {% elif plugin_type == 'hook' %}
        // Unregister lifecycle hooks
        self.unregister_hooks().await?;
        {% elif plugin_type == 'formatter' %}
        // Unregister output formatters
        self.unregister_formatters().await?;
        {% elif plugin_type == 'validator' %}
        // Unregister input validators
        self.unregister_validators().await?;
        {% endif %}
        
        self.enabled = false;
        Ok(true)
    }

    /// Check if plugin is enabled
    fn is_enabled(&self) -> bool {
        self.enabled
    }

    /// Get plugin priority
    fn get_priority(&self) -> u32 {
        self.priority
    }

    /// Get plugin information
    fn get_info(&self) -> &PluginInfo {
        &PLUGIN_INFO
    }
}

{% if plugin_type == 'completion' %}
/// Completion provider for {{ plugin_name }}
#[derive(Debug)]
pub struct {{ plugin_name | title }}CompletionProvider {
    priority: u32,
    enabled: bool,
}

impl {{ plugin_name | title }}CompletionProvider {
    /// Create a new completion provider
    pub fn new(priority: u32) -> Self {
        Self {
            priority,
            enabled: true,
        }
    }
}

#[async_trait]
impl CompletionProvider for {{ plugin_name | title }}CompletionProvider {
    fn priority(&self) -> u32 {
        self.priority
    }

    fn enabled(&self) -> bool {
        self.enabled
    }

    fn can_provide(&self, context: &CompletionContext) -> bool {
        // Implement your completion logic here
        context.current_command.contains("{{ plugin_name }}")
    }

    async fn provide_completions(&self, context: &CompletionContext) -> Result<Vec<String>, Box<dyn std::error::Error>> {
        let mut completions = Vec::new();

        // Implement your completion suggestions here
        if !context.current_word.is_empty() {
            // Example: provide completions based on current word
            let sample_completions = vec!["option1", "option2", "option3"];
            for completion in sample_completions {
                if completion.starts_with(&context.current_word) {
                    completions.push(completion.to_string());
                }
            }
        }

        Ok(completions)
    }
}
{% endif %}

/// Get plugin information
pub fn get_plugin_info() -> PluginInfo {
    PLUGIN_INFO.clone()
}

/// Create and return plugin instance
pub fn create_plugin() -> {{ plugin_name | title }}Plugin {
    {{ plugin_name | title }}Plugin::new()
}

/// Activate the plugin (entry point for plugin system)
pub async fn activate_plugin() -> Result<bool, Box<dyn std::error::Error>> {
    let mut plugin = create_plugin();
    plugin.activate().await
}

/// Deactivate the plugin (entry point for plugin system)
pub async fn deactivate_plugin() -> Result<bool, Box<dyn std::error::Error>> {
    let mut plugin = create_plugin();
    plugin.deactivate().await
}

#[cfg(test)]
mod tests {
    use super::*;

    #[tokio::test]
    async fn test_plugin_creation() {
        let plugin = create_plugin();
        assert!(!plugin.is_enabled()); // Starts disabled until activated
    }

    #[tokio::test] 
    async fn test_plugin_activation() {
        let mut plugin = create_plugin();
        let result = plugin.activate().await;
        assert!(result.is_ok());
        assert!(plugin.is_enabled());
    }

    #[tokio::test]
    async fn test_plugin_deactivation() {
        let mut plugin = create_plugin();
        let _ = plugin.activate().await;
        let result = plugin.deactivate().await;
        assert!(result.is_ok());
        assert!(!plugin.is_enabled());
    }

    #[test]
    fn test_plugin_info() {
        let info = get_plugin_info();
        assert_eq!(info.name, "{{ plugin_name }}");
        assert_eq!(info.version, "{{ plugin_version }}");
        assert_eq!(info.language, "rust");
    }

    {% if plugin_type == 'completion' %}
    #[tokio::test]
    async fn test_completion_provider() {
        let provider = {{ plugin_name | title }}CompletionProvider::new(50);
        assert!(provider.enabled());
        assert_eq!(provider.priority(), 50);
    }

    #[tokio::test]
    async fn test_completion_suggestions() {
        let provider = {{ plugin_name | title }}CompletionProvider::new(50);
        let context = CompletionContext {
            current_command: "{{ plugin_name }}".to_string(),
            current_word: "opt".to_string(),
            args: vec![],
            cwd: std::env::current_dir().unwrap(),
            env: HashMap::new(),
            history: vec![],
            available_commands: HashSet::new(),
            available_options: HashSet::new(),
            metadata: HashMap::new(),
            language: "rust".to_string(),
            config: HashMap::new(),
        };

        if provider.can_provide(&context) {
            let completions = provider.provide_completions(&context).await.unwrap();
            assert!(!completions.is_empty());
        }
    }
    {% endif %}
}

// Main function for testing
#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    env_logger::init();
    
    let plugin = create_plugin();
    println!("Plugin: {:?}", plugin);
    println!("Info: {:?}", get_plugin_info());
    
    let activate_result = activate_plugin().await?;
    println!("Activate: {}", activate_result);
    
    let deactivate_result = deactivate_plugin().await?;
    println!("Deactivate: {}", deactivate_result);
    
    Ok(())
}