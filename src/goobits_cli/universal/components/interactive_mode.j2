{# Universal Interactive Mode Template
   
   This template generates interactive mode for CLI applications.
   It provides a REPL interface where users can run commands interactively.
   
   If features.interactive_mode.repl is enabled, generates enhanced REPL with:
   - Multi-line command support
   - Smart completion integration  
   - Persistent command history
   - Performance optimizations
   
   Variables expected:
   - language: Target language (python, nodejs, typescript, rust)
   - project: Project metadata
   - cli: CLI schema with commands, arguments, options
   - features.interactive_mode.repl: Boolean to enable enhanced REPL features
#}

{%- set repl_enabled = features.interactive_mode.repl | default(false) -%}

{%- if repl_enabled -%}
{# Enhanced REPL Mode - Use the repl_loop.j2 template content #}
{% include 'repl_loop.j2' %}

{%- else -%}
{# Standard Interactive Mode #}

{%- if language == 'python' -%}
#!/usr/bin/env python3
"""
Interactive mode for {{ project.name }}
Generated by Goobits CLI Framework
"""

import cmd
import shlex
import sys
from typing import List, Optional
try:
    from .{{ cli.root_command.name.replace('-', '_') }}_cli import cli
    from .hooks import *  # Import all hook functions
except ImportError:
    # Fallback imports
    from {{ cli.root_command.name.replace('-', '_') }}_cli import cli
    try:
        from hooks import *
    except ImportError:
        pass

class {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive(cmd.Cmd):
    """Interactive CLI for {{ project.name }}"""
    
    intro = "Welcome to {{ project.name }} interactive mode. Type 'help' for commands, 'exit' to quit."
    prompt = "{{ cli.root_command.name }}> "
    
    def __init__(self):
        super().__init__()
        self.command_history = []
        
    def do_exit(self, arg):
        """Exit the interactive mode"""
        print("Goodbye!")
        return True
        
    def do_quit(self, arg):
        """Exit the interactive mode"""
        return self.do_exit(arg)
        
    def do_EOF(self, arg):
        """Handle Ctrl+D"""
        print()  # New line after ^D
        return True

{%- for command in cli.root_command.subcommands %}
    
    def do_{{ command.name.replace('-', '_') }}(self, arg):
        """{{ command.description }}
        
        Usage: {{ command.name }}{% for arg in command.arguments %} {% if not arg.required %}[{% endif %}{{ arg.name | upper }}{% if not arg.required %}]{% endif %}{% endfor %}{% for option in command.options %} [--{{ option.name }}{% if option.short %}|-{{ option.short }}{% endif %}]{% endfor %}
        {%- if command.arguments %}
        
        Arguments:
        {%- for arg in command.arguments %}
            {{ arg.name | upper }}: {{ arg.description }}{% if not arg.required %} (optional){% endif %}
        {%- endfor %}
        {%- endif %}
        {%- if command.options %}
        
        Options:
        {%- for option in command.options %}
            --{{ option.name }}{% if option.short %}, -{{ option.short }}{% endif %}: {{ option.description }}
        {%- endfor %}
        {%- endif %}
        """
        try:
            # Parse arguments
            args = shlex.split(arg)
            
            # Call the hook function if it exists
            hook_name = "{{ command.hook_name }}"
            if hook_name in globals():
                hook_func = globals()[hook_name]
                # Parse and validate arguments according to command definition
                import inspect
                sig = inspect.signature(hook_func)
                try:
                    bound_args = sig.bind(*args)
                    bound_args.apply_defaults()
                    hook_func(*bound_args.args, **bound_args.kwargs)
                except TypeError as e:
                    print(f"Error calling {hook_name}: {e}")
                    print(f"Expected signature: {sig}")
            else:
                print(f"Command '{{ command.name }}' executed successfully")
                print(f"To implement custom behavior, add '{hook_name}' function to hooks.py")
        except Exception as e:
            print(f"Error: {e}")
    
    def complete_{{ command.name.replace('-', '_') }}(self, text, line, begidx, endidx):
        """Tab completion for {{ command.name }} command"""
        # Basic completion for options
        options = [{% for option in command.options %}"--{{ option.name }}"{% if option.short %}, "-{{ option.short }}"{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}]
        return [opt for opt in options if opt.startswith(text)]
{%- endfor %}
    
    def default(self, line):
        """Handle unknown commands"""
        print(f"Unknown command: {line.split()[0] if line else ''}")
        print("Type 'help' for available commands")
    
    def emptyline(self):
        """Handle empty line (do nothing instead of repeating last command)"""
        pass
    
    def precmd(self, line):
        """Hook before command execution"""
        if line and not line.startswith('help'):
            self.command_history.append(line)
        return line
    
    def postcmd(self, stop, line):
        """Hook after command execution"""
        return stop

def run_interactive():
    """Launch the interactive mode"""
    try:
        {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive().cmdloop()
    except KeyboardInterrupt:
        print("\nInterrupted. Use 'exit' to quit.")
        run_interactive()

if __name__ == "__main__":
    run_interactive()

{%- elif language == 'nodejs' -%}
#!/usr/bin/env node
/**
 * Interactive mode for {{ project.name }}
 * Generated by Goobits CLI Framework
 */

const readline = require('readline');
const hooks = require('./hooks');

class {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive {
    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: '{{ cli.root_command.name }}> ',
            completer: this.completer.bind(this)
        });
        
        this.commands = {
{%- for command in cli.root_command.subcommands %}
            '{{ command.name }}': {
                description: '{{ command.description }}',
                handler: this.handle{{ command.name | replace('-', '') | title }}.bind(this)
            },
{%- endfor %}
            'help': {
                description: 'Show available commands',
                handler: this.handleHelp.bind(this)
            },
            'exit': {
                description: 'Exit interactive mode',
                handler: this.handleExit.bind(this)
            },
            'quit': {
                description: 'Exit interactive mode',
                handler: this.handleExit.bind(this)
            }
        };
        
        this.commandHistory = [];
    }
    
    start() {
        console.log("Welcome to {{ project.name }} interactive mode. Type 'help' for commands, 'exit' to quit.");
        
        this.rl.prompt();
        
        this.rl.on('line', async (line) => {
            const trimmed = line.trim();
            if (!trimmed) {
                this.rl.prompt();
                return;
            }
            
            this.commandHistory.push(trimmed);
            const [cmd, ...args] = trimmed.split(/\s+/);
            
            if (this.commands[cmd]) {
                try {
                    await this.commands[cmd].handler(args);
                } catch (error) {
                    console.error('Error:', error.message);
                }
            } else {
                console.log(`Unknown command: ${cmd}`);
                console.log("Type 'help' for available commands");
            }
            
            this.rl.prompt();
        });
        
        this.rl.on('close', () => {
            console.log('\nGoodbye!');
            process.exit(0);
        });
    }
    
    completer(line) {
        const completions = Object.keys(this.commands);
        const hits = completions.filter((c) => c.startsWith(line));
        return [hits.length ? hits : completions, line];
    }
    
    handleHelp(args) {
        console.log('\nAvailable commands:');
        for (const [cmd, info] of Object.entries(this.commands)) {
            console.log(`  ${cmd.padEnd(15)} ${info.description}`);
        }
        console.log();
    }
    
    handleExit(args) {
        this.rl.close();
    }

{%- for command in cli.root_command.subcommands %}
    
    async handle{{ command.name | replace('-', '') | title }}(args) {
        const hookName = '{{ command.hook_name }}';
        if (typeof hooks[hookName] === 'function') {
            // Parse and validate arguments for the command
            const hookName = "{{ command.hook_name }}";
            if (typeof hooks[hookName] === 'function') {
                try {
                    const result = await hooks[hookName](...args);
                    if (result !== undefined) {
                        console.log(result);
                    }
                } catch (error) {
                    console.error(`Error executing ${hookName}:`, error.message);
                }
            } else {
                console.log(`Command '{{ command.name }}' executed successfully`);
                console.log(`To implement custom behavior, add '${hookName}' function to hooks.js`);
            }
            await hooks[hookName](...args);
        } else {
            console.log(`Command '{{ command.name }}' executed successfully`);
            console.log(`To implement custom behavior, add '${hookName}' function to hooks.js`);
        }
    }
{%- endfor %}
}

function runInteractive() {
    const interactive = new {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive();
    interactive.start();
}

module.exports = { runInteractive };

if (require.main === module) {
    runInteractive();
}

{%- elif language == 'typescript' -%}
#!/usr/bin/env node
/**
 * Interactive mode for {{ project.name }}
 * Generated by Goobits CLI Framework
 */

import * as readline from 'readline';
import * as hooks from './hooks';

interface Command {
    description: string;
    handler: (args: string[]) => Promise<void>;
}

export class {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive {
    private rl: readline.Interface;
    private commands: Record<string, Command>;
    private commandHistory: string[] = [];

    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: '{{ cli.root_command.name }}> ',
            completer: this.completer.bind(this)
        });
        
        this.commands = {
{%- for command in cli.root_command.subcommands %}
            '{{ command.name }}': {
                description: '{{ command.description }}',
                handler: this.handle{{ command.name | replace('-', '') | title }}.bind(this)
            },
{%- endfor %}
            'help': {
                description: 'Show available commands',
                handler: this.handleHelp.bind(this)
            },
            'exit': {
                description: 'Exit interactive mode',
                handler: this.handleExit.bind(this)
            },
            'quit': {
                description: 'Exit interactive mode',
                handler: this.handleExit.bind(this)
            }
        };
    }
    
    public start(): void {
        console.log("Welcome to {{ project.name }} interactive mode. Type 'help' for commands, 'exit' to quit.");
        
        this.rl.prompt();
        
        this.rl.on('line', async (line: string) => {
            const trimmed = line.trim();
            if (!trimmed) {
                this.rl.prompt();
                return;
            }
            
            this.commandHistory.push(trimmed);
            const [cmd, ...args] = trimmed.split(/\s+/);
            
            if (this.commands[cmd]) {
                try {
                    await this.commands[cmd].handler(args);
                } catch (error) {
                    console.error('Error:', (error as Error).message);
                }
            } else {
                console.log(`Unknown command: ${cmd}`);
                console.log("Type 'help' for available commands");
            }
            
            this.rl.prompt();
        });
        
        this.rl.on('close', () => {
            console.log('\nGoodbye!');
            process.exit(0);
        });
    }
    
    private completer(line: string): [string[], string] {
        const completions = Object.keys(this.commands);
        const hits = completions.filter((c) => c.startsWith(line));
        return [hits.length ? hits : completions, line];
    }
    
    private async handleHelp(args: string[]): Promise<void> {
        console.log('\nAvailable commands:');
        for (const [cmd, info] of Object.entries(this.commands)) {
            console.log(`  ${cmd.padEnd(15)} ${info.description}`);
        }
        console.log();
    }
    
    private async handleExit(args: string[]): Promise<void> {
        this.rl.close();
    }

{%- for command in cli.root_command.subcommands %}
    
    private async handle{{ command.name | replace('-', '') | title }}(args: string[]): Promise<void> {
        const hookName = '{{ command.hook_name }}' as keyof typeof hooks;
        if (typeof hooks[hookName] === 'function') {
            // Parse and validate arguments for the command
            const hookName = "{{ command.hook_name }}";
            if (typeof hooks[hookName] === 'function') {
                try {
                    const result = await hooks[hookName](...args);
                    if (result !== undefined) {
                        console.log(result);
                    }
                } catch (error) {
                    console.error(`Error executing ${hookName}:`, error.message);
                }
            } else {
                console.log(`Command '{{ command.name }}' executed successfully`);
                console.log(`To implement custom behavior, add '${hookName}' function to hooks.js`);
            }
            await (hooks[hookName] as Function)(...args);
        } else {
            console.log(`Command '{{ command.name }}' executed successfully`);
            console.log(`To implement custom behavior, add '${hookName}' function to hooks.ts`);
        }
    }
{%- endfor %}
}

export function runInteractive(): void {
    const interactive = new {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive();
    interactive.start();
}

if (require.main === module) {
    runInteractive();
}

{%- elif language == 'rust' -%}
use rustyline::error::ReadlineError;
use rustyline::{DefaultEditor, Result};
use std::collections::HashMap;

mod hooks;

pub struct {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive {
    editor: DefaultEditor,
    commands: HashMap<String, fn(&[&str]) -> Result<()>>,
}

impl {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive {
    pub fn new() -> Result<Self> {
        let mut editor = DefaultEditor::new()?;
        let mut commands = HashMap::new();
        
        // Register commands
{%- for command in cli.root_command.subcommands %}
        commands.insert("{{ command.name }}".to_string(), |args| {
            match hooks::{{ command.hook_name }}(args) {
                Ok(_) => Ok(()),
                Err(e) => {
                    eprintln!("Error: {}", e);
                    Ok(())
                }
            }
        });
{%- endfor %}
        
        Ok(Self { editor, commands })
    }
    
    pub fn run(&mut self) -> Result<()> {
        println!("Welcome to {{ project.name }} interactive mode. Type 'help' for commands, 'exit' to quit.");
        
        let prompt = "{{ cli.root_command.name }}> ";
        
        loop {
            let readline = self.editor.readline(prompt);
            match readline {
                Ok(line) => {
                    if line.trim().is_empty() {
                        continue;
                    }
                    
                    self.editor.add_history_entry(line.as_str())?;
                    
                    let parts: Vec<&str> = line.trim().split_whitespace().collect();
                    if parts.is_empty() {
                        continue;
                    }
                    
                    match parts[0] {
                        "exit" | "quit" => {
                            println!("Goodbye!");
                            break;
                        }
                        "help" => {
                            self.show_help();
                        }
                        cmd => {
                            if let Some(handler) = self.commands.get(cmd) {
                                let args = &parts[1..];
                                if let Err(e) = handler(args) {
                                    eprintln!("Error executing command: {}", e);
                                }
                            } else {
                                println!("Unknown command: {}", cmd);
                                println!("Type 'help' for available commands");
                            }
                        }
                    }
                }
                Err(ReadlineError::Interrupted) => {
                    println!("^C");
                    continue;
                }
                Err(ReadlineError::Eof) => {
                    println!("^D");
                    break;
                }
                Err(err) => {
                    eprintln!("Error: {:?}", err);
                    break;
                }
            }
        }
        
        Ok(())
    }
    
    fn show_help(&self) {
        println!("\nAvailable commands:");
        println!("  {:15} {}", "help", "Show available commands");
        println!("  {:15} {}", "exit", "Exit interactive mode");
{%- for command in cli.root_command.subcommands %}
        println!("  {:15} {}", "{{ command.name }}", "{{ command.description }}");
{%- endfor %}
        println!();
    }
}

pub fn run_interactive() -> Result<()> {
    let mut interactive = {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive::new()?;
    interactive.run()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_interactive_creation() {
        let result = {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive::new();
        assert!(result.is_ok());
    }
}

{%- endif -%}

{%- endif -%}