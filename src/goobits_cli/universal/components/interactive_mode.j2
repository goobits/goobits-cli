{# Universal Interactive Mode Template
   
   This template generates interactive mode for CLI applications.
   It provides a REPL interface where users can run commands interactively.
   
   If features.interactive_mode.repl is enabled, generates enhanced REPL with:
   - Multi-line command support
   - Smart completion integration  
   - Persistent command history
   - Performance optimizations
   
   Variables expected:
   - language: Target language (python, nodejs, typescript, rust)
   - project: Project metadata
   - cli: CLI schema with commands, arguments, options
   - features.interactive_mode.repl: Boolean to enable enhanced REPL features
#}

{%- set repl_enabled = features.interactive_mode.repl | default(false) -%}
{%- set session_enabled = features.interactive_mode.session_persistence | default(false) -%}
{%- set variables_enabled = features.interactive_mode.variables | default(false) -%}
{%- set pipelines_enabled = features.interactive_mode.pipelines | default(false) -%}

{%- if repl_enabled -%}
{# Enhanced REPL Mode with embedded content #}

{%- if language == 'python' -%}
#!/usr/bin/env python3
"""
Enhanced REPL for {{ project.name }}
Generated by Goobits CLI Framework with BasicREPL support
"""

import sys
import os
import asyncio
from pathlib import Path

# Import BasicREPL and session management
try:
    from goobits_cli.universal.interactive import BasicREPL, create_basic_repl{% if session_enabled %}, SessionREPL{% endif %}{% if variables_enabled %}, VariableREPL{% endif %}{% if pipelines_enabled %}, PipelineREPL{% endif %}
    
    from goobits_cli.universal.completion.smart_completion import get_smart_completion_registry
    REPL_AVAILABLE = True
{% if session_enabled %}
    SESSION_AVAILABLE = True
{% endif %}
{% if variables_enabled %}
    VARIABLES_AVAILABLE = True
{% endif %}
{% if pipelines_enabled %}
    PIPELINES_AVAILABLE = True
{% endif %}
except ImportError:
    # Fallback to basic interactive mode
    try:
        from .{{ cli.root_command.name.replace('-', '_') }}_interactive import {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive
    except ImportError:
        from {{ cli.root_command.name.replace('-', '_') }}_interactive import {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive
    REPL_AVAILABLE = False
{% if session_enabled %}
    SESSION_AVAILABLE = False
{% endif %}
{% if variables_enabled %}
    VARIABLES_AVAILABLE = False
{% endif %}
{% if pipelines_enabled %}
    PIPELINES_AVAILABLE = False
{% endif %}

try:
    from .{{ cli.root_command.name.replace('-', '_') }}_cli import cli
    from .hooks import *  # Import all hook functions
except ImportError:
    # Fallback imports
    from {{ cli.root_command.name.replace('-', '_') }}_cli import cli
    try:
        from hooks import *
    except ImportError:
        pass


{% if pipelines_enabled %}
class {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL(PipelineREPL if PIPELINES_AVAILABLE else (VariableREPL if VARIABLES_AVAILABLE else (SessionREPL if SESSION_AVAILABLE else (BasicREPL if REPL_AVAILABLE else object)))):
    """Enhanced REPL for {{ project.name }} with pipeline operations, variable management, session management and smart completion."""
    
    def __init__(self, cli_config=None, smart_completion_enabled=True):
        """Initialize the enhanced REPL with pipeline system."""
        if PIPELINES_AVAILABLE:
            # Pipeline configuration from features
            pipeline_config = {
                'enabled': True,
                'pipeline_templates': {{ features.interactive_mode.pipeline_templates | default(true) | tojson }},
                'timeout': {{ features.interactive_mode.pipeline_timeout | default(60) | tojson }}
            }
            
            # Variable configuration from features (if enabled)
            variable_config = None
            {% if variables_enabled %}
            variable_config = {
                'enabled': True,
                'substitution': {{ features.interactive_mode.variable_expansion | default(true) | tojson }},
                'max_variables': {{ features.interactive_mode.max_variables | default(100) | tojson }}
            }
            {% endif %}
            
            # Session configuration from features (if enabled)
            session_config = None
            {% if session_enabled %}
            session_config = {
                'auto_save': {{ features.interactive_mode.auto_save | default(false) | tojson }},
                'max_sessions': {{ features.interactive_mode.max_sessions | default(20) | tojson }},
                'session_directory': {{ features.interactive_mode.session_directory | default('') | tojson }} or None,
                'auto_load_last': {{ features.interactive_mode.auto_load_last | default(false) | tojson }},
                'max_history': {{ features.interactive_mode.max_history | default(1000) | tojson }}
            }
            {% endif %}
            
            super().__init__(
                cli_config or {}, 
                pipeline_config=pipeline_config,
                variable_config=variable_config, 
                session_config=session_config, 
                smart_completion_enabled=smart_completion_enabled
            )
        elif VARIABLES_AVAILABLE:
            # Variable configuration from features
            variable_config = {
                'enabled': True,
                'substitution': {{ features.interactive_mode.variable_expansion | default(true) | tojson }},
                'max_variables': {{ features.interactive_mode.max_variables | default(100) | tojson }}
            }
            
            # Session configuration from features (if enabled)
            session_config = None
            {% if session_enabled %}
            session_config = {
                'auto_save': {{ features.interactive_mode.auto_save | default(false) | tojson }},
                'max_sessions': {{ features.interactive_mode.max_sessions | default(20) | tojson }},
                'session_directory': {{ features.interactive_mode.session_directory | default('') | tojson }} or None,
                'auto_load_last': {{ features.interactive_mode.auto_load_last | default(false) | tojson }},
                'max_history': {{ features.interactive_mode.max_history | default(1000) | tojson }}
            }
            {% endif %}
            
            super().__init__(cli_config or {}, variable_config=variable_config, session_config=session_config, smart_completion_enabled=smart_completion_enabled)
        elif SESSION_AVAILABLE:
            # Session configuration from features
            session_config = {
                'auto_save': {{ features.interactive_mode.auto_save | default(false) | tojson }},
                'max_sessions': {{ features.interactive_mode.max_sessions | default(20) | tojson }},
                'session_directory': {{ features.interactive_mode.session_directory | default('') | tojson }} or None,
                'auto_load_last': {{ features.interactive_mode.auto_load_last | default(false) | tojson }},
                'max_history': {{ features.interactive_mode.max_history | default(1000) | tojson }}
            }
            super().__init__(cli_config or {}, session_config, smart_completion_enabled=smart_completion_enabled)
        elif REPL_AVAILABLE:
            super().__init__(cli_config or {}, smart_completion_enabled)
{%- elif variables_enabled %}
class {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL(VariableREPL if VARIABLES_AVAILABLE else (SessionREPL if SESSION_AVAILABLE else (BasicREPL if REPL_AVAILABLE else object))):
    """Enhanced REPL for {{ project.name }} with variable management, session management and smart completion."""
    
    def __init__(self, cli_config=None, smart_completion_enabled=True):
        """Initialize the enhanced REPL with variable system."""
        if VARIABLES_AVAILABLE:
            # Variable configuration from features
            variable_config = {
                'enabled': True,
                'substitution': {{ features.interactive_mode.variable_expansion | default(true) | tojson }},
                'max_variables': {{ features.interactive_mode.max_variables | default(100) | tojson }}
            }
            
            # Session configuration from features (if enabled)
            session_config = None
            {% if session_enabled %}
            session_config = {
                'auto_save': {{ features.interactive_mode.auto_save | default(false) | tojson }},
                'max_sessions': {{ features.interactive_mode.max_sessions | default(20) | tojson }},
                'session_directory': {{ features.interactive_mode.session_directory | default('') | tojson }} or None,
                'auto_load_last': {{ features.interactive_mode.auto_load_last | default(false) | tojson }},
                'max_history': {{ features.interactive_mode.max_history | default(1000) | tojson }}
            }
            {% endif %}
            
            super().__init__(cli_config or {}, variable_config=variable_config, session_config=session_config, smart_completion_enabled=smart_completion_enabled)
        elif SESSION_AVAILABLE:
            # Session configuration from features
            session_config = {
                'auto_save': {{ features.interactive_mode.auto_save | default(false) | tojson }},
                'max_sessions': {{ features.interactive_mode.max_sessions | default(20) | tojson }},
                'session_directory': {{ features.interactive_mode.session_directory | default('') | tojson }} or None,
                'auto_load_last': {{ features.interactive_mode.auto_load_last | default(false) | tojson }},
                'max_history': {{ features.interactive_mode.max_history | default(1000) | tojson }}
            }
            super().__init__(cli_config or {}, session_config, smart_completion_enabled=smart_completion_enabled)
        elif REPL_AVAILABLE:
            super().__init__(cli_config or {}, smart_completion_enabled)
{%- elif session_enabled %}
class {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL(SessionREPL if SESSION_AVAILABLE else (BasicREPL if REPL_AVAILABLE else object)):
    """Enhanced REPL for {{ project.name }} with session management and smart completion."""
    
    def __init__(self, cli_config=None, smart_completion_enabled=True):
        """Initialize the enhanced REPL with session management."""
        if SESSION_AVAILABLE:
            # Session configuration from features
            session_config = {
                'auto_save': {{ features.interactive_mode.auto_save | default(false) | tojson }},
                'max_sessions': {{ features.interactive_mode.max_sessions | default(20) | tojson }},
                'session_directory': {{ features.interactive_mode.session_directory | default('') | tojson }} or None,
                'auto_load_last': {{ features.interactive_mode.auto_load_last | default(false) | tojson }},
                'max_history': {{ features.interactive_mode.max_history | default(1000) | tojson }}
            }
            super().__init__(cli_config or {}, session_config, smart_completion_enabled=smart_completion_enabled)
        elif REPL_AVAILABLE:
            super().__init__(cli_config or {}, smart_completion_enabled)
{%- else %}
class {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL(BasicREPL if REPL_AVAILABLE else object):
    """Enhanced REPL for {{ project.name }} with smart completion."""
    
    def __init__(self, cli_config=None, smart_completion_enabled=True):
        """Initialize the enhanced REPL."""
        if REPL_AVAILABLE:
            super().__init__(cli_config or {}, smart_completion_enabled)
{%- endif %}
        
        # Override prompts
        self.prompt = "{{ cli.root_command.name }}> "
        self.continuation_prompt = "{{ cli.root_command.name }}... "
        # Enhanced intro message based on available features
        feature_list = ["Multi-line commands (\\\\)", "Smart completion (TAB)", "Command history"]
        {% if pipelines_enabled %}
        if PIPELINES_AVAILABLE:
            feature_list.extend(["Pipeline operations (cmd1 | cmd2)", "Pipeline templates"])
        {% endif %}
        {% if variables_enabled %}
        if VARIABLES_AVAILABLE:
            feature_list.extend(["Variable management ($var_name)", "Session persistence"])
        {% endif %}
        {% if session_enabled %}
        elif SESSION_AVAILABLE:
            feature_list.append("Session persistence")
        {% endif %}
        
        self.intro = (
            f"Welcome to {{ project.name }} Enhanced REPL mode.\\n"
            f"Features: {', '.join(feature_list)}\\n"
            f"Type 'help' for commands, 'exit' to quit."
        )
    
    def handle_cli_command(self, command, args):
        """Handle CLI command execution with proper hook integration."""
        if not REPL_AVAILABLE:
            return self._fallback_handle_command(command, args)
        
        hook_name = command.get('hook_name', f"on_{command['name'].replace('-', '_')}")
        
        # Check if hook function exists in global scope
        if hook_name in globals():
            hook_func = globals()[hook_name]
            try:
                import inspect
                sig = inspect.signature(hook_func)
                
                # Try to bind arguments to function signature
                if len(sig.parameters) == 0:
                    # Function takes no arguments
                    result = hook_func()
                elif len(args) == 0:
                    # No args provided, try calling with no args
                    result = hook_func()
                else:
                    # Try to pass arguments
                    try:
                        bound_args = sig.bind(*args)
                        bound_args.apply_defaults()
                        result = hook_func(*bound_args.args, **bound_args.kwargs)
                    except TypeError:
                        # Fallback: pass all args as list
                        result = hook_func(args)
                
                if result is not None:
                    print(result)
                
            except Exception as e:
                print(f"Error executing {hook_name}: {e}")
                print(f"Arguments provided: {args}")
        else:
            print(f"Command '{command['name']}' executed successfully")
            print(f"To implement custom behavior, add '{hook_name}' function to hooks.py")
    
    def _fallback_handle_command(self, command, args):
        """Fallback command handling when BasicREPL not available."""
        hook_name = command.get('hook_name', f"on_{command['name'].replace('-', '_')}")
        print(f"Command '{command['name']}' executed (fallback mode)")
        print(f"To implement custom behavior, add '{hook_name}' function to hooks.py")


def run_enhanced_repl():
    """Launch the enhanced REPL with smart completion."""
    if not REPL_AVAILABLE:
        print("Enhanced REPL not available, falling back to basic interactive mode")
        try:
            interactive = {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive()
            interactive.cmdloop()
        except NameError:
            print("Basic interactive mode not available either. Running minimal REPL.")
            repl = {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL()
            if hasattr(repl, 'run'):
                repl.run()
            else:
                print("REPL functionality not available.")
        return
    
    # Build CLI config from our CLI definition
    cli_config = {
        'root_command': {
            'name': '{{ cli.root_command.name }}',
            'description': '{{ cli.root_command.description }}',
            'subcommands': [
{%- for command in cli.root_command.subcommands %}
                {
                    'name': '{{ command.name }}',
                    'description': '{{ command.description }}',
                    'hook_name': '{{ command.hook_name }}',
                    'arguments': {{ command.arguments | default([]) | tojson }},
                    'options': {{ command.options | default([]) | tojson }}
                },
{%- endfor %}
            ]
        },
        'features': {
            'interactive_mode': {
                'repl': True,
                'smart_completion': True{%- if session_enabled %},
                'session_persistence': True,
                'auto_save': {{ features.interactive_mode.auto_save | default(false) | tojson }},
                'max_sessions': {{ features.interactive_mode.max_sessions | default(20) | tojson }},
                'session_directory': {{ features.interactive_mode.session_directory | default('') | tojson }} or None,
                'auto_load_last': {{ features.interactive_mode.auto_load_last | default(false) | tojson }},
                'max_history': {{ features.interactive_mode.max_history | default(1000) | tojson }}
{%- endif %}{%- if variables_enabled %},
                'variables': True,
                'variable_expansion': {{ features.interactive_mode.variable_expansion | default(true) | tojson }},
                'variable_types': {{ features.interactive_mode.variable_types | default(true) | tojson }},
                'max_variables': {{ features.interactive_mode.max_variables | default(100) | tojson }}
{%- endif %}{%- if pipelines_enabled %},
                'pipelines': True,
                'pipeline_templates': {{ features.interactive_mode.pipeline_templates | default(true) | tojson }},
                'max_pipelines': {{ features.interactive_mode.max_pipelines | default(50) | tojson }},
                'pipeline_timeout': {{ features.interactive_mode.pipeline_timeout | default(60) | tojson }}
{%- endif %}
            }
        }
    }
    
    # Create and run enhanced REPL
    repl = {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL(cli_config, smart_completion_enabled=True)
    repl.run()


if __name__ == "__main__":
    run_enhanced_repl()

{%- elif language == 'nodejs' -%}
{# Node.js Enhanced REPL - simplified version for now #}
#!/usr/bin/env node
/**
 * Enhanced REPL for {{ project.name }}
 * Generated by Goobits CLI Framework with BasicREPL support
 */

const readline = require('readline');
const path = require('path');
const fs = require('fs');

// Import hooks
let hooks = {};
try {
    hooks = require('./hooks');
} catch (error) {
    console.warn('Warning: hooks.js not found or could not be loaded');
}

class {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL {
    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: '{{ cli.root_command.name }}> ',
            completer: this.completer.bind(this)
        });
        
        this.continuationPrompt = '{{ cli.root_command.name }}... ';
        this.multiLineBuffer = '';
        this.maxHistory = 100;
        
        // Command registry
        this.commands = {
{%- for command in cli.root_command.subcommands %}
            '{{ command.name }}': {
                description: '{{ command.description }}',
                hookName: '{{ command.hook_name }}',
                handler: this.handle{{ command.name | replace('-', '') | title }}.bind(this)
            },
{%- endfor %}
            'help': {
                description: 'Show available commands',
                handler: this.handleHelp.bind(this)
            },
            'history': {
                description: 'Show command history',
                handler: this.handleHistory.bind(this)
            },
            'exit': {
                description: 'Exit REPL mode',
                handler: this.handleExit.bind(this)
            },
            'quit': {
                description: 'Exit REPL mode', 
                handler: this.handleExit.bind(this)
            }{%- if session_enabled %},
            'save-session': {
                description: 'Save current session',
                handler: this.handleSaveSession.bind(this)
            },
            'load-session': {
                description: 'Load a saved session', 
                handler: this.handleLoadSession.bind(this)
            },
            'list-sessions': {
                description: 'List available sessions',
                handler: this.handleListSessions.bind(this)
            },
            'delete-session': {
                description: 'Delete a saved session',
                handler: this.handleDeleteSession.bind(this)
            },
            'session-stats': {
                description: 'Show session statistics',
                handler: this.handleSessionStats.bind(this)
            }
{%- endif %}{%- if variables_enabled %},
            'set': {
                description: 'Set a variable with automatic type inference',
                handler: this.handleSetVariable.bind(this)
            },
            'vars': {
                description: 'List all variables with their types and values',
                handler: this.handleListVariables.bind(this)
            },
            'unset': {
                description: 'Remove a variable',
                handler: this.handleUnsetVariable.bind(this)
            },
            'var-stats': {
                description: 'Show variable store statistics',
                handler: this.handleVariableStats.bind(this)
            }
{%- endif %}{%- if pipelines_enabled %},
            'pipeline': {
                description: 'Define a reusable pipeline template',
                handler: this.handlePipelineDefinition.bind(this)
            },
            'run': {
                description: 'Execute a pipeline template',
                handler: this.handleRunPipeline.bind(this)
            },
            'pipelines': {
                description: 'List all available pipeline templates',
                handler: this.handleListPipelines.bind(this)
            },
            'pipeline-stats': {
                description: 'Show pipeline execution statistics', 
                handler: this.handlePipelineStats.bind(this)
            }
{%- endif %}
        };
        
        this.commandHistory = [];
{%- if variables_enabled %}
        // Simple variable store for Node.js
        this.variableStore = new Map();
        this.variableConfig = {
            enabled: {{ variables_enabled | tojson }},
            substitution: {{ features.interactive_mode.variable_expansion | default(true) | tojson }},
            maxVariables: {{ features.interactive_mode.max_variables | default(100) | tojson }}
        };
{%- endif %}
{%- if pipelines_enabled %}
        // Simple pipeline system for Node.js
        this.pipelineTemplates = new Map();
        this.pipelineConfig = {
            enabled: {{ pipelines_enabled | tojson }},
            pipelineTemplates: {{ features.interactive_mode.pipeline_templates | default(true) | tojson }},
            maxPipelines: {{ features.interactive_mode.max_pipelines | default(50) | tojson }},
            timeout: {{ features.interactive_mode.pipeline_timeout | default(60) | tojson }}
        };
        this.executionHistory = [];
{%- endif %}
{%- if session_enabled %}
        this.sessionManager = null;
        this.currentSession = null;
        this.sessionConfig = {
            autoSave: {{ features.interactive_mode.auto_save | default(false) | tojson }},
            maxSessions: {{ features.interactive_mode.max_sessions | default(20) | tojson }},
            sessionDirectory: {{ features.interactive_mode.session_directory | default('') | tojson }} || null,
            maxHistory: {{ features.interactive_mode.max_history | default(1000) | tojson }}
        };
        this.initializeSessionManager();
{%- endif %}
        this.setupHistory();
    }
    
    setupHistory() {
        const historyFile = `.{{ cli.root_command.name }}_history`;
        
        // Load history from file
        try {
            if (fs.existsSync(historyFile)) {
                const history = fs.readFileSync(historyFile, 'utf8')
                    .split('\\n')
                    .filter(line => line.trim())
                    .slice(-this.maxHistory);
                this.commandHistory = history;
            }
        } catch (error) {
            // Ignore history loading errors
        }
        
        // Save history on exit
        process.on('exit', () => {
            try {
                const historyToSave = this.commandHistory
                    .slice(-this.maxHistory)
                    .join('\\n');
                fs.writeFileSync(historyFile, historyToSave);
            } catch (error) {
                // Ignore history saving errors
            }
        });
    }
    
    start() {
        console.log('Welcome to {{ project.name }} Enhanced REPL mode.');
        console.log('Features: Multi-line commands (\\\\), Tab completion, Command history');
        console.log("Type 'help' for commands, 'exit' to quit.");
        
        this.rl.prompt();
        
        this.rl.on('line', async (line) => {
            await this.handleLine(line);
        });
        
        this.rl.on('close', () => {
            console.log('\\nGoodbye!');
            process.exit(0);
        });
        
        this.rl.on('SIGINT', () => {
            console.log('\\nKeyboardInterrupt (use \\'exit\\' to quit)');
            this.multiLineBuffer = '';  // Clear partial input
            this.rl.prompt();
        });
    }
    
    async handleLine(line) {
        const trimmed = line.trim();
        
        // Handle empty input
        if (!trimmed && !this.multiLineBuffer) {
            this.rl.prompt();
            return;
        }
        
        // Parse multi-line input
        const { command, isContinuation } = this.parseMultiLineInput(trimmed);
        
        if (isContinuation) {
            // Use continuation prompt
            this.rl.setPrompt(this.continuationPrompt);
            this.rl.prompt();
            return;
        }
        
        // Reset to normal prompt
        this.rl.setPrompt('{{ cli.root_command.name }}> ');
        
        // Execute complete command
        if (command.trim()) {
            this.addToHistory(command);
            await this.executeCommand(command);
        }
        
        this.rl.prompt();
    }
    
    parseMultiLineInput(line) {
        // Check for line continuation (ends with backslash)
        if (line.endsWith('\\\\')) {
            this.multiLineBuffer += line.slice(0, -1) + ' ';
            return { command: '', isContinuation: true };
        }
        
        // Complete command
        if (this.multiLineBuffer) {
            const command = this.multiLineBuffer + line;
            this.multiLineBuffer = '';
            return { command, isContinuation: false };
        }
        
        return { command: line, isContinuation: false };
    }
    
    async executeCommand(line) {
{%- if variables_enabled %}
        // Apply variable substitution if enabled
        if (this.variableConfig && this.variableConfig.substitution) {
            const originalLine = line;
            line = this.substituteVariables(line);
            if (line !== originalLine) {
                console.log(`Expanded: ${line}`);
            }
        }
{%- endif %}
        
{%- if pipelines_enabled %}
        // Check if this is a pipeline command (contains |)
        if (this.pipelineConfig && this.pipelineConfig.enabled && 
            line.includes('|') && 
            !line.trim().startsWith('"') && 
            !line.trim().startsWith("'")) {
            
            // Execute as pipeline
            await this.executePipeline(line);
            return;
        }
{%- endif %}
        
        const [cmd, ...args] = line.split(/\\s+/);
        
        if (this.commands[cmd]) {
            try {
                await this.commands[cmd].handler(args);
            } catch (error) {
                console.error('Error:', error.message);
            }
        } else {
            console.log(`Unknown command: ${cmd}`);
            console.log("Type 'help' for available commands");
        }
    }
    
{%- if pipelines_enabled %}
    async executePipeline(line) {
        console.log(`Executing pipeline: ${line}`);
        
        // Simple pipeline execution (splits by | and processes sequentially)
        const commands = line.split('|').map(cmd => cmd.trim());
        let currentData = '';
        
        try {
            for (let i = 0; i < commands.length; i++) {
                const cmd = commands[i];
                const cmdName = cmd.split(' ')[0];
                
                // Mock command execution with delay
                await new Promise(resolve => setTimeout(resolve, 50));
                
                // Simulate different command behaviors
                if (cmdName === 'list-users') {
                    currentData = 'alice\\nbob\\ncharlie';
                    console.log(`[${cmdName}] Generated 3 users`);
                } else if (cmdName === 'filter') {
                    const users = currentData.split('\\n');
                    if (cmd.includes('--active')) {
                        currentData = users.filter(u => u !== 'charlie').join('\\n');
                        console.log(`[${cmdName}] Filtered to ${currentData.split('\\n').length} active users`);
                    }
                } else if (cmdName === 'greet') {
                    const users = currentData.split('\\n').filter(u => u);
                    const style = cmd.match(/--style\\s+(\\w+)/)?.[1] || 'casual';
                    const greetings = users.map(user => `Hello ${user} (${style})`);
                    currentData = greetings.join('\\n');
                    console.log(`[${cmdName}] Generated ${greetings.length} greetings`);
                } else {
                    console.log(`[${cmdName}] Processed data: ${cmd.split(' ').slice(1).join(' ')}`);
                }
            }
            
            if (currentData) {
                console.log('\\nFinal output:');
                console.log(currentData);
            }
            
            // Add to execution history
            this.executionHistory.push({
                pipeline: line,
                commands: commands.map(cmd => cmd.split(' ')[0]),
                success: true,
                timestamp: Date.now()
            });
            
        } catch (error) {
            console.error(`Pipeline execution error: ${error.message}`);
            
            this.executionHistory.push({
                pipeline: line,
                commands: commands.map(cmd => cmd.split(' ')[0]),
                success: false,
                timestamp: Date.now()
            });
        }
    }
{%- endif %}
    
    addToHistory(command) {
        if (command.trim() && !command.startsWith('help')) {
            this.commandHistory.push(command);
            if (this.commandHistory.length > this.maxHistory) {
                this.commandHistory.shift();
            }
        }
    }
    
    completer(line) {
        let completions = Object.keys(this.commands);
        
{%- if variables_enabled %}
        // Add variable completions for $var_name patterns
        if (this.variableConfig && this.variableConfig.enabled && line.includes('$')) {
            const dollarIndex = line.lastIndexOf('$');
            if (dollarIndex !== -1) {
                const varPrefix = line.substring(dollarIndex + 1);
                const variableCompletions = Array.from(this.variableStore.keys())
                    .filter(name => name.startsWith(varPrefix))
                    .map(name => `$${name}`);
                completions = completions.concat(variableCompletions);
            }
        }
{%- endif %}
        
        // Basic command completion
        const [cmd] = line.split(/\\s+/);
        const hits = completions.filter(c => c.startsWith(cmd));
        
        return [hits.length ? hits : completions, line];
    }
    
    async handleHelp(args) {
        console.log('\\nAvailable commands:');
        for (const [cmd, info] of Object.entries(this.commands)) {
            console.log(`  ${cmd.padEnd(15)} ${info.description}`);
        }
        console.log();
    }
    
    async handleHistory(args) {
        if (this.commandHistory.length === 0) {
            console.log('No command history available.');
            return;
        }
        
        console.log('\\nCommand history:');
        this.commandHistory.forEach((cmd, i) => {
            console.log(`${(i + 1).toString().padStart(4)}  ${cmd}`);
        });
        console.log();
    }
    
    async handleExit(args) {
{%- if session_enabled %}
        // Auto-save session on exit if configured
        if (this.sessionConfig.autoSave && this.sessionManager && this.currentSession) {
            console.log(`\nAuto-saving session '${this.currentSession}'...`);
            try {
                await this.sessionManager.saveSession(this.currentSession, this.commandHistory);
            } catch (error) {
                console.warn('Warning: Failed to auto-save session');
            }
        }
{%- endif %}
        this.rl.close();
    }
{%- if session_enabled %}
    
    initializeSessionManager() {
        // Simplified session management for Node.js
        const fs = require('fs');
        const os = require('os');
        const path = require('path');
        
        const sessionDir = this.sessionConfig.sessionDirectory || 
                          path.join(os.homedir(), '.goobits', 'sessions', '{{ cli.root_command.name }}');
        
        this.sessionManager = {
            sessionDir,
            async saveSession(name, history) {
                try {
                    await fs.promises.mkdir(sessionDir, { recursive: true });
                    const sessionData = {
                        name,
                        timestamp: Date.now(),
                        history: history.slice(-1000), // Limit history size
                        version: '1.0'
                    };
                    const sessionFile = path.join(sessionDir, `${name}.json`);
                    await fs.promises.writeFile(sessionFile, JSON.stringify(sessionData, null, 2));
                    return true;
                } catch (error) {
                    console.error(`Failed to save session: ${error.message}`);
                    return false;
                }
            },
            async loadSession(name) {
                try {
                    const sessionFile = path.join(sessionDir, `${name}.json`);
                    const data = await fs.promises.readFile(sessionFile, 'utf8');
                    const sessionData = JSON.parse(data);
                    return sessionData;
                } catch (error) {
                    return null;
                }
            },
            async listSessions() {
                try {
                    const files = await fs.promises.readdir(sessionDir);
                    const sessions = [];
                    for (const file of files) {
                        if (file.endsWith('.json')) {
                            const sessionFile = path.join(sessionDir, file);
                            try {
                                const data = await fs.promises.readFile(sessionFile, 'utf8');
                                const sessionData = JSON.parse(data);
                                const stats = await fs.promises.stat(sessionFile);
                                sessions.push({
                                    name: path.basename(file, '.json'),
                                    timestamp: sessionData.timestamp || stats.mtime.getTime(),
                                    commandCount: sessionData.history ? sessionData.history.length : 0
                                });
                            } catch (error) {
                                // Skip invalid session files
                            }
                        }
                    }
                    return sessions.sort((a, b) => b.timestamp - a.timestamp);
                } catch (error) {
                    return [];
                }
            },
            async deleteSession(name) {
                try {
                    const sessionFile = path.join(sessionDir, `${name}.json`);
                    await fs.promises.unlink(sessionFile);
                    return true;
                } catch (error) {
                    return false;
                }
            }
        };
    }
    
    async handleSaveSession(args) {
        if (args.length === 0) {
            console.log('Usage: save-session <session_name>');
            return;
        }
        
        const sessionName = args[0];
        const success = await this.sessionManager.saveSession(sessionName, this.commandHistory);
        
        if (success) {
            console.log(`Session '${sessionName}' saved successfully`);
            this.currentSession = sessionName;
        } else {
            console.log(`Failed to save session '${sessionName}'`);
        }
    }
    
    async handleLoadSession(args) {
        if (args.length === 0) {
            console.log('Usage: load-session <session_name>');
            return;
        }
        
        const sessionName = args[0];
        const sessionData = await this.sessionManager.loadSession(sessionName);
        
        if (sessionData) {
            this.commandHistory = sessionData.history || [];
            this.currentSession = sessionName;
            console.log(`Session '${sessionName}' loaded successfully (${sessionData.history?.length || 0} commands)`);
        } else {
            console.log(`Failed to load session '${sessionName}' or session not found`);
        }
    }
    
    async handleListSessions(args) {
        const sessions = await this.sessionManager.listSessions();
        
        if (sessions.length === 0) {
            console.log('No saved sessions found');
            return;
        }
        
        console.log('\nAvailable sessions:');
        console.log('Name                 Commands  Last Modified');
        console.log('─'.repeat(50));
        
        for (const session of sessions) {
            const lastMod = new Date(session.timestamp).toLocaleString();
            const current = session.name === this.currentSession ? ' (current)' : '';
            console.log(`${session.name.padEnd(20)} ${session.commandCount.toString().padEnd(9)} ${lastMod}${current}`);
        }
        console.log();
    }
    
    async handleDeleteSession(args) {
        if (args.length === 0) {
            console.log('Usage: delete-session <session_name>');
            return;
        }
        
        const sessionName = args[0];
        
        // Simple confirmation (in a real implementation, you might want a proper prompt)
        console.log(`Are you sure you want to delete session '${sessionName}'? Type 'yes' to confirm.`);
        
        // For simplicity, we'll just delete it - in a real implementation you'd wait for user input
        const success = await this.sessionManager.deleteSession(sessionName);
        
        if (success) {
            console.log(`Session '${sessionName}' deleted`);
            if (this.currentSession === sessionName) {
                this.currentSession = null;
            }
        } else {
            console.log(`Failed to delete session '${sessionName}'`);
        }
    }
    
    async handleSessionStats(args) {
        const sessions = await this.sessionManager.listSessions();
        
        console.log('\nSession Statistics:');
        console.log(`  Current session: ${this.currentSession || 'unsaved'}`);
        console.log(`  Commands in session: ${this.commandHistory.length}`);
        console.log(`  Total saved sessions: ${sessions.length}`);
        
        if (sessions.length > 0) {
            const totalCommands = sessions.reduce((sum, s) => sum + s.commandCount, 0);
            console.log(`  Total commands across all sessions: ${totalCommands}`);
        }
        
        console.log(`  Storage directory: ${this.sessionManager.sessionDir}`);
    }
{%- endif %}
{%- if variables_enabled %}
    
    async handleSetVariable(args) {
        if (!this.variableConfig.enabled) {
            console.log('Variable system is not enabled');
            return;
        }
        
        if (args.length === 0) {
            console.log('Usage: set variable_name=value');
            console.log('Examples:');
            console.log('  set name="John Doe"');
            console.log('  set count=42');
            console.log('  set debug=true');
            console.log('  set servers=["web1", "web2", "web3"]');
            return;
        }
        
        const assignment = args.join(' ');
        const eqIndex = assignment.indexOf('=');
        
        if (eqIndex === -1) {
            console.log('Error: Assignment must be in format variable_name=value');
            return;
        }
        
        const varName = assignment.substring(0, eqIndex).trim();
        const varValue = assignment.substring(eqIndex + 1).trim();
        
        if (!varName) {
            console.log('Error: Variable name cannot be empty');
            return;
        }
        
        if (this.variableStore.size >= this.variableConfig.maxVariables && !this.variableStore.has(varName)) {
            console.log(`Error: Variable limit reached (${this.variableConfig.maxVariables})`);
            return;
        }
        
        // Simple type inference for Node.js
        let parsedValue = this.inferTypeAndParse(varValue);
        const variableType = this.getVariableType(parsedValue);
        
        this.variableStore.set(varName, {
            value: parsedValue,
            type: variableType,
            createdAt: Date.now(),
            lastModified: Date.now()
        });
        
        const displayValue = this.formatValueForDisplay(parsedValue, variableType);
        console.log(`Variable set: ${varName} = ${displayValue} (${variableType})`);
    }
    
    async handleListVariables(args) {
        if (!this.variableConfig.enabled) {
            console.log('Variable system is not enabled');
            return;
        }
        
        if (this.variableStore.size === 0) {
            console.log('No variables defined');
            return;
        }
        
        console.log('\\nDefined variables:');
        console.log('Name                 Type      Value');
        console.log('─'.repeat(50));
        
        for (const [name, variable] of this.variableStore.entries()) {
            const displayValue = this.formatValueForDisplay(variable.value, variable.type);
            const truncatedValue = displayValue.length > 30 ? displayValue.substring(0, 27) + '...' : displayValue;
            console.log(`${name.padEnd(20)} ${variable.type.padEnd(9)} ${truncatedValue}`);
        }
        console.log();
    }
    
    async handleUnsetVariable(args) {
        if (!this.variableConfig.enabled) {
            console.log('Variable system is not enabled');
            return;
        }
        
        if (args.length === 0) {
            console.log('Usage: unset variable_name');
            return;
        }
        
        const varName = args[0];
        if (this.variableStore.delete(varName)) {
            console.log(`Variable unset: ${varName}`);
        } else {
            console.log(`Variable not found: ${varName}`);
        }
    }
    
    async handleVariableStats(args) {
        if (!this.variableConfig.enabled) {
            console.log('Variable system is not enabled');
            return;
        }
        
        const typeDistribution = {};
        let totalMemory = 0;
        
        for (const [name, variable] of this.variableStore.entries()) {
            typeDistribution[variable.type] = (typeDistribution[variable.type] || 0) + 1;
            totalMemory += JSON.stringify(variable.value).length;
        }
        
        console.log('\\nVariable Store Statistics:');
        console.log(`  Total variables: ${this.variableStore.size}`);
        console.log(`  Usage: ${((this.variableStore.size / this.variableConfig.maxVariables) * 100).toFixed(1)}% of ${this.variableConfig.maxVariables} max`);
        console.log(`  Memory usage estimate: ${totalMemory} bytes`);
        
        if (Object.keys(typeDistribution).length > 0) {
            console.log('  Type distribution:');
            for (const [type, count] of Object.entries(typeDistribution)) {
                console.log(`    ${type}: ${count}`);
            }
        }
        console.log();
    }
    
    inferTypeAndParse(rawValue) {
        rawValue = rawValue.trim();
        
        if (!rawValue) return '';
        
        // Try number parsing
        if (/^-?(?:0|[1-9]\\d*)(?:\\.\\d+)?(?:[eE][+-]?\\d+)?$/.test(rawValue)) {
            const num = Number(rawValue);
            return isNaN(num) ? rawValue : num;
        }
        
        // Try boolean parsing
        if (/^(?:true|false|yes|no|on|off|1|0)$/i.test(rawValue)) {
            const lower = rawValue.toLowerCase();
            return ['true', 'yes', 'on', '1'].includes(lower);
        }
        
        // Try JSON parsing
        if ((rawValue.startsWith('[') && rawValue.endsWith(']')) ||
            (rawValue.startsWith('{') && rawValue.endsWith('}'))) {
            try {
                return JSON.parse(rawValue);
            } catch {
                // Fall through to string
            }
        }
        
        // Remove quotes if present
        if ((rawValue.startsWith('"') && rawValue.endsWith('"')) ||
            (rawValue.startsWith("'") && rawValue.endsWith("'"))) {
            return rawValue.slice(1, -1);
        }
        
        return rawValue;
    }
    
    getVariableType(value) {
        if (typeof value === 'string') return 'string';
        if (typeof value === 'number') return 'number';
        if (typeof value === 'boolean') return 'boolean';
        if (Array.isArray(value)) return 'array';
        if (typeof value === 'object' && value !== null) return 'object';
        return 'string';
    }
    
    formatValueForDisplay(value, type) {
        if (type === 'string') return `"${value}"`;
        if (type === 'array' || type === 'object') return JSON.stringify(value);
        return String(value);
    }
    
    substituteVariables(commandLine) {
        if (!this.variableConfig.substitution || !commandLine.includes('$')) {
            return commandLine;
        }
        
        return commandLine.replace(/\\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (match, varName) => {
            const variable = this.variableStore.get(varName);
            if (!variable) {
                console.warn(`Undefined variable: ${varName}`);
                return match; // Return original $var_name
            }
            
            const value = variable.value;
            if (Array.isArray(value)) {
                return value.join(' ');
            } else if (typeof value === 'object' && value !== null) {
                return JSON.stringify(value);
            } else if (typeof value === 'string' && (value.includes(' ') || value.includes('"'))) {
                return `"${value.replace(/"/g, '\\\\"')}"`;
            }
            return String(value);
        });
    }
{%- endif %}
{%- if pipelines_enabled %}
    
    async handlePipelineDefinition(args) {
        if (!this.pipelineConfig.enabled) {
            console.log('Pipeline system is not enabled');
            return;
        }
        
        if (args.length === 0) {
            console.log('Usage: pipeline name { command1 | command2 | command3 }');
            console.log('       pipeline name(param1,param2) { command1 --arg $param1 | command2 }');
            console.log('Examples:');
            console.log('  pipeline greet_users { list-users | greet --style casual }');
            console.log('  pipeline process_data(format) { load-data | transform --format $format | save-output }');
            return;
        }
        
        const definition = args.join(' ');
        
        // Parse pipeline definition using regex
        const match = definition.match(/(\w+)(?:\\(([^)]*)\\))?\\s*\\{\\s*([^}]+)\\s*\\}/);
        if (!match) {
            console.log('Error: Invalid pipeline definition format');
            console.log('Expected: pipeline_name { commands } or pipeline_name(params) { commands }');
            return;
        }
        
        const pipelineName = match[1];
        const parametersStr = match[2] || '';
        const commands = match[3];
        
        // Parse parameters
        const parameters = parametersStr ? parametersStr.split(',').map(p => p.trim()).filter(p => p) : [];
        
        if (this.pipelineTemplates.size >= this.pipelineConfig.maxPipelines && !this.pipelineTemplates.has(pipelineName)) {
            console.log(`Error: Pipeline limit reached (${this.pipelineConfig.maxPipelines})`);
            return;
        }
        
        this.pipelineTemplates.set(pipelineName, {
            name: pipelineName,
            commands: commands.split('|').map(cmd => cmd.trim()),
            parameters: parameters,
            description: `Pipeline with ${commands.split('|').length} commands`,
            createdAt: Date.now(),
            usageCount: 0
        });
        
        const paramInfo = parameters.length > 0 ? ` with parameters: ${parameters.join(', ')}` : '';
        console.log(`Pipeline template '${pipelineName}' defined successfully${paramInfo}`);
    }
    
    async handleRunPipeline(args) {
        if (!this.pipelineConfig.enabled) {
            console.log('Pipeline system is not enabled');
            return;
        }
        
        if (args.length === 0) {
            console.log('Usage: run pipeline_name [param1=value1] [param2=value2]');
            console.log('Example: run greet_users style=formal');
            return;
        }
        
        const pipelineName = args[0];
        const template = this.pipelineTemplates.get(pipelineName);
        
        if (!template) {
            console.log(`Pipeline template '${pipelineName}' not found`);
            return;
        }
        
        // Parse parameter values
        const parameterValues = {};
        for (let i = 1; i < args.length; i++) {
            const arg = args[i];
            if (arg.includes('=')) {
                const [key, value] = arg.split('=', 2);
                parameterValues[key.trim()] = value.trim();
            }
        }
        
        // Substitute parameters in commands
        let commandLine = template.commands.join(' | ');
        
        if (template.parameters.length > 0) {
            for (const param of template.parameters) {
                if (parameterValues[param]) {
                    commandLine = commandLine.replace(new RegExp(`\\\\$${param}`, 'g'), parameterValues[param]);
                }
            }
        }
        
        // Execute the pipeline (simplified simulation)
        template.usageCount++;
        
        console.log(`Executing pipeline '${pipelineName}': ${commandLine}`);
        
        // Simulate pipeline execution
        const commands = commandLine.split(' | ').map(cmd => cmd.trim());
        let currentData = '';
        
        for (let i = 0; i < commands.length; i++) {
            const cmd = commands[i];
            const cmdName = cmd.split(' ')[0];
            
            // Mock command execution
            await new Promise(resolve => setTimeout(resolve, 100)); // Simulate processing
            
            if (cmdName === 'list-users') {
                currentData = 'alice\\nbob\\ncharlie';
                console.log(`[${cmdName}] Generated 3 users`);
            } else if (cmdName === 'filter') {
                const users = currentData.split('\\n');
                if (cmd.includes('--active')) {
                    currentData = users.filter(u => u !== 'charlie').join('\\n'); // Mock filter
                    console.log(`[${cmdName}] Filtered to ${currentData.split('\\n').length} active users`);
                }
            } else if (cmdName === 'greet') {
                const users = currentData.split('\\n').filter(u => u);
                const style = cmd.match(/--style\\s+(\\w+)/)?.[1] || 'casual';
                const greetings = users.map(user => `Hello ${user} (${style})`);
                currentData = greetings.join('\\n');
                console.log(`[${cmdName}] Generated ${greetings.length} greetings`);
            } else {
                console.log(`[${cmdName}] Processed data`);
            }
        }
        
        if (currentData) {
            console.log('\\nFinal output:');
            console.log(currentData);
        }
        
        // Add to execution history
        this.executionHistory.push({
            pipeline: commandLine,
            commands: commands.map(cmd => cmd.split(' ')[0]),
            success: true,
            timestamp: Date.now()
        });
        
        console.log(`\\nPipeline '${pipelineName}' completed successfully`);
    }
    
    async handleListPipelines(args) {
        if (!this.pipelineConfig.enabled) {
            console.log('Pipeline system is not enabled');
            return;
        }
        
        if (this.pipelineTemplates.size === 0) {
            console.log('No pipeline templates defined');
            console.log('Use \\'pipeline name { commands }\\' to define a template');
            return;
        }
        
        console.log('\\nAvailable pipeline templates:');
        console.log('Name                 Commands  Parameters       Usage    Description');
        console.log('─'.repeat(80));
        
        const templates = Array.from(this.pipelineTemplates.values())
            .sort((a, b) => b.usageCount - a.usageCount || a.name.localeCompare(b.name));
        
        for (const template of templates) {
            const params = template.parameters.length > 0 ? template.parameters.join(', ') : 'none';
            const paramsTrunc = params.length > 12 ? params.substring(0, 9) + '...' : params;
            const descTrunc = template.description.length > 25 ? template.description.substring(0, 22) + '...' : template.description;
            
            console.log(`${template.name.padEnd(20)} ${template.commands.length.toString().padEnd(9)} ${paramsTrunc.padEnd(16)} ${template.usageCount.toString().padEnd(8)} ${descTrunc}`);
        }
        
        console.log(`\\nTotal: ${templates.length} templates`);
        console.log('Use \\'run template_name\\' to execute a template');
    }
    
    async handlePipelineStats(args) {
        if (!this.pipelineConfig.enabled) {
            console.log('Pipeline system is not enabled');
            return;
        }
        
        const totalExecutions = this.executionHistory.length;
        const successfulExecutions = this.executionHistory.filter(exec => exec.success).length;
        const totalTemplates = this.pipelineTemplates.size;
        
        let mostUsedTemplate = null;
        if (totalTemplates > 0) {
            const templates = Array.from(this.pipelineTemplates.values());
            mostUsedTemplate = templates.reduce((max, template) => 
                template.usageCount > (max?.usageCount || 0) ? template : max, null)?.name;
        }
        
        console.log('\\nPipeline Execution Statistics:');
        console.log(`  Total executions: ${totalExecutions}`);
        console.log(`  Success rate: ${totalExecutions > 0 ? (successfulExecutions / totalExecutions * 100).toFixed(1) : 0}%`);
        console.log(`  Total templates: ${totalTemplates}`);
        
        if (mostUsedTemplate) {
            console.log(`  Most used template: ${mostUsedTemplate}`);
        }
        
        if (this.executionHistory.length > 0) {
            console.log('\\n  Recent executions:');
            const recent = this.executionHistory.slice(-5);
            for (const exec of recent) {
                const status = exec.success ? '✓' : '✗';
                const commands = exec.commands.join(' | ');
                const cmdsTrunc = commands.length > 40 ? commands.substring(0, 37) + '...' : commands;
                console.log(`    ${status} ${cmdsTrunc}`);
            }
        }
        
        console.log();
    }
{%- endif %}

{%- for command in cli.root_command.subcommands %}
    
    async handle{{ command.name | replace('-', '') | title }}(args) {
        const hookName = '{{ command.hook_name }}';
        if (typeof hooks[hookName] === 'function') {
            try {
                const result = await hooks[hookName](...args);
                if (result !== undefined) {
                    console.log(result);
                }
            } catch (error) {
                console.error(`Error executing ${hookName}:`, error.message);
            }
        } else {
            console.log(`Command '{{ command.name }}' executed successfully`);
            console.log(`To implement custom behavior, add '${hookName}' function to hooks.js`);
        }
    }
{%- endfor %}
}

function runEnhancedREPL() {
    const repl = new {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL();
    repl.start();
}

module.exports = { runEnhancedREPL };

if (require.main === module) {
    runEnhancedREPL();
}

{%- elif language == 'typescript' -%}
{# TypeScript Enhanced REPL - similar to Node.js but with types #}
#!/usr/bin/env node
/**
 * Enhanced REPL for {{ project.name }}
 * Generated by Goobits CLI Framework with BasicREPL support
 */

import * as readline from 'readline';
import * as path from 'path';
import * as fs from 'fs';

// Import hooks
let hooks: any = {};
try {
    hooks = require('./hooks');
} catch (error) {
    console.warn('Warning: hooks.ts not found or could not be loaded');
}

interface Command {
    description: string;
    hookName?: string;
    handler: (args: string[]) => Promise<void>;
}

export class {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL {
    private rl: readline.Interface;
    private commands: Record<string, Command>;
    private commandHistory: string[] = [];
    private multiLineBuffer: string = '';
    private readonly maxHistory: number = 100;
    private readonly continuationPrompt: string = '{{ cli.root_command.name }}... ';

    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: '{{ cli.root_command.name }}> ',
            completer: this.completer.bind(this)
        });
        
        this.commands = {
{%- for command in cli.root_command.subcommands %}
            '{{ command.name }}': {
                description: '{{ command.description }}',
                hookName: '{{ command.hook_name }}',
                handler: this.handle{{ command.name | replace('-', '') | title }}.bind(this)
            },
{%- endfor %}
            'help': {
                description: 'Show available commands',
                handler: this.handleHelp.bind(this)
            },
            'history': {
                description: 'Show command history',
                handler: this.handleHistory.bind(this)
            },
            'exit': {
                description: 'Exit REPL mode',
                handler: this.handleExit.bind(this)
            },
            'quit': {
                description: 'Exit REPL mode',
                handler: this.handleExit.bind(this)
            }{%- if session_enabled %},
            'save-session': {
                description: 'Save current session',
                handler: this.handleSaveSession.bind(this)
            },
            'load-session': {
                description: 'Load a saved session',
                handler: this.handleLoadSession.bind(this)
            },
            'list-sessions': {
                description: 'List available sessions',
                handler: this.handleListSessions.bind(this)
            },
            'delete-session': {
                description: 'Delete a saved session',
                handler: this.handleDeleteSession.bind(this)
            },
            'session-stats': {
                description: 'Show session statistics',
                handler: this.handleSessionStats.bind(this)
            }
{%- endif %}
        };
        
        this.setupHistory();
    }
    
    private setupHistory(): void {
        const historyFile = `.{{ cli.root_command.name }}_history`;
        
        // Load history from file
        try {
            if (fs.existsSync(historyFile)) {
                const history = fs.readFileSync(historyFile, 'utf8')
                    .split('\\n')
                    .filter(line => line.trim())
                    .slice(-this.maxHistory);
                this.commandHistory = history;
            }
        } catch (error) {
            // Ignore history loading errors
        }
        
        // Save history on exit
        process.on('exit', () => {
            try {
                const historyToSave = this.commandHistory
                    .slice(-this.maxHistory)
                    .join('\\n');
                fs.writeFileSync(historyFile, historyToSave);
            } catch (error) {
                // Ignore history saving errors
            }
        });
    }
    
    public start(): void {
        console.log('Welcome to {{ project.name }} Enhanced REPL mode.');
        console.log('Features: Multi-line commands (\\\\), Tab completion, Command history');
        console.log("Type 'help' for commands, 'exit' to quit.");
        
        this.rl.prompt();
        
        this.rl.on('line', async (line: string) => {
            await this.handleLine(line);
        });
        
        this.rl.on('close', () => {
            console.log('\\nGoodbye!');
            process.exit(0);
        });
        
        this.rl.on('SIGINT', () => {
            console.log('\\nKeyboardInterrupt (use \\'exit\\' to quit)');
            this.multiLineBuffer = '';  // Clear partial input
            this.rl.prompt();
        });
    }
    
    private async handleLine(line: string): Promise<void> {
        const trimmed = line.trim();
        
        // Handle empty input
        if (!trimmed && !this.multiLineBuffer) {
            this.rl.prompt();
            return;
        }
        
        // Parse multi-line input
        const { command, isContinuation } = this.parseMultiLineInput(trimmed);
        
        if (isContinuation) {
            // Use continuation prompt
            this.rl.setPrompt(this.continuationPrompt);
            this.rl.prompt();
            return;
        }
        
        // Reset to normal prompt
        this.rl.setPrompt('{{ cli.root_command.name }}> ');
        
        // Execute complete command
        if (command.trim()) {
            this.addToHistory(command);
            await this.executeCommand(command);
        }
        
        this.rl.prompt();
    }
    
    private parseMultiLineInput(line: string): { command: string; isContinuation: boolean } {
        // Check for line continuation (ends with backslash)
        if (line.endsWith('\\\\')) {
            this.multiLineBuffer += line.slice(0, -1) + ' ';
            return { command: '', isContinuation: true };
        }
        
        // Complete command
        if (this.multiLineBuffer) {
            const command = this.multiLineBuffer + line;
            this.multiLineBuffer = '';
            return { command, isContinuation: false };
        }
        
        return { command: line, isContinuation: false };
    }
    
    private async executeCommand(line: string): Promise<void> {
        const [cmd, ...args] = line.split(/\\s+/);
        
        if (this.commands[cmd]) {
            try {
                await this.commands[cmd].handler(args);
            } catch (error) {
                console.error('Error:', (error as Error).message);
            }
        } else {
            console.log(`Unknown command: ${cmd}`);
            console.log("Type 'help' for available commands");
        }
    }
    
    private addToHistory(command: string): void {
        if (command.trim() && !command.startsWith('help')) {
            this.commandHistory.push(command);
            if (this.commandHistory.length > this.maxHistory) {
                this.commandHistory.shift();
            }
        }
    }
    
    private completer(line: string): [string[], string] {
        const completions = Object.keys(this.commands);
        
        // Basic command completion
        const [cmd] = line.split(/\\s+/);
        const hits = completions.filter(c => c.startsWith(cmd));
        
        return [hits.length ? hits : completions, line];
    }
    
    private async handleHelp(args: string[]): Promise<void> {
        console.log('\\nAvailable commands:');
        for (const [cmd, info] of Object.entries(this.commands)) {
            console.log(`  ${cmd.padEnd(15)} ${info.description}`);
        }
        console.log();
    }
    
    private async handleHistory(args: string[]): Promise<void> {
        if (this.commandHistory.length === 0) {
            console.log('No command history available.');
            return;
        }
        
        console.log('\\nCommand history:');
        this.commandHistory.forEach((cmd, i) => {
            console.log(`${(i + 1).toString().padStart(4)}  ${cmd}`);
        });
        console.log();
    }
    
    private async handleExit(args: string[]): Promise<void> {
        this.rl.close();
    }

{%- for command in cli.root_command.subcommands %}
    
    private async handle{{ command.name | replace('-', '') | title }}(args: string[]): Promise<void> {
        const hookName = '{{ command.hook_name }}';
        if (typeof hooks[hookName] === 'function') {
            try {
                const result = await hooks[hookName](...args);
                if (result !== undefined) {
                    console.log(result);
                }
            } catch (error) {
                console.error(`Error executing ${hookName}:`, (error as Error).message);
            }
        } else {
            console.log(`Command '{{ command.name }}' executed successfully`);
            console.log(`To implement custom behavior, add '${hookName}' function to hooks.ts`);
        }
    }
{%- endfor %}
}

export function runEnhancedREPL(): void {
    const repl = new {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL();
    repl.start();
}

if (require.main === module) {
    runEnhancedREPL();
}

{%- elif language == 'rust' -%}
{# Rust Enhanced REPL - simplified version for now #}
use std::collections::HashMap;
use std::fs;
use std::io::{self, Write};

// For now, we'll create a basic implementation without rustyline dependency
pub struct {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL {
    commands: HashMap<String, fn(&[String]) -> Result<(), Box<dyn std::error::Error>>>,
    history: Vec<String>,
    max_history: usize,
}

impl {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL {
    pub fn new() -> Result<Self, Box<dyn std::error::Error>> {
        let mut commands = HashMap::new();
        
{%- for command in cli.root_command.subcommands %}
        commands.insert("{{ command.name }}".to_string(), |args| {
            println!("Command '{{ command.name }}' executed with args: {:?}", args);
            println!("To implement custom behavior, add '{{ command.hook_name }}' function to hooks.rs");
            Ok(())
        });
{%- endfor %}
        
        let max_history = 100;
        
        Ok(Self {
            commands,
            history: Vec::new(),
            max_history,
        })
    }
    
    pub fn run(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        println!("Welcome to {{ project.name }} Enhanced REPL mode.");
        println!("Features: Multi-line commands (\\\\), Command history");
        println!("Type 'help' for commands, 'exit' to quit.");
        
        let mut multi_line_buffer = String::new();
        
        loop {
            let prompt = if multi_line_buffer.is_empty() {
                "{{ cli.root_command.name }}> "
            } else {
                "{{ cli.root_command.name }}... "
            };
            
            print!("{}", prompt);
            io::stdout().flush()?;
            
            let mut input = String::new();
            match io::stdin().read_line(&mut input) {
                Ok(0) => {
                    // EOF (Ctrl+D)
                    println!("\\nGoodbye!");
                    break;
                }
                Ok(_) => {
                    let trimmed = input.trim();
                    
                    if trimmed.is_empty() && multi_line_buffer.is_empty() {
                        continue;
                    }
                    
                    // Parse multi-line input
                    let (complete_command, is_continuation) = 
                        self.parse_multi_line_input(trimmed, &mut multi_line_buffer);
                    
                    if is_continuation {
                        continue;
                    }
                    
                    if !complete_command.trim().is_empty() {
                        self.add_to_history(complete_command.clone());
                        self.execute_command(&complete_command)?;
                    }
                }
                Err(error) => {
                    eprintln!("Error reading input: {}", error);
                    break;
                }
            }
        }
        
        Ok(())
    }
    
    fn parse_multi_line_input(&self, line: &str, buffer: &mut String) -> (String, bool) {
        // Check for line continuation (ends with backslash)
        if line.ends_with("\\\\") {
            // Add to buffer without the backslash
            buffer.push_str(&line[..line.len()-1]);
            buffer.push(' ');
            return (String::new(), true);
        }
        
        // Complete command
        if !buffer.is_empty() {
            let complete_command = format!("{}{}", buffer, line);
            buffer.clear();
            return (complete_command, false);
        }
        
        (line.to_string(), false)
    }
    
    fn execute_command(&self, line: &str) -> Result<(), Box<dyn std::error::Error>> {
        let parts: Vec<String> = line.split_whitespace()
            .map(|s| s.to_string())
            .collect();
        
        if parts.is_empty() {
            return Ok(());
        }
        
        let cmd = &parts[0];
        let args = &parts[1..];
        
        match cmd.as_str() {
            "exit" | "quit" => {
                println!("Goodbye!");
                std::process::exit(0);
            }
            "help" => {
                self.show_help();
            }
            "history" => {
                self.show_history();
            }
            _ => {
                if let Some(handler) = self.commands.get(cmd) {
                    if let Err(e) = handler(args) {
                        eprintln!("Error executing command: {}", e);
                    }
                } else {
                    println!("Unknown command: {}", cmd);
                    println!("Type 'help' for available commands");
                }
            }
        }
        
        Ok(())
    }
    
    fn add_to_history(&mut self, command: String) {
        if !command.trim().is_empty() && !command.starts_with("help") {
            self.history.push(command);
            if self.history.len() > self.max_history {
                self.history.remove(0);
            }
        }
    }
    
    fn show_help(&self) {
        println!("\\nAvailable commands:");
        println!("  {:15} {}", "help", "Show available commands");
        println!("  {:15} {}", "history", "Show command history");
        println!("  {:15} {}", "exit", "Exit REPL mode");
{%- for command in cli.root_command.subcommands %}
        println!("  {:15} {}", "{{ command.name }}", "{{ command.description }}");
{%- endfor %}
        println!();
    }
    
    fn show_history(&self) {
        if self.history.is_empty() {
            println!("No command history available.");
            return;
        }
        
        println!("\\nCommand history:");
        for (i, cmd) in self.history.iter().enumerate() {
            println!("{:4}  {}", i + 1, cmd);
        }
        println!();
    }
}

pub fn run_enhanced_repl() -> Result<(), Box<dyn std::error::Error>> {
    let mut repl = {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL::new()?;
    repl.run()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_repl_creation() {
        let result = {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL::new();
        assert!(result.is_ok());
    }
}

{%- endif -%}

{%- else -%}
{# Standard Interactive Mode #}

{%- if language == 'python' -%}
#!/usr/bin/env python3
"""
Interactive mode for {{ project.name }}
Generated by Goobits CLI Framework
"""

import cmd
import shlex
import sys
from typing import List, Optional
try:
    from .{{ cli.root_command.name.replace('-', '_') }}_cli import cli
    from .hooks import *  # Import all hook functions
except ImportError:
    # Fallback imports
    from {{ cli.root_command.name.replace('-', '_') }}_cli import cli
    try:
        from hooks import *
    except ImportError:
        pass

class {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive(cmd.Cmd):
    """Interactive CLI for {{ project.name }}"""
    
    intro = "Welcome to {{ project.name }} interactive mode. Type 'help' for commands, 'exit' to quit."
    prompt = "{{ cli.root_command.name }}> "
    
    def __init__(self):
        super().__init__()
        self.command_history = []
        
    def do_exit(self, arg):
        """Exit the interactive mode"""
        print("Goodbye!")
        return True
        
    def do_quit(self, arg):
        """Exit the interactive mode"""
        return self.do_exit(arg)
        
    def do_EOF(self, arg):
        """Handle Ctrl+D"""
        print()  # New line after ^D
        return True

{%- for command in cli.root_command.subcommands %}
    
    def do_{{ command.name.replace('-', '_') }}(self, arg):
        """{{ command.description }}
        
        Usage: {{ command.name }}{% for arg in command.arguments %} {% if not arg.required %}[{% endif %}{{ arg.name | upper }}{% if not arg.required %}]{% endif %}{% endfor %}{% for option in command.options %} [--{{ option.name }}{% if option.short %}|-{{ option.short }}{% endif %}]{% endfor %}
        {%- if command.arguments %}
        
        Arguments:
        {%- for arg in command.arguments %}
            {{ arg.name | upper }}: {{ arg.description }}{% if not arg.required %} (optional){% endif %}
        {%- endfor %}
        {% endif %}
        {%- if command.options %}
        
        Options:
        {%- for option in command.options %}
            --{{ option.name }}{% if option.short %}, -{{ option.short }}{% endif %}: {{ option.description }}
        {%- endfor %}
        {% endif %}
        """
        try:
            # Parse arguments
            args = shlex.split(arg)
            
            # Call the hook function if it exists
            hook_name = "{{ command.hook_name }}"
            if hook_name in globals():
                hook_func = globals()[hook_name]
                # Parse and validate arguments according to command definition
                import inspect
                sig = inspect.signature(hook_func)
                try:
                    bound_args = sig.bind(*args)
                    bound_args.apply_defaults()
                    hook_func(*bound_args.args, **bound_args.kwargs)
                except TypeError as e:
                    print(f"Error calling {hook_name}: {e}")
                    print(f"Expected signature: {sig}")
            else:
                print(f"Command '{{ command.name }}' executed successfully")
                print(f"To implement custom behavior, add '{hook_name}' function to hooks.py")
        except Exception as e:
            print(f"Error: {e}")
    
    def complete_{{ command.name.replace('-', '_') }}(self, text, line, begidx, endidx):
        """Tab completion for {{ command.name }} command"""
        # Basic completion for options
        options = [{% for option in command.options %}"--{{ option.name }}"{% if option.short %}, "-{{ option.short }}"{% endif %}{% if not loop.last %}, {% endif %}{% endfor %}]
        return [opt for opt in options if opt.startswith(text)]
{%- endfor %}
    
    def default(self, line):
        """Handle unknown commands"""
        print(f"Unknown command: {line.split()[0] if line else ''}")
        print("Type 'help' for available commands")
    
    def emptyline(self):
        """Handle empty line (do nothing instead of repeating last command)"""
        pass
    
    def precmd(self, line):
        """Hook before command execution"""
        if line and not line.startswith('help'):
            self.command_history.append(line)
        return line
    
    def postcmd(self, stop, line):
        """Hook after command execution"""
        return stop

def run_interactive():
    """Launch the interactive mode"""
    try:
        {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive().cmdloop()
    except KeyboardInterrupt:
        print("\nInterrupted. Use 'exit' to quit.")
        run_interactive()

if __name__ == "__main__":
    run_interactive()

{%- elif language == 'nodejs' -%}
#!/usr/bin/env node
/**
 * Interactive mode for {{ project.name }}
 * Generated by Goobits CLI Framework
 */

const readline = require('readline');
const hooks = require('./hooks');

class {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive {
    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: '{{ cli.root_command.name }}> ',
            completer: this.completer.bind(this)
        });
        
        this.commands = {
{%- for command in cli.root_command.subcommands %}
            '{{ command.name }}': {
                description: '{{ command.description }}',
                handler: this.handle{{ command.name | replace('-', '') | title }}.bind(this)
            },
{%- endfor %}
            'help': {
                description: 'Show available commands',
                handler: this.handleHelp.bind(this)
            },
            'exit': {
                description: 'Exit interactive mode',
                handler: this.handleExit.bind(this)
            },
            'quit': {
                description: 'Exit interactive mode',
                handler: this.handleExit.bind(this)
            }
        };
        
        this.commandHistory = [];
    }
    
    start() {
        console.log("Welcome to {{ project.name }} interactive mode. Type 'help' for commands, 'exit' to quit.");
        
        this.rl.prompt();
        
        this.rl.on('line', async (line) => {
            const trimmed = line.trim();
            if (!trimmed) {
                this.rl.prompt();
                return;
            }
            
            this.commandHistory.push(trimmed);
            const [cmd, ...args] = trimmed.split(/\s+/);
            
            if (this.commands[cmd]) {
                try {
                    await this.commands[cmd].handler(args);
                } catch (error) {
                    console.error('Error:', error.message);
                }
            } else {
                console.log(`Unknown command: ${cmd}`);
                console.log("Type 'help' for available commands");
            }
            
            this.rl.prompt();
        });
        
        this.rl.on('close', () => {
            console.log('\nGoodbye!');
            process.exit(0);
        });
    }
    
    completer(line) {
        const completions = Object.keys(this.commands);
        const hits = completions.filter((c) => c.startsWith(line));
        return [hits.length ? hits : completions, line];
    }
    
    handleHelp(args) {
        console.log('\nAvailable commands:');
        for (const [cmd, info] of Object.entries(this.commands)) {
            console.log(`  ${cmd.padEnd(15)} ${info.description}`);
        }
        console.log();
    }
    
    handleExit(args) {
        this.rl.close();
    }

{%- for command in cli.root_command.subcommands %}
    
    async handle{{ command.name | replace('-', '') | title }}(args) {
        const hookName = '{{ command.hook_name }}';
        if (typeof hooks[hookName] === 'function') {
            // Parse and validate arguments for the command
            const hookName = "{{ command.hook_name }}";
            if (typeof hooks[hookName] === 'function') {
                try {
                    const result = await hooks[hookName](...args);
                    if (result !== undefined) {
                        console.log(result);
                    }
                } catch (error) {
                    console.error(`Error executing ${hookName}:`, error.message);
                }
            } else {
                console.log(`Command '{{ command.name }}' executed successfully`);
                console.log(`To implement custom behavior, add '${hookName}' function to hooks.js`);
            }
            await hooks[hookName](...args);
        } else {
            console.log(`Command '{{ command.name }}' executed successfully`);
            console.log(`To implement custom behavior, add '${hookName}' function to hooks.js`);
        }
    }
{%- endfor %}
}

function runInteractive() {
    const interactive = new {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive();
    interactive.start();
}

module.exports = { runInteractive };

if (require.main === module) {
    runInteractive();
}

{%- elif language == 'typescript' -%}
#!/usr/bin/env node
/**
 * Interactive mode for {{ project.name }}
 * Generated by Goobits CLI Framework
 */

import * as readline from 'readline';
import * as hooks from './hooks';

interface Command {
    description: string;
    handler: (args: string[]) => Promise<void>;
}

export class {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive {
    private rl: readline.Interface;
    private commands: Record<string, Command>;
    private commandHistory: string[] = [];

    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: '{{ cli.root_command.name }}> ',
            completer: this.completer.bind(this)
        });
        
        this.commands = {
{%- for command in cli.root_command.subcommands %}
            '{{ command.name }}': {
                description: '{{ command.description }}',
                handler: this.handle{{ command.name | replace('-', '') | title }}.bind(this)
            },
{%- endfor %}
            'help': {
                description: 'Show available commands',
                handler: this.handleHelp.bind(this)
            },
            'exit': {
                description: 'Exit interactive mode',
                handler: this.handleExit.bind(this)
            },
            'quit': {
                description: 'Exit interactive mode',
                handler: this.handleExit.bind(this)
            }
        };
    }
    
    public start(): void {
        console.log("Welcome to {{ project.name }} interactive mode. Type 'help' for commands, 'exit' to quit.");
        
        this.rl.prompt();
        
        this.rl.on('line', async (line: string) => {
            const trimmed = line.trim();
            if (!trimmed) {
                this.rl.prompt();
                return;
            }
            
            this.commandHistory.push(trimmed);
            const [cmd, ...args] = trimmed.split(/\s+/);
            
            if (this.commands[cmd]) {
                try {
                    await this.commands[cmd].handler(args);
                } catch (error) {
                    console.error('Error:', (error as Error).message);
                }
            } else {
                console.log(`Unknown command: ${cmd}`);
                console.log("Type 'help' for available commands");
            }
            
            this.rl.prompt();
        });
        
        this.rl.on('close', () => {
            console.log('\nGoodbye!');
            process.exit(0);
        });
    }
    
    private completer(line: string): [string[], string] {
        const completions = Object.keys(this.commands);
        const hits = completions.filter((c) => c.startsWith(line));
        return [hits.length ? hits : completions, line];
    }
    
    private async handleHelp(args: string[]): Promise<void> {
        console.log('\nAvailable commands:');
        for (const [cmd, info] of Object.entries(this.commands)) {
            console.log(`  ${cmd.padEnd(15)} ${info.description}`);
        }
        console.log();
    }
    
    private async handleExit(args: string[]): Promise<void> {
        this.rl.close();
    }

{%- for command in cli.root_command.subcommands %}
    
    private async handle{{ command.name | replace('-', '') | title }}(args: string[]): Promise<void> {
        const hookName = '{{ command.hook_name }}' as keyof typeof hooks;
        if (typeof hooks[hookName] === 'function') {
            // Parse and validate arguments for the command
            const hookName = "{{ command.hook_name }}";
            if (typeof hooks[hookName] === 'function') {
                try {
                    const result = await hooks[hookName](...args);
                    if (result !== undefined) {
                        console.log(result);
                    }
                } catch (error) {
                    console.error(`Error executing ${hookName}:`, error.message);
                }
            } else {
                console.log(`Command '{{ command.name }}' executed successfully`);
                console.log(`To implement custom behavior, add '${hookName}' function to hooks.js`);
            }
            await (hooks[hookName] as Function)(...args);
        } else {
            console.log(`Command '{{ command.name }}' executed successfully`);
            console.log(`To implement custom behavior, add '${hookName}' function to hooks.ts`);
        }
    }
{%- endfor %}
}

export function runInteractive(): void {
    const interactive = new {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive();
    interactive.start();
}

if (require.main === module) {
    runInteractive();
}

{%- elif language == 'rust' -%}
use rustyline::error::ReadlineError;
use rustyline::{DefaultEditor, Result};
use std::collections::HashMap;

mod hooks;

pub struct {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive {
    editor: DefaultEditor,
    commands: HashMap<String, fn(&[&str]) -> Result<()>>,
}

impl {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive {
    pub fn new() -> Result<Self> {
        let mut editor = DefaultEditor::new()?;
        let mut commands = HashMap::new();
        
        // Register commands
{%- for command in cli.root_command.subcommands %}
        commands.insert("{{ command.name }}".to_string(), |args| {
            match hooks::{{ command.hook_name }}(args) {
                Ok(_) => Ok(()),
                Err(e) => {
                    eprintln!("Error: {}", e);
                    Ok(())
                }
            }
        });
{%- endfor %}
        
        Ok(Self { editor, commands })
    }
    
    pub fn run(&mut self) -> Result<()> {
        println!("Welcome to {{ project.name }} interactive mode. Type 'help' for commands, 'exit' to quit.");
        
        let prompt = "{{ cli.root_command.name }}> ";
        
        loop {
            let readline = self.editor.readline(prompt);
            match readline {
                Ok(line) => {
                    if line.trim().is_empty() {
                        continue;
                    }
                    
                    self.editor.add_history_entry(line.as_str())?;
                    
                    let parts: Vec<&str> = line.trim().split_whitespace().collect();
                    if parts.is_empty() {
                        continue;
                    }
                    
                    match parts[0] {
                        "exit" | "quit" => {
                            println!("Goodbye!");
                            break;
                        }
                        "help" => {
                            self.show_help();
                        }
                        cmd => {
                            if let Some(handler) = self.commands.get(cmd) {
                                let args = &parts[1..];
                                if let Err(e) = handler(args) {
                                    eprintln!("Error executing command: {}", e);
                                }
                            } else {
                                println!("Unknown command: {}", cmd);
                                println!("Type 'help' for available commands");
                            }
                        }
                    }
                }
                Err(ReadlineError::Interrupted) => {
                    println!("^C");
                    continue;
                }
                Err(ReadlineError::Eof) => {
                    println!("^D");
                    break;
                }
                Err(err) => {
                    eprintln!("Error: {:?}", err);
                    break;
                }
            }
        }
        
        Ok(())
    }
    
    fn show_help(&self) {
        println!("\nAvailable commands:");
        println!("  {:15} {}", "help", "Show available commands");
        println!("  {:15} {}", "exit", "Exit interactive mode");
{%- for command in cli.root_command.subcommands %}
        println!("  {:15} {}", "{{ command.name }}", "{{ command.description }}");
{%- endfor %}
        println!();
    }
}

pub fn run_interactive() -> Result<()> {
    let mut interactive = {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive::new()?;
    interactive.run()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_interactive_creation() {
        let result = {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive::new();
        assert!(result.is_ok());
    }
}

{%- endif -%}

{%- endif -%}