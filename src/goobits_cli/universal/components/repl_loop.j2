{# Universal REPL Loop Template

   This template generates enhanced REPL (Read-Eval-Print Loop) functionality
   that builds on the existing interactive mode system.
   
   Features:
   - Multi-line command support with continuation (\)
   - Smart completion integration from Phase 1A
   - Enhanced command history with persistence
   - Language-specific readline/input handling
   - Performance-optimized startup (<50ms overhead)
   
   Variables expected:
   - language: Target language (python, nodejs, typescript, rust)
   - project: Project metadata
   - cli: CLI schema with commands, arguments, options
   - features.interactive_mode.repl: Boolean flag to enable REPL features
#}

{%- if language == 'python' -%}
#!/usr/bin/env python3
"""
Enhanced REPL for {{ project.name }}
Generated by Goobits CLI Framework with BasicREPL support
"""

import sys
import os
import asyncio
from pathlib import Path

# Import BasicREPL and smart completion
try:
    from goobits_cli.universal.interactive import BasicREPL, create_basic_repl
    from goobits_cli.universal.completion.smart_completion import get_smart_completion_registry
    REPL_AVAILABLE = True
except ImportError:
    # Fallback to basic interactive mode
    from .{{ cli.root_command.name.replace('-', '_') }}_interactive import {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive
    REPL_AVAILABLE = False

try:
    from .{{ cli.root_command.name.replace('-', '_') }}_cli import cli
    from .hooks import *  # Import all hook functions
except ImportError:
    # Fallback imports
    from {{ cli.root_command.name.replace('-', '_') }}_cli import cli
    try:
        from hooks import *
    except ImportError:
        pass


class {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL(BasicREPL):
    """Enhanced REPL for {{ project.name }} with smart completion."""
    
    def __init__(self, cli_config: dict, smart_completion_enabled: bool = True):
        """Initialize the enhanced REPL."""
        super().__init__(cli_config, smart_completion_enabled)
        
        # Override prompts
        self.prompt = "{{ cli.root_command.name }}> "
        self.continuation_prompt = "{{ cli.root_command.name }}... "
        self.intro = (
            f"Welcome to {{ project.name }} Enhanced REPL mode.\n"
            f"Features: Multi-line commands (\\), Smart completion (TAB), Command history\n"
            f"Type 'help' for commands, 'exit' to quit."
        )
    
    def handle_cli_command(self, command: dict, args: list):
        """Handle CLI command execution with proper hook integration."""
        hook_name = command.get('hook_name', f"on_{command['name'].replace('-', '_')}")
        
        # Check if hook function exists in global scope
        if hook_name in globals():
            hook_func = globals()[hook_name]
            try:
                import inspect
                sig = inspect.signature(hook_func)
                
                # Try to bind arguments to function signature
                if len(sig.parameters) == 0:
                    # Function takes no arguments
                    result = hook_func()
                elif len(args) == 0:
                    # No args provided, try calling with no args
                    result = hook_func()
                else:
                    # Try to pass arguments
                    try:
                        bound_args = sig.bind(*args)
                        bound_args.apply_defaults()
                        result = hook_func(*bound_args.args, **bound_args.kwargs)
                    except TypeError:
                        # Fallback: pass all args as list
                        result = hook_func(args)
                
                if result is not None:
                    print(result)
                
            except Exception as e:
                print(f"Error executing {hook_name}: {e}")
                print(f"Arguments provided: {args}")
        else:
            print(f"Command '{command['name']}' executed successfully")
            print(f"To implement custom behavior, add '{hook_name}' function to hooks.py")


def run_enhanced_repl():
    """Launch the enhanced REPL with smart completion."""
    if not REPL_AVAILABLE:
        print("Enhanced REPL not available, falling back to basic interactive mode")
        interactive = {{ project.name | replace('-', '') | replace(' ', '') | title }}Interactive()
        interactive.cmdloop()
        return
    
    # Build CLI config from our CLI definition
    cli_config = {
        'root_command': {
            'name': '{{ cli.root_command.name }}',
            'description': '{{ cli.root_command.description }}',
            'subcommands': [
{%- for command in cli.root_command.subcommands %}
                {
                    'name': '{{ command.name }}',
                    'description': '{{ command.description }}',
                    'hook_name': '{{ command.hook_name }}',
                    'arguments': {{ command.arguments | default([]) | tojson }},
                    'options': {{ command.options | default([]) | tojson }}
                },
{%- endfor %}
            ]
        },
        'features': {
            'interactive_mode': {
                'repl': True,
                'smart_completion': True
            }
        }
    }
    
    # Create and run enhanced REPL
    repl = {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL(cli_config, smart_completion_enabled=True)
    repl.run()


if __name__ == "__main__":
    run_enhanced_repl()

{%- elif language == 'nodejs' -%}
#!/usr/bin/env node
/**
 * Enhanced REPL for {{ project.name }}
 * Generated by Goobits CLI Framework with BasicREPL support
 */

const readline = require('readline');
const path = require('path');
const fs = require('fs');
const hooks = require('./hooks');

class {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL {
    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: '{{ cli.root_command.name }}> ',
            completer: this.completer.bind(this)
        });
        
        this.continuationPrompt = '{{ cli.root_command.name }}... ';
        this.multiLineBuffer = '';
        this.maxHistory = 100;
        
        // Command registry
        this.commands = {
{%- for command in cli.root_command.subcommands %}
            '{{ command.name }}': {
                description: '{{ command.description }}',
                hookName: '{{ command.hook_name }}',
                handler: this.handle{{ command.name | replace('-', '') | title }}.bind(this)
            },
{%- endfor %}
            'help': {
                description: 'Show available commands',
                handler: this.handleHelp.bind(this)
            },
            'history': {
                description: 'Show command history',
                handler: this.handleHistory.bind(this)
            },
            'exit': {
                description: 'Exit REPL mode',
                handler: this.handleExit.bind(this)
            },
            'quit': {
                description: 'Exit REPL mode', 
                handler: this.handleExit.bind(this)
            }
        };
        
        this.commandHistory = [];
        this.setupHistory();
    }
    
    setupHistory() {
        const historyFile = `.{{ cli.root_command.name }}_history`;
        
        // Load history from file
        try {
            if (fs.existsSync(historyFile)) {
                const history = fs.readFileSync(historyFile, 'utf8')
                    .split('\n')
                    .filter(line => line.trim())
                    .slice(-this.maxHistory);
                this.commandHistory = history;
            }
        } catch (error) {
            // Ignore history loading errors
        }
        
        // Save history on exit
        process.on('exit', () => {
            try {
                const historyToSave = this.commandHistory
                    .slice(-this.maxHistory)
                    .join('\n');
                fs.writeFileSync(historyFile, historyToSave);
            } catch (error) {
                // Ignore history saving errors
            }
        });
    }
    
    start() {
        console.log('Welcome to {{ project.name }} Enhanced REPL mode.');
        console.log('Features: Multi-line commands (\\\\), Tab completion, Command history');
        console.log("Type 'help' for commands, 'exit' to quit.");
        
        this.rl.prompt();
        
        this.rl.on('line', async (line) => {
            await this.handleLine(line);
        });
        
        this.rl.on('close', () => {
            console.log('\\nGoodbye!');
            process.exit(0);
        });
        
        this.rl.on('SIGINT', () => {
            console.log('\\nKeyboardInterrupt (use \\'exit\\' to quit)');
            this.multiLineBuffer = '';  // Clear partial input
            this.rl.prompt();
        });
    }
    
    async handleLine(line) {
        const trimmed = line.trim();
        
        // Handle empty input
        if (!trimmed && !this.multiLineBuffer) {
            this.rl.prompt();
            return;
        }
        
        // Parse multi-line input
        const { command, isContinuation } = this.parseMultiLineInput(trimmed);
        
        if (isContinuation) {
            // Use continuation prompt
            this.rl.setPrompt(this.continuationPrompt);
            this.rl.prompt();
            return;
        }
        
        // Reset to normal prompt
        this.rl.setPrompt('{{ cli.root_command.name }}> ');
        
        // Execute complete command
        if (command.trim()) {
            this.addToHistory(command);
            await this.executeCommand(command);
        }
        
        this.rl.prompt();
    }
    
    parseMultiLineInput(line) {
        // Check for line continuation (ends with backslash)
        if (line.endsWith('\\\\')) {
            this.multiLineBuffer += line.slice(0, -1) + ' ';
            return { command: '', isContinuation: true };
        }
        
        // Complete command
        if (this.multiLineBuffer) {
            const command = this.multiLineBuffer + line;
            this.multiLineBuffer = '';
            return { command, isContinuation: false };
        }
        
        return { command: line, isContinuation: false };
    }
    
    async executeCommand(line) {
        const [cmd, ...args] = line.split(/\\s+/);
        
        if (this.commands[cmd]) {
            try {
                await this.commands[cmd].handler(args);
            } catch (error) {
                console.error('Error:', error.message);
            }
        } else {
            console.log(`Unknown command: ${cmd}`);
            console.log("Type 'help' for available commands");
        }
    }
    
    addToHistory(command) {
        if (command.trim() && !command.startsWith('help')) {
            this.commandHistory.push(command);
            if (this.commandHistory.length > this.maxHistory) {
                this.commandHistory.shift();
            }
        }
    }
    
    completer(line) {
        const completions = Object.keys(this.commands);
        
        // Basic command completion
        const [cmd] = line.split(/\\s+/);
        const hits = completions.filter(c => c.startsWith(cmd));
        
        return [hits.length ? hits : completions, line];
    }
    
    async handleHelp(args) {
        console.log('\\nAvailable commands:');
        for (const [cmd, info] of Object.entries(this.commands)) {
            console.log(`  ${cmd.padEnd(15)} ${info.description}`);
        }
        console.log();
    }
    
    async handleHistory(args) {
        if (this.commandHistory.length === 0) {
            console.log('No command history available.');
            return;
        }
        
        console.log('\\nCommand history:');
        this.commandHistory.forEach((cmd, i) => {
            console.log(`${(i + 1).toString().padStart(4)}  ${cmd}`);
        });
        console.log();
    }
    
    async handleExit(args) {
        this.rl.close();
    }

{%- for command in cli.root_command.subcommands %}
    
    async handle{{ command.name | replace('-', '') | title }}(args) {
        const hookName = '{{ command.hook_name }}';
        if (typeof hooks[hookName] === 'function') {
            try {
                const result = await hooks[hookName](...args);
                if (result !== undefined) {
                    console.log(result);
                }
            } catch (error) {
                console.error(`Error executing ${hookName}:`, error.message);
            }
        } else {
            console.log(`Command '{{ command.name }}' executed successfully`);
            console.log(`To implement custom behavior, add '${hookName}' function to hooks.js`);
        }
    }
{%- endfor %}
}

function runEnhancedREPL() {
    const repl = new {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL();
    repl.start();
}

module.exports = { runEnhancedREPL };

if (require.main === module) {
    runEnhancedREPL();
}

{%- elif language == 'typescript' -%}
#!/usr/bin/env node
/**
 * Enhanced REPL for {{ project.name }}
 * Generated by Goobits CLI Framework with BasicREPL support
 */

import * as readline from 'readline';
import * as path from 'path';
import * as fs from 'fs';
import * as hooks from './hooks';

interface Command {
    description: string;
    hookName?: string;
    handler: (args: string[]) => Promise<void>;
}

export class {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL {
    private rl: readline.Interface;
    private commands: Record<string, Command>;
    private commandHistory: string[] = [];
    private multiLineBuffer: string = '';
    private readonly maxHistory: number = 100;
    private readonly continuationPrompt: string = '{{ cli.root_command.name }}... ';

    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: '{{ cli.root_command.name }}> ',
            completer: this.completer.bind(this)
        });
        
        this.commands = {
{%- for command in cli.root_command.subcommands %}
            '{{ command.name }}': {
                description: '{{ command.description }}',
                hookName: '{{ command.hook_name }}',
                handler: this.handle{{ command.name | replace('-', '') | title }}.bind(this)
            },
{%- endfor %}
            'help': {
                description: 'Show available commands',
                handler: this.handleHelp.bind(this)
            },
            'history': {
                description: 'Show command history',
                handler: this.handleHistory.bind(this)
            },
            'exit': {
                description: 'Exit REPL mode',
                handler: this.handleExit.bind(this)
            },
            'quit': {
                description: 'Exit REPL mode',
                handler: this.handleExit.bind(this)
            }
        };
        
        this.setupHistory();
    }
    
    private setupHistory(): void {
        const historyFile = `.{{ cli.root_command.name }}_history`;
        
        // Load history from file
        try {
            if (fs.existsSync(historyFile)) {
                const history = fs.readFileSync(historyFile, 'utf8')
                    .split('\\n')
                    .filter(line => line.trim())
                    .slice(-this.maxHistory);
                this.commandHistory = history;
            }
        } catch (error) {
            // Ignore history loading errors
        }
        
        // Save history on exit
        process.on('exit', () => {
            try {
                const historyToSave = this.commandHistory
                    .slice(-this.maxHistory)
                    .join('\\n');
                fs.writeFileSync(historyFile, historyToSave);
            } catch (error) {
                // Ignore history saving errors
            }
        });
    }
    
    public start(): void {
        console.log('Welcome to {{ project.name }} Enhanced REPL mode.');
        console.log('Features: Multi-line commands (\\\\), Tab completion, Command history');
        console.log("Type 'help' for commands, 'exit' to quit.");
        
        this.rl.prompt();
        
        this.rl.on('line', async (line: string) => {
            await this.handleLine(line);
        });
        
        this.rl.on('close', () => {
            console.log('\\nGoodbye!');
            process.exit(0);
        });
        
        this.rl.on('SIGINT', () => {
            console.log('\\nKeyboardInterrupt (use \\'exit\\' to quit)');
            this.multiLineBuffer = '';  // Clear partial input
            this.rl.prompt();
        });
    }
    
    private async handleLine(line: string): Promise<void> {
        const trimmed = line.trim();
        
        // Handle empty input
        if (!trimmed && !this.multiLineBuffer) {
            this.rl.prompt();
            return;
        }
        
        // Parse multi-line input
        const { command, isContinuation } = this.parseMultiLineInput(trimmed);
        
        if (isContinuation) {
            // Use continuation prompt
            this.rl.setPrompt(this.continuationPrompt);
            this.rl.prompt();
            return;
        }
        
        // Reset to normal prompt
        this.rl.setPrompt('{{ cli.root_command.name }}> ');
        
        // Execute complete command
        if (command.trim()) {
            this.addToHistory(command);
            await this.executeCommand(command);
        }
        
        this.rl.prompt();
    }
    
    private parseMultiLineInput(line: string): { command: string; isContinuation: boolean } {
        // Check for line continuation (ends with backslash)
        if (line.endsWith('\\\\')) {
            this.multiLineBuffer += line.slice(0, -1) + ' ';
            return { command: '', isContinuation: true };
        }
        
        // Complete command
        if (this.multiLineBuffer) {
            const command = this.multiLineBuffer + line;
            this.multiLineBuffer = '';
            return { command, isContinuation: false };
        }
        
        return { command: line, isContinuation: false };
    }
    
    private async executeCommand(line: string): Promise<void> {
        const [cmd, ...args] = line.split(/\\s+/);
        
        if (this.commands[cmd]) {
            try {
                await this.commands[cmd].handler(args);
            } catch (error) {
                console.error('Error:', (error as Error).message);
            }
        } else {
            console.log(`Unknown command: ${cmd}`);
            console.log("Type 'help' for available commands");
        }
    }
    
    private addToHistory(command: string): void {
        if (command.trim() && !command.startsWith('help')) {
            this.commandHistory.push(command);
            if (this.commandHistory.length > this.maxHistory) {
                this.commandHistory.shift();
            }
        }
    }
    
    private completer(line: string): [string[], string] {
        const completions = Object.keys(this.commands);
        
        // Basic command completion
        const [cmd] = line.split(/\\s+/);
        const hits = completions.filter(c => c.startsWith(cmd));
        
        return [hits.length ? hits : completions, line];
    }
    
    private async handleHelp(args: string[]): Promise<void> {
        console.log('\\nAvailable commands:');
        for (const [cmd, info] of Object.entries(this.commands)) {
            console.log(`  ${cmd.padEnd(15)} ${info.description}`);
        }
        console.log();
    }
    
    private async handleHistory(args: string[]): Promise<void> {
        if (this.commandHistory.length === 0) {
            console.log('No command history available.');
            return;
        }
        
        console.log('\\nCommand history:');
        this.commandHistory.forEach((cmd, i) => {
            console.log(`${(i + 1).toString().padStart(4)}  ${cmd}`);
        });
        console.log();
    }
    
    private async handleExit(args: string[]): Promise<void> {
        this.rl.close();
    }

{%- for command in cli.root_command.subcommands %}
    
    private async handle{{ command.name | replace('-', '') | title }}(args: string[]): Promise<void> {
        const hookName = '{{ command.hook_name }}' as keyof typeof hooks;
        if (typeof hooks[hookName] === 'function') {
            try {
                const result = await (hooks[hookName] as Function)(...args);
                if (result !== undefined) {
                    console.log(result);
                }
            } catch (error) {
                console.error(`Error executing ${hookName}:`, (error as Error).message);
            }
        } else {
            console.log(`Command '{{ command.name }}' executed successfully`);
            console.log(`To implement custom behavior, add '${hookName}' function to hooks.ts`);
        }
    }
{%- endfor %}
}

export function runEnhancedREPL(): void {
    const repl = new {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL();
    repl.start();
}

if (require.main === module) {
    runEnhancedREPL();
}

{%- elif language == 'rust' -%}
use std::collections::HashMap;
use std::fs;
use std::io::{self, Write};
use rustyline::error::ReadlineError;
use rustyline::{DefaultEditor, Result};

mod hooks;

pub struct {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL {
    editor: DefaultEditor,
    commands: HashMap<String, fn(&[String]) -> Result<()>>,
    history_file: String,
    max_history: usize,
    multi_line_buffer: String,
    continuation_prompt: String,
}

impl {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL {
    pub fn new() -> Result<Self> {
        let mut editor = DefaultEditor::new()?;
        let mut commands = HashMap::new();
        
        // Register CLI commands
{%- for command in cli.root_command.subcommands %}
        commands.insert("{{ command.name }}".to_string(), |args| {
            match hooks::{{ command.hook_name }}(args) {
                Ok(_) => {
                    println!("Command '{{ command.name }}' executed successfully");
                    Ok(())
                },
                Err(e) => {
                    eprintln!("Error executing {{ command.hook_name }}: {}", e);
                    Ok(())
                }
            }
        });
{%- endfor %}
        
        let history_file = format!(".{{ cli.root_command.name }}_history");
        let max_history = 100;
        
        // Load command history
        if let Ok(_) = editor.load_history(&history_file) {
            // History loaded successfully
        }
        
        Ok(Self {
            editor,
            commands,
            history_file,
            max_history,
            multi_line_buffer: String::new(),
            continuation_prompt: "{{ cli.root_command.name }}... ".to_string(),
        })
    }
    
    pub fn run(&mut self) -> Result<()> {
        println!("Welcome to {{ project.name }} Enhanced REPL mode.");
        println!("Features: Multi-line commands (\\\\), Tab completion, Command history");
        println!("Type 'help' for commands, 'exit' to quit.");
        
        let prompt = "{{ cli.root_command.name }}> ";
        
        loop {
            let current_prompt = if self.multi_line_buffer.is_empty() {
                prompt
            } else {
                &self.continuation_prompt
            };
            
            let readline = self.editor.readline(current_prompt);
            match readline {
                Ok(line) => {
                    let trimmed = line.trim();
                    
                    if trimmed.is_empty() && self.multi_line_buffer.is_empty() {
                        continue;
                    }
                    
                    // Parse multi-line input
                    let (complete_command, is_continuation) = self.parse_multi_line_input(trimmed);
                    
                    if is_continuation {
                        continue;
                    }
                    
                    if !complete_command.trim().is_empty() {
                        self.editor.add_history_entry(complete_command.as_str())?;
                        self.execute_command(&complete_command)?;
                    }
                }
                Err(ReadlineError::Interrupted) => {
                    println!("KeyboardInterrupt (use 'exit' to quit)");
                    self.multi_line_buffer.clear();
                    continue;
                }
                Err(ReadlineError::Eof) => {
                    println!("Goodbye!");
                    break;
                }
                Err(err) => {
                    eprintln!("Error: {:?}", err);
                    break;
                }
            }
        }
        
        // Save history
        if let Err(_) = self.editor.save_history(&self.history_file) {
            // Ignore save errors
        }
        
        Ok(())
    }
    
    fn parse_multi_line_input(&mut self, line: &str) -> (String, bool) {
        // Check for line continuation (ends with backslash)
        if line.ends_with("\\\\") {
            // Add to buffer without the backslash
            self.multi_line_buffer.push_str(&line[..line.len()-1]);
            self.multi_line_buffer.push(' ');
            return (String::new(), true);
        }
        
        // Complete command
        if !self.multi_line_buffer.is_empty() {
            let complete_command = format!("{}{}", self.multi_line_buffer, line);
            self.multi_line_buffer.clear();
            return (complete_command, false);
        }
        
        (line.to_string(), false)
    }
    
    fn execute_command(&self, line: &str) -> Result<()> {
        let parts: Vec<String> = line.split_whitespace()
            .map(|s| s.to_string())
            .collect();
        
        if parts.is_empty() {
            return Ok(());
        }
        
        let cmd = &parts[0];
        let args = &parts[1..];
        
        match cmd.as_str() {
            "exit" | "quit" => {
                println!("Goodbye!");
                std::process::exit(0);
            }
            "help" => {
                self.show_help();
            }
            "history" => {
                self.show_history();
            }
            _ => {
                if let Some(handler) = self.commands.get(cmd) {
                    if let Err(e) = handler(args) {
                        eprintln!("Error executing command: {}", e);
                    }
                } else {
                    println!("Unknown command: {}", cmd);
                    println!("Type 'help' for available commands");
                }
            }
        }
        
        Ok(())
    }
    
    fn show_help(&self) {
        println!("\\nAvailable commands:");
        println!("  {:15} {}", "help", "Show available commands");
        println!("  {:15} {}", "history", "Show command history");
        println!("  {:15} {}", "exit", "Exit REPL mode");
{%- for command in cli.root_command.subcommands %}
        println!("  {:15} {}", "{{ command.name }}", "{{ command.description }}");
{%- endfor %}
        println!();
    }
    
    fn show_history(&self) {
        // For simplicity, we'll just show a message
        // In a full implementation, you'd access the editor's history
        println!("Use up/down arrows to navigate command history");
        println!("History is automatically saved to {}", self.history_file);
    }
}

pub fn run_enhanced_repl() -> Result<()> {
    let mut repl = {{ project.name | replace('-', '') | replace(' ', '') | title }}REPL::new()?;
    repl.run()
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_repl_creation() {
        let result = {{ project.name | replace('-', '') | replace('', '') | title }}REPL::new();
        assert!(result.is_ok());
    }
}

{%- endif -%}