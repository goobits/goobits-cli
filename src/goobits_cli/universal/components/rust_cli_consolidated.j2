// {{ project.name }} - {{ project.description }}
// Generated by Goobits CLI Framework v{{ generator_version }}
// 
// This is a consolidated Rust CLI file with all modules inline.
// Generated from: {{ config_filename }}

use clap::{Command, Arg, ArgMatches};
use clap_complete;
use anyhow::{Result, Context, bail};
use serde::{Serialize, Deserialize};
use std::fs;
use std::path::{Path, PathBuf};
use std::collections::HashMap;
use dirs;
use log::{debug, info, warn, error};
use env_logger;
use colored::Colorize;
use chrono::Local;
use std::io::{Write, IsTerminal};

// ============================================================================
// INLINE CONFIG MODULE
// ============================================================================

mod config {
    use super::*;
    
    #[derive(Debug, Serialize, Deserialize, Clone)]
    pub struct Config {
        #[serde(default)]
        pub debug: bool,
        #[serde(default)]
        pub verbose: bool,
        #[serde(default = "default_output_format")]
        pub output_format: String,
        {%- if cli.default_config %}
          {%- for key, value in cli.default_config.items() %}
        #[serde(default)]
        pub {{ key }}: {{ 'bool' if value is sameas true or value is sameas false else 'String' if value is string else 'i64' if value is number else 'serde_json::Value' }},
          {%- endfor %}
        {%- endif %}
        #[serde(flatten)]
        pub extra: HashMap<String, serde_json::Value>,
    }
    
    fn default_output_format() -> String {
        "text".to_string()
    }
    
    impl Default for Config {
        fn default() -> Self {
            Self {
                debug: false,
                verbose: false,
                output_format: default_output_format(),
                {%- if cli.default_config %}
          {%- for key, value in cli.default_config.items() %}
                {{ key }}: {{ value | tojson }},
                  {%- endfor %}
                {%- endif %}
                extra: HashMap::new(),
            }
        }
    }
    
    pub struct ConfigManager {
        config_file: PathBuf,
        pub config: Config,
    }
    
    impl ConfigManager {
        pub fn new() -> Result<Self> {
            let config_dir = dirs::config_dir()
                .context("Unable to determine config directory")?
                .join("{{ cli.name | default(project.command_name) }}");
            
            fs::create_dir_all(&config_dir)?;
            let config_file = config_dir.join("config.yaml");
            
            let config = if config_file.exists() {
                let contents = fs::read_to_string(&config_file)?;
                serde_yaml::from_str(&contents).unwrap_or_default()
            } else {
                Config::default()
            };
            
            Ok(Self {
                config_file,
                config,
            })
        }
        
        pub fn save(&self) -> Result<()> {
            let contents = serde_yaml::to_string(&self.config)?;
            fs::write(&self.config_file, contents)?;
            Ok(())
        }
        
        pub fn get<T: serde::de::DeserializeOwned>(&self, key: &str) -> Option<T> {
            self.config.extra.get(key)
                .and_then(|v| serde_json::from_value(v.clone()).ok())
        }
        
        pub fn set(&mut self, key: &str, value: serde_json::Value) {
            self.config.extra.insert(key.to_string(), value);
        }
    }
}

// ============================================================================
// INLINE ERROR MODULE
// ============================================================================

mod errors {
    use super::*;
    
    #[derive(Debug)]
    pub enum CliError {
        Usage(String),
        Config(String),
        Network(String),
        Permission(String),
        FileNotFound(String),
        General(String),
    }
    
    impl std::fmt::Display for CliError {
        fn fmt(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
            match self {
                CliError::Usage(msg) => write!(f, "Usage error: {}", msg),
                CliError::Config(msg) => write!(f, "Configuration error: {}", msg),
                CliError::Network(msg) => write!(f, "Network error: {}", msg),
                CliError::Permission(msg) => write!(f, "Permission error: {}", msg),
                CliError::FileNotFound(msg) => write!(f, "File not found: {}", msg),
                CliError::General(msg) => write!(f, "Error: {}", msg),
            }
        }
    }
    
    impl std::error::Error for CliError {}
    
    impl CliError {
        pub fn exit_code(&self) -> i32 {
            match self {
                CliError::Usage(_) => 2,
                CliError::Config(_) => 3,
                CliError::Network(_) => 4,
                CliError::Permission(_) => 5,
                CliError::FileNotFound(_) => 6,
                CliError::General(_) => 1,
            }
        }
    }
    
    pub fn handle_error(error: anyhow::Error, verbose: bool) -> ! {
        if let Some(cli_error) = error.downcast_ref::<CliError>() {
            eprintln!("{}: {}", "Error".red().bold(), cli_error);
            if verbose {
                eprintln!("\n{}: {:?}", "Debug".cyan(), error);
            }
            std::process::exit(cli_error.exit_code());
        } else {
            eprintln!("{}: {}", "Error".red().bold(), error);
            if verbose {
                eprintln!("\n{}: {:?}", "Debug".cyan(), error);
            } else {
                eprintln!("Run with --verbose for more details");
            }
            std::process::exit(1);
        }
    }
}

// ============================================================================
// INLINE LOGGER MODULE
// ============================================================================

mod logger {
    use super::*;
    
    pub fn init_logger(verbose: bool, debug: bool) {
        let mut builder = env_logger::Builder::new();
        
        builder.format(|buf, record| {
            let timestamp = Local::now().format("%Y-%m-%d %H:%M:%S");
            let level = match record.level() {
                log::Level::Error => "ERROR".red(),
                log::Level::Warn => "WARN".yellow(),
                log::Level::Info => "INFO".green(),
                log::Level::Debug => "DEBUG".cyan(),
                log::Level::Trace => "TRACE".purple(),
            };
            
            writeln!(
                buf,
                "{} {} {}",
                timestamp.to_string().dimmed(),
                level,
                record.args()
            )
        });
        
        if debug {
            builder.filter_level(log::LevelFilter::Debug);
        } else if verbose {
            builder.filter_level(log::LevelFilter::Info);
        } else {
            builder.filter_level(log::LevelFilter::Warn);
        }
        
        builder.init();
    }
}

// ============================================================================
// INLINE COMPLETION MODULE
// ============================================================================

mod completion {
    use super::*;
    
    pub fn generate_completion(app: &Command, shell: clap_complete::Shell) -> String {
        let mut buffer = Vec::new();
        clap_complete::generate(shell, &mut app.clone(), "{{ cli.name | default(project.command_name) }}", &mut buffer);
        String::from_utf8_lossy(&buffer).to_string()
    }
    
    pub fn print_completion(shell: &str) -> Result<()> {
        let app = build_cli();
        let shell = match shell {
            "bash" => clap_complete::Shell::Bash,
            "zsh" => clap_complete::Shell::Zsh,
            "fish" => clap_complete::Shell::Fish,
            "powershell" => clap_complete::Shell::PowerShell,
            "elvish" => clap_complete::Shell::Elvish,
            _ => bail!("Unsupported shell: {}", shell),
        };
        
        let completion = generate_completion(&app, shell);
        println!("{}", completion);
        Ok(())
    }
}

// ============================================================================
// HOOKS MODULE
// ============================================================================

// Import user hooks directly
mod cli_hooks;

// ============================================================================
// CLI BUILDER
// ============================================================================

fn build_cli() -> Command {
    Command::new("{{ cli.name | default(project.command_name) }}")
        .version("{{ cli.version | default(project.version) | default('1.0.0') }}")
        .about("{{ cli.description | default(project.description) }}")
        .arg(
            Arg::new("verbose")
                .short('v')
                .long("verbose")
                .help("Enable verbose output")
                .action(clap::ArgAction::SetTrue)
        )
        .arg(
            Arg::new("debug")
                .long("debug")
                .help("Enable debug output")
                .action(clap::ArgAction::SetTrue)
        )
        {%- for option in cli.global_options | default([]) %}
        .arg(
            Arg::new("{{ option.name }}")
                {%- if option.short %}
                .short('{{ option.short.lstrip('-') if option.short else option.name[:1] }}')
                {%- endif %}
                .long("{{ option.name }}")
                .help("{{ option.description }}")
                {%- if option.type != 'boolean' %}
                .value_name("VALUE")
                {%- else %}
                .action(clap::ArgAction::SetTrue)
                {%- endif %}
        )
        {%- endfor %}
        {%- if clap_commands and clap_commands.subcommands %}
          {%- for cmd_data in clap_commands.subcommands %}
        .subcommand(
            Command::new("{{ cmd_data.name }}")
                .about("{{ cmd_data.description }}")
                {%- for arg in cmd_data.arguments | default([]) %}
                .arg(
                    Arg::new("{{ arg.name }}")
                        .help("{{ arg.description }}")
                        .required(true)
                        .index({{ loop.index }})
                )
                {%- endfor %}
                {%- for option in cmd_data.options | default([]) %}
                .arg(
                    Arg::new("{{ option.name }}")
                        {%- if option.short %}
                        .short('{{ option.short.lstrip('-') if option.short else option.name[:1] }}')
                        {%- endif %}
                        .long("{{ option.name }}")
                        .help("{{ option.description }}")
                        {%- if option.type != 'boolean' %}
                        .value_name("VALUE")
                        {%- else %}
                        .action(clap::ArgAction::SetTrue)
                        {%- endif %}
                )
                {%- endfor %}
                {%- if cmd_data.subcommands %}
                  {%- for sub_data in cmd_data.subcommands %}
                .subcommand(
                    Command::new("{{ sub_data.name }}")
                        .about("{{ sub_data.description }}")
                        {%- for arg in sub_data.arguments | default([]) %}
                        .arg(
                            Arg::new("{{ arg.name }}")
                                .help("{{ arg.description }}")
                                .required(true)
                                .index({{ loop.index }})
                        )
                        {%- endfor %}
                )
                  {%- endfor %}
                {%- endif %}
        )
          {%- endfor %}
        {%- elif cli.root_command and cli.root_command.subcommands %}
          {%- for command in cli.root_command.subcommands %}
        .subcommand(
            Command::new("{{ command.name }}")
                .about("{{ command.description }}")
                {%- for arg in command.arguments | default([]) %}
                .arg(
                    Arg::new("{{ arg.name }}")
                        .help("{{ arg.description }}")
                        .required(true)
                        .index({{ loop.index }})
                )
                {%- endfor %}
                {%- for option in command.options | default([]) %}
                .arg(
                    Arg::new("{{ option.name }}")
                        {%- if option.short %}
                        .short('{{ option.short.lstrip('-') if option.short else option.name[:1] }}')
                        {%- endif %}
                        .long("{{ option.name }}")
                        .help("{{ option.description }}")
                        {%- if option.type != 'boolean' %}
                        .value_name("VALUE")
                        {%- else %}
                        .action(clap::ArgAction::SetTrue)
                        {%- endif %}
                )
                {%- endfor %}
        )
          {%- endfor %}
        {%- endif %}
        .subcommand(
            Command::new("completions")
                .about("Generate shell completions")
                .arg(
                    Arg::new("shell")
                        .help("Shell to generate completions for")
                        .required(true)
                        .value_parser(["bash", "zsh", "fish", "powershell", "elvish"])
                )
        )
}

// ============================================================================
// MAIN ENTRY POINT
// ============================================================================

fn run_cli() -> Result<()> {
    let app = build_cli();
    let matches = app.get_matches();
    
    // Initialize logging
    let verbose = matches.get_flag("verbose");
    let debug = matches.get_flag("debug");
    logger::init_logger(verbose, debug);
    
    // Load configuration
    let mut config_manager = config::ConfigManager::new()
        .context("Failed to initialize configuration")?;
    
    // Handle commands
    match matches.subcommand() {
        Some(("completions", sub_matches)) => {
            let shell = sub_matches.get_one::<String>("shell").unwrap();
            completion::print_completion(shell)?;
        }
        {%- if clap_commands and clap_commands.subcommands %}
          {%- for cmd_data in clap_commands.subcommands %}
        Some(("{{ cmd_data.name }}", sub_matches)) => {
            {%- if cmd_data.subcommands %}
            match sub_matches.subcommand() {
                {%- for sub_data in cmd_data.subcommands %}
                Some(("{{ sub_data.name }}", sub_sub_matches)) => {
                    debug!("Executing {{ cmd_data.name }} {{ sub_data.name }} command");
                    cli_hooks::on_{{ cmd_data.name.replace('-', '_') }}_{{ sub_data.name.replace('-', '_') }}(sub_sub_matches)
                        .context("Failed to execute {{ cmd_data.name }} {{ sub_data.name }}")?;
                }
                {%- endfor %}
                _ => {
                    debug!("Executing {{ cmd_data.name }} command");
                    cli_hooks::on_{{ cmd_data.name.replace('-', '_') }}(sub_matches)
                        .context("Failed to execute {{ cmd_data.name }}")?;
                }
            }
            {%- else %}
            debug!("Executing {{ cmd_data.name }} command");
            cli_hooks::on_{{ cmd_data.name.replace('-', '_') }}(sub_matches)
                .context("Failed to execute {{ cmd_data.name }}")?;
            {%- endif %}
        }
          {%- endfor %}
        {%- elif cli.root_command and cli.root_command.subcommands %}
          {%- for command in cli.root_command.subcommands %}
        Some(("{{ command.name }}", sub_matches)) => {
            debug!("Executing {{ command.name }} command");
            cli_hooks::on_{{ command.name.replace('-', '_') }}(sub_matches)
                .context("Failed to execute {{ command.name }}")?;
        }
          {%- endfor %}
        {%- endif %}
        _ => {
            // No subcommand provided, show help
            println!("{}", build_cli().render_help());
        }
    }
    
    Ok(())
}

// Handle errors properly
#[cfg(not(test))]
fn main_wrapper() {
    // Add spacing before command output (except when output is redirected)
    if std::io::IsTerminal::is_terminal(&std::io::stdout()) {
        println!();  // Empty line before
    }
    
    if let Err(e) = run_cli() {
        let verbose = std::env::args().any(|arg| arg == "--verbose" || arg == "-v");
        errors::handle_error(e, verbose);
    }
    
    // Add spacing after command output (except when output is redirected)
    if std::io::IsTerminal::is_terminal(&std::io::stdout()) {
        println!();  // Empty line after
    }
}

// Entry point with enhanced spacing
#[cfg(not(test))]
fn main() {
    main_wrapper();
}