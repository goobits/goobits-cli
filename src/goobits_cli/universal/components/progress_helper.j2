{#
Universal Component: Progress helper utilities for TypeScript
This template generates TypeScript utilities for progress tracking and display.
#}
/**
 * Progress helper utilities for {{ project.name }} CLI
 * Generated by Goobits CLI Framework
 */

export interface ProgressOptions {
  total?: number;
  format?: string;
  clearOnComplete?: boolean;
  hideCursor?: boolean;
  fps?: number;
  stream?: NodeJS.WriteStream;
  forceRedraw?: boolean;
}

export interface ProgressState {
  current: number;
  total: number;
  percentage: number;
  startTime: number;
  elapsedTime: number;
  estimatedTime?: number;
  rate?: number;
}

export class ProgressBar {
  private options: Required<ProgressOptions>;
  private state: ProgressState;
  private timer?: NodeJS.Timer;
  private lastRender: string = '';

  constructor(options: ProgressOptions = {}) {
    this.options = {
      total: options.total || 100,
      format: options.format || '[:bar] :current/:total :percent :etas',
      clearOnComplete: options.clearOnComplete !== false,
      hideCursor: options.hideCursor !== false,
      fps: options.fps || 10,
      stream: options.stream || process.stderr,
      forceRedraw: options.forceRedraw || false,
    };

    this.state = {
      current: 0,
      total: this.options.total,
      percentage: 0,
      startTime: Date.now(),
      elapsedTime: 0,
    };

    if (this.options.hideCursor) {
      this.options.stream.write('\x1B[?25l');
    }
  }

  public update(current: number): void {
    this.state.current = Math.min(current, this.state.total);
    this.state.percentage = this.state.total > 0 ? (this.state.current / this.state.total) * 100 : 0;
    this.state.elapsedTime = Date.now() - this.state.startTime;
    
    if (this.state.elapsedTime > 0) {
      this.state.rate = this.state.current / (this.state.elapsedTime / 1000);
      if (this.state.rate > 0 && this.state.current < this.state.total) {
        this.state.estimatedTime = (this.state.total - this.state.current) / this.state.rate;
      }
    }

    this.render();

    if (this.state.current >= this.state.total) {
      this.complete();
    }
  }

  public increment(step: number = 1): void {
    this.update(this.state.current + step);
  }

  public setTotal(total: number): void {
    this.state.total = total;
    this.options.total = total;
  }

  public complete(): void {
    this.state.current = this.state.total;
    this.state.percentage = 100;
    this.render();

    if (this.timer) {
      clearInterval(this.timer);
    }

    if (this.options.clearOnComplete) {
      this.options.stream.clearLine(0);
      this.options.stream.cursorTo(0);
    } else {
      this.options.stream.write('\n');
    }

    if (this.options.hideCursor) {
      this.options.stream.write('\x1B[?25h');
    }
  }

  public terminate(): void {
    if (this.timer) {
      clearInterval(this.timer);
    }

    if (this.options.hideCursor) {
      this.options.stream.write('\x1B[?25h');
    }
  }

  private render(): void {
    const rendered = this.format();
    
    if (rendered === this.lastRender && !this.options.forceRedraw) {
      return;
    }

    this.options.stream.clearLine(0);
    this.options.stream.cursorTo(0);
    this.options.stream.write(rendered);
    this.lastRender = rendered;
  }

  private format(): string {
    let str = this.options.format;
    const barWidth = 40;
    const progress = Math.floor((this.state.percentage / 100) * barWidth);
    const bar = '='.repeat(progress) + ' '.repeat(barWidth - progress);

    str = str.replace(':bar', `[${bar}]`);
    str = str.replace(':current', this.state.current.toString());
    str = str.replace(':total', this.state.total.toString());
    str = str.replace(':percent', `${this.state.percentage.toFixed(1)}%`);
    str = str.replace(':elapsed', this.formatTime(this.state.elapsedTime / 1000));
    str = str.replace(':eta', this.state.estimatedTime ? this.formatTime(this.state.estimatedTime) : 'N/A');
    str = str.replace(':etas', this.state.estimatedTime ? this.formatTime(this.state.estimatedTime) : '');
    str = str.replace(':rate', this.state.rate ? `${this.state.rate.toFixed(2)}/s` : '0/s');

    return str;
  }

  private formatTime(seconds: number): string {
    const h = Math.floor(seconds / 3600);
    const m = Math.floor((seconds % 3600) / 60);
    const s = Math.floor(seconds % 60);

    if (h > 0) {
      return `${h}:${m.toString().padStart(2, '0')}:${s.toString().padStart(2, '0')}`;
    }
    return `${m}:${s.toString().padStart(2, '0')}`;
  }
}

export function createProgressBar(options?: ProgressOptions): ProgressBar {
  return new ProgressBar(options);
}

export function withProgress<T>(
  total: number,
  task: (progress: ProgressBar) => Promise<T>,
  options?: Omit<ProgressOptions, 'total'>
): Promise<T> {
  const progress = createProgressBar({ ...options, total });
  
  return task(progress)
    .then(result => {
      progress.complete();
      return result;
    })
    .catch(error => {
      progress.terminate();
      throw error;
    });
}