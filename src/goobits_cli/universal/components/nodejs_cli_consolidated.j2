#!/usr/bin/env node
/**
 * {{ project.name }} - {{ project.description }}
 * Generated by Goobits CLI Framework v{{ generator_version }}
 * 
 * This is a consolidated CLI file with all utilities embedded.
 * Generated from: {{ config_filename }}
 */

import { Command } from 'commander';
import chalk from 'chalk';
import ora from 'ora';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { homedir } from 'os';
import yaml from 'js-yaml';
import { fileURLToPath } from 'url';
import { AsyncLocalStorage } from 'async_hooks';
import winston from 'winston';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// ============================================================================
// EMBEDDED CONFIGURATION MANAGER
// ============================================================================

class ConfigManager {
    constructor(configFile = null) {
        this.configFile = configFile || this._getDefaultConfigPath();
        this.config = {
            {%- for key, value in (cli.default_config | default({})).items() %}
            {{ key }}: {{ value | tojson }},
            {%- endfor %}
            debug: false,
            outputFormat: 'text'
        };
        this.loadConfig();
    }

    _getDefaultConfigPath() {
        const configDir = join(homedir(), '.config', '{{ cli.name | default(project.command_name) }}');
        if (!existsSync(configDir)) {
            mkdirSync(configDir, { recursive: true });
        }
        return join(configDir, 'config.yaml');
    }

    loadConfig() {
        if (existsSync(this.configFile)) {
            try {
                const content = readFileSync(this.configFile, 'utf8');
                const loaded = yaml.load(content) || {};
                this.config = { ...this.config, ...loaded };
            } catch (error) {
                console.warn(`Warning: Failed to load config from ${this.configFile}: ${error.message}`);
            }
        }
        
        // Environment variable overrides
        for (const key of Object.keys(this.config)) {
            const envKey = `{{ (cli.name | default(project.command_name)).upper().replace('-', '_') }}_${key.toUpperCase()}`;
            if (process.env[envKey]) {
                const value = process.env[envKey];
                this.config[key] = value === 'true' ? true : 
                                   value === 'false' ? false : 
                                   isNaN(value) ? value : Number(value);
            }
        }
    }

    saveConfig() {
        try {
            const content = yaml.dump(this.config, { indent: 2 });
            writeFileSync(this.configFile, content, 'utf8');
            return true;
        } catch (error) {
            console.error(`Failed to save config: ${error.message}`);
            return false;
        }
    }

    get(key, defaultValue = undefined) {
        return this.config[key] !== undefined ? this.config[key] : defaultValue;
    }

    set(key, value) {
        this.config[key] = value;
    }

    update(updates) {
        this.config = { ...this.config, ...updates };
    }
}

// ============================================================================
// EMBEDDED ERROR HANDLER
// ============================================================================

const ExitCode = {
    SUCCESS: 0,
    GENERAL_ERROR: 1,
    USAGE_ERROR: 2,
    CONFIG_ERROR: 3,
    NETWORK_ERROR: 4,
    PERMISSION_ERROR: 5,
    FILE_NOT_FOUND: 6
};

class CliError extends Error {
    constructor(message, exitCode = ExitCode.GENERAL_ERROR, details = {}) {
        super(message);
        this.name = 'CliError';
        this.exitCode = exitCode;
        this.details = details;
        Error.captureStackTrace(this, CliError);
    }
}

class ErrorHandler {
    constructor(options = {}) {
        this.debug = options.debug || false;
        this.verbose = options.verbose || options.debug || false;
    }

    handleError(error, context = null) {
        if (error instanceof CliError) {
            this._handleCliError(error, context);
        } else {
            this._handleUnexpectedError(error, context);
        }
    }

    _handleCliError(error, context) {
        let message = chalk.red(`Error: ${error.message}`);
        if (context) {
            message = `${context}: ${message}`;
        }
        console.error(message);

        if (this.verbose && Object.keys(error.details).length > 0) {
            console.error('Additional details:');
            for (const [key, value] of Object.entries(error.details)) {
                console.error(`  ${key}: ${value}`);
            }
        }

        if (this.verbose) {
            console.error(error.stack);
        }

        process.exit(error.exitCode);
    }

    _handleUnexpectedError(error, context) {
        let message = chalk.red(`Unexpected error: ${error.message}`);
        if (context) {
            message = `${context}: ${message}`;
        }
        console.error(message);

        if (this.verbose) {
            console.error(error.stack);
        } else {
            console.error(chalk.gray('Run with --verbose for more details'));
        }

        process.exit(ExitCode.GENERAL_ERROR);
    }

    warn(message, details = {}) {
        console.error(chalk.yellow(`Warning: ${message}`));
        if (this.verbose && Object.keys(details).length > 0) {
            for (const [key, value] of Object.entries(details)) {
                console.error(`  ${key}: ${value}`);
            }
        }
    }
}

// ============================================================================
// EMBEDDED LOGGER
// ============================================================================

const contextStorage = new AsyncLocalStorage();

const structuredFormatter = winston.format.printf(({ timestamp, level, message, ...meta }) => {
    const context = contextStorage.getStore() || {};
    const environment = process.env.ENVIRONMENT || 'development';
    const isProduction = environment.toLowerCase() === 'production';
    
    const logData = {
        timestamp,
        level,
        message,
        ...meta
    };
    
    if (Object.keys(context).length > 0) {
        logData.context = context;
    }
    
    if (isProduction) {
        return JSON.stringify(logData);
    } else {
        const contextStr = Object.keys(context).length > 0 
            ? ` [${Object.entries(context).map(([k, v]) => `${k}=${v}`).join(', ')}]` 
            : '';
        
        const extraFields = Object.keys(meta).filter(key => 
            !['timestamp', 'level', 'message', 'context'].includes(key)
        );
        const extraStr = extraFields.length > 0 
            ? ` ${JSON.stringify(extraFields.reduce((acc, key) => ({ ...acc, [key]: meta[key] }), {}))}` 
            : '';
        
        return `${timestamp} ${level.toUpperCase().padEnd(8)} {{ project.name }}.${message}${contextStr}${extraStr}`;
    }
});

let logger = null;

function setupLogging() {
    const logLevel = process.env.LOG_LEVEL || 'info';
    const logOutput = process.env.LOG_OUTPUT || 'stdout';
    
    const transports = [];
    
    if (logOutput === 'stderr') {
        transports.push(new winston.transports.Console({ 
            stderrLevels: ['error', 'warn', 'info', 'debug'],
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    } else if (logOutput.startsWith('file:')) {
        const logFile = logOutput.substring(5);
        const logDir = dirname(logFile);
        
        if (!existsSync(logDir)) {
            mkdirSync(logDir, { recursive: true });
        }
        
        transports.push(new winston.transports.File({
            filename: logFile,
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    } else {
        transports.push(new winston.transports.Console({
            level: 'info',
            stderrLevels: ['error', 'warn'],
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    }
    
    logger = winston.createLogger({
        level: logLevel,
        transports,
        exitOnError: false
    });
    
    logger.info(`Logging initialized: level=${logLevel}, output=${logOutput}`);
}

function getLogger(name = 'main') {
    if (!logger) {
        setupLogging();
    }
    
    return {
        debug: (message, meta = {}) => logger.debug(message, { module: name, ...meta }),
        info: (message, meta = {}) => logger.info(message, { module: name, ...meta }),
        warn: (message, meta = {}) => logger.warn(message, { module: name, ...meta }),
        error: (message, meta = {}) => logger.error(message, { module: name, ...meta })
    };
}

// ============================================================================
// EMBEDDED COMPLETION ENGINE
// ============================================================================

function generateCompletion(program, shell = 'bash') {
    const commands = [];
    
    function extractCommands(cmd, prefix = '') {
        const name = prefix ? `${prefix} ${cmd.name()}` : cmd.name();
        commands.push(name);
        
        cmd.commands.forEach(subCmd => {
            extractCommands(subCmd, name);
        });
    }
    
    extractCommands(program);
    
    if (shell === 'bash') {
        return `#!/bin/bash
_{{ cli.name.replace('-', '_') }}_completions() {
    local cur prev commands
    cur="\${COMP_WORDS[COMP_CWORD]}"
    prev="\${COMP_WORDS[COMP_CWORD-1]}"
    commands="${commands.join(' ')}"
    
    if [[ \${COMP_CWORD} -eq 1 ]]; then
        COMPREPLY=( $(compgen -W "\${commands}" -- \${cur}) )
    fi
}

complete -F _{{ cli.name.replace('-', '_') }}_completions {{ cli.name }}`;
    }
    
    return '# Completion not implemented for this shell';
}

// ============================================================================
// HOOK SYSTEM
// ============================================================================

let hooks = null;

async function loadHooks() {
    try {
        const hookModule = await import('./src/hooks.mjs');
        hooks = hookModule.default || hookModule;
    } catch (error) {
        if (error.code === 'ERR_MODULE_NOT_FOUND') {
            console.error(chalk.red('Hook implementation not found.'));
            console.error('Please create \'src/hooks.mjs\' with your command implementations.');
            console.error('Example:');
            console.error(chalk.gray(`
export async function onBuild(args) {
    console.log('Build command:', args);
}
            `));
        } else {
            console.error(chalk.red(`Failed to load hooks: ${error.message}`));
        }
        process.exit(2);
    }
}

// ============================================================================
// CLI SETUP
// ============================================================================

// Initialize components
const configManager = new ConfigManager();
const errorHandler = new ErrorHandler({ 
    verbose: configManager.get('verbose', false),
    debug: configManager.get('debug', false)
});
const log = getLogger('cli');

// Create main program
const program = new Command();

program
    .name('{{ cli.name | default(project.command_name) }}')
    .description('{{ cli.description | default(project.description) }}')
    .version('{{ cli.version | default(project.version) | default("1.0.0") }}');

// Global options
{%- for option in cli.global_options | default([]) %}
program.option(
    '{{ option.short | default("") }}{{ ", " if option.short else "" }}{{ option.long }}{{ " <value>" if option.type != "boolean" else "" }}',
    '{{ option.description }}'
    {%- if option.default is defined %},
    {{ option.default | tojson }}
    {%- endif %}
);
{%- endfor %}

// Commands - handle both old (cli.commands) and new (cli.root_command.subcommands) formats
{%- if cli.commands %}
  {%- for cmd_name, cmd_data in cli.commands.items() %}
program
    .command('{{ cmd_name }}')
    .description('{{ cmd_data.desc | default(cmd_data.description) }}')
    {%- for arg in cmd_data.arguments | default([]) %}
    .argument('{{ arg.format | default(arg.name) }}', '{{ arg.description }}')
    {%- endfor %}
    {%- for option in cmd_data.options | default([]) %}
    .option(
        '{{ option.short | default("") }}{{ ", " if option.short else "" }}{{ option.long }}{{ " <value>" if option.type != "boolean" else "" }}',
        '{{ option.description }}'
        {%- if option.default is defined %},
        {{ option.default | tojson }}
        {%- endif %}
    )
    {%- endfor %}
    .action(async (...args) => {
        try {
            // Load hooks if not already loaded
            if (!hooks) {
                await loadHooks();
            }
            
            // Call the hook function
            const hookName = 'on{{ cmd_name | capitalize }}';
            if (hooks && typeof hooks[hookName] === 'function') {
                await hooks[hookName](...args);
            } else {
                console.error(chalk.red(`Hook function '${hookName}' not found in src/hooks.mjs`));
                process.exit(1);
            }
        } catch (error) {
            errorHandler.handleError(error, '{{ cmd_name }} command');
        }
    });
    
    {%- if cmd_data.subcommands %}
    // Nested subcommands for {{ cmd_name }}
    {%- for sub_name, sub_data in cmd_data.subcommands.items() %}
    program.command('{{ cmd_name }} {{ sub_name }}')
        .description('{{ sub_data.desc | default(sub_data.description) }}')
        .action(async (...args) => {
            try {
                if (!hooks) {
                    await loadHooks();
                }
                const hookName = 'on{{ cmd_name | capitalize }}{{ sub_name | capitalize }}';
                if (hooks && typeof hooks[hookName] === 'function') {
                    await hooks[hookName](...args);
                } else {
                    console.error(chalk.red(`Hook function '${hookName}' not found in src/hooks.mjs`));
                    process.exit(1);
                }
            } catch (error) {
                errorHandler.handleError(error, '{{ cmd_name }} {{ sub_name }} command');
            }
        });
    {%- endfor %}
    {%- endif %}
  {%- endfor %}
{%- elif cli.root_command and cli.root_command.subcommands %}
  {%- for command in cli.root_command.subcommands %}
program
    .command('{{ command.name }}')
    {%- if command.aliases %}
    .aliases({{ command.aliases | tojson }})
    {%- endif %}
    .description('{{ command.description }}')
    {%- for arg in command.arguments | default([]) %}
    .argument('{{ arg.format | default(arg.name) }}', '{{ arg.description }}')
    {%- endfor %}
    {%- for option in command.options | default([]) %}
    .option(
        '{{ option.short | default("") }}{{ ", " if option.short else "" }}{{ option.long }}{{ " <value>" if option.type != "boolean" else "" }}',
        '{{ option.description }}'
        {%- if option.default is defined %},
        {{ option.default | tojson }}
        {%- endif %}
    )
    {%- endfor %}
    .action(async (...args) => {
        try {
            // Load hooks if not already loaded
            if (!hooks) {
                await loadHooks();
            }
            
            // Call the hook function
            const hookName = 'on{{ command.name | capitalize }}';
            if (hooks && typeof hooks[hookName] === 'function') {
                await hooks[hookName](...args);
            } else {
                console.error(chalk.red(`Hook function '${hookName}' not found in src/hooks.mjs`));
                process.exit(1);
            }
        } catch (error) {
            errorHandler.handleError(error, '{{ command.name }} command');
        }
    });
  {%- endfor %}
{%- endif %}

// Interactive mode support
{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
program.option('--interactive', 'Run in interactive mode');

if (process.argv.includes('--interactive')) {
    console.log(chalk.cyan('Interactive mode is enabled but not yet implemented.'));
    console.log('This feature will be available in a future version.');
    process.exit(0);
}
{%- endif %}

// Error handlers
process.on('SIGINT', () => {
    console.error(chalk.yellow('\nOperation cancelled by user'));
    process.exit(ExitCode.GENERAL_ERROR);
});

process.on('uncaughtException', (error) => {
    console.error(chalk.red('Uncaught Exception:'), error);
    process.exit(ExitCode.GENERAL_ERROR);
});

process.on('unhandledRejection', (reason, promise) => {
    console.error(chalk.red('Unhandled Rejection at:'), promise, 'reason:', reason);
    process.exit(ExitCode.GENERAL_ERROR);
});

// Parse arguments
program.parse(process.argv);