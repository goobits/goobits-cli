{#
Universal Configuration Manager Template (Simplified)
====================================================

This is the SIMPLIFIED version of config_manager.j2 that uses the extracted
ConfigFramework instead of embedding business logic in the template.

Previously: 524 lines of complex template logic
Now: ~50 lines of simple framework integration

The business logic has been extracted to:
- src/goobits_cli/config/config_framework.py (core orchestration)
- src/goobits_cli/config/language_adapters.py (language-specific generation)
#}

{#- Import the config framework -#}
{%- set config_framework = get_config_framework() -%}

{#- Prepare configuration for the framework -#}
{%- set framework_config = {
    'project': {
        'name': project.package_name|default(project.name|default('cli')),
        'command_name': project.command_name|default(project.name|default('cli')),
        'display_name': project.display_name|default(project.name|default('CLI')),
        'description': project.description|default('')
    },
    'config_schema': config_schema|default({}),
    'config_format': config_format|default('yaml'),
    'default_config_path': default_config_path|default(none),
    'env_prefix': env_prefix|default(none),
    'config_validation': config_validation|default(true)
} -%}

{#- Generate language-specific configuration management code using the framework -#}
{{ config_framework.generate_config_code(language, framework_config) }}

{#
That's it! All the complex business logic is now in testable Python code.

Benefits of this approach:
1. Business logic is now unit testable
2. No more duplicated conditionals across languages
3. Easy to debug and maintain
4. Clear separation of concerns
5. Template is now just a thin integration layer

The extracted framework provides:
- Language-specific code generation
- Configuration validation
- File format handling (YAML, JSON, TOML)
- Environment variable support
- Testable business logic
- Maintainable architecture
#}