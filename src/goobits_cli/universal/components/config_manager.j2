{# Universal Configuration Manager Template
   
   This template generates configuration management code for CLIs,
   including reading config files, environment variables, and defaults.
   
   Variables expected:
   - language: Target language
   - project: Project metadata
   - config_schema: Configuration schema definition
#}

{%- if language == 'python' -%}
"""
Configuration management for {{ project.name }}
"""

import os
import json
import yaml
from pathlib import Path
from typing import Dict, Any, Optional
from dataclasses import dataclass, asdict

@dataclass
class Config:
    """Configuration data structure."""
    
    # Default configuration values
{%- if config_schema and config_schema.properties %}
{%- for prop_name, prop_info in config_schema.properties.items() %}
    {{ prop_name }}: {{ prop_info.get('python_type', 'str') }} = {{ prop_info.get('default', 'None') }}
{%- endfor %}
{%- else %}
    # Add your configuration fields here
    debug: bool = False
    output_format: str = "text"
{%- endif %}

class ConfigManager:
    """Manages configuration loading and saving."""
    
    def __init__(self, config_file: Optional[str] = None):
        self.config_file = config_file or self._get_default_config_path()
        self.config = Config()
        self.load_config()
    
    def _get_default_config_path(self) -> str:
        """Get the default configuration file path."""
        config_dir = Path.home() / ".config" / "{{ (project.name or 'app') | lower | replace(' ', '-') }}"
        config_dir.mkdir(parents=True, exist_ok=True)
        return str(config_dir / "config.yaml")
    
    def load_config(self) -> None:
        """Load configuration from file and environment variables."""
        # Load from config file if it exists
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    if self.config_file.endswith('.json'):
                        data = json.load(f)
                    else:
                        data = yaml.safe_load(f)
                
                if data:
                    for key, value in data.items():
                        if hasattr(self.config, key):
                            setattr(self.config, key, value)
            except Exception as e:
                print(f"Warning: Failed to load config file {self.config_file}: {e}")
        
        # Override with environment variables
        env_prefix = "{{ (project.name or 'APP') | upper | replace(' ', '_') | replace('-', '_') }}_"
        for key in asdict(self.config).keys():
            env_key = f"{env_prefix}{key.upper()}"
            if env_key in os.environ:
                value = os.environ[env_key]
                # Convert string values to appropriate types
                if hasattr(self.config, key):
                    current_value = getattr(self.config, key)
                    if isinstance(current_value, bool):
                        value = value.lower() in ('true', '1', 'yes', 'on')
                    elif isinstance(current_value, int):
                        value = int(value)
                    elif isinstance(current_value, float):
                        value = float(value)
                    setattr(self.config, key, value)
    
    def save_config(self) -> None:
        """Save current configuration to file."""
        try:
            config_path = Path(self.config_file)
            config_path.parent.mkdir(parents=True, exist_ok=True)
            
            with open(self.config_file, 'w') as f:
                yaml.dump(asdict(self.config), f, default_flow_style=False)
        except Exception as e:
            print(f"Error: Failed to save config file {self.config_file}: {e}")
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get a configuration value."""
        return getattr(self.config, key, default)
    
    def set(self, key: str, value: Any) -> None:
        """Set a configuration value."""
        if hasattr(self.config, key):
            setattr(self.config, key, value)
        else:
            raise KeyError(f"Unknown configuration key: {key}")
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert configuration to dictionary."""
        return asdict(self.config)

# Global configuration instance
_config_manager = None

def get_config() -> ConfigManager:
    """Get the global configuration manager instance."""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager()
    return _config_manager

{%- elif language == 'nodejs' -%}
/**
 * Configuration management for {{ project.name }}
 */

const fs = require('fs');
const path = require('path');
const os = require('os');
const yaml = require('js-yaml');

class ConfigManager {
    constructor(configFile = null) {
        this.configFile = configFile || this._getDefaultConfigPath();
        this.config = {
{%- if config_schema and config_schema.properties %}
{%- for prop_name, prop_info in config_schema.properties.items() %}
            {{ prop_name }}: {{ prop_info.get('default', 'null') | tojson }},
{%- endfor %}
{%- else %}
            debug: false,
            outputFormat: 'text'
{%- endif %}
        };
        this.loadConfig();
    }

    _getDefaultConfigPath() {
        const configDir = path.join(os.homedir(), '.config', '{{ (project.name or 'app') | lower | replace(' ', '-') }}');
        if (!fs.existsSync(configDir)) {
            fs.mkdirSync(configDir, { recursive: true });
        }
        return path.join(configDir, 'config.yaml');
    }

    loadConfig() {
        // Load from config file if it exists
        if (fs.existsSync(this.configFile)) {
            try {
                const content = fs.readFileSync(this.configFile, 'utf8');
                let data;
                
                if (this.configFile.endsWith('.json')) {
                    data = JSON.parse(content);
                } else {
                    data = yaml.load(content);
                }

                if (data) {
                    Object.assign(this.config, data);
                }
            } catch (error) {
                console.warn(`Warning: Failed to load config file ${this.configFile}: ${error.message}`);
            }
        }

        // Override with environment variables
        const envPrefix = '{{ (project.name or 'APP') | upper | replace(' ', '_') | replace('-', '_') }}_';
        for (const key of Object.keys(this.config)) {
            const envKey = `${envPrefix}${key.toUpperCase()}`;
            if (process.env[envKey]) {
                let value = process.env[envKey];
                
                // Convert string values to appropriate types
                const currentValue = this.config[key];
                if (typeof currentValue === 'boolean') {
                    value = ['true', '1', 'yes', 'on'].includes(value.toLowerCase());
                } else if (typeof currentValue === 'number') {
                    value = Number(value);
                }
                
                this.config[key] = value;
            }
        }
    }

    saveConfig() {
        try {
            const configDir = path.dirname(this.configFile);
            if (!fs.existsSync(configDir)) {
                fs.mkdirSync(configDir, { recursive: true });
            }

            const content = yaml.dump(this.config);
            fs.writeFileSync(this.configFile, content, 'utf8');
        } catch (error) {
            console.error(`Error: Failed to save config file ${this.configFile}: ${error.message}`);
        }
    }

    get(key, defaultValue = null) {
        return this.config[key] !== undefined ? this.config[key] : defaultValue;
    }

    set(key, value) {
        if (key in this.config) {
            this.config[key] = value;
        } else {
            throw new Error(`Unknown configuration key: ${key}`);
        }
    }

    toObject() {
        return { ...this.config };
    }
}

// Global configuration instance
let _configManager = null;

function getConfig() {
    if (!_configManager) {
        _configManager = new ConfigManager();
    }
    return _configManager;
}

module.exports = {
    ConfigManager,
    getConfig
};

{%- elif language == 'typescript' -%}
/**
 * Configuration management for {{ project.name }}
 */

import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import * as yaml from 'js-yaml';

interface ConfigSchema {
{%- if config_schema and config_schema.properties %}
{%- for prop_name, prop_info in config_schema.properties.items() %}
    {{ prop_name }}: {{ prop_info.get('typescript_type', 'string') }};
{%- endfor %}
{%- else %}
    debug: boolean;
    outputFormat: string;
{%- endif %}
}

export class ConfigManager {
    private configFile: string;
    private config: ConfigSchema;

    constructor(configFile?: string) {
        this.configFile = configFile || this.getDefaultConfigPath();
        this.config = {
{%- if config_schema and config_schema.properties %}
{%- for prop_name, prop_info in config_schema.properties.items() %}
            {{ prop_name }}: {{ prop_info.get('default', 'null') | tojson }},
{%- endfor %}
{%- else %}
            debug: false,
            outputFormat: 'text'
{%- endif %}
        };
        this.loadConfig();
    }

    private getDefaultConfigPath(): string {
        const configDir = path.join(os.homedir(), '.config', '{{ (project.name or 'app') | lower | replace(' ', '-') }}');
        if (!fs.existsSync(configDir)) {
            fs.mkdirSync(configDir, { recursive: true });
        }
        return path.join(configDir, 'config.yaml');
    }

    public loadConfig(): void {
        // Load from config file if it exists
        if (fs.existsSync(this.configFile)) {
            try {
                const content = fs.readFileSync(this.configFile, 'utf8');
                let data: any;
                
                if (this.configFile.endsWith('.json')) {
                    data = JSON.parse(content);
                } else {
                    data = yaml.load(content);
                }

                if (data) {
                    Object.assign(this.config, data);
                }
            } catch (error) {
                console.warn(`Warning: Failed to load config file ${this.configFile}: ${(error as Error).message}`);
            }
        }

        // Override with environment variables
        const envPrefix = '{{ (project.name or 'APP') | upper | replace(' ', '_') | replace('-', '_') }}_';
        for (const key of Object.keys(this.config) as (keyof ConfigSchema)[]) {
            const envKey = `${envPrefix}${String(key).toUpperCase()}`;
            if (process.env[envKey]) {
                let value: any = process.env[envKey];
                
                // Convert string values to appropriate types
                const currentValue = this.config[key];
                if (typeof currentValue === 'boolean') {
                    value = ['true', '1', 'yes', 'on'].includes(value.toLowerCase());
                } else if (typeof currentValue === 'number') {
                    value = Number(value);
                }
                
                this.config[key] = value;
            }
        }
    }

    public saveConfig(): void {
        try {
            const configDir = path.dirname(this.configFile);
            if (!fs.existsSync(configDir)) {
                fs.mkdirSync(configDir, { recursive: true });
            }

            const content = yaml.dump(this.config);
            fs.writeFileSync(this.configFile, content, 'utf8');
        } catch (error) {
            console.error(`Error: Failed to save config file ${this.configFile}: ${(error as Error).message}`);
        }
    }

    public get<K extends keyof ConfigSchema>(key: K): ConfigSchema[K];
    public get(key: string, defaultValue?: any): any;
    public get(key: any, defaultValue: any = null): any {
        return this.config[key as keyof ConfigSchema] !== undefined ? this.config[key as keyof ConfigSchema] : defaultValue;
    }

    public set<K extends keyof ConfigSchema>(key: K, value: ConfigSchema[K]): void;
    public set(key: string, value: any): void;
    public set(key: any, value: any): void {
        if (key in this.config) {
            (this.config as any)[key] = value;
        } else {
            throw new Error(`Unknown configuration key: ${key}`);
        }
    }

    public toObject(): ConfigSchema {
        return { ...this.config };
    }
}

// Global configuration instance
let _configManager: ConfigManager | null = null;

export function getConfig(): ConfigManager {
    if (!_configManager) {
        _configManager = new ConfigManager();
    }
    return _configManager;
}

{%- elif language == 'rust' -%}
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::PathBuf;

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {
{%- if config_schema and config_schema.properties %}
{%- for prop_name, prop_info in config_schema.properties.items() %}
    pub {{ prop_name }}: {{ prop_info.get('rust_type', 'String') }},
{%- endfor %}
{%- else %}
    pub debug: bool,
    pub output_format: String,
{%- endif %}
}

impl Default for Config {
    fn default() -> Self {
        Self {
{%- if config_schema and config_schema.properties %}
{%- for prop_name, prop_info in config_schema.properties.items() %}
            {{ prop_name }}: {{ prop_info.get('rust_default', '""') }},
{%- endfor %}
{%- else %}
            debug: false,
            output_format: "text".to_string(),
{%- endif %}
        }
    }
}

pub struct ConfigManager {
    config_file: PathBuf,
    config: Config,
}

impl ConfigManager {
    pub fn new(config_file: Option<PathBuf>) -> Result<Self, Box<dyn std::error::Error>> {
        let config_file = config_file.unwrap_or_else(|| Self::get_default_config_path());
        let mut manager = Self {
            config_file,
            config: Config::default(),
        };
        manager.load_config()?;
        Ok(manager)
    }

    fn get_default_config_path() -> PathBuf {
        let home_dir = env::var("HOME").unwrap_or_else(|_| ".".to_string());
        let config_dir = PathBuf::from(home_dir)
            .join(".config")
            .join("{{ (project.name or 'app') | lower | replace(' ', '-') }}");
        
        if let Err(_) = fs::create_dir_all(&config_dir) {
            eprintln!("Warning: Could not create config directory");
        }
        
        config_dir.join("config.yaml")
    }

    pub fn load_config(&mut self) -> Result<(), Box<dyn std::error::Error>> {
        // Load from config file if it exists
        if self.config_file.exists() {
            let content = fs::read_to_string(&self.config_file)?;
            
            if let Ok(data) = if self.config_file.extension().and_then(|s| s.to_str()) == Some("json") {
                serde_json::from_str::<Config>(&content)
            } else {
                serde_yaml::from_str::<Config>(&content)
            } {
                self.config = data;
            } else {
                eprintln!("Warning: Failed to parse config file");
            }
        }

        // Override with environment variables
        let env_prefix = "{{ (project.name or 'APP') | upper | replace(' ', '_') | replace('-', '_') }}_";
        
{%- if config_schema and config_schema.properties %}
{%- for prop_name, prop_info in config_schema.properties.items() %}
        if let Ok(val) = env::var(format!("{}{{ prop_name.upper() }}", env_prefix)) {
            {%- if prop_info.get('rust_type') == 'bool' %}
            self.config.{{ prop_name }} = ["true", "1", "yes", "on"].contains(&val.to_lowercase().as_str());
            {%- elif prop_info.get('rust_type', '').startswith('i') or prop_info.get('rust_type', '').startswith('u') %}
            if let Ok(parsed) = val.parse() {
                self.config.{{ prop_name }} = parsed;
            }
            {%- elif prop_info.get('rust_type', '').startswith('f') %}
            if let Ok(parsed) = val.parse() {
                self.config.{{ prop_name }} = parsed;
            }
            {%- else %}
            self.config.{{ prop_name }} = val;
            {%- endif %}
        }
{%- endfor %}
{%- else %}
        if let Ok(val) = env::var(format!("{}DEBUG", env_prefix)) {
            self.config.debug = ["true", "1", "yes", "on"].contains(&val.to_lowercase().as_str());
        }
        if let Ok(val) = env::var(format!("{}OUTPUT_FORMAT", env_prefix)) {
            self.config.output_format = val;
        }
{%- endif %}

        Ok(())
    }

    pub fn save_config(&self) -> Result<(), Box<dyn std::error::Error>> {
        if let Some(parent) = self.config_file.parent() {
            fs::create_dir_all(parent)?;
        }

        let content = serde_yaml::to_string(&self.config)?;
        fs::write(&self.config_file, content)?;
        Ok(())
    }

    pub fn get_config(&self) -> &Config {
        &self.config
    }

    pub fn get_config_mut(&mut self) -> &mut Config {
        &mut self.config
    }
}

// Global configuration instance
static mut CONFIG_MANAGER: Option<ConfigManager> = None;
static mut CONFIG_INIT: std::sync::Once = std::sync::Once::new();

pub fn get_config() -> &'static ConfigManager {
    unsafe {
        CONFIG_INIT.call_once(|| {
            CONFIG_MANAGER = Some(ConfigManager::new(None).expect("Failed to initialize config"));
        });
        CONFIG_MANAGER.as_ref().unwrap()
    }
}

{%- endif -%}