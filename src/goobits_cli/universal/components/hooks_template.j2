{# User Hooks Template Generator
   
   This template generates a template file showing users how to implement
   their hook functions with the correct naming and structure.
   
   Variables expected:
   - language: Target language
   - project: Project metadata
   - cli: CLI schema with commands
#}

{%- if language == 'python' -%}
"""
Hook implementations for {{ project.name | default(project.package_name) }}.

This file contains the business logic for your CLI commands.
Implement the hook functions below to handle your CLI commands.

IMPORTANT: Hook names must use snake_case with 'on_' prefix
Example:
- Command 'hello' -> Hook function 'on_hello'
- Command 'hello-world' -> Hook function 'on_hello_world'
"""

# Import any modules you need here
import sys
import json
from typing import Any, Dict, Optional

{%- if cli.commands %}
{%- for cmd_name, cmd in cli.commands.items() %}

def on_{{ cmd_name | replace('-', '_') }}(
{%- if cmd.args %}
{%- for arg in cmd.args %}
    {{ arg.name }}: {{ 'str' if arg.type == 'string' else arg.type | default('str') }},
{%- endfor %}
{%- endif %}
{%- if cmd.options %}
{%- for option in cmd.options %}
    {{ option.name | replace('-', '_') }}: {{ 'bool' if option.type == 'flag' or option.type == 'boolean' else 'Optional[' + (option.type | default('str')) + ']' }} = {{ 'False' if option.type == 'flag' or option.type == 'boolean' else 'None' }},
{%- endfor %}
{%- endif %}
    **kwargs
) -> Dict[str, Any]:
    """
    Handle {{ cmd_name }} command.
    
{%- if cmd.args %}
    Args:
{%- for arg in cmd.args %}
        {{ arg.name }}: {{ arg.desc | default(arg.description) | default('No description') }}
{%- endfor %}
{%- endif %}
{%- if cmd.options %}
{%- for option in cmd.options %}
        {{ option.name | replace('-', '_') }}: {{ option.desc | default(option.description) | default('No description') }}
{%- endfor %}
{%- endif %}
    
    Returns:
        Dictionary with status and optional results
    """
    # Add your business logic here
    print(f"Executing {{ cmd_name }} command")
    
{%- if cmd.args %}
{%- for arg in cmd.args %}
    print(f"  {{ arg.name }}: {{ '{' }}{{ arg.name }}{{ '}' }}")
{%- endfor %}
{%- endif %}
    
    return {
        "status": "success",
        "message": "{{ cmd_name }} completed successfully"
    }
{%- endfor %}
{%- else %}
# Add your command hook implementations here
# Example:
# def on_hello(name: str, **kwargs) -> Dict[str, Any]:
#     print(f"Hello {name}!")
#     return {"status": "success"}
{%- endif %}

{%- elif language == 'nodejs' -%}
/**
 * Hook implementations for {{ project.name }}
 * 
 * This file contains the business logic for your CLI commands.
 * Implement the hook functions below to handle your CLI commands.
 * 
 * IMPORTANT: Hook names must use snake_case with 'on_' prefix
 * Example:
 * - Command 'hello' -> Hook function 'on_hello'
 * - Command 'hello-world' -> Hook function 'on_hello_world'
 */

// Import any modules you need here
import fs from 'fs';
import path from 'path';

{%- for cmd in cli.root_command.subcommands if cmd.subcommands is not defined or not cmd.subcommands %}

/**
 * {{ cmd.description }}
{%- for arg in cmd.arguments %}
 * @param {{ '{' }}{{ cmd.arguments | selectattr('name', 'equalto', arg.name) | map(attribute='type') | first | default('string') }}{{ '}' }} {{ arg.name }} - {{ arg.description }}
{%- endfor %}
{%- if cmd.options %}
 * @param {{ '{' }}Object{{ '}' }} options - Command options
{%- for option in cmd.options %}
 * @param {{ '{' }}{{ option.type | default('string') }}{{ '}' }} options.{{ option.name | replace('-', '_') }} - {{ option.description }}
{%- endfor %}
{%- endif %}
 * @returns {{ '{' }}Promise<number>{{ '}' }} - Exit code (0 for success)
 */
async function on_{{ cmd.name | replace('-', '_') }}({% for arg in cmd.arguments %}{{ arg.name }}{% if not loop.last or cmd.options %}, {% endif %}{% endfor %}{% if cmd.options %}options{% endif %}) {
    {%- if cmd.name == 'greet' %}
    // Implement greeting business logic
    const nameValue = {{ cmd.arguments[0].name if cmd.arguments else 'name' }} || 'World';
    const messageValue = {{ cmd.arguments[1].name if cmd.arguments|length > 1 else 'message' }} || 'Hello';
    const style = options?.style || 'casual';
    const count = parseInt(options?.count) || 1;
    const uppercase = options?.uppercase || false;
    const language = options?.language || 'en';
    
    // Language-specific greetings
    const greetings = {
        'en': { casual: 'Hi', formal: 'Hello', friendly: 'Hey' },
        'es': { casual: 'Hola', formal: 'Buenos d√≠as', friendly: 'Ey' },
        'fr': { casual: 'Salut', formal: 'Bonjour', friendly: 'Coucou' },
        'de': { casual: 'Hallo', formal: 'Guten Tag', friendly: 'Hey' }
    };
    
    const greetingWord = greetings[language]?.[style] || greetings['en'][style] || messageValue;
    let output = `${greetingWord}, ${nameValue}!`;
    
    if (uppercase) {
        output = output.toUpperCase();
    }
    
    // Repeat the greeting
    for (let i = 0; i < count; i++) {
        console.log(output);
    }
    {%- elif cmd.name == 'info' %}
    // Implement system info display logic
    const format = options?.format || 'text';
    const verbose = options?.verbose || false;
    const sections = (options?.sections || 'all').split(',').map(s => s.trim());
    
    const info = {
        system: {
            platform: process.platform,
            arch: process.arch,
            version: process.version,
            uptime: Math.floor(process.uptime())
        },
        environment: {
            nodeVersion: process.version,
            cwd: process.cwd(),
            user: process.env.USER || process.env.USERNAME || 'unknown'
        },
        memory: {
            used: Math.round(process.memoryUsage().rss / 1024 / 1024),
            heap: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
            external: Math.round(process.memoryUsage().external / 1024 / 1024)
        }
    };
    
    const showSection = (section) => sections.includes('all') || sections.includes(section);
    
    if (format === 'json') {
        const output = {};
        if (showSection('system')) output.system = info.system;
        if (showSection('environment')) output.environment = info.environment;
        if (showSection('memory')) output.memory = info.memory;
        console.log(JSON.stringify(output, null, verbose ? 2 : 0));
    } else {
        console.log('System Information:');
        
        if (showSection('system')) {
            console.log('\nüì± System:');
            console.log(`  Platform: ${info.system.platform}`);
            console.log(`  Architecture: ${info.system.arch}`);
            console.log(`  Node.js: ${info.system.version}`);
            if (verbose) console.log(`  Uptime: ${info.system.uptime}s`);
        }
        
        if (showSection('environment')) {
            console.log('\nüåç Environment:');
            console.log(`  Working Directory: ${info.environment.cwd}`);
            console.log(`  User: ${info.environment.user}`);
            if (verbose) console.log(`  Node Version: ${info.environment.nodeVersion}`);
        }
        
        if (showSection('memory')) {
            console.log('\nüíæ Memory Usage:');
            console.log(`  RSS: ${info.memory.used}MB`);
            console.log(`  Heap Used: ${info.memory.heap}MB`);
            if (verbose) console.log(`  External: ${info.memory.external}MB`);
        }
    }
    {%- else %}
    // Generic command implementation
    console.log('Executing {{ cmd.name }} command...');
    {%- if cmd.arguments %}
    console.log('Arguments received:', { {% for arg in cmd.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %} });
    {%- endif %}
    {%- if cmd.options %}
    console.log('Options received:', options);
    {%- endif %}
    console.log('‚úÖ Command completed successfully!');
    {%- endif %}
    
    return 0;
}
{%- endfor %}

{%- for cmd in cli.root_command.subcommands if cmd.subcommands is defined and cmd.subcommands %}
{%- if cmd.subcommands is mapping %}
{%- for subcmd_name, subcmd in cmd.subcommands.items() %}

/**
 * {{ subcmd.description | default(subcmd.desc) | default('No description') }}
{%- for arg in subcmd.arguments %}
 * @param {{ '{' }}{{ subcmd.arguments | selectattr('name', 'equalto', arg.name) | map(attribute='type') | first | default('string') }}{{ '}' }} {{ arg.name }} - {{ arg.description }}
{%- endfor %}
{%- if subcmd.options %}
 * @param {{ '{' }}Object{{ '}' }} options - Command options
{%- for option in subcmd.options %}
 * @param {{ '{' }}{{ option.type | default('string') }}{{ '}' }} options.{{ option.name | replace('-', '_') }} - {{ option.description }}
{%- endfor %}
{%- endif %}
 * @returns {{ '{' }}Promise<number>{{ '}' }} - Exit code (0 for success)
 */
async function on_{{ cmd.name | replace('-', '_') }}_{{ subcmd_name | replace('-', '_') }}({% for arg in subcmd.arguments %}{{ arg.name }}{% if not loop.last or subcmd.options %}, {% endif %}{% endfor %}{% if subcmd.options %}options{% endif %}) {
    // Add your business logic here
    console.log('Hook on_{{ cmd.name | replace('-', '_') }}_{{ subcmd_name | replace('-', '_') }} called');
    {%- if subcmd.arguments %}
    console.log('Arguments:', { {% for arg in subcmd.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %} });
    {%- endif %}
    {%- if subcmd.options %}
    console.log('Options:', options);
    {%- endif %}
    
    // Return 0 for success, non-zero for error
    return 0;
}
{%- endfor %}
{%- else %}
{%- for subcmd in cmd.subcommands %}

/**
 * {{ subcmd.description | default(subcmd.desc) | default('No description') }}
{%- for arg in subcmd.arguments %}
 * @param {{ '{' }}{{ subcmd.arguments | selectattr('name', 'equalto', arg.name) | map(attribute='type') | first | default('string') }}{{ '}' }} {{ arg.name }} - {{ arg.description }}
{%- endfor %}
{%- if subcmd.options %}
 * @param {{ '{' }}Object{{ '}' }} options - Command options
{%- for option in subcmd.options %}
 * @param {{ '{' }}{{ option.type | default('string') }}{{ '}' }} options.{{ option.name | replace('-', '_') }} - {{ option.description }}
{%- endfor %}
{%- endif %}
 * @returns {{ '{' }}Promise<number>{{ '}' }} - Exit code (0 for success)
 */
async function on_{{ cmd.name | replace('-', '_') }}_{{ subcmd.name | replace('-', '_') }}({% for arg in subcmd.arguments %}{{ arg.name }}{% if not loop.last or subcmd.options %}, {% endif %}{% endfor %}{% if subcmd.options %}options{% endif %}) {
    // Add your business logic here
    console.log('Hook on_{{ cmd.name | replace('-', '_') }}_{{ subcmd.name | replace('-', '_') }} called');
    {%- if subcmd.arguments %}
    console.log('Arguments:', { {% for arg in subcmd.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %} });
    {%- endif %}
    {%- if subcmd.options %}
    console.log('Options:', options);
    {%- endif %}
    
    // Return 0 for success, non-zero for error
    return 0;
}
{%- endfor %}
{%- endif %}
{%- endfor %}

// Export all hook functions
export {
{%- for cmd in cli.root_command.subcommands if cmd.subcommands is not defined or not cmd.subcommands %}
    on_{{ cmd.name | replace('-', '_') }},
{%- endfor %}
{%- for cmd in cli.root_command.subcommands if cmd.subcommands is defined and cmd.subcommands %}
{%- if cmd.subcommands is mapping %}
{%- for subcmd_name, subcmd in cmd.subcommands.items() %}
    on_{{ cmd.name | replace('-', '_') }}_{{ subcmd_name | replace('-', '_') }},
{%- endfor %}
{%- else %}
{%- for subcmd in cmd.subcommands %}
    on_{{ cmd.name | replace('-', '_') }}_{{ subcmd.name | replace('-', '_') }},
{%- endfor %}
{%- endif %}
{%- endfor %}
};

{%- elif language == 'typescript' -%}
/**
 * Hook implementations for {{ project.name }}
 * 
 * This file contains the business logic for your CLI commands.
 * Implement the hook functions below to handle your CLI commands.
 * 
 * IMPORTANT: Hook names must use snake_case with 'on_' prefix
 * Example:
 * - Command 'hello' -> Hook function 'on_hello'
 * - Command 'hello-world' -> Hook function 'on_hello_world'
 */

// Import any modules you need here
import * as fs from 'fs';
import * as path from 'path';

{%- for cmd in cli.root_command.subcommands if cmd.subcommands is not defined or not cmd.subcommands %}

/**
 * {{ cmd.description }}
{%- for arg in cmd.arguments %}
 * @param {{ arg.name }} {{ arg.description }}
{%- endfor %}
{%- if cmd.options %}
 * @param options Command options
{%- for option in cmd.options %}
 * @param options.{{ option.name | replace('-', '_') }} {{ option.description }}
{%- endfor %}
{%- endif %}
 * @returns Promise<number> - Exit code (0 for success)
 */
export async function on_{{ cmd.name | replace('-', '_') }}(
{%- for arg in cmd.arguments %}
    {{ arg.name }}: {% if arg.multiple %}string[]{% else %}string{% endif %}{% if not loop.last or cmd.options %},{% endif %}
{%- endfor %}
{%- if cmd.options %}
    options: {
{%- for option in cmd.options %}
        {{ option.name | replace('-', '_') }}?: {% if option.type == 'boolean' %}boolean{% elif option.type == 'integer' %}number{% elif option.type == 'float' %}number{% else %}string{% endif %};
{%- endfor %}
    }
{%- endif %}
): Promise<number> {
    {%- if cmd.name == 'greet' %}
    // Implement greeting business logic with TypeScript types
    const nameValue: string = {{ cmd.arguments[0].name if cmd.arguments else 'name' }} || 'World';
    const messageValue: string = {{ cmd.arguments[1].name if cmd.arguments|length > 1 else 'message' }} || 'Hello';
    const style: string = options?.style || 'casual';
    const count: number = parseInt(String(options?.count)) || 1;
    const uppercase: boolean = options?.uppercase || false;
    const language: string = options?.language || 'en';
    
    // Language-specific greetings with types
    const greetings: { [key: string]: { [style: string]: string } } = {
        'en': { casual: 'Hi', formal: 'Hello', friendly: 'Hey' },
        'es': { casual: 'Hola', formal: 'Buenos d√≠as', friendly: 'Ey' },
        'fr': { casual: 'Salut', formal: 'Bonjour', friendly: 'Coucou' },
        'de': { casual: 'Hallo', formal: 'Guten Tag', friendly: 'Hey' }
    };
    
    const greetingWord: string = greetings[language]?.[style] || greetings['en'][style] || messageValue;
    let output: string = `${greetingWord}, ${nameValue}!`;
    
    if (uppercase) {
        output = output.toUpperCase();
    }
    
    // Repeat the greeting
    for (let i = 0; i < count; i++) {
        console.log(output);
    }
    {%- elif cmd.name == 'info' %}
    // Implement system info display logic with TypeScript types
    const format: string = options?.format || 'text';
    const verbose: boolean = options?.verbose || false;
    const sections: string[] = (options?.sections || 'all').split(',').map((s: string) => s.trim());
    
    interface SystemInfo {
        system: {
            platform: string;
            arch: string;
            version: string;
            uptime: number;
        };
        environment: {
            nodeVersion: string;
            cwd: string;
            user: string;
        };
        memory: {
            used: number;
            heap: number;
            external: number;
        };
    }
    
    const info: SystemInfo = {
        system: {
            platform: process.platform,
            arch: process.arch,
            version: process.version,
            uptime: Math.floor(process.uptime())
        },
        environment: {
            nodeVersion: process.version,
            cwd: process.cwd(),
            user: process.env.USER || process.env.USERNAME || 'unknown'
        },
        memory: {
            used: Math.round(process.memoryUsage().rss / 1024 / 1024),
            heap: Math.round(process.memoryUsage().heapUsed / 1024 / 1024),
            external: Math.round(process.memoryUsage().external / 1024 / 1024)
        }
    };
    
    const showSection = (section: string): boolean => sections.includes('all') || sections.includes(section);
    
    if (format === 'json') {
        const output: Partial<SystemInfo> = {};
        if (showSection('system')) output.system = info.system;
        if (showSection('environment')) output.environment = info.environment;
        if (showSection('memory')) output.memory = info.memory;
        console.log(JSON.stringify(output, null, verbose ? 2 : 0));
    } else {
        console.log('System Information:');
        
        if (showSection('system')) {
            console.log('\nüì± System:');
            console.log(`  Platform: ${info.system.platform}`);
            console.log(`  Architecture: ${info.system.arch}`);
            console.log(`  Node.js: ${info.system.version}`);
            if (verbose) console.log(`  Uptime: ${info.system.uptime}s`);
        }
        
        if (showSection('environment')) {
            console.log('\nüåç Environment:');
            console.log(`  Working Directory: ${info.environment.cwd}`);
            console.log(`  User: ${info.environment.user}`);
            if (verbose) console.log(`  Node Version: ${info.environment.nodeVersion}`);
        }
        
        if (showSection('memory')) {
            console.log('\nüíæ Memory Usage:');
            console.log(`  RSS: ${info.memory.used}MB`);
            console.log(`  Heap Used: ${info.memory.heap}MB`);
            if (verbose) console.log(`  External: ${info.memory.external}MB`);
        }
    }
    {%- else %}
    // Generic command implementation
    console.log('Executing {{ cmd.name }} command...');
    {%- if cmd.arguments %}
    console.log('Arguments received:', { {% for arg in cmd.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %} });
    {%- endif %}
    {%- if cmd.options %}
    console.log('Options received:', options);
    {%- endif %}
    console.log('‚úÖ Command completed successfully!');
    {%- endif %}
    
    // Return 0 for success, non-zero for error
    return 0;
}
{%- endfor %}

{%- for cmd in cli.root_command.subcommands if cmd.subcommands is defined and cmd.subcommands %}
{%- if cmd.subcommands is mapping %}
{%- for subcmd_name, subcmd in cmd.subcommands.items() %}

/**
 * {{ subcmd.description | default(subcmd.desc) | default('No description') }}
{%- for arg in subcmd.arguments %}
 * @param {{ arg.name }} {{ arg.description }}
{%- endfor %}
{%- if subcmd.options %}
 * @param options Command options
{%- for option in subcmd.options %}
 * @param options.{{ option.name | replace('-', '_') }} {{ option.description }}
{%- endfor %}
{%- endif %}
 * @returns Promise<number> - Exit code (0 for success)
 */
export async function on_{{ cmd.name | replace('-', '_') }}_{{ subcmd_name | replace('-', '_') }}(
{%- for arg in subcmd.arguments %}
    {{ arg.name }}: {% if arg.multiple %}string[]{% else %}string{% endif %}{% if not loop.last or subcmd.options %},{% endif %}
{%- endfor %}
{%- if subcmd.options %}
    options: {
{%- for option in subcmd.options %}
        {{ option.name | replace('-', '_') }}?: {% if option.type == 'boolean' %}boolean{% elif option.type == 'integer' %}number{% elif option.type == 'float' %}number{% else %}string{% endif %};
{%- endfor %}
    }
{%- endif %}
): Promise<number> {
    // Add your business logic here
    console.log('Hook on_{{ cmd.name | replace('-', '_') }}_{{ subcmd_name | replace('-', '_') }} called');
    {%- if subcmd.arguments %}
    console.log('Arguments:', { {% for arg in subcmd.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %} });
    {%- endif %}
    {%- if subcmd.options %}
    console.log('Options:', options);
    {%- endif %}
    
    // Return 0 for success, non-zero for error
    return 0;
}
{%- endfor %}
{%- else %}
{%- for subcmd in cmd.subcommands %}

/**
 * {{ subcmd.description | default(subcmd.desc) | default('No description') }}
{%- for arg in subcmd.arguments %}
 * @param {{ arg.name }} {{ arg.description }}
{%- endfor %}
{%- if subcmd.options %}
 * @param options Command options
{%- for option in subcmd.options %}
 * @param options.{{ option.name | replace('-', '_') }} {{ option.description }}
{%- endfor %}
{%- endif %}
 * @returns Promise<number> - Exit code (0 for success)
 */
export async function on_{{ cmd.name | replace('-', '_') }}_{{ subcmd.name | replace('-', '_') }}(
{%- for arg in subcmd.arguments %}
    {{ arg.name }}: {% if arg.multiple %}string[]{% else %}string{% endif %}{% if not loop.last or subcmd.options %},{% endif %}
{%- endfor %}
{%- if subcmd.options %}
    options: {
{%- for option in subcmd.options %}
        {{ option.name | replace('-', '_') }}?: {% if option.type == 'boolean' %}boolean{% elif option.type == 'integer' %}number{% elif option.type == 'float' %}number{% else %}string{% endif %};
{%- endfor %}
    }
{%- endif %}
): Promise<number> {
    // Add your business logic here
    console.log('Hook on_{{ cmd.name | replace('-', '_') }}_{{ subcmd.name | replace('-', '_') }} called');
    {%- if subcmd.arguments %}
    console.log('Arguments:', { {% for arg in subcmd.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %} });
    {%- endif %}
    {%- if subcmd.options %}
    console.log('Options:', options);
    {%- endif %}
    
    // Return 0 for success, non-zero for error
    return 0;
}
{%- endfor %}
{%- endif %}
{%- endfor %}

{%- elif language == 'rust' -%}
// Hook implementations for {{ project.name }}
//
// This file contains the business logic for your CLI commands.
// Implement the hook functions below to handle your CLI commands.
//
// IMPORTANT: Hook names must use snake_case with 'on_' prefix
// Example:
// - Command 'hello' -> Hook function 'on_hello'
// - Command 'hello-world' -> Hook function 'on_hello_world'

use clap::ArgMatches;
use anyhow::Result;

{% if cli.commands -%}
{%- for cmd_name, cmd in cli.commands.items() %}
/// {{ cmd.description | default('Handle ' + cmd_name + ' command') }}
pub fn on_{{ cmd_name | replace('-', '_') }}(matches: &ArgMatches) -> Result<()> {
    // Add your business logic here
    println!("Executing {{ cmd_name }} command");
    {% if cmd.args %}
    // Access arguments
    {% for arg in cmd.args %}
    if let Some({{ arg.name | replace('-', '_') }}) = matches.get_one::<String>("{{ arg.name }}") {
        println!("{{ arg.name }}: {}", {{ arg.name | replace('-', '_') }});
    }
    {% endfor %}
    {% endif %}
    {% if cmd.options %}
    // Access options
    {% for opt in cmd.options %}
    if let Some({{ opt.name | replace('-', '_') }}) = matches.get_one::<String>("{{ opt.name }}") {
        println!("{{ opt.name }}: {}", {{ opt.name | replace('-', '_') }});
    }
    {% endfor %}
    {% endif %}
    
    Ok(())
}

{%- if cmd.subcommands %}
{%- if cmd.subcommands is mapping %}
{%- for sub_name, sub_cmd in cmd.subcommands.items() %}
/// {{ sub_cmd.description | default(sub_cmd.desc) | default('Handle ' + cmd_name + ' ' + sub_name + ' subcommand') }}
pub fn on_{{ cmd_name | replace('-', '_') }}_{{ sub_name | replace('-', '_') }}(matches: &ArgMatches) -> Result<()> {
    // Add your business logic here
    println!("Executing {{ cmd_name }} {{ sub_name }} subcommand");
    {%- if sub_cmd.args %}
    // Access arguments
    {%- for arg in sub_cmd.args %}
    if let Some({{ arg.name | replace('-', '_') }}) = matches.get_one::<String>("{{ arg.name }}") {
        println!("{{ arg.name }}: {}", {{ arg.name | replace('-', '_') }});
    }
    {%- endfor %}
    {%- endif %}
    {%- if sub_cmd.options %}
    // Access options
    {%- for opt in sub_cmd.options %}
    if let Some({{ opt.name | replace('-', '_') }}) = matches.get_one::<String>("{{ opt.name }}") {
        println!("{{ opt.name }}: {}", {{ opt.name | replace('-', '_') }});
    }
    {%- endfor %}
    {%- endif %}
    
    Ok(())
}

{%- endfor %}
{%- else %}
{%- for sub_cmd in cmd.subcommands %}
/// {{ sub_cmd.description | default(sub_cmd.desc) | default('Handle ' + cmd_name + ' ' + sub_cmd.name + ' subcommand') }}
pub fn on_{{ cmd_name | replace('-', '_') }}_{{ sub_cmd.name | replace('-', '_') }}(matches: &ArgMatches) -> Result<()> {
    // Add your business logic here
    println!("Executing {{ cmd_name }} {{ sub_cmd.name }} subcommand");
    {%- if sub_cmd.args %}
    // Access arguments
    {%- for arg in sub_cmd.args %}
    if let Some({{ arg.name | replace('-', '_') }}) = matches.get_one::<String>("{{ arg.name }}") {
        println!("{{ arg.name }}: {}", {{ arg.name | replace('-', '_') }});
    }
    {%- endfor %}
    {%- endif %}
    {%- if sub_cmd.options %}
    // Access options
    {%- for opt in sub_cmd.options %}
    if let Some({{ opt.name | replace('-', '_') }}) = matches.get_one::<String>("{{ opt.name }}") {
        println!("{{ opt.name }}: {}", {{ opt.name | replace('-', '_') }});
    }
    {%- endfor %}
    {%- endif %}
    
    Ok(())
}

{%- endfor %}
{%- endif %}
{%- endif %}
{% endfor -%}
{%- else %}
/// Default handler when no commands are defined
pub fn on_default(_matches: &ArgMatches) -> Result<()> {
    println!("No commands defined yet");
    Ok(())
}
{%- endif %}

{%- endif -%}