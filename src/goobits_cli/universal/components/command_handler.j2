{# Universal Command Handler Template
   
   This template generates the main CLI command structure for any supported language.
   It includes argument parsing, option handling, and hook integration.
   
   Variables expected:
   - language: Target language (python, nodejs, typescript, rust)
   - project: Project metadata
   - cli: CLI schema with commands, arguments, options
#}

{%- if language == 'python' -%}
#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                           AUTO-GENERATED FILE                                ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  Generated by: goobits-cli v{{ project.version or '3.0.0' }}                        ‚ïë
‚ïë  Generated from: {{ config_filename | default('goobits.yaml') }}            ‚ïë
‚ïë  Generated on: {{ datetime.now().strftime('%Y-%m-%d %H:%M:%S') }}            ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  ‚ö†Ô∏è  DO NOT EDIT THIS FILE MANUALLY                                         ‚ïë
‚ïë  Changes will be overwritten on next generation                             ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  To regenerate: goobits build --universal-templates                         ‚ïë
‚ïë                                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

{{ project.display_name or project.name }} CLI
Generated from: {{ config_filename | default('goobits.yaml') }}
"""

import rich_click as click
from rich_click import RichGroup
import sys
import traceback
import inspect
import builtins
{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
try:
    from .{{ (cli.root_command.name if cli.root_command else project.command_name).replace('-', '_') }}_interactive import run_interactive
except ImportError:
    run_interactive = None
{% endif %}

# Enhanced Error Handling Classes
class CLIError(Exception):
    """Base exception for CLI errors."""
    def __init__(self, message: str, exit_code: int = 1, suggestion: str = None):
        self.message = message
        self.exit_code = exit_code
        self.suggestion = suggestion
        super().__init__(self.message)

class ConfigError(CLIError):
    """Configuration-related error."""
    def __init__(self, message: str, suggestion: str = None):
        super().__init__(message, exit_code=2, suggestion=suggestion)

class HookError(CLIError):
    """Hook execution error."""
    def __init__(self, message: str, hook_name: str = None):
        self.hook_name = hook_name
        super().__init__(message, exit_code=3, suggestion=f"Check the '{hook_name}' function in your app_hooks.py file" if hook_name else None)

# Global error handler
def handle_cli_error(error: Exception, verbose: bool = False) -> int:
    """Handle CLI errors with appropriate messages and exit codes."""
    if isinstance(error, CLIError):
        click.echo(f"‚ùå Error: {error.message}", err=True)
        if error.suggestion:
            click.echo(f"üí° Suggestion: {error.suggestion}", err=True)
        if verbose and hasattr(error, '__cause__') and error.__cause__:
            click.echo(f"Details: {traceback.format_exc()}", err=True)
        return error.exit_code
    else:
        click.echo(f"‚ùå Unexpected error: {str(error)}", err=True)
        if verbose:
            click.echo(f"Details: {traceback.format_exc()}", err=True)
        return 1

# Set up rich-click configuration globally
click.rich_click.USE_RICH_MARKUP = True  
click.rich_click.USE_MARKDOWN = False  # Disable markdown to avoid conflicts
click.rich_click.MARKUP_MODE = "rich"

# Helper function to convert file path to Python import path
def _path_to_import_path(file_path: str, package_name: str = "{{ project.package_name | default('') | replace('-', '_') }}") -> tuple[str, str]:
    """Convert a file path like 'mypackage/cli/hooks.py' to import path 'mypackage.cli.hooks'"""
    # Remove .py extension
    clean_path = file_path.replace(".py", "")
    
    # Convert forward slashes to dots for Python import
    import_path = clean_path.replace("/", ".")
    
    # Remove 'src.' prefix if present
    if import_path.startswith("src."):
        import_path = import_path[4:]
    
    # Extract just the module name (e.g., 'hooks' from 'mypackage.cli.hooks')
    module_name = import_path.split(".")[-1]
    
    return import_path, module_name

# Robust hook discovery function with package-relative imports
def _find_and_import_hooks():
    """Find and import hooks using package-relative imports with filesystem fallback"""
    import importlib
    import importlib.util
    from pathlib import Path
    
    {% if project.cli_hooks or project.hooks_path -%}
    # Using configured hooks path: {{ project.cli_hooks or project.hooks_path }}
    configured_path = "{{ project.cli_hooks or project.hooks_path }}"
    import_path, module_name = _path_to_import_path(configured_path)
    
    # Strategy 1: Try package-relative import (works from any directory when installed)
    try:
        return importlib.import_module(import_path)
    except ImportError:
        pass
    
    # Strategy 2: Try relative import from current package
    try:
        if "." in import_path:
            # Try importing from the base package
            package_parts = import_path.split(".")
            if len(package_parts) >= 2:
                relative_import = ".".join(package_parts[1:])  # Remove package name
                return importlib.import_module(f".{relative_import}", package="{{ project.package_name | default('') | replace('-', '_') }}")
        else:
            # Direct relative import
            return importlib.import_module(f".{module_name}", package="{{ project.package_name | default('') | replace('-', '_') }}")
    except ImportError:
        pass
    
    # Strategy 3: Try direct module name import (for simple cases)
    try:
        return importlib.import_module(module_name)
    except ImportError:
        pass
    
    # Strategy 4: File-based import as fallback (development mode)
    try:
        # Look for the file relative to the CLI script location
        cli_dir = Path(__file__).parent
        
        # Try multiple possible locations relative to CLI
        search_paths = [
            cli_dir / configured_path,                    # Same directory as CLI
            cli_dir.parent / configured_path,             # Parent of CLI directory  
            cli_dir.parent.parent / configured_path,      # Two levels up (src structure)
            cli_dir.parent.parent.parent / configured_path, # Three levels up (deep structure)
        ]
        
        for hooks_file in search_paths:
            if hooks_file.exists():
                spec = importlib.util.spec_from_file_location(module_name, hooks_file)
                if spec and spec.loader:
                    hooks_module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(hooks_module)
                    return hooks_module
    except Exception:
        pass
    
    {% else -%}
    # No hooks path configured, try default locations
    default_module_name = "app_hooks"
    
    # Strategy 1: Try package-relative import
    try:
        return importlib.import_module(f"{{ project.package_name | default('') | replace('-', '_') }}.{default_module_name}")
    except ImportError:
        pass
    
    # Strategy 2: Try relative import
    try:
        return importlib.import_module(f".{default_module_name}", package="{{ project.package_name | default('') | replace('-', '_') }}")
    except ImportError:
        pass
    
    # Strategy 3: Try direct import from Python path
    try:
        return importlib.import_module(default_module_name)
    except ImportError:
        pass
    
    # Strategy 4: File-based fallback for development
    try:
        cli_dir = Path(__file__).parent
        search_paths = [
            cli_dir / f"{default_module_name}.py",
            cli_dir.parent / f"{default_module_name}.py",
            cli_dir.parent.parent / f"{default_module_name}.py",
            cli_dir.parent.parent.parent / f"{default_module_name}.py",
        ]
        
        for hooks_file in search_paths:
            if hooks_file.exists():
                spec = importlib.util.spec_from_file_location(default_module_name, hooks_file)
                if spec and spec.loader:
                    hooks_module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(hooks_module)
                    return hooks_module
    except Exception:
        pass
    {% endif %}
    
    return None

hooks = _find_and_import_hooks()

def get_version():
    """Get version from package metadata or pyproject.toml"""
    # First try to get version from installed package metadata
    try:
        from importlib.metadata import version, PackageNotFoundError
        try:
            # Try the package name
            return version("{{ installation.pypi_name | default(project.package_name) | default(project.name) }}")
        except PackageNotFoundError:
            pass
    except ImportError:
        # Python < 3.8
        try:
            import pkg_resources
            return pkg_resources.get_distribution("{{ installation.pypi_name | default(project.package_name) | default(project.name) }}").version
        except:
            pass
    
    # Fallback to reading from pyproject.toml (development mode)
    import re
    from pathlib import Path
    
    try:
        # Try to get version from pyproject.toml FIRST (Python projects)
        possible_toml_paths = [
            Path(__file__).parent.parent / "pyproject.toml",  # For flat structure
            Path(__file__).parent.parent.parent / "pyproject.toml",  # For src/ structure
        ]
        for path in possible_toml_paths:
            if path.exists():
                content = path.read_text()
                match = re.search(r'version\s*=\s*["\']([^"\']+)["\']', content)
                if match:
                    return match.group(1)
    except Exception:
        pass
    
    try:
        # Try package.json for Node.js/TypeScript projects
        possible_json_paths = [
            Path(__file__).parent.parent / "package.json",
            Path(__file__).parent.parent.parent / "package.json",
        ]
        for path in possible_json_paths:
            if path.exists():
                import json
                with open(path) as f:
                    data = json.load(f)
                    if 'version' in data:
                        return data['version']
    except Exception:
        pass
    
    try:
        # Try Cargo.toml for Rust projects
        possible_cargo_paths = [
            Path(__file__).parent.parent / "Cargo.toml",
            Path(__file__).parent.parent.parent / "Cargo.toml",
        ]
        for path in possible_cargo_paths:
            if path.exists():
                content = path.read_text()
                match = re.search(r'version\s*=\s*["\']([^"\']+)["\']', content)
                if match:
                    return match.group(1)
    except Exception:
        pass
    
    try:
        # Fallback to __init__.py
        init_path = Path(__file__).parent / "__init__.py"
        if init_path.exists():
            content = init_path.read_text()
            match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
            if match:
                return match.group(1)
    except Exception:
        pass
    
    # Final fallback
    return "1.0.0"

class VersionedRichGroup(RichGroup):
    def format_usage(self, ctx, formatter):
        """Override to include version in usage."""
        pieces = self.collect_usage_pieces(ctx)
        formatter.write_usage(f"{{ project.command_name | default('cli') }} v{get_version()}", " ".join(pieces))
    
    def format_help(self, ctx, formatter):
        """Override to add spacing after help."""
        super().format_help(ctx, formatter)
        formatter.write("\n")

@click.group(cls=VersionedRichGroup)
@click.version_option(version=get_version(), prog_name=f"{{ project.command_name | default('cli') }} v{get_version()}")
@click.option(
    "--verbose", "-v",
    help="Enable verbose error output and debugging information",
    is_flag=True,
    default=False
)
{% if cli.root_command.options %}
{% for option in cli.root_command.options if option.name != 'verbose' %}
@click.option(
    "--{{ option.name }}"{% if option.short is defined and option.short %}, "-{{ option.short }}"{% endif %},
    help="{{ (option.description if option.description is defined else 'No description') }}"{% if option.type is defined and (option.type == "flag" or option.type == "boolean") %},
    is_flag=True{% elif option.type is defined and option.type == "integer" %},
    type=int{% elif option.type is defined and option.type == "float" %},
    type=float{% endif %},
{%- if option.default is defined and option.default is not none %}
    default={{ option.default | repr }},
{% endif %}
    {%- if option.required is defined and option.required %}
    required=True,
    {% endif %}
    {%- if option.multiple is defined and option.multiple %}
    multiple=True,
    {% endif %}
)
{% endfor %}
{% endif %}
@click.pass_context
def main(ctx, verbose{% if cli.root_command.options %}{% for option in cli.root_command.options if option.name != 'verbose' %}, {{ option.name.replace('-', '_') }}{% endfor %}{% endif %}):
    """{{ cli.tagline | default((cli.description if cli.description is defined else (project.description if project.description is defined else 'No description'))) }}

    \b
    [italic #B3B8C0]{{ cli.description if cli.description is defined else (project.description if project.description is defined else 'Transform simple YAML configuration into rich terminal applications.') }}[/italic #B3B8C0]
    
{% if cli.header_sections %}{% for section in cli.header_sections %}
    [bold yellow]{{ section.title }}[/bold yellow]
    
    {% for item in section['items'] %}
    {% if item.style == "example" -%}
    [green]   {{ item.item.ljust(27) }}[/green]   [italic][#B3B8C0]# {{ item.desc }}[/#B3B8C0][/italic]
    
    {% elif item.style == "command" -%}
    [green]   {{ item.item.ljust(5) }}[/green]   {{ item.desc }}
    
    {% elif item.style == "setup" -%}
    [#B3B8C0]   {{ (item.item + ':').ljust(23) }}[/#B3B8C0]   [green]{{ item.desc }}[/green]
    
    {% endif %}{% endfor %}
    {% if not loop.last %}
    [dim] [/dim]
    
    {% endif %}
{% endfor %}
{% if cli.footer_note %}
    [dim] [/dim]
    
    {{ cli.footer_note }}
{% endif %}{% endif %}
    """
    {% if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled -%}
    # Check if interactive mode was requested
    if ctx.params.get('interactive'):
        if run_interactive:
            run_interactive()
            sys.exit(0)
        else:
            click.echo("Interactive mode not available. Please ensure all dependencies are installed.", err=True)
            sys.exit(1)
    {% endif %}
    pass

# Built-in upgrade command
@main.command()
@click.option('--check', is_flag=True, help='Check for updates without installing')
@click.option('--version', type=str, help='Install specific version')
@click.option('--pre', is_flag=True, help='Include pre-release versions')
@click.option('--dry-run', is_flag=True, help='Show what would be done without doing it')
def upgrade(check, version, pre, dry_run):
    """Upgrade {{ project.display_name | default(project.name) }} to the latest version"""
    import subprocess
    import shutil
    from pathlib import Path
    
    package_name = "{{ installation.pypi_name | default(project.package_name) | default(project.name) }}"
    command_name = "{{ project.command_name | default('cli') }}"
    display_name = "{{ project.display_name | default(project.name) }}"
    
    # Get current version
    current_version = get_version()
    print(f"Current version: {current_version}")
    
    if check:
        print(f"Checking for updates to {display_name}...")
        try:
            import sys
            result = subprocess.run([
                sys.executable, '-m', 'pip', 'index', 'versions', package_name
            ], capture_output=True, text=True)
            if result.returncode == 0:
                print("Version check completed")
            else:
                print("Update check not available. Run without --check to upgrade.")
        except Exception:
            print("Update check not available. Run without --check to upgrade.")
        return
    
    # Detect installation method
    use_pipx = False
    if shutil.which("pipx"):
        result = subprocess.run(["pipx", "list"], capture_output=True, text=True)
        if package_name in result.stdout:
            use_pipx = True
    
    # Build the upgrade command
    if use_pipx:
        print(f"Upgrading {display_name} with pipx...")
        if version:
            cmd = ["pipx", "install", f"{package_name}=={version}", "--force"]
        else:
            cmd = ["pipx", "upgrade", package_name]
            if pre:
                cmd.extend(["--pip-args", "--pre"])
    else:
        print(f"Upgrading {display_name} with pip...")
        import sys
        cmd = [sys.executable, "-m", "pip", "install", "--upgrade"]
        if version:
            cmd.append(f"{package_name}=={version}")
        else:
            cmd.append(package_name)
            if pre:
                cmd.append("--pre")
    
    if dry_run:
        print(f"Dry run - would execute: {' '.join(cmd)}")
        return
    
    # Execute upgrade
    print("Upgrading...")
    result = subprocess.run(cmd)
    
    if result.returncode == 0:
        print(f"‚úÖ {display_name} upgraded successfully!")
        print(f"Run '{command_name} --version' to verify the new version.")
    else:
        print(f"‚ùå Upgrade failed with exit code {result.returncode}")
        import sys
        sys.exit(1)

{# Universal Command Generation using Hierarchical System #}

{# Macro for rendering a single command with proper decorators #}
{% macro render_command(cmd) -%}
{% if cmd.depth == 1 -%}
{# Level 1 commands use decorators on main #}
{% if cmd.is_group -%}
@main.group()
{% else -%}
@main.command()
{% endif -%}
{% for arg in cmd.arguments if cmd.arguments -%}
@click.argument('{{ arg.name.upper() }}'{% if arg.nargs == '*' or arg.multiple %}, nargs=-1{% endif %}{% if not (arg.required is defined and arg.required) %}, required=False{% endif %})
{% endfor -%}
{% for option in cmd.options if cmd.options -%}
@click.option(
    "--{{ option.name }}"{% if option.short is defined and option.short %}, "-{{ option.short }}"{% endif %},
    help="{{ (option.description if option.description is defined else 'No description') }}"{%- if option.type is defined and (option.type == "flag" or option.type == "boolean") %},
    is_flag=True{%- elif option.type is defined and option.type == "integer" %},
    type=int{%- elif option.type is defined and option.type == "float" %},
    type=float{% endif %}{%- if option.default is defined and option.default is not none %},
    default={{ option.default | repr }}{% endif %}{%- if option.required is defined and option.required %},
    required=True{% endif %}{%- if option.multiple is defined and option.multiple %},
    multiple=True{% endif %}
)
{% endfor -%}
@click.pass_context
def {{ cmd.name.replace('-', '_') }}(ctx{% for arg in cmd.arguments if cmd.arguments %}, {{ arg.name.lower() }}{% endfor %}{% for option in cmd.options if cmd.options %}, {{ option.name.replace('-', '_') }}{% endfor %}):
    """{{ (cmd.description if cmd.description else ('Command ' + cmd.name)) }}"""
{% else -%}
{# Level 2+ commands are created programmatically #}
# Level {{ cmd.depth }} command: {{ ' '.join(cmd.path) }}
{% if cmd.is_group -%}
{{ '_'.join(cmd.path).replace('-', '_') }} = click.Group('{{ cmd.name }}', help="{{ (cmd.description if cmd.description else ('Command ' + cmd.name)) }}")
{% else -%}
@click.command()
{% for arg in cmd.arguments if cmd.arguments -%}
@click.argument('{{ arg.name.upper() }}'{% if arg.nargs == '*' or arg.multiple %}, nargs=-1{% endif %}{% if not (arg.required is defined and arg.required) %}, required=False{% endif %})
{% endfor -%}
{% for option in cmd.options if cmd.options -%}
@click.option(
    "--{{ option.name }}"{% if option.short is defined and option.short %}, "-{{ option.short }}"{% endif %},
    help="{{ (option.description if option.description is defined else 'No description') }}"{%- if option.type is defined and (option.type == "flag" or option.type == "boolean") %},
    is_flag=True{%- elif option.type is defined and option.type == "integer" %},
    type=int{%- elif option.type is defined and option.type == "float" %},
    type=float{% endif %}{%- if option.default is defined and option.default is not none %},
    default={{ option.default | repr }}{% endif %}{%- if option.required is defined and option.required %},
    required=True{% endif %}{%- if option.multiple is defined and option.multiple %},
    multiple=True{% endif %}
)
{% endfor -%}
@click.pass_context
def {{ '_'.join(cmd.path).replace('-', '_') }}_cmd(ctx{% for arg in cmd.arguments if cmd.arguments %}, {{ arg.name.lower() }}{% endfor %}{% for option in cmd.options if cmd.options %}, {{ option.name.replace('-', '_') }}{% endfor %}):
    """{{ (cmd.description if cmd.description else ('Command ' + cmd.name)) }}"""
{% endif -%}
{% endif -%}
    
{% if cmd.is_group and cmd.depth == 1 %}
    # This is a group command - subcommands will handle the actual logic
    if ctx.invoked_subcommand is None:
        click.echo(ctx.get_help())
{% elif not cmd.is_group %}
    # Enhanced error handling for Python CLI
    verbose_path = ['verbose']
    current_ctx = ctx
    verbose = False
    
    # Navigate up the context chain to find verbose flag
    while current_ctx:
        if hasattr(current_ctx, 'params') and 'verbose' in current_ctx.params:
            verbose = current_ctx.params['verbose']
            break
        current_ctx = current_ctx.parent
    
    try:
        if hooks is None:
            # Provide helpful error with search paths
            package_name = "{{ project.package_name if project.package_name else 'unknown' }}"
            
            error_msg = f"Hook implementation not found. Expected: app_hooks.py"
            
            raise ConfigError(
                error_msg,
                suggestion=f"Create app_hooks.py with function: def {{ cmd.hook_name }}(...): pass"
            )
        
        hook_name = '{{ cmd.hook_name }}'
        if not hasattr(hooks, hook_name):
            available_hooks = [name for name in dir(hooks) if not name.startswith('_') and callable(getattr(hooks, name))]
            raise ConfigError(
                f"Hook function '{hook_name}' not found in app_hooks.py",
                suggestion=f"Available functions: {', '.join(available_hooks) if available_hooks else 'none'}"
            )
        
        hook_function = getattr(hooks, hook_name)
        
        # Prepare arguments and options for the hook
        args = [{% for arg in cmd.arguments if cmd.arguments %}{{ arg.name.lower() }}{% if not loop.last %}, {% endif %}{% endfor %}]
        options = {
{% for option in cmd.options if cmd.options -%}
            '{{ option.name.replace('-', '_') }}': {{ option.name.replace('-', '_') }}{% if not loop.last %},
{% else %}
{% endif -%}
{% endfor -%}
        }
        
        # Execute the hook function with signature-aware parameter filtering
        sig = inspect.signature(hook_function)
        expected_params = builtins.set(sig.parameters.keys())
        accepts_kwargs = any(p.kind == p.VAR_KEYWORD for p in sig.parameters.values())
        
        # Build kwargs with parameters the function expects
        call_kwargs = {}
        
        # Add positional arguments as kwargs if function expects them
        {% for arg in cmd.arguments if cmd.arguments %}
        if '{{ arg.name.lower() }}' in expected_params or accepts_kwargs:
            call_kwargs['{{ arg.name.lower() }}'] = {{ arg.name.lower() }}
        {% endfor %}
        
        # Add options that the function expects or if it accepts **kwargs
        for param_name, param_value in options.items():
            if param_name in expected_params or accepts_kwargs:
                call_kwargs[param_name] = param_value
        
        # Call the hook function
        try:
            result = hook_function(**call_kwargs)
        except TypeError as te:
            raise HookError(
                f"Hook function signature mismatch: {te}",
                hook_name=hook_name
            )
        
        # Handle return codes
        if isinstance(result, int) and result != 0:
            click.echo(f"Command '{{ ' '.join(cmd.path) }}' failed with exit code {result}", err=True)
            sys.exit(result)
            
    except KeyboardInterrupt:
        click.echo("\\n‚ö†Ô∏è  Command interrupted by user", err=True)
        sys.exit(130)
        
    except Exception as e:
        exit_code = handle_cli_error(e, verbose)
        sys.exit(exit_code)
{% endif %}

{%- endmacro %}

{# Render all commands in correct order (parents before children) #}
{%- for cmd in cli.command_hierarchy.flat_commands %}

{{ render_command(cmd) }}
{% endfor %}

{# Attach nested commands programmatically for levels 2+ #}
# Attach nested commands to their parents
{% for cmd in cli.command_hierarchy.flat_commands if cmd.depth > 1 %}
{% if cmd.depth == 2 %}
# Attach {{ cmd.name }} to {{ cmd.parent_path[0] }}
{{ cmd.parent_path[0].replace('-', '_') }}.add_command({% if cmd.is_group %}{{ '_'.join(cmd.path).replace('-', '_') }}{% else %}{{ '_'.join(cmd.path).replace('-', '_') }}_cmd{% endif %}, '{{ cmd.name }}')
{% elif cmd.depth > 2 %}
# Attach {{ cmd.name }} to {{ ' '.join(cmd.parent_path) }}
{{ '_'.join(cmd.parent_path).replace('-', '_') }}.add_command({% if cmd.is_group %}{{ '_'.join(cmd.path).replace('-', '_') }}{% else %}{{ '_'.join(cmd.path).replace('-', '_') }}_cmd{% endif %}, '{{ cmd.name }}')
{% endif %}
{% endfor %}

if __name__ == "__main__":
    main()

def cli_entry():
    """Entry point for the CLI."""
    try:
        main()
    finally:
        # Ensure clean exit with trailing newline
        print()

{%- elif language == 'nodejs' -%}
#!/usr/bin/env node
/**
 * {{ project.name }} - {{ project.description }}
 * Generated by Goobits CLI Framework
 */

const { Command } = require('commander');
// Hook loading with enhanced error handling
let hooks = null;
try {
    hooks = require('./hooks');
} catch (error) {
    if (error.code === 'MODULE_NOT_FOUND') {
        console.error('Hook implementation not found. Please create \'src/hooks.js\' with your command implementations.');
        console.error('See documentation for hook function signatures.');
    } else {
        console.error(`Failed to load hooks: ${error.message}`);
    }
    process.exit(2);
}

{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
let runInteractive;
try {
    const interactive = require('./{{ cli.name.replace('-', '_') }}_interactive');
    runInteractive = interactive.runInteractive;
} catch (e) {
    // Interactive mode not available
}
{% endif %}

// Enhanced error handling for Node.js
class CLIError extends Error {
    constructor(message, code = 1, details = null) {
        super(message);
        this.name = 'CLIError';
        this.code = code;
        this.details = details;
    }
}

// Global error handler
function handleError(error, context = 'Command execution', verbose = false) {
    if (error instanceof CLIError) {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.details) {
            console.error('Details:', error.details);
        }
        process.exit(error.code);
    } else if (error.code === 'MODULE_NOT_FOUND' && error.message.includes('hooks')) {
        console.error('Hook implementation not found.');
        console.error('Please implement the required hook function in src/hooks.js');
        process.exit(2);
    } else {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.stack) {
            console.error('Stack trace:', error.stack);
        }
        process.exit(1);
    }
}

const program = new Command();

program
    .name('{{ cli.name }}')
    .description('{{ ((cli.description if cli.description is defined else (project.description if project.description is defined else 'No description'))) | js_string }}')
    .version('{{ cli.version }}')
    .option('-v, --verbose', 'Enable verbose error output and debugging information', false);

{%- for option in cli.options %}
program.option(
    '--{{ option.name }}{% if option.short is defined and option.short %}, -{{ option.short }}{% endif %}',
    '{{ ((option.description if option.description is defined else 'No description')) | js_string }}'{% if option.default is defined and option.default %}, {{ option.default | tojson }}{% endif %}
);
{% endfor %}

{# Build commands using flat_commands for unlimited nesting support #}
// Command hierarchy building for unlimited nesting
const commandMap = new Map();

{%- for cmd in cli.command_hierarchy.flat_commands if cli.command_hierarchy and cli.command_hierarchy.flat_commands %}
{% if cmd.depth == 1 %}
// Level {{ cmd.depth }}: {{ cmd.path | join(' ') }}
const {{ cmd.name.replace('-', '_') }}Cmd = program
    .command('{{ cmd.name }}')
    .description('{{ ((cmd.description if cmd.description is defined else 'No description')) | js_string }}');
{% if not cmd.is_group %}
{% for arg in cmd.arguments if cmd.arguments %}
{{ cmd.name.replace('-', '_') }}Cmd.argument('{% if not (arg.required is defined and arg.required) %}[{% endif %}{{ arg.name }}{% if arg.multiple is defined and arg.multiple %}...{% endif %}{% if not (arg.required is defined and arg.required) %}]{% endif %}', '{{ ((arg.desc if arg.desc is defined else 'No description')) | js_string }}');
{% endfor %}
{% for option in cmd.options if cmd.options %}
{{ cmd.name.replace('-', '_') }}Cmd.option('--{{ option.name }}{% if option.short is defined and option.short %}, -{{ option.short }}{% endif %}', '{{ option.description | js_string }}'{% if option.default is defined and option.default %}, {{ option.default | tojson }}{% endif %});
{% endfor %}
{{ cmd.name.replace('-', '_') }}Cmd.action(async ({% for arg in cmd.arguments if cmd.arguments %}{{ arg.name }}{% if cmd.options or not loop.last %}, {% endif %}{% endfor %}options) => {
    const globalOpts = program.opts();
    const verbose = globalOpts.verbose || false;
    
    try {
        const hookName = '{{ cmd.hook_name }}';
        
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${hookName}' not implemented in src/hooks.js`;
            const details = availableHooks.length > 0 
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.js';
            throw new CLIError(message, 2, details);
        }
        
        // Execute the hook function with proper error handling
        const args = [{% for arg in cmd.arguments if cmd.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %}];
        const result = await hooks[hookName](...args{% if cmd.arguments and cmd.arguments|length > 0 %}, {% endif %}options);
        
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command '{{ ' '.join(cmd.path) }}' failed with exit code ${result}`, result);
        }
        
    } catch (error) {
        if (error.code === 'SIGINT' || error.message.includes('interrupted')) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        
        handleError(error, 'Command execution', verbose);
    }
});
{% endif %}
commandMap.set('{{ '/'.join(cmd.path) }}', {{ cmd.name.replace('-', '_') }}Cmd);

{% elif cmd.depth > 1 %}

// Level {{ cmd.depth }}: {{ cmd.path | join(' ') }}
{% set parent_path = cmd.parent_path | join('/') %}
{% set parent_var = cmd.parent_path[-1].replace('-', '_') + 'Cmd' %}
const {{ cmd.path | join('_') | replace('-', '_') }}Cmd = commandMap.get('{{ parent_path }}')
    .command('{{ cmd.name }}')
    .description('{{ ((cmd.description if cmd.description is defined else 'No description')) | js_string }}');
{% if not cmd.is_group %}
{%- for arg in cmd.arguments if cmd.arguments %}
{{ cmd.path | join('_') | replace('-', '_') }}Cmd.argument('{% if not (arg.required is defined and arg.required) %}[{% endif %}{{ arg.name }}{% if arg.multiple is defined and arg.multiple %}...{% endif %}{% if not (arg.required is defined and arg.required) %}]{% endif %}', '{{ ((arg.desc if arg.desc is defined else 'No description')) | js_string }}');
{% endfor %}
{%- for option in cmd.options if cmd.options %}
{{ cmd.path | join('_') | replace('-', '_') }}Cmd.option('--{{ option.name }}{% if option.short is defined and option.short %}, -{{ option.short }}{% endif %}', '{{ option.description | js_string }}'{% if option.default is defined and option.default %}, {{ option.default | tojson }}{% endif %});
{% endfor %}
{{ cmd.path | join('_') | replace('-', '_') }}Cmd.action(async ({% for arg in cmd.arguments if cmd.arguments %}{{ arg.name }}{% if cmd.options or not loop.last %}, {% endif %}{% endfor %}options) => {
    const globalOpts = program.opts();
    const verbose = globalOpts.verbose || false;
    
    try {
        const hookName = '{{ cmd.hook_name }}';
        
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${hookName}' not implemented in src/hooks.js`;
            const details = availableHooks.length > 0 
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.js';
            throw new CLIError(message, 2, details);
        }
        
        // Execute the hook function with proper error handling
        const args = [{% for arg in cmd.arguments if cmd.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %}];
        const result = await hooks[hookName](...args{% if cmd.arguments and cmd.arguments|length > 0 %}, {% endif %}options);
        
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command '{{ ' '.join(cmd.path) }}' failed with exit code ${result}`, result);
        }
        
    } catch (error) {
        if (error.code === 'SIGINT' || error.message.includes('interrupted')) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        
        handleError(error, 'Command execution', verbose);
    }
});
{% endif %}
commandMap.set('{{ '/'.join(cmd.path) }}', {{ cmd.path | join('_') | replace('-', '_') }}Cmd);

{% endif %}
{% endfor %}

{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
// Check for interactive mode
program.hook('preAction', (thisCommand, actionCommand) => {
    const opts = thisCommand.opts();
    if (opts.interactive) {
        if (runInteractive) {
            runInteractive();
            process.exit(0);
        } else {
            console.error('Interactive mode not available. Please ensure all dependencies are installed.');
            process.exit(1);
        }
    }
});
{% endif %}

program.parse();

{%- elif language == 'typescript' -%}
#!/usr/bin/env node
/**
 * {{ project.name }} - {{ project.description }}
 * Generated by Goobits CLI Framework
 */

import { Command } from 'commander';
// Enhanced error handling for TypeScript
class CLIError extends Error {
    public code: number;
    public details?: string;
    
    constructor(message: string, code: number = 1, details?: string) {
        super(message);
        this.name = 'CLIError';
        this.code = code;
        this.details = details;
    }
}

// Hook loading with enhanced error handling
let hooks: any = null;
// Dynamic import for ES modules
const loadHooks = async () => {
    try {
        hooks = await import('./hooks.js');
    } catch (error: any) {
        if (error.code === 'MODULE_NOT_FOUND') {
            console.error('Hook implementation not found. Please create \'src/hooks.ts\' with your command implementations.');
            console.error('See documentation for hook function signatures.');
        } else {
            console.error(`Failed to load hooks: ${error.message}`);
        }
        process.exit(2);
    }
};

// Load hooks at startup
await loadHooks();

{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
import { runInteractive } from './{{ cli.name.replace('-', '_') }}_interactive';
{% endif %}

// Global error handler
function handleError(error: unknown, context: string = 'Command execution', verbose: boolean = false): never {
    if (error instanceof CLIError) {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.details) {
            console.error('Details:', error.details);
        }
        process.exit(error.code);
    } else if (error instanceof Error) {
        if (error.message.includes('Cannot resolve module') || error.message.includes('MODULE_NOT_FOUND')) {
            console.error('Hook implementation not found.');
            console.error('Please implement the required hook function in src/hooks.ts');
            process.exit(2);
        } else {
            console.error(`${context} failed: ${error.message}`);
            if (verbose && error.stack) {
                console.error('Stack trace:', error.stack);
            }
            process.exit(1);
        }
    } else {
        console.error(`${context} failed: Unknown error`);
        if (verbose) {
            console.error('Error details:', error);
        }
        process.exit(1);
    }
}

const program = new Command();

program
    .name('{{ cli.name }}')
    .description('{{ ((cli.description if cli.description is defined else (project.description if project.description is defined else 'No description'))) | js_string }}')
    .version('{{ cli.version }}')
    .option('-v, --verbose', 'Enable verbose error output and debugging information', false);

{%- for option in cli.options %}
program.option(
    '--{{ option.name }}{% if option.short is defined and option.short %}, -{{ option.short }}{% endif %}',
    '{{ ((option.description if option.description is defined else 'No description')) | js_string }}'{% if option.default is defined and option.default %}, {{ option.default | tojson }}{% endif %}
);
{% endfor %}

{# Build commands using flat_commands for unlimited nesting support #}
// Command hierarchy building for unlimited nesting
const commandMap = new Map<string, any>();

{%- for cmd in cli.command_hierarchy.flat_commands if cli.command_hierarchy and cli.command_hierarchy.flat_commands %}
{% if cmd.depth == 1 %}
// Level {{ cmd.depth }}: {{ cmd.path | join(' ') }}
const {{ cmd.name.replace('-', '_') }}Cmd = program
    .command('{{ cmd.name }}')
    .description('{{ ((cmd.description if cmd.description is defined else 'No description')) | js_string }}');
{% if not cmd.is_group %}
{% for arg in cmd.arguments if cmd.arguments %}
{{ cmd.name.replace('-', '_') }}Cmd.argument('{% if not (arg.required is defined and arg.required) %}[{% endif %}{{ arg.name }}{% if arg.multiple is defined and arg.multiple %}...{% endif %}{% if not (arg.required is defined and arg.required) %}]{% endif %}', '{{ ((arg.desc if arg.desc is defined else 'No description')) | js_string }}');
{% endfor %}
{% for option in cmd.options if cmd.options %}
{{ cmd.name.replace('-', '_') }}Cmd.option('--{{ option.name }}{% if option.short is defined and option.short %}, -{{ option.short }}{% endif %}', '{{ option.description | js_string }}'{% if option.default is defined and option.default %}, {{ option.default | tojson }}{% endif %});
{% endfor %}
{{ cmd.name.replace('-', '_') }}Cmd.action(async ({% for arg in cmd.arguments if cmd.arguments %}{{ arg.name }}: {% if arg.multiple is defined and arg.multiple %}string[]{% else %}string{% endif %}{% if cmd.options or not loop.last %}, {% endif %}{% endfor %}options: any) => {
    const globalOpts = program.opts();
    const verbose: boolean = globalOpts.verbose || false;
    
    try {
        const hookName = '{{ cmd.hook_name }}' as keyof typeof hooks;
        
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${String(hookName)}' not implemented in src/hooks.ts`;
            const details = availableHooks.length > 0 
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.ts';
            throw new CLIError(message, 2, details);
        }
        
        // Execute the hook function with proper error handling
        const args = [{% for arg in cmd.arguments if cmd.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %}];
        const result = await (hooks[hookName] as Function)(...args{% if cmd.arguments %}, {% endif %}options);
        
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command '{{ ' '.join(cmd.path) }}' failed with exit code ${result}`, result);
        }
        
    } catch (error: unknown) {
        if (error instanceof Error && (error.message.includes('SIGINT') || error.message.includes('interrupted'))) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        
        handleError(error, 'Command execution', verbose);
    }
});
{% endif %}
commandMap.set('{{ '/'.join(cmd.path) }}', {{ cmd.name.replace('-', '_') }}Cmd);

{% elif cmd.depth > 1 %}

// Level {{ cmd.depth }}: {{ cmd.path | join(' ') }}
{% set parent_path = cmd.parent_path | join('/') %}
{% set parent_var = cmd.parent_path[-1].replace('-', '_') + 'Cmd' %}
const {{ cmd.path | join('_') | replace('-', '_') }}Cmd = commandMap.get('{{ parent_path }}')
    .command('{{ cmd.name }}')
    .description('{{ ((cmd.description if cmd.description is defined else 'No description')) | js_string }}');
{% if not cmd.is_group %}
{%- for arg in cmd.arguments if cmd.arguments %}
{{ cmd.path | join('_') | replace('-', '_') }}Cmd.argument('{% if not (arg.required is defined and arg.required) %}[{% endif %}{{ arg.name }}{% if arg.multiple is defined and arg.multiple %}...{% endif %}{% if not (arg.required is defined and arg.required) %}]{% endif %}', '{{ ((arg.desc if arg.desc is defined else 'No description')) | js_string }}');
{% endfor %}
{%- for option in cmd.options if cmd.options %}
{{ cmd.path | join('_') | replace('-', '_') }}Cmd.option('--{{ option.name }}{% if option.short is defined and option.short %}, -{{ option.short }}{% endif %}', '{{ option.description | js_string }}'{% if option.default is defined and option.default %}, {{ option.default | tojson }}{% endif %});
{% endfor %}
{{ cmd.path | join('_') | replace('-', '_') }}Cmd.action(async ({% for arg in cmd.arguments if cmd.arguments %}{{ arg.name }}: {% if arg.multiple is defined and arg.multiple %}string[]{% else %}string{% endif %}{% if cmd.options or not loop.last %}, {% endif %}{% endfor %}options: any) => {
    const globalOpts = program.opts();
    const verbose: boolean = globalOpts.verbose || false;
    
    try {
        const hookName = '{{ cmd.hook_name }}' as keyof typeof hooks;
        
        if (!hooks) {
            throw new CLIError('Hook module not loaded', 2);
        }
        
        if (typeof hooks[hookName] !== 'function') {
            const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
            const message = `Hook function '${String(hookName)}' not implemented in src/hooks.ts`;
            const details = availableHooks.length > 0 
                ? `Available hooks: ${availableHooks.join(', ')}`
                : 'No hook functions found in src/hooks.ts';
            throw new CLIError(message, 2, details);
        }
        
        // Execute the hook function with proper error handling
        const args = [{% for arg in cmd.arguments if cmd.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %}];
        const result = await (hooks[hookName] as Function)(...args{% if cmd.arguments %}, {% endif %}options);
        
        // Handle return codes
        if (typeof result === 'number' && result !== 0) {
            throw new CLIError(`Command '{{ ' '.join(cmd.path) }}' failed with exit code ${result}`, result);
        }
        
    } catch (error: unknown) {
        if (error instanceof Error && (error.message.includes('SIGINT') || error.message.includes('interrupted'))) {
            console.error('\\nCommand interrupted by user');
            process.exit(130);
        }
        
        handleError(error, 'Command execution', verbose);
    }
});
{% endif %}
commandMap.set('{{ '/'.join(cmd.path) }}', {{ cmd.path | join('_') | replace('-', '_') }}Cmd);

{% endif %}
{% endfor %}

{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
// Check for interactive mode
program.hook('preAction', (thisCommand, actionCommand) => {
    const opts = thisCommand.opts();
    if (opts.interactive) {
        if (typeof runInteractive === 'function') {
            runInteractive();
            process.exit(0);
        } else {
            console.error('Interactive mode not available. Please ensure all dependencies are installed.');
            process.exit(1);
        }
    }
});
{% endif %}

program.parse();

{%- elif language == 'rust' -%}
use clap::{Arg, Command, ArgMatches};
use std::process;
use anyhow::{Result, anyhow};

mod hooks;
{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
mod {{ cli.name.replace('-', '_') }}_interactive;
use {{ cli.name.replace('-', '_') }}_interactive::run_interactive;
{% endif %}

/// Enhanced error handling function
fn handle_error(error: anyhow::Error, context: &str, verbose: bool) -> ! {
    eprintln!("‚ùå {}: {}", context, error);
    
    if verbose {
        eprintln!("Details: {:#}", error);
    }
    
    // Check for specific error types to provide better exit codes
    if error.to_string().contains("not implemented") {
        process::exit(2); // Configuration/implementation error
    } else if error.to_string().contains("permission denied") {
        process::exit(3); // Permission error
    } else {
        process::exit(1); // General error
    }
}

fn main() {
    let app = Command::new("{{ cli.name }}")
        .version("{{ cli.version }}")
        .about("{{ (cli.description if cli.description is defined else (project.description if project.description is defined else 'No description')) }}")
        .arg_required_else_help(true)
        .arg(
            Arg::new("verbose")
                .long("verbose")
                .short('v')
                .help("Enable verbose error output and debugging information")
                .action(clap::ArgAction::SetTrue)
        )
{%- for option in cli.options %}
        .arg(
            Arg::new("{{ option.name }}")
                .long("{{ option.name }}")
                {%- if option.short is defined and option.short and option.short != 'None' %}
                .short('{{ option.short }}')
                {% endif %}
                .help("{{ option.description }}")
                {%- if option.required is defined and option.required %}
                .required(true)
                {% endif %}
                {%- if option.multiple is defined and option.multiple %}
                .action(clap::ArgAction::Append)
                {%- elif option.type is defined and option.type == "boolean" %}
                .action(clap::ArgAction::SetTrue)
                {%- else %}
                .action(clap::ArgAction::Set)
                {% endif %}
        )
{% endfor %}
        // Built-in upgrade subcommand
        .subcommand(
            Command::new("upgrade")
                .about("Upgrade {{ project.display_name | default(project.name) }} to the latest version")
                .arg(
                    Arg::new("check")
                        .long("check")
                        .help("Check for updates without installing")
                        .action(clap::ArgAction::SetTrue)
                )
                .arg(
                    Arg::new("version")
                        .long("version")
                        .help("Install specific version")
                        .action(clap::ArgAction::Set)
                )
                .arg(
                    Arg::new("pre")
                        .long("pre")
                        .help("Include pre-release versions")
                        .action(clap::ArgAction::SetTrue)
                )
                .arg(
                    Arg::new("dry-run")
                        .long("dry-run")
                        .help("Show what would be done without doing it")
                        .action(clap::ArgAction::SetTrue)
                )
        )
{# Build commands using flat_commands for unlimited nesting support #}
{%- for cmd in cli.command_hierarchy.flat_commands if cli.command_hierarchy and cli.command_hierarchy.flat_commands %}
        .subcommand(
            Command::new("{{ ' '.join(cmd.path) }}")
                .about("{{ (cmd.description if cmd.description is defined else 'No description') }}")
{% if not cmd.is_group %}
{%- for arg in cmd.arguments if cmd.arguments %}
                .arg(
                    Arg::new("{{ arg.name }}")
                        .help("{{ (arg.desc if arg.desc is defined else 'No description') }}")
                        {%- if arg.required is defined and arg.required %}
                        .required(true)
                        {% endif %}
                        {%- if arg.multiple is defined and arg.multiple %}
                        .action(clap::ArgAction::Append)
                        {%- else %}
                        .action(clap::ArgAction::Set)
                        {% endif %}
                )
{% endfor %}
{%- for option in cmd.options if cmd.options %}
                .arg(
                    Arg::new("{{ option.name }}")
                        .long("{{ option.name }}")
                        {%- if option.short is defined and option.short and option.short != 'None' %}
                        .short('{{ option.short }}')
                        {% endif %}
                        .help("{{ (option.description if option.description is defined else 'No description') }}")
                        {%- if option.required is defined and option.required %}
                        .required(true)
                        {% endif %}
                        {%- if option.multiple is defined and option.multiple %}
                        .action(clap::ArgAction::Append)
                        {%- else %}
                        .action(clap::ArgAction::Set)
                        {% endif %}
                )
{% endfor %}
{% endif %}
        )
{% endfor %};

    let matches = app.get_matches();
    
    // Extract verbose flag for global error handling
    let verbose = matches.get_flag("verbose");
    
    {%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
    // Check for interactive mode
    if matches.get_flag("interactive") {
        match run_interactive() {
            Ok(_) => return,
            Err(e) => {
                handle_error(e.into(), "Interactive mode execution", verbose);
            }
        }
    }
    {% endif %}

    match matches.subcommand() {
        Some(("upgrade", sub_matches)) => {
            // Built-in upgrade command implementation
            let package_name = "{{ installation.pypi_name | default(project.package_name) | default(project.name) }}";
            let command_name = "{{ project.command_name | default('cli') }}";
            let display_name = "{{ project.display_name | default(project.name) }}";
            
            // Get current version (simple fallback for Rust)
            let current_version = "{{ cli.version | default('1.0.0') }}";
            println!("Current version: {}", current_version);
            
            let check_only = sub_matches.get_flag("check");
            let version = sub_matches.get_one::<String>("version");
            let pre = sub_matches.get_flag("pre");
            let dry_run = sub_matches.get_flag("dry-run");
            
            if check_only {
                println!("Checking for updates to {}...", display_name);
                println!("Update check not yet implemented for Rust. Use without --check to upgrade.");
                return;
            }
            
            // Build the cargo install command
            let mut cmd_args = vec!["install"];
            
            if let Some(v) = version {
                cmd_args.push("--version");
                cmd_args.push(v);
            } else {
                cmd_args.push("--force"); // Force reinstall for upgrade
            }
            
            if pre {
                // Cargo doesn't have direct pre-release flag, but we can note it
                println!("Note: Cargo install will use the latest compatible version");
            }
            
            cmd_args.push(package_name);
            
            if dry_run {
                println!("Dry run - would execute: cargo {}", cmd_args.join(" "));
                return;
            }
            
            // Execute upgrade
            println!("Upgrading {} with cargo...", display_name);
            
            let output = std::process::Command::new("cargo")
                .args(&cmd_args)
                .output();
                
            match output {
                Ok(result) => {
                    if result.status.success() {
                        println!("‚úÖ {} upgraded successfully!", display_name);
                        println!("Run '{} --version' to verify the new version.", command_name);
                    } else {
                        eprintln!("‚ùå Upgrade failed with exit code {:?}", result.status.code());
                        process::exit(result.status.code().unwrap_or(1));
                    }
                }
                Err(e) => {
                    eprintln!("‚ùå Failed to execute cargo install: {}", e);
                    process::exit(1);
                }
            }
        }
{# Match commands using flat_commands for unlimited nesting support #}
{%- for cmd in cli.command_hierarchy.flat_commands if cli.command_hierarchy and cli.command_hierarchy.flat_commands %}
{% if not cmd.is_group %}
        Some(("{{ ' '.join(cmd.path) }}", sub_matches)) => {
            // Enhanced error handling for Rust commands
            let hook_name = "{{ cmd.hook_name }}";
            match hooks::{{ cmd.hook_name }}(sub_matches) {
                Ok(_) => {
                    // Command executed successfully
                }
                Err(e) => {
                    let error_context = format!("Command '{{ ' '.join(cmd.path) }}' execution");
                    
                    // Check for specific error types
                    if e.to_string().contains("not implemented") {
                        let enhanced_error = anyhow!(
                            "Hook function '{}' not implemented in src/hooks.rs. \
                            Please implement: pub fn {}(matches: &ArgMatches) -> Result<()>",
                            hook_name, hook_name
                        );
                        handle_error(enhanced_error, &error_context, verbose);
                    } else {
                        handle_error(e, &error_context, verbose);
                    }
                }
            }
        }
{% endif %}
{% endfor %}
        _ => {
            eprintln!("No subcommand provided. Use --help for available commands.");
            process::exit(1);
        }
    }
}

{%- endif -%}