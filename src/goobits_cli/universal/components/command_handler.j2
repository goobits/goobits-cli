{# Universal Command Handler Template
   
   This template generates the main CLI command structure for any supported language.
   It includes argument parsing, option handling, and hook integration.
   
   Variables expected:
   - language: Target language (python, nodejs, typescript, rust)
   - project: Project metadata
   - cli: CLI schema with commands, arguments, options
#}

{%- if language == 'python' -%}
#!/usr/bin/env python3
"""
Auto-generated from {{ config_filename | default('goobits.yaml') }}
"""

import rich_click as click
from rich_click import RichGroup
import sys
import traceback
import inspect
{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
try:
    from .{{ cli.name.replace('-', '_') }}_interactive import run_interactive
except ImportError:
    run_interactive = None
{%- endif %}

# Enhanced Error Handling Classes
class CLIError(Exception):
    """Base exception for CLI errors."""
    def __init__(self, message: str, exit_code: int = 1, suggestion: str = None):
        self.message = message
        self.exit_code = exit_code
        self.suggestion = suggestion
        super().__init__(self.message)

class ConfigError(CLIError):
    """Configuration-related error."""
    def __init__(self, message: str, suggestion: str = None):
        super().__init__(message, exit_code=2, suggestion=suggestion)

class HookError(CLIError):
    """Hook execution error."""
    def __init__(self, message: str, hook_name: str = None):
        self.hook_name = hook_name
        super().__init__(message, exit_code=3, suggestion=f"Check the '{hook_name}' function in your app_hooks.py file" if hook_name else None)

# Global error handler
def handle_cli_error(error: Exception, verbose: bool = False) -> int:
    """Handle CLI errors with appropriate messages and exit codes."""
    if isinstance(error, CLIError):
        click.echo(f"âŒ Error: {error.message}", err=True)
        if error.suggestion:
            click.echo(f"ðŸ’¡ Suggestion: {error.suggestion}", err=True)
        if verbose and hasattr(error, '__cause__') and error.__cause__:
            click.echo(f"Details: {traceback.format_exc()}", err=True)
        return error.exit_code
    else:
        click.echo(f"âŒ Unexpected error: {str(error)}", err=True)
        if verbose:
            click.echo(f"Details: {traceback.format_exc()}", err=True)
        return 1

# Import hooks module with enhanced error handling
try:
    import app_hooks as hooks
except ImportError:
    hooks = None

@click.group(cls=RichGroup)
@click.version_option(version="{{ cli.version | default('1.0.0') }}")
@click.option(
    "--verbose", "-v",
    help="Enable verbose error output and debugging information",
    is_flag=True,
    default=False
)
{%- if cli.options %}
{% for option in cli.options %}
@click.option(
    "--{{ option.name }}"{% if option.short is defined and option.short %}, "-{{ option.short }}"{% endif %},
    help="{{ (option.desc if option.desc is defined else 'No description') }}"{% if option.type is defined and (option.type == "flag" or option.type == "boolean") %},
    is_flag=True{% elif option.type is defined and option.type == "integer" %},
    type=int{% elif option.type is defined and option.type == "float" %},
    type=float{% endif %},
{%- if option.default is defined and option.default is not none %}
    default={{ option.default | repr }},
{%- endif %}
    {%- if option.required is defined and option.required %}
    required=True,
    {%- endif %}
    {%- if option.multiple is defined and option.multiple %}
    multiple=True,
    {%- endif %}
)
{% endfor %}
{%- endif %}
@click.pass_context
def main(ctx):
    """{{ (cli.description if cli.description is defined else (project.description if project.description is defined else 'No description')) }}"""
    {% if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled -%}
    # Check if interactive mode was requested
    if ctx.params.get('interactive'):
        if run_interactive:
            run_interactive()
            sys.exit(0)
        else:
            click.echo("Interactive mode not available. Please ensure all dependencies are installed.", err=True)
            sys.exit(1)
    {%- endif %}
    pass

{%- for command_name, command_config in cli.commands.items() %}

@main.command()
{%- for arg in command_config.args if command_config.args is defined %}
@click.argument('{{ arg.name.upper() }}'{% if not (arg.required is defined and arg.required) %}, required=False{% endif %})
{%- endfor %}
{%- for option in command_config.options if command_config.options is defined %}
@click.option(
    "--{{ option.name }}"{% if option.short is defined and option.short %}, "-{{ option.short }}"{% endif %},
    help="{{ (option.desc if option.desc is defined else 'No description') }}"{% if option.type is defined and (option.type == "flag" or option.type == "boolean") %},
    is_flag=True{% elif option.type is defined and option.type == "integer" %},
    type=int{% elif option.type is defined and option.type == "float" %},
    type=float{% endif %},
{%- if option.default is defined and option.default is not none %}
    default={{ option.default | repr }},
{%- endif %}
    {%- if option.required is defined and option.required %}
    required=True,
    {%- endif %}
    {%- if option.multiple is defined and option.multiple %}
    multiple=True,
    {%- endif %}
)
{%- endfor %}
@click.pass_context
def {{ command_name.replace('-', '_') }}(ctx{% for arg in command_config.args if command_config.args is defined %}, {{ arg.name.lower() }}{% endfor %}{% for option in command_config.options if command_config.options is defined %}, {{ option.name.replace('-', '_') }}{% endfor %}):
    """{{ (command_config.desc if command_config.desc is defined else (command_config.description if command_config.description is defined else ('Command ' + command_name))) }}"""
    
    # Enhanced error handling for Python CLI
    verbose = ctx.parent.params.get('verbose', False) if ctx.parent else False
    
    try:
        if hooks is None:
            raise ConfigError(
                "Hook implementation not found. Please create 'app_hooks.py' with your command implementations.",
                suggestion="Create app_hooks.py with function: def on_{{ command_name.replace('-', '_') }}(...): pass"
            )
        
        hook_name = 'on_{{ command_name.replace('-', '_') }}'
        if not hasattr(hooks, hook_name):
            available_hooks = [name for name in dir(hooks) if not name.startswith('_') and callable(getattr(hooks, name))]
            raise ConfigError(
                f"Hook function '{hook_name}' not found in app_hooks.py",
                suggestion=f"Available functions: {', '.join(available_hooks) if available_hooks else 'none'}"
            )
        
        hook_function = getattr(hooks, hook_name)
        
        # Prepare arguments and options for the hook
        args = [{% for arg in command_config.args if command_config.args is defined %}{{ arg.name.lower() }}{% if not loop.last %}, {% endif %}{% endfor %}]
        options = {
        {%- for option in command_config.options if command_config.options is defined %}
            '{{ option.name }}': {{ option.name.replace('-', '_') }}{% if not loop.last %},{% endif %}
        {%- endfor %}
        }
        
        # Execute the hook function with proper signature detection
        sig = inspect.signature(hook_function)
        params = list(sig.parameters.keys())
        
        # Call function with appropriate arguments
        try:
            if len(params) == 0:
                result = hook_function()
            elif len(params) == 1 and any(keyword in params[0].lower() for keyword in ['args', 'arguments']):
                result = hook_function(args)
            elif len(params) == 1 and any(keyword in params[0].lower() for keyword in ['opts', 'options']):
                result = hook_function(options)
            else:
                # Try calling with individual arguments and options
                if args and options:
                    result = hook_function(*args, **options)
                elif args:
                    result = hook_function(*args)
                elif options:
                    result = hook_function(**options)
                else:
                    result = hook_function()
        except TypeError as te:
            raise HookError(
                f"Hook function signature mismatch: {te}",
                hook_name=hook_name
            )
        
        # Handle return codes
        if isinstance(result, int) and result != 0:
            click.echo(f"Command '{{ command_name }}' failed with exit code {result}", err=True)
            sys.exit(result)
            
    except KeyboardInterrupt:
        click.echo("\\nâš ï¸  Command interrupted by user", err=True)
        sys.exit(130)
        
    except Exception as e:
        exit_code = handle_cli_error(e, verbose)
        sys.exit(exit_code)

{%- endfor %}

if __name__ == "__main__":
    main()

{%- elif language == 'nodejs' -%}
#!/usr/bin/env node
/**
 * {{ project.name }} - {{ project.description }}
 * Generated by Goobits CLI Framework
 */

const { Command } = require('commander');
// Hook loading with enhanced error handling
let hooks = null;
try {
    hooks = require('./hooks');
} catch (error) {
    if (error.code === 'MODULE_NOT_FOUND') {
        console.error('Hook implementation not found. Please create \'src/hooks.js\' with your command implementations.');
        console.error('See documentation for hook function signatures.');
    } else {
        console.error(`Failed to load hooks: ${error.message}`);
    }
    process.exit(2);
}

{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
let runInteractive;
try {
    const interactive = require('./{{ cli.name.replace('-', '_') }}_interactive');
    runInteractive = interactive.runInteractive;
} catch (e) {
    // Interactive mode not available
}
{%- endif %}

// Enhanced error handling for Node.js
class CLIError extends Error {
    constructor(message, code = 1, details = null) {
        super(message);
        this.name = 'CLIError';
        this.code = code;
        this.details = details;
    }
}

// Global error handler
function handleError(error, context = 'Command execution', verbose = false) {
    if (error instanceof CLIError) {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.details) {
            console.error('Details:', error.details);
        }
        process.exit(error.code);
    } else if (error.code === 'MODULE_NOT_FOUND' && error.message.includes('hooks')) {
        console.error('Hook implementation not found.');
        console.error('Please implement the required hook function in src/hooks.js');
        process.exit(2);
    } else {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.stack) {
            console.error('Stack trace:', error.stack);
        }
        process.exit(1);
    }
}

const program = new Command();

program
    .name('{{ cli.name }}')
    .description('{{ ((cli.description if cli.description is defined else (project.description if project.description is defined else 'No description'))) | js_string }}')
    .version('{{ cli.version }}')
    .option('-v, --verbose', 'Enable verbose error output and debugging information', false);

{%- for option in cli.options %}
program.option(
    '--{{ option.name }}{% if option.short is defined and option.short %}, -{{ option.short }}{% endif %}',
    '{{ ((option.description if option.description is defined else 'No description')) | js_string }}'{% if option.default is defined and option.default %}, {{ option.default | tojson }}{% endif %}
);
{%- endfor %}

{%- for command_name, command_config in cli.commands.items() %}

program
    .command('{{ command_name }}')
    .description('{{ ((command_config.description if command_config.description is defined else (command_config.desc if command_config.desc is defined else 'No description'))) | js_string }}')
{%- for arg in command_config.args if command_config.args is defined %}
    .argument('{% if not (arg.required is defined and arg.required) %}[{% endif %}{{ arg.name }}{% if arg.multiple is defined and arg.multiple %}...{% endif %}{% if not (arg.required is defined and arg.required) %}]{% endif %}', '{{ ((arg.desc if arg.desc is defined else 'No description')) | js_string }}')
{%- endfor %}
{%- for option in command_config.options if command_config.options is defined %}
    .option('--{{ option.name }}{% if option.short is defined and option.short %}, -{{ option.short }}{% endif %}', '{{ option.desc | js_string }}'{% if option.default is defined and option.default %}, {{ option.default | tojson }}{% endif %})
{%- endfor %}
    .action(async ({% for arg in command_config.args if command_config.args is defined %}{{ arg.name }}{% if command_config.options or not loop.last %}, {% endif %}{% endfor %}options) => {
        const globalOpts = program.opts();
        const verbose = globalOpts.verbose || false;
        
        try {
            const hookName = 'on{{ command_name | title | replace('-', '') }}';
            
            if (!hooks) {
                throw new CLIError('Hook module not loaded', 2);
            }
            
            if (typeof hooks[hookName] !== 'function') {
                const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
                const message = `Hook function '${hookName}' not implemented in src/hooks.js`;
                const details = availableHooks.length > 0 
                    ? `Available hooks: ${availableHooks.join(', ')}`
                    : 'No hook functions found in src/hooks.js';
                throw new CLIError(message, 2, details);
            }
            
            // Execute the hook function with proper error handling
            const args = [{% for arg in command_config.args if command_config.args is defined %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %}];
            const result = await hooks[hookName](...args{% if command_config.args %}, {% endif %}options);
            
            // Handle return codes
            if (typeof result === 'number' && result !== 0) {
                throw new CLIError(`Command '{{ command_name }}' failed with exit code ${result}`, result);
            }
            
        } catch (error) {
            if (error.code === 'SIGINT' || error.message.includes('interrupted')) {
                console.error('\\nCommand interrupted by user');
                process.exit(130);
            }
            
            handleError(error, 'Command execution', verbose);
        }
    });

{%- endfor %}

{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
// Check for interactive mode
program.hook('preAction', (thisCommand, actionCommand) => {
    const opts = thisCommand.opts();
    if (opts.interactive) {
        if (runInteractive) {
            runInteractive();
            process.exit(0);
        } else {
            console.error('Interactive mode not available. Please ensure all dependencies are installed.');
            process.exit(1);
        }
    }
});
{%- endif %}

program.parse();

{%- elif language == 'typescript' -%}
#!/usr/bin/env node
/**
 * {{ project.name }} - {{ project.description }}
 * Generated by Goobits CLI Framework
 */

import { Command } from 'commander';
// Enhanced error handling for TypeScript
class CLIError extends Error {
    public code: number;
    public details?: string;
    
    constructor(message: string, code: number = 1, details?: string) {
        super(message);
        this.name = 'CLIError';
        this.code = code;
        this.details = details;
    }
}

// Hook loading with enhanced error handling
let hooks: any = null;
try {
    hooks = require('./hooks');
} catch (error: any) {
    if (error.code === 'MODULE_NOT_FOUND') {
        console.error('Hook implementation not found. Please create \'src/hooks.ts\' with your command implementations.');
        console.error('See documentation for hook function signatures.');
    } else {
        console.error(`Failed to load hooks: ${error.message}`);
    }
    process.exit(2);
}

{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
import { runInteractive } from './{{ cli.name.replace('-', '_') }}_interactive';
{%- endif %}

// Global error handler
function handleError(error: unknown, context: string = 'Command execution', verbose: boolean = false): never {
    if (error instanceof CLIError) {
        console.error(`${context} failed: ${error.message}`);
        if (verbose && error.details) {
            console.error('Details:', error.details);
        }
        process.exit(error.code);
    } else if (error instanceof Error) {
        if (error.message.includes('Cannot resolve module') || error.message.includes('MODULE_NOT_FOUND')) {
            console.error('Hook implementation not found.');
            console.error('Please implement the required hook function in src/hooks.ts');
            process.exit(2);
        } else {
            console.error(`${context} failed: ${error.message}`);
            if (verbose && error.stack) {
                console.error('Stack trace:', error.stack);
            }
            process.exit(1);
        }
    } else {
        console.error(`${context} failed: Unknown error`);
        if (verbose) {
            console.error('Error details:', error);
        }
        process.exit(1);
    }
}

const program = new Command();

program
    .name('{{ cli.name }}')
    .description('{{ ((cli.description if cli.description is defined else (project.description if project.description is defined else 'No description'))) | js_string }}')
    .version('{{ cli.version }}')
    .option('-v, --verbose', 'Enable verbose error output and debugging information', false);

{%- for option in cli.options %}
program.option(
    '--{{ option.name }}{% if option.short is defined and option.short %}, -{{ option.short }}{% endif %}',
    '{{ ((option.description if option.description is defined else 'No description')) | js_string }}'{% if option.default is defined and option.default %}, {{ option.default | tojson }}{% endif %}
);
{%- endfor %}

{%- for command_name, command_config in cli.commands.items() %}

program
    .command('{{ command_name }}')
    .description('{{ ((command_config.description if command_config.description is defined else (command_config.desc if command_config.desc is defined else 'No description'))) | js_string }}')
{%- for arg in command_config.args if command_config.args is defined %}
    .argument('{% if not (arg.required is defined and arg.required) %}[{% endif %}{{ arg.name }}{% if arg.multiple is defined and arg.multiple %}...{% endif %}{% if not (arg.required is defined and arg.required) %}]{% endif %}', '{{ ((arg.desc if arg.desc is defined else 'No description')) | js_string }}')
{%- endfor %}
{%- for option in command_config.options if command_config.options is defined %}
    .option('--{{ option.name }}{% if option.short is defined and option.short %}, -{{ option.short }}{% endif %}', '{{ option.desc | js_string }}'{% if option.default is defined and option.default %}, {{ option.default | tojson }}{% endif %})
{%- endfor %}
    .action(async ({% for arg in command_config.args if command_config.args is defined %}{{ arg.name }}: {% if arg.multiple is defined and arg.multiple %}string[]{% else %}string{% endif %}{% if command_config.options or not loop.last %}, {% endif %}{% endfor %}options: any) => {
        const globalOpts = program.opts();
        const verbose: boolean = globalOpts.verbose || false;
        
        try {
            const hookName = 'on{{ command_name | title | replace('-', '') }}' as keyof typeof hooks;
            
            if (!hooks) {
                throw new CLIError('Hook module not loaded', 2);
            }
            
            if (typeof hooks[hookName] !== 'function') {
                const availableHooks = Object.keys(hooks).filter(key => typeof hooks[key] === 'function');
                const message = `Hook function '${String(hookName)}' not implemented in src/hooks.ts`;
                const details = availableHooks.length > 0 
                    ? `Available hooks: ${availableHooks.join(', ')}`
                    : 'No hook functions found in src/hooks.ts';
                throw new CLIError(message, 2, details);
            }
            
            // Execute the hook function with proper error handling
            const args = [{% for arg in command_config.args if command_config.args is defined %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %}];
            const result = await (hooks[hookName] as Function)(...args{% if command_config.args %}, {% endif %}options);
            
            // Handle return codes
            if (typeof result === 'number' && result !== 0) {
                throw new CLIError(`Command '{{ command_name }}' failed with exit code ${result}`, result);
            }
            
        } catch (error: unknown) {
            if (error instanceof Error && (error.message.includes('SIGINT') || error.message.includes('interrupted'))) {
                console.error('\\nCommand interrupted by user');
                process.exit(130);
            }
            
            handleError(error, 'Command execution', verbose);
        }
    });

{%- endfor %}

{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
// Check for interactive mode
program.hook('preAction', (thisCommand, actionCommand) => {
    const opts = thisCommand.opts();
    if (opts.interactive) {
        if (typeof runInteractive === 'function') {
            runInteractive();
            process.exit(0);
        } else {
            console.error('Interactive mode not available. Please ensure all dependencies are installed.');
            process.exit(1);
        }
    }
});
{%- endif %}

program.parse();

{%- elif language == 'rust' -%}
use clap::{Arg, Command, ArgMatches};
use std::process;
use anyhow::Result;

mod hooks;
{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
mod {{ cli.name.replace('-', '_') }}_interactive;
use {{ cli.name.replace('-', '_') }}_interactive::run_interactive;
{%- endif %}

fn main() {
    let app = Command::new("{{ cli.name }}")
        .version("{{ cli.version }}")
        .about("{{ (cli.description if cli.description is defined else (project.description if project.description is defined else 'No description')) }}")
        .arg_required_else_help(true)
{%- for option in cli.options %}
        .arg(
            Arg::new("{{ option.name }}")
                .long("{{ option.name }}")
                {%- if option.short is defined and option.short %}
                .short('{{ option.short }}')
                {%- endif %}
                .help("{{ option.description }}")
                {%- if option.required is defined and option.required %}
                .required(true)
                {%- endif %}
                {%- if option.multiple is defined and option.multiple %}
                .action(clap::ArgAction::Append)
                {%- elif option.type is defined and option.type == "boolean" %}
                .action(clap::ArgAction::SetTrue)
                {%- else %}
                .action(clap::ArgAction::Set)
                {%- endif %}
        )
{%- endfor %}
{%- for command_name, command_config in cli.commands.items() %}
        .subcommand(
            Command::new("{{ command_name }}")
                .about("{{ (command_config.description if command_config.description is defined else (command_config.desc if command_config.desc is defined else 'No description')) }}")
{%- for arg in command_config.args if command_config.args is defined %}
                .arg(
                    Arg::new("{{ arg.name }}")
                        .help("{{ (arg.desc if arg.desc is defined else 'No description') }}")
                        {%- if arg.required is defined and arg.required %}
                        .required(true)
                        {%- endif %}
                        {%- if arg.multiple is defined and arg.multiple %}
                        .action(clap::ArgAction::Append)
                        {%- else %}
                        .action(clap::ArgAction::Set)
                        {%- endif %}
                )
{%- endfor %}
{%- for option in command_config.options if command_config.options is defined %}
                .arg(
                    Arg::new("{{ option.name }}")
                        .long("{{ option.name }}")
                        {%- if option.short is defined and option.short %}
                        .short('{{ option.short }}')
                        {%- endif %}
                        .help("{{ (option.desc if option.desc is defined else 'No description') }}")
                        {%- if option.required is defined and option.required %}
                        .required(true)
                        {%- endif %}
                        {%- if option.multiple is defined and option.multiple %}
                        .action(clap::ArgAction::Append)
                        {%- else %}
                        .action(clap::ArgAction::Set)
                        {%- endif %}
                )
{%- endfor %}
        )
{%- endfor %};

    let matches = app.get_matches();
    
    {%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
    // Check for interactive mode
    if matches.get_flag("interactive") {
        match run_interactive() {
            Ok(_) => return,
            Err(e) => {
                eprintln!("Error running interactive mode: {}", e);
                process::exit(1);
            }
        }
    }
    {%- endif %}

    match matches.subcommand() {
{%- for command_name, command_config in cli.commands.items() %}
        Some(("{{ command_name }}", sub_matches)) => {
            // Enhanced error handling for Rust commands
            let hook_name = "on_{{ command_name | replace('-', '_') }}";
            match hooks::on_{{ command_name | replace('-', '_') }}(sub_matches) {
                Ok(exit_code) => {
                    if exit_code != 0 {
                        eprintln!("Command '{{ command_name }}' failed with exit code {}", exit_code);
                        process::exit(exit_code);
                    }
                }
                Err(e) => {
                    let error_context = format!("Command '{{ command_name }}' execution");
                    
                    // Check for specific error types
                    if e.to_string().contains("not implemented") {
                        let enhanced_error = anyhow!(
                            "Hook function '{}' not implemented in src/hooks.rs. \
                            Please implement: pub fn {}(matches: &ArgMatches) -> Result<i32>",
                            hook_name, hook_name
                        );
                        handle_error(enhanced_error, &error_context, verbose);
                    } else {
                        handle_error(e.context(error_context), "Command execution", verbose);
                    }
                }
            }
        }
{%- endfor %}
        _ => {
            eprintln!("No subcommand provided. Use --help for available commands.");
            process::exit(1);
        }
    }
}

{%- endif -%}