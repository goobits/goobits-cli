{# Universal Command Handler Template
   
   This template generates the main CLI command structure for any supported language.
   It includes argument parsing, option handling, and hook integration.
   
   Variables expected:
   - language: Target language (python, nodejs, typescript, rust)
   - project: Project metadata
   - cli: CLI schema with commands, arguments, options
#}

{%- if language == 'python' -%}
#!/usr/bin/env python3
"""
{{ project.name }} - {{ project.description }}
Generated by Goobits CLI Framework
"""

import click
import sys
from typing import Any
try:
    from .hooks import *  # Import all hook functions
except ImportError:
    # Hooks not implemented yet
    pass

@click.group(
    name="{{ cli.root_command.name }}",
    help="{{ cli.root_command.description }}",
    context_settings={"help_option_names": ["-h", "--help"]}
)
@click.version_option(version="{{ cli.root_command.version }}")
{%- for option in cli.root_command.options %}
@click.option(
    "--{{ option.name }}"{% if option.short %}, "-{{ option.short }}"{% endif %},
    help="{{ option.description }}",
    {%- if option.type == "boolean" %}
    is_flag=True,
    {%- elif option.type == "integer" %}
    type=int,
    {%- elif option.type == "float" %}
    type=float,
    {%- endif %}
    {%- if option.default is not none %}
    default={{ option.default | repr }},
    {%- endif %}
    {%- if option.required %}
    required=True,
    {%- endif %}
    {%- if option.multiple %}
    multiple=True,
    {%- endif %}
)
{%- endfor %}
def cli({% for option in cli.root_command.options %}{{ option.name.replace('-', '_') }}{% if not loop.last %}, {% endif %}{% endfor %}):
    """{{ cli.root_command.description }}"""
    pass

{%- for command in cli.root_command.subcommands %}

@cli.command(name="{{ command.name }}", help="{{ command.description }}")
{%- for arg in command.arguments %}
@click.argument("{{ arg.name }}"{% if not arg.required %}, required=False{% endif %}{% if arg.multiple %}, nargs=-1{% endif %})
{%- endfor %}
{%- for option in command.options %}
@click.option(
    "--{{ option.name }}"{% if option.short %}, "-{{ option.short }}"{% endif %},
    help="{{ option.description }}",
    {%- if option.type == "boolean" %}
    is_flag=True,
    {%- elif option.type == "integer" %}
    type=int,
    {%- elif option.type == "float" %}
    type=float,
    {%- endif %}
    {%- if option.default is not none %}
    default={{ option.default | repr }},
    {%- endif %}
    {%- if option.required %}
    required=True,
    {%- endif %}
    {%- if option.multiple %}
    multiple=True,
    {%- endif %}
)
{%- endfor %}
def {{ command.name.replace('-', '_') }}_command({% for arg in command.arguments %}{{ arg.name }}{% if command.options or not loop.last %}, {% endif %}{% endfor %}{% for option in command.options %}{{ option.name.replace('-', '_') }}{% if not loop.last %}, {% endif %}{% endfor %}):
    """{{ command.description }}"""
    try:
        # Call the hook function if it exists
        hook_name = "{{ command.hook_name }}"
        if hook_name in globals():
            hook_func = globals()[hook_name]
            hook_func({% for arg in command.arguments %}{{ arg.name }}{% if command.options or not loop.last %}, {% endif %}{% endfor %}{% for option in command.options %}{{ option.name.replace('-', '_') }}{% if not loop.last %}, {% endif %}{% endfor %})
        else:
            click.echo(f"Hook function '{hook_name}' not implemented")
            sys.exit(1)
    except Exception as e:
        click.echo(f"Error: {e}", err=True)
        sys.exit(1)

{%- endfor %}

if __name__ == "__main__":
    cli()

{%- elif language == 'nodejs' -%}
#!/usr/bin/env node
/**
 * {{ project.name }} - {{ project.description }}
 * Generated by Goobits CLI Framework
 */

const { Command } = require('commander');
const hooks = require('./hooks');

const program = new Command();

program
    .name('{{ cli.root_command.name }}')
    .description('{{ cli.root_command.description }}')
    .version('{{ cli.root_command.version }}');

{%- for option in cli.root_command.options %}
program.option(
    '--{{ option.name }}{% if option.short %}, -{{ option.short }}{% endif %}',
    '{{ option.description }}'{% if option.default %}, {{ option.default | tojson }}{% endif %}
);
{%- endfor %}

{%- for command in cli.root_command.subcommands %}

program
    .command('{{ command.name }}')
    .description('{{ command.description }}')
{%- for arg in command.arguments %}
    .argument('{% if not arg.required %}[{% endif %}{{ arg.name }}{% if arg.multiple %}...{% endif %}{% if not arg.required %}]{% endif %}', '{{ arg.description }}')
{%- endfor %}
{%- for option in command.options %}
    .option('--{{ option.name }}{% if option.short %}, -{{ option.short }}{% endif %}', '{{ option.description }}'{% if option.default %}, {{ option.default | tojson }}{% endif %})
{%- endfor %}
    .action(async ({% for arg in command.arguments %}{{ arg.name }}{% if command.options or not loop.last %}, {% endif %}{% endfor %}options) => {
        try {
            const hookName = '{{ command.hook_name }}';
            if (typeof hooks[hookName] === 'function') {
                await hooks[hookName]({% for arg in command.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %}{% if command.arguments %}, {% endif %}options);
            } else {
                console.error(`Hook function '${hookName}' not implemented`);
                process.exit(1);
            }
        } catch (error) {
            console.error('Error:', error.message);
            process.exit(1);
        }
    });

{%- endfor %}

program.parse();

{%- elif language == 'typescript' -%}
#!/usr/bin/env node
/**
 * {{ project.name }} - {{ project.description }}
 * Generated by Goobits CLI Framework
 */

import { Command } from 'commander';
import * as hooks from './hooks';

const program = new Command();

program
    .name('{{ cli.root_command.name }}')
    .description('{{ cli.root_command.description }}')
    .version('{{ cli.root_command.version }}');

{%- for option in cli.root_command.options %}
program.option(
    '--{{ option.name }}{% if option.short %}, -{{ option.short }}{% endif %}',
    '{{ option.description }}'{% if option.default %}, {{ option.default | tojson }}{% endif %}
);
{%- endfor %}

{%- for command in cli.root_command.subcommands %}

program
    .command('{{ command.name }}')
    .description('{{ command.description }}')
{%- for arg in command.arguments %}
    .argument('{% if not arg.required %}[{% endif %}{{ arg.name }}{% if arg.multiple %}...{% endif %}{% if not arg.required %}]{% endif %}', '{{ arg.description }}')
{%- endfor %}
{%- for option in command.options %}
    .option('--{{ option.name }}{% if option.short %}, -{{ option.short }}{% endif %}', '{{ option.description }}'{% if option.default %}, {{ option.default | tojson }}{% endif %})
{%- endfor %}
    .action(async ({% for arg in command.arguments %}{{ arg.name }}: {% if arg.multiple %}string[]{% else %}string{% endif %}{% if command.options or not loop.last %}, {% endif %}{% endfor %}options: any) => {
        try {
            const hookName = '{{ command.hook_name }}' as keyof typeof hooks;
            if (typeof hooks[hookName] === 'function') {
                await (hooks[hookName] as Function)({% for arg in command.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %}{% if command.arguments %}, {% endif %}options);
            } else {
                console.error(`Hook function '${hookName}' not implemented`);
                process.exit(1);
            }
        } catch (error) {
            console.error('Error:', (error as Error).message);
            process.exit(1);
        }
    });

{%- endfor %}

program.parse();

{%- elif language == 'rust' -%}
use clap::{Arg, Command, ArgMatches};
use std::process;

mod hooks;

fn main() {
    let app = Command::new("{{ cli.root_command.name }}")
        .version("{{ cli.root_command.version }}")
        .about("{{ cli.root_command.description }}")
        .arg_required_else_help(true)
{%- for option in cli.root_command.options %}
        .arg(
            Arg::new("{{ option.name }}")
                .long("{{ option.name }}")
                {%- if option.short %}
                .short('{{ option.short }}')
                {%- endif %}
                .help("{{ option.description }}")
                {%- if option.required %}
                .required(true)
                {%- endif %}
                {%- if option.multiple %}
                .action(clap::ArgAction::Append)
                {%- else %}
                .action(clap::ArgAction::Set)
                {%- endif %}
        )
{%- endfor %}
{%- for command in cli.root_command.subcommands %}
        .subcommand(
            Command::new("{{ command.name }}")
                .about("{{ command.description }}")
{%- for arg in command.arguments %}
                .arg(
                    Arg::new("{{ arg.name }}")
                        .help("{{ arg.description }}")
                        {%- if arg.required %}
                        .required(true)
                        {%- endif %}
                        {%- if arg.multiple %}
                        .action(clap::ArgAction::Append)
                        {%- else %}
                        .action(clap::ArgAction::Set)
                        {%- endif %}
                )
{%- endfor %}
{%- for option in command.options %}
                .arg(
                    Arg::new("{{ option.name }}")
                        .long("{{ option.name }}")
                        {%- if option.short %}
                        .short('{{ option.short }}')
                        {%- endif %}
                        .help("{{ option.description }}")
                        {%- if option.required %}
                        .required(true)
                        {%- endif %}
                        {%- if option.multiple %}
                        .action(clap::ArgAction::Append)
                        {%- else %}
                        .action(clap::ArgAction::Set)
                        {%- endif %}
                )
{%- endfor %}
        )
{%- endfor %};

    let matches = app.get_matches();

    match matches.subcommand() {
{%- for command in cli.root_command.subcommands %}
        Some(("{{ command.name }}", sub_matches)) => {
            if let Err(e) = hooks::{{ command.hook_name }}(sub_matches) {
                eprintln!("Error: {}", e);
                process::exit(1);
            }
        }
{%- endfor %}
        _ => {
            eprintln!("No subcommand provided");
            process::exit(1);
        }
    }
}

{%- endif -%}