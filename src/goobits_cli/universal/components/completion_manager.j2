{# Universal Completion Manager Template
   
   This template generates advanced shell completion systems for any language.
   Provides auto-completion for commands, options, and dynamic values.
   
   Variables expected:
   - language: Target language (python, nodejs, typescript)
   - project: Project metadata  
   - cli: CLI schema with commands
#}

{%- if language == 'python' -%}
"""
Advanced shell completion management for {{ project.name }}
Generated by Goobits CLI Framework using Universal Templates
"""

import os
import sys
from pathlib import Path
from typing import Dict, List, Optional


class CompletionManager:
    """Advanced shell completion manager"""
    
    def __init__(self, cli_name: str = "{{ (project.name or 'app') | lower | replace(' ', '-') }}"):
        self.cli_name = cli_name
        self.script_name = cli_name
    
    def generate_bash_completion(self) -> str:
        """Generate enhanced bash completion script"""
        completion_func = self.cli_name.replace("-", "_")
        
        commands = []
{%- for command in cli.root_command.subcommands %}
        commands.append("{{ command.name }}")
{%- endfor %}
        
        return f"""#!/bin/bash
# Enhanced bash completion for {self.cli_name}
# Generated by Goobits CLI Framework

_{completion_func}_completion() {{'{{'}}
    local cur prev opts commands
    COMPREPLY=()
    cur="{% raw %}${{COMP_WORDS[COMP_CWORD]}}{% endraw %}"
    prev="{% raw %}${{COMP_WORDS[COMP_CWORD-1]}}{% endraw %}"
    
    # Available commands
    commands="{' '.join(commands)}"
    
    # Global options
    global_opts="--help --version"
    
    if [[ {% raw %}${{COMP_CWORD}}{% endraw %} -eq 1 ]]; then
        # Complete top-level commands
        COMPREPLY=( $(compgen -W "$commands $global_opts" -- "$cur") )
        return 0
    fi
    
    # Command-specific completions
    local command="{% raw %}${{COMP_WORDS[1]}}{% endraw %}"
    case "$command" in
{%- for command in cli.root_command.subcommands %}
        {{ command.name }})
            local {{ command.name.replace('-', '_') }}_opts="--help"
{%- for option in command.options %}
            {{ command.name.replace('-', '_') }}_opts="\\${{ command.name.replace('-', '_') }}_opts --{{ option.name }}"
{%- if option.short %}
            {{ command.name.replace('-', '_') }}_opts="\\${{ command.name.replace('-', '_') }}_opts -{{ option.short }}"
{%- endif %}
{%- endfor %}
            COMPREPLY=( $(compgen -W "\\${{ command.name.replace('-', '_') }}_opts" -- "$cur") )
            ;;
{%- endfor %}
        *)
            COMPREPLY=( $(compgen -W "$global_opts" -- "$cur") )
            ;;
    esac
    
    return 0
}}

complete -F _{completion_func}_completion {self.script_name}
"""
    
    def generate_zsh_completion(self) -> str:
        """Generate enhanced zsh completion script"""
        completion_func = self.cli_name.replace("-", "_")
        
        commands_section = ""
{%- for command in cli.root_command.subcommands %}
        commands_section += f"                '{{ command.name }}:{{ command.description }}'\n"
{%- endfor %}
        
        return f"""#compdef {self.script_name}
# Enhanced zsh completion for {self.cli_name}
# Generated by Goobits CLI Framework

_{completion_func}() {{'{{'}}
    local context state line
    typeset -A opt_args
    
    _arguments -s -S \\
        '(--help -h){{--help,-h}}[Show help message]' \\
        '(--version -V){{--version,-V}}[Show version]' \\
        '1: :->commands' \\
        '*:: :->args' && return 0
    
    case $state in
        (commands)
            local commands
            commands=(
{commands_section}            )
            _describe 'commands' commands
            ;;
        (args)
            case $words[1] in
{%- for command in cli.root_command.subcommands %}
                ({{ command.name }})
                    _arguments -s -S \\
                        '(--help -h){{'{{--help,-h}}'}}[Show help message]'\\
{%- for option in command.options %}
                        '(--{{ option.name }}{% if option.short %} -{{ option.short }}{% endif %}){{'{{--'}}{{ option.name }}{% if option.short %},-{{ option.short }}{% endif %}{{'}}'}}}[{{ option.description }}]'\\
{%- endfor %}
                    ;;
{%- endfor %}
            esac
            ;;
    esac
}}

_{completion_func} "$@"
"""
    
    def generate_fish_completion(self) -> str:
        """Generate enhanced fish completion script"""
        
        completions = f"""# Enhanced fish completion for {self.cli_name}
# Generated by Goobits CLI Framework

# Complete main commands
{%- for command in cli.root_command.subcommands %}
complete -c {self.script_name} -n '__fish_use_subcommand' -a '{{ command.name }}' -d '{{ command.description }}'
{%- endfor %}

# Global options
complete -c {self.script_name} -s h -l help -d 'Show help message'
complete -c {self.script_name} -s V -l version -d 'Show version'

# Command-specific options
{%- for command in cli.root_command.subcommands %}
{%- for option in command.options %}
complete -c {self.script_name} -n '__fish_seen_subcommand_from {{ command.name }}' -l {{ option.name }} -d '{{ option.description }}'
{%- if option.short %}
complete -c {self.script_name} -n '__fish_seen_subcommand_from {{ command.name }}' -s {{ option.short }} -d '{{ option.description }}'
{%- endif %}
{%- endfor %}
{%- endfor %}
"""
        
        return completions
    
    def get_installation_instructions(self, shell: str) -> Dict[str, str]:
        """Get installation instructions for completion scripts"""
        instructions = {
            'bash': {
                'system_path': f'/etc/bash_completion.d/{self.cli_name}',
                'user_path': f'~/.local/share/bash-completion/completions/{self.cli_name}',
                'install_cmd': f'sudo cp {self.cli_name}-completion.bash /etc/bash_completion.d/{self.cli_name}',
                'user_install_cmd': f'mkdir -p ~/.local/share/bash-completion/completions && cp {self.cli_name}-completion.bash ~/.local/share/bash-completion/completions/{self.cli_name}',
                'reload_cmd': 'source ~/.bashrc',
            },
            'zsh': {
                'system_path': f'/usr/share/zsh/site-functions/_{self.cli_name}',
                'user_path': f'~/.local/share/zsh/site-functions/_{self.cli_name}',
                'install_cmd': f'sudo cp {self.cli_name}-completion.zsh /usr/share/zsh/site-functions/_{self.cli_name}',
                'user_install_cmd': f'mkdir -p ~/.local/share/zsh/site-functions && cp {self.cli_name}-completion.zsh ~/.local/share/zsh/site-functions/_{self.cli_name}',
                'reload_cmd': 'exec zsh',
            },
            'fish': {
                'system_path': f'/usr/share/fish/completions/{self.cli_name}.fish',
                'user_path': f'~/.config/fish/completions/{self.cli_name}.fish',
                'install_cmd': f'sudo cp {self.cli_name}-completion.fish /usr/share/fish/completions/{self.cli_name}.fish',
                'user_install_cmd': f'mkdir -p ~/.config/fish/completions && cp {self.cli_name}-completion.fish ~/.config/fish/completions/{self.cli_name}.fish',
                'reload_cmd': 'Fish will auto-detect new completions',
            }
        }
        
        return instructions.get(shell, {})
    
    def save_completion_script(self, shell: str, output_dir: Optional[Path] = None) -> Path:
        """Save completion script to file"""
        if output_dir is None:
            output_dir = Path.cwd()
        
        generators = {
            'bash': self.generate_bash_completion,
            'zsh': self.generate_zsh_completion,
            'fish': self.generate_fish_completion,
        }
        
        if shell not in generators:
            raise ValueError(f"Unsupported shell: {shell}. Supported: {list(generators.keys())}")
        
        script_content = generators[shell]()
        script_file = output_dir / f"{self.cli_name}-completion.{shell}"
        
        script_file.write_text(script_content)
        return script_file
    
    def install_completion(self, shell: str, user_install: bool = True) -> bool:
        """Install completion script for the specified shell"""
        try:
            script_content = getattr(self, f'generate_{shell}_completion')()
            instructions = self.get_installation_instructions(shell)
            
            if user_install:
                script_path = Path(instructions['user_path']).expanduser()
            else:
                script_path = Path(instructions['system_path'])
            
            # Create directory if it doesn't exist
            script_path.parent.mkdir(parents=True, exist_ok=True)
            
            # Write the completion script
            script_path.write_text(script_content)
            
            return True
            
        except Exception as e:
            print(f"Error installing completion for {shell}: {e}")
            return False


# Global instance
_completion_manager = None

def get_completion_manager() -> CompletionManager:
    """Get the global completion manager instance"""
    global _completion_manager
    if _completion_manager is None:
        _completion_manager = CompletionManager()
    return _completion_manager

# Convenience functions
def generate_completion_script(shell: str) -> str:
    """Generate completion script for the specified shell"""
    manager = get_completion_manager()
    generators = {
        'bash': manager.generate_bash_completion,
        'zsh': manager.generate_zsh_completion,
        'fish': manager.generate_fish_completion,
    }
    
    if shell not in generators:
        raise ValueError(f"Unsupported shell: {shell}. Supported: {list(generators.keys())}")
    
    return generators[shell]()

def install_completion(shell: str, user_install: bool = True) -> bool:
    """Install completion script for the specified shell"""
    return get_completion_manager().install_completion(shell, user_install)

def get_install_instructions(shell: str) -> Dict[str, str]:
    """Get installation instructions for completion scripts"""
    return get_completion_manager().get_installation_instructions(shell)

{%- elif language == 'nodejs' -%}
/**
 * Advanced shell completion management for {{ project.name }}
 * Generated by Goobits CLI Framework using Universal Templates
 */

const fs = require('fs');
const path = require('path');
const os = require('os');

class CompletionManager {
    constructor(cliName = '{{ (project.name or "app") | lower | replace(" ", "-") }}') {
        this.cliName = cliName;
        this.scriptName = cliName;
    }

    generateBashCompletion() {
        const completionFunc = this.cliName.replace(/-/g, '_');
        const commands = [
{%- for command in cli.root_command.subcommands %}
            '{{ command.name }}',
{%- endfor %}
        ];

        return `#!/bin/bash
# Enhanced bash completion for ${this.cliName}
# Generated by Goobits CLI Framework

_${completionFunc}_completion() {
    local cur prev opts commands
    COMPREPLY=()
    cur="\${COMP_WORDS[COMP_CWORD]}"
    prev="\${COMP_WORDS[COMP_CWORD-1]}"
    
    # Available commands
    commands="${commands.join(' ')}"
    
    # Global options
    global_opts="--help --version"
    
    if [[ \${COMP_CWORD} -eq 1 ]]; then
        # Complete top-level commands
        COMPREPLY=( $(compgen -W "$commands $global_opts" -- "$cur") )
        return 0
    fi
    
    # Command-specific completions
    local command="\${COMP_WORDS[1]}"
    case "$command" in
{%- for command in cli.root_command.subcommands %}
        {{ command.name }})
            local {{ command.name.replace('-', '_') }}_opts="--help"
{%- for option in command.options %}
            {{ command.name.replace('-', '_') }}_opts="\\${{ command.name.replace('-', '_') }}_opts --{{ option.name }}"
{%- endfor %}
            COMPREPLY=( $(compgen -W "\\${{ command.name.replace('-', '_') }}_opts" -- "$cur") )
            ;;
{%- endfor %}
        *)
            COMPREPLY=( $(compgen -W "$global_opts" -- "$cur") )
            ;;
    esac
    
    return 0
}

complete -F _${completionFunc}_completion ${this.scriptName}
`;
    }

    generateZshCompletion() {
        const completionFunc = this.cliName.replace(/-/g, '_');
        
        return `#compdef ${this.scriptName}
# Enhanced zsh completion for ${this.cliName}
# Generated by Goobits CLI Framework

_${completionFunc}() {
    local context state line
    typeset -A opt_args
    
    _arguments -s -S \\
        '(--help -h){--help,-h}[Show help message]' \\
        '(--version -V){--version,-V}[Show version]' \\
        '1: :->commands' \\
        '*:: :->args' && return 0
    
    case $state in
        (commands)
            local commands
            commands=(
{%- for command in cli.root_command.subcommands %}
                '{{ command.name }}:{{ command.description }}'
{%- endfor %}
            )
            _describe 'commands' commands
            ;;
        (args)
            case $words[1] in
{%- for command in cli.root_command.subcommands %}
                ({{ command.name }})
                    _arguments -s -S \\
                        '(--help -h){--help,-h}[Show help message]'\\
{%- for option in command.options %}
                        '(--{{ option.name }})--{{ option.name }}[{{ option.description }}]'\\
{%- endfor %}
                    ;;
{%- endfor %}
            esac
            ;;
    esac
}

_${completionFunc} "$@"
`;
    }

    generateFishCompletion() {
        return `# Enhanced fish completion for ${this.cliName}
# Generated by Goobits CLI Framework

# Complete main commands
{%- for command in cli.root_command.subcommands %}
complete -c ${this.scriptName} -n '__fish_use_subcommand' -a '{{ command.name }}' -d '{{ command.description }}'
{%- endfor %}

# Global options
complete -c ${this.scriptName} -s h -l help -d 'Show help message'
complete -c ${this.scriptName} -s V -l version -d 'Show version'

# Command-specific options
{%- for command in cli.root_command.subcommands %}
{%- for option in command.options %}
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from {{ command.name }}' -l {{ option.name }} -d '{{ option.description }}'
{%- endfor %}
{%- endfor %}
`;
    }

    getInstallationInstructions(shell) {
        const instructions = {
            bash: {
                systemPath: `/etc/bash_completion.d/${this.cliName}`,
                userPath: `~/.local/share/bash-completion/completions/${this.cliName}`,
                installCmd: `sudo cp ${this.cliName}-completion.bash /etc/bash_completion.d/${this.cliName}`,
                userInstallCmd: `mkdir -p ~/.local/share/bash-completion/completions && cp ${this.cliName}-completion.bash ~/.local/share/bash-completion/completions/${this.cliName}`,
                reloadCmd: 'source ~/.bashrc',
            },
            zsh: {
                systemPath: `/usr/share/zsh/site-functions/_${this.cliName}`,
                userPath: `~/.local/share/zsh/site-functions/_${this.cliName}`,
                installCmd: `sudo cp ${this.cliName}-completion.zsh /usr/share/zsh/site-functions/_${this.cliName}`,
                userInstallCmd: `mkdir -p ~/.local/share/zsh/site-functions && cp ${this.cliName}-completion.zsh ~/.local/share/zsh/site-functions/_${this.cliName}`,
                reloadCmd: 'exec zsh',
            },
            fish: {
                systemPath: `/usr/share/fish/completions/${this.cliName}.fish`,
                userPath: `~/.config/fish/completions/${this.cliName}.fish`,
                installCmd: `sudo cp ${this.cliName}-completion.fish /usr/share/fish/completions/${this.cliName}.fish`,
                userInstallCmd: `mkdir -p ~/.config/fish/completions && cp ${this.cliName}-completion.fish ~/.config/fish/completions/${this.cliName}.fish`,
                reloadCmd: 'Fish will auto-detect new completions',
            }
        };
        
        return instructions[shell] || {};
    }

    saveCompletionScript(shell, outputDir = process.cwd()) {
        const generators = {
            bash: () => this.generateBashCompletion(),
            zsh: () => this.generateZshCompletion(),
            fish: () => this.generateFishCompletion(),
        };
        
        if (!(shell in generators)) {
            throw new Error(`Unsupported shell: ${shell}. Supported: ${Object.keys(generators).join(', ')}`);
        }
        
        const scriptContent = generators[shell]();
        const scriptFile = path.join(outputDir, `${this.cliName}-completion.${shell}`);
        
        fs.writeFileSync(scriptFile, scriptContent);
        return scriptFile;
    }

    installCompletion(shell, userInstall = true) {
        try {
            const generators = {
                bash: () => this.generateBashCompletion(),
                zsh: () => this.generateZshCompletion(),
                fish: () => this.generateFishCompletion(),
            };
            
            const scriptContent = generators[shell]();
            const instructions = this.getInstallationInstructions(shell);
            
            const scriptPath = userInstall ? 
                instructions.userPath.replace('~', os.homedir()) : 
                instructions.systemPath;
            
            // Create directory if it doesn't exist
            const dir = path.dirname(scriptPath);
            fs.mkdirSync(dir, { recursive: true });
            
            // Write the completion script
            fs.writeFileSync(scriptPath, scriptContent);
            
            return true;
            
        } catch (error) {
            console.error(`Error installing completion for ${shell}: ${error.message}`);
            return false;
        }
    }
}

// Global instance
let _completionManager = null;

function getCompletionManager() {
    if (!_completionManager) {
        _completionManager = new CompletionManager();
    }
    return _completionManager;
}

// Convenience functions
function generateCompletionScript(shell) {
    const manager = getCompletionManager();
    const generators = {
        bash: () => manager.generateBashCompletion(),
        zsh: () => manager.generateZshCompletion(),
        fish: () => manager.generateFishCompletion(),
    };
    
    if (!(shell in generators)) {
        throw new Error(`Unsupported shell: ${shell}. Supported: ${Object.keys(generators).join(', ')}`);
    }
    
    return generators[shell]();
}

function installCompletion(shell, userInstall = true) {
    return getCompletionManager().installCompletion(shell, userInstall);
}

function getInstallInstructions(shell) {
    return getCompletionManager().getInstallationInstructions(shell);
}

module.exports = {
    CompletionManager,
    getCompletionManager,
    generateCompletionScript,
    installCompletion,
    getInstallInstructions
};

{%- elif language == 'typescript' -%}
/**
 * Advanced shell completion management for {{ project.name }}
 * Generated by Goobits CLI Framework using Universal Templates
 */

import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

export class CompletionManager {
    private cliName: string;
    private scriptName: string;

    constructor(cliName: string = '{{ project.name | lower | replace(" ", "-") }}') {
        this.cliName = cliName;
        this.scriptName = cliName;
    }

    public generateBashCompletion(): string {
        const completionFunc = this.cliName.replace(/-/g, '_');
        const commands = [
{%- for command in cli.root_command.subcommands %}
            '{{ command.name }}',
{%- endfor %}
        ];

        return `#!/bin/bash
# Enhanced bash completion for ${this.cliName}
# Generated by Goobits CLI Framework

_${completionFunc}_completion() {
    local cur prev opts commands
    COMPREPLY=()
    cur="\${COMP_WORDS[COMP_CWORD]}"
    prev="\${COMP_WORDS[COMP_CWORD-1]}"
    
    # Available commands
    commands="${commands.join(' ')}"
    
    # Global options
    global_opts="--help --version"
    
    if [[ \${COMP_CWORD} -eq 1 ]]; then
        # Complete top-level commands
        COMPREPLY=( $(compgen -W "$commands $global_opts" -- "$cur") )
        return 0
    fi
    
    # Command-specific completions
    local command="\${COMP_WORDS[1]}"
    case "$command" in
{%- for command in cli.root_command.subcommands %}
        {{ command.name }})
            local {{ command.name.replace('-', '_') }}_opts="--help"
{%- for option in command.options %}
            {{ command.name.replace('-', '_') }}_opts="\\${{ command.name.replace('-', '_') }}_opts --{{ option.name }}"
{%- endfor %}
            COMPREPLY=( $(compgen -W "\\${{ command.name.replace('-', '_') }}_opts" -- "$cur") )
            ;;
{%- endfor %}
        *)
            COMPREPLY=( $(compgen -W "$global_opts" -- "$cur") )
            ;;
    esac
    
    return 0
}

complete -F _${completionFunc}_completion ${this.scriptName}
`;
    }

    public generateZshCompletion(): string {
        const completionFunc = this.cliName.replace(/-/g, '_');
        
        return `#compdef ${this.scriptName}
# Enhanced zsh completion for ${this.cliName}
# Generated by Goobits CLI Framework

_${completionFunc}() {
    local context state line
    typeset -A opt_args
    
    _arguments -s -S \\
        '(--help -h){--help,-h}[Show help message]' \\
        '(--version -V){--version,-V}[Show version]' \\
        '1: :->commands' \\
        '*:: :->args' && return 0
    
    case $state in
        (commands)
            local commands
            commands=(
{%- for command in cli.root_command.subcommands %}
                '{{ command.name }}:{{ command.description }}'
{%- endfor %}
            )
            _describe 'commands' commands
            ;;
        (args)
            case $words[1] in
{%- for command in cli.root_command.subcommands %}
                ({{ command.name }})
                    _arguments -s -S \\
                        '(--help -h){--help,-h}[Show help message]'\\
{%- for option in command.options %}
                        '(--{{ option.name }})--{{ option.name }}[{{ option.description }}]'\\
{%- endfor %}
                    ;;
{%- endfor %}
            esac
            ;;
    esac
}

_${completionFunc} "$@"
`;
    }

    public generateFishCompletion(): string {
        return `# Enhanced fish completion for ${this.cliName}
# Generated by Goobits CLI Framework

# Complete main commands
{%- for command in cli.root_command.subcommands %}
complete -c ${this.scriptName} -n '__fish_use_subcommand' -a '{{ command.name }}' -d '{{ command.description }}'
{%- endfor %}

# Global options
complete -c ${this.scriptName} -s h -l help -d 'Show help message'
complete -c ${this.scriptName} -s V -l version -d 'Show version'

# Command-specific options
{%- for command in cli.root_command.subcommands %}
{%- for option in command.options %}
complete -c ${this.scriptName} -n '__fish_seen_subcommand_from {{ command.name }}' -l {{ option.name }} -d '{{ option.description }}'
{%- endfor %}
{%- endfor %}
`;
    }

    public getInstallationInstructions(shell: string): Record<string, string> {
        const instructions: Record<string, Record<string, string>> = {
            bash: {
                systemPath: `/etc/bash_completion.d/${this.cliName}`,
                userPath: `~/.local/share/bash-completion/completions/${this.cliName}`,
                installCmd: `sudo cp ${this.cliName}-completion.bash /etc/bash_completion.d/${this.cliName}`,
                userInstallCmd: `mkdir -p ~/.local/share/bash-completion/completions && cp ${this.cliName}-completion.bash ~/.local/share/bash-completion/completions/${this.cliName}`,
                reloadCmd: 'source ~/.bashrc',
            },
            zsh: {
                systemPath: `/usr/share/zsh/site-functions/_${this.cliName}`,
                userPath: `~/.local/share/zsh/site-functions/_${this.cliName}`,
                installCmd: `sudo cp ${this.cliName}-completion.zsh /usr/share/zsh/site-functions/_${this.cliName}`,
                userInstallCmd: `mkdir -p ~/.local/share/zsh/site-functions && cp ${this.cliName}-completion.zsh ~/.local/share/zsh/site-functions/_${this.cliName}`,
                reloadCmd: 'exec zsh',
            },
            fish: {
                systemPath: `/usr/share/fish/completions/${this.cliName}.fish`,
                userPath: `~/.config/fish/completions/${this.cliName}.fish`,
                installCmd: `sudo cp ${this.cliName}-completion.fish /usr/share/fish/completions/${this.cliName}.fish`,
                userInstallCmd: `mkdir -p ~/.config/fish/completions && cp ${this.cliName}-completion.fish ~/.config/fish/completions/${this.cliName}.fish`,
                reloadCmd: 'Fish will auto-detect new completions',
            }
        };
        
        return instructions[shell] || {};
    }

    public saveCompletionScript(shell: string, outputDir: string = process.cwd()): string {
        const generators: Record<string, () => string> = {
            bash: () => this.generateBashCompletion(),
            zsh: () => this.generateZshCompletion(),
            fish: () => this.generateFishCompletion(),
        };
        
        if (!(shell in generators)) {
            throw new Error(`Unsupported shell: ${shell}. Supported: ${Object.keys(generators).join(', ')}`);
        }
        
        const scriptContent = generators[shell]();
        const scriptFile = path.join(outputDir, `${this.cliName}-completion.${shell}`);
        
        fs.writeFileSync(scriptFile, scriptContent);
        return scriptFile;
    }

    public installCompletion(shell: string, userInstall: boolean = true): boolean {
        try {
            const generators: Record<string, () => string> = {
                bash: () => this.generateBashCompletion(),
                zsh: () => this.generateZshCompletion(),
                fish: () => this.generateFishCompletion(),
            };
            
            const scriptContent = generators[shell]();
            const instructions = this.getInstallationInstructions(shell);
            
            const scriptPath = userInstall ? 
                instructions.userPath.replace('~', os.homedir()) : 
                instructions.systemPath;
            
            // Create directory if it doesn't exist
            const dir = path.dirname(scriptPath);
            fs.mkdirSync(dir, { recursive: true });
            
            // Write the completion script
            fs.writeFileSync(scriptPath, scriptContent);
            
            return true;
            
        } catch (error) {
            console.error(`Error installing completion for ${shell}: ${(error as Error).message}`);
            return false;
        }
    }
}

// Global instance
let _completionManager: CompletionManager | null = null;

export function getCompletionManager(): CompletionManager {
    if (!_completionManager) {
        _completionManager = new CompletionManager();
    }
    return _completionManager;
}

// Convenience functions
export function generateCompletionScript(shell: string): string {
    const manager = getCompletionManager();
    const generators: Record<string, () => string> = {
        bash: () => manager.generateBashCompletion(),
        zsh: () => manager.generateZshCompletion(),
        fish: () => manager.generateFishCompletion(),
    };
    
    if (!(shell in generators)) {
        throw new Error(`Unsupported shell: ${shell}. Supported: ${Object.keys(generators).join(', ')}`);
    }
    
    return generators[shell]();
}

export function installCompletion(shell: string, userInstall: boolean = true): boolean {
    return getCompletionManager().installCompletion(shell, userInstall);
}

export function getInstallInstructions(shell: string): Record<string, string> {
    return getCompletionManager().getInstallationInstructions(shell);
}

{%- endif -%}