{# Universal Hook System Template
   
   This template generates the hook system integration that allows
   users to implement business logic in their preferred language
   without modifying the generated CLI code.
   
   Variables expected:
   - language: Target language
   - project: Project metadata
   - cli: CLI schema with commands
#}

{%- if language == 'python' -%}
"""
Hook system interface for {{ project.name }}

This module defines the interface between the generated CLI and user-defined hooks.
Users should implement hook functions in app_hooks.py to provide business logic.
"""

import importlib
import inspect
import sys
from typing import Any, Callable, Dict, Optional
from pathlib import Path

class HookManager:
    """Manages loading and execution of user-defined hooks."""
    
    def __init__(self, hooks_module_name: str = "app_hooks"):
        self.hooks_module_name = hooks_module_name
        self.hooks_module = None
        self.hooks_cache: Dict[str, Callable] = {}
        self.load_hooks()
    
    def load_hooks(self) -> None:
        """Load the hooks module."""
        try:
            # Try to import the hooks module
            self.hooks_module = importlib.import_module(self.hooks_module_name)
            
            # Cache all hook functions
            for name, obj in inspect.getmembers(self.hooks_module):
                if (inspect.isfunction(obj) and 
                    name.startswith('on_') and 
                    not name.startswith('_')):
                    self.hooks_cache[name] = obj
                    
        except ImportError:
            # Hooks module doesn't exist yet
            self.hooks_module = None
            self.hooks_cache = {}
    
    def reload_hooks(self) -> None:
        """Reload the hooks module (useful for development)."""
        if self.hooks_module:
            importlib.reload(self.hooks_module)
        else:
            self.load_hooks()
    
    def has_hook(self, hook_name: str) -> bool:
        """Check if a hook function exists."""
        return hook_name in self.hooks_cache
    
    def execute_hook(self, hook_name: str, *args, **kwargs) -> Any:
        """
        Execute a hook function.
        
        Args:
            hook_name: Name of the hook function
            *args: Positional arguments to pass to the hook
            **kwargs: Keyword arguments to pass to the hook
            
        Returns:
            The return value of the hook function
            
        Raises:
            HookNotFoundError: If the hook doesn't exist
            Exception: Any exception raised by the hook
        """
        if not self.has_hook(hook_name):
            raise HookNotFoundError(f"Hook '{hook_name}' not found")
        
        hook_func = self.hooks_cache[hook_name]
        
        try:
            return hook_func(*args, **kwargs)
        except Exception as e:
            # Re-raise with additional context
            raise HookExecutionError(f"Error executing hook '{hook_name}': {str(e)}") from e
    
    def get_hook_signature(self, hook_name: str) -> Optional[inspect.Signature]:
        """Get the signature of a hook function."""
        if hook_name in self.hooks_cache:
            return inspect.signature(self.hooks_cache[hook_name])
        return None
    
    def list_hooks(self) -> Dict[str, str]:
        """
        List all available hooks with their docstrings.
        
        Returns:
            Dictionary mapping hook names to their docstrings
        """
        hooks_info = {}
        for name, func in self.hooks_cache.items():
            docstring = inspect.getdoc(func) or "No description available"
            hooks_info[name] = docstring
        return hooks_info
    
    def generate_hooks_template(self) -> str:
        """Generate a template hooks file for the user."""
        template = f'''"""
Hook implementations for {{ project.name }}

This file contains the business logic for your CLI commands.
Implement the hook functions below to handle your CLI commands.

Each command in your CLI corresponds to a hook function named 'on_<command_name>'.
Command names with hyphens are converted to underscores.

Example:
- Command 'hello-world' -> Hook function 'on_hello_world'
- Command 'status' -> Hook function 'on_status'
"""

# Import any modules you need here
import sys
import os

{%- for command in cli.root_command.subcommands %}

def {{ command.hook_name }}({% for arg in command.arguments %}{{ arg.name }}{% if command.options or not loop.last %}, {% endif %}{% endfor %}{% for option in command.options %}{{ option.name.replace('-', '_') }}=None{% if not loop.last %}, {% endif %}{% endfor %}):
    """
    {{ command.description }}
    
    Args:
{%- for arg in command.arguments %}
        {{ arg.name }} ({% if arg.multiple %}list{% else %}str{% endif %}): {{ arg.description }}
{%- endfor %}
{%- for option in command.options %}
        {{ option.name.replace('-', '_') }} ({% if option.type == 'boolean' %}bool{% elif option.type == 'integer' %}int{% elif option.type == 'float' %}float{% else %}str{% endif %}): {{ option.description }}
{%- endfor %}
    """
    # TODO: Implement your business logic here
    print(f"Hook {{ command.hook_name }} called")
    {%- if command.arguments %}
    print(f"Arguments: {%- for arg in command.arguments %}{{ arg.name }}={{ '{' }}{{ arg.name }}{{ '}' }}{% if not loop.last %}, {% endif %}{% endfor %}")
    {%- endif %}
    {%- if command.options %}
    print(f"Options: {%- for opt in command.options %}{{ opt.name.replace('-', '_') }}={{ '{' }}{{ opt.name.replace('-', '_') }}{{ '}' }}{% if not loop.last %}, {% endif %}{% endfor %}")
    {%- endif %}
    
    # Return 0 for success, non-zero for error
    return 0

{%- endfor %}

# Add any utility functions or classes here
'''
        return template

class HookNotFoundError(Exception):
    """Raised when a requested hook function is not found."""
    pass

class HookExecutionError(Exception):
    """Raised when a hook function execution fails."""
    pass

# Global hook manager instance
_hook_manager = None

def get_hook_manager() -> HookManager:
    """Get the global hook manager instance."""
    global _hook_manager
    if _hook_manager is None:
        _hook_manager = HookManager()
    return _hook_manager

def execute_hook(hook_name: str, *args, **kwargs) -> Any:
    """Convenience function to execute a hook."""
    return get_hook_manager().execute_hook(hook_name, *args, **kwargs)

def has_hook(hook_name: str) -> bool:
    """Convenience function to check if a hook exists."""
    return get_hook_manager().has_hook(hook_name)

{%- elif language == 'nodejs' -%}
/**
 * Hook system interface for {{ project.name }}
 * 
 * This module defines the interface between the generated CLI and user-defined hooks.
 * Users should implement hook functions in hooks.js to provide business logic.
 */

const fs = require('fs');
const path = require('path');

class HookManager {
    constructor(hooksModulePath = './hooks.js') {
        this.hooksModulePath = hooksModulePath;
        this.hooks = {};
        this.loadHooks();
    }

    loadHooks() {
        try {
            // Clear require cache to allow reloading
            delete require.cache[require.resolve(this.hooksModulePath)];
            
            const hooksModule = require(this.hooksModulePath);
            this.hooks = {};
            
            // Cache all exported hook functions
            for (const [name, func] of Object.entries(hooksModule)) {
                if (typeof func === 'function' && name.startsWith('on')) {
                    this.hooks[name] = func;
                }
            }
        } catch (error) {
            if (error.code === 'MODULE_NOT_FOUND') {
                // Hooks module doesn't exist yet
                this.hooks = {};
            } else {
                console.warn(`Warning: Failed to load hooks: ${error.message}`);
                this.hooks = {};
            }
        }
    }

    reloadHooks() {
        this.loadHooks();
    }

    hasHook(hookName) {
        return hookName in this.hooks;
    }

    async executeHook(hookName, ...args) {
        if (!this.hasHook(hookName)) {
            throw new HookNotFoundError(`Hook '${hookName}' not found`);
        }

        const hookFunc = this.hooks[hookName];

        try {
            const result = await hookFunc(...args);
            return result;
        } catch (error) {
            throw new HookExecutionError(`Error executing hook '${hookName}': ${error.message}`);
        }
    }

    listHooks() {
        const hooksInfo = {};
        for (const [name, func] of Object.entries(this.hooks)) {
            // Try to extract function docstring/comments
            const funcString = func.toString();
            const commentMatch = funcString.match(/\/\*\*([\s\S]*?)\*\//);
            const description = commentMatch ? commentMatch[1].trim() : 'No description available';
            hooksInfo[name] = description;
        }
        return hooksInfo;
    }

    generateHooksTemplate() {
        return `/**
 * Hook implementations for {{ project.name }}
 * 
 * This file contains the business logic for your CLI commands.
 * Implement the hook functions below to handle your CLI commands.
 * 
 * Each command in your CLI corresponds to a hook function named 'on<CommandName>'.
 * Command names with hyphens are converted to camelCase.
 * 
 * Example:
 * - Command 'hello-world' -> Hook function 'onHelloWorld'
 * - Command 'status' -> Hook function 'onStatus'
 */

// Import any modules you need here
const fs = require('fs');
const path = require('path');

{%- for command in cli.root_command.subcommands %}

/**
 * {{ command.description }}
 * 
{%- for arg in command.arguments %}
 * @param {{ '{' }}{{ arg.name }}{{ '}' }} {{ arg.description }}
{%- endfor %}
 * @param {{ '{' }}Object{{ '}' }} options - Command options
{%- for option in command.options %}
 * @param {{ '{' }}{{ option.type | default('string') }}{{ '}' }} options.{{ option.name.replace('-', '_') }} - {{ option.description }}
{%- endfor %}
 * @returns {{ '{' }}Promise<void>{{ '}' }}
 */
async function {{ command.hook_name }}({% for arg in command.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %}{% if command.arguments and command.options %}, {% endif %}{% if command.options %}options{% endif %}) {
    // TODO: Implement your business logic here
    console.log('Hook {{ command.hook_name }} called');
    {%- if command.arguments %}
    console.log('Arguments:', { {{ command.arguments | map(attribute='name') | join(', ') }} });
    {%- endif %}
    {%- if command.options %}
    console.log('Options:', options);
    {%- endif %}
    
    // You can return a value or throw an error
    // Returning nothing is equivalent to success
}

{%- endfor %}

// Export all hook functions
module.exports = {
{%- for command in cli.root_command.subcommands %}
    {{ command.hook_name }},
{%- endfor %}
};

// Add any utility functions or classes here
`;
    }
}

class HookNotFoundError extends Error {
    constructor(message) {
        super(message);
        this.name = 'HookNotFoundError';
    }
}

class HookExecutionError extends Error {
    constructor(message) {
        super(message);
        this.name = 'HookExecutionError';
    }
}

// Global hook manager instance
let _hookManager = null;

function getHookManager() {
    if (!_hookManager) {
        _hookManager = new HookManager();
    }
    return _hookManager;
}

async function executeHook(hookName, ...args) {
    return getHookManager().executeHook(hookName, ...args);
}

function hasHook(hookName) {
    return getHookManager().hasHook(hookName);
}

module.exports = {
    HookManager,
    HookNotFoundError,
    HookExecutionError,
    getHookManager,
    executeHook,
    hasHook
};

{%- elif language == 'typescript' -%}
/**
 * Hook system interface for {{ project.name }}
 * 
 * This module defines the interface between the generated CLI and user-defined hooks.
 * Users should implement hook functions in hooks.ts to provide business logic.
 */

import * as fs from 'fs';
import * as path from 'path';

type HookFunction = (...args: any[]) => Promise<any> | any;

export class HookManager {
    private hooksModulePath: string;
    private hooks: Record<string, HookFunction> = {};

    constructor(hooksModulePath: string = './hooks') {
        this.hooksModulePath = hooksModulePath;
        this.loadHooks();
    }

    public async loadHooks(): Promise<void> {
        try {
            // Dynamic import to support reloading
            const hooksModule = await import(`${this.hooksModulePath}?t=${Date.now()}`);
            this.hooks = {};
            
            // Cache all exported hook functions
            for (const [name, func] of Object.entries(hooksModule)) {
                if (typeof func === 'function' && name.startsWith('on')) {
                    this.hooks[name] = func as HookFunction;
                }
            }
        } catch (error) {
            if ((error as any).code === 'MODULE_NOT_FOUND') {
                // Hooks module doesn't exist yet
                this.hooks = {};
            } else {
                console.warn(`Warning: Failed to load hooks: ${(error as Error).message}`);
                this.hooks = {};
            }
        }
    }

    public async reloadHooks(): Promise<void> {
        await this.loadHooks();
    }

    public hasHook(hookName: string): boolean {
        return hookName in this.hooks;
    }

    public async executeHook(hookName: string, ...args: any[]): Promise<any> {
        if (!this.hasHook(hookName)) {
            throw new HookNotFoundError(`Hook '${hookName}' not found`);
        }

        const hookFunc = this.hooks[hookName];

        try {
            const result = await hookFunc(...args);
            return result;
        } catch (error) {
            throw new HookExecutionError(`Error executing hook '${hookName}': ${(error as Error).message}`);
        }
    }

    public listHooks(): Record<string, string> {
        const hooksInfo: Record<string, string> = {};
        for (const [name, func] of Object.entries(this.hooks)) {
            // Try to extract function docstring/comments
            const funcString = func.toString();
            const commentMatch = funcString.match(/\/\*\*([\s\S]*?)\*\//);
            const description = commentMatch ? commentMatch[1].trim() : 'No description available';
            hooksInfo[name] = description;
        }
        return hooksInfo;
    }

    public generateHooksTemplate(): string {
        return `/**
 * Hook implementations for {{ project.name }}
 * 
 * This file contains the business logic for your CLI commands.
 * Implement the hook functions below to handle your CLI commands.
 * 
 * Each command in your CLI corresponds to a hook function named 'on<CommandName>'.
 * Command names with hyphens are converted to camelCase.
 * 
 * Example:
 * - Command 'hello-world' -> Hook function 'onHelloWorld'
 * - Command 'status' -> Hook function 'onStatus'
 */

// Import any modules you need here
import * as fs from 'fs';
import * as path from 'path';

{%- for command in cli.root_command.subcommands %}

/**
 * {{ command.description }}
 * 
{%- for arg in command.arguments %}
 * @param {{ arg.name }} {{ arg.description }}
{%- endfor %}
 * @param options Command options
{%- for option in command.options %}
 * @param options.{{ option.name.replace('-', '_') }} {{ option.description }}
{%- endfor %}
 * @returns Promise<void>
 */
export async function {{ command.hook_name }}(
{%- for arg in command.arguments %}
    {{ arg.name }}: {% if arg.multiple %}string[]{% else %}string{% endif %}{% if command.options or not loop.last %},{% endif %}
{%- endfor %}
{%- if command.options %}
    options: {
{%- for option in command.options %}
        {{ option.name.replace('-', '_') }}?: {% if option.type == 'boolean' %}boolean{% elif option.type == 'integer' %}number{% elif option.type == 'float' %}number{% else %}string{% endif %};
{%- endfor %}
    }
{%- endif %}
): Promise<void> {
    // TODO: Implement your business logic here
    console.log('Hook {{ command.hook_name }} called');
    {%- if command.arguments %}
    console.log('Arguments:', { {{ command.arguments | map(attribute='name') | join(', ') }} });
    {%- endif %}
    {%- if command.options %}
    console.log('Options:', options);
    {%- endif %}
    
    // You can return a value or throw an error
    // Returning nothing is equivalent to success
}

{%- endfor %}

// Add any utility functions or classes here
`;
    }
}

export class HookNotFoundError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'HookNotFoundError';
    }
}

export class HookExecutionError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'HookExecutionError';
    }
}

// Global hook manager instance
let _hookManager: HookManager | null = null;

export function getHookManager(): HookManager {
    if (!_hookManager) {
        _hookManager = new HookManager();
    }
    return _hookManager;
}

export async function executeHook(hookName: string, ...args: any[]): Promise<any> {
    return getHookManager().executeHook(hookName, ...args);
}

export function hasHook(hookName: string): boolean {
    return getHookManager().hasHook(hookName);
}

{%- elif language == 'rust' -%}
//! Hook system interface for {{ project.name }}
//! 
//! This module defines the interface between the generated CLI and user-defined hooks.
//! Users should implement hook functions in hooks.rs to provide business logic.

use std::collections::HashMap;
use clap::ArgMatches;

pub type HookResult = Result<(), Box<dyn std::error::Error>>;

/// Trait that all hook implementations must follow
pub trait Hook {
    fn execute(&self, args: &ArgMatches) -> HookResult;
}

/// Hook manager that handles registration and execution of hooks
pub struct HookManager {
    hooks: HashMap<String, Box<dyn Hook>>,
}

impl HookManager {
    pub fn new() -> Self {
        Self {
            hooks: HashMap::new(),
        }
    }

    pub fn register_hook<H: Hook + 'static>(&mut self, name: String, hook: H) {
        self.hooks.insert(name, Box::new(hook));
    }

    pub fn has_hook(&self, name: &str) -> bool {
        self.hooks.contains_key(name)
    }

    pub fn execute_hook(&self, name: &str, args: &ArgMatches) -> HookResult {
        match self.hooks.get(name) {
            Some(hook) => hook.execute(args),
            None => Err(format!("Hook '{}' not found", name).into()),
        }
    }

    pub fn list_hooks(&self) -> Vec<&String> {
        self.hooks.keys().collect()
    }
}

impl Default for HookManager {
    fn default() -> Self {
        Self::new()
    }
}

/// Generate a template hooks.rs file for the user
pub fn generate_hooks_template() -> String {
    format!(r#"//! Hook implementations for {{ project.name }}
//! 
//! This file contains the business logic for your CLI commands.
//! Implement the hook functions below to handle your CLI commands.
//! 
//! Each command in your CLI corresponds to a hook function.

use clap::ArgMatches;
use crate::{{HookResult, Hook}};

{%- for command in cli.root_command.subcommands %}

/// {{ command.description }}
pub struct {{ command.name.title().replace('-', '') }}Hook;

impl Hook for {{ command.name.title().replace('-', '') }}Hook {
    fn execute(&self, args: &ArgMatches) -> HookResult {
        // TODO: Implement your business logic here
        println!("Hook {{ command.hook_name }} called");
        
        {%- if command.arguments %}
        // Extract arguments
        {%- for arg in command.arguments %}
        {%- if arg.multiple %}
        if let Some({{ arg.name }}_values) = args.get_many::<String>("{{ arg.name }}") {
            let {{ arg.name }}: Vec<&str> = {{ arg.name }}_values.collect();
            println!("{{ arg.name }}: {:?}", {{ arg.name }});
        }
        {%- else %}
        if let Some({{ arg.name }}) = args.get_one::<String>("{{ arg.name }}") {
            println!("{{ arg.name }}: {}", {{ arg.name }});
        }
        {%- endif %}
        {%- endfor %}
        {%- endif %}
        
        {%- if command.options %}
        // Extract options
        {%- for option in command.options %}
        {%- if option.type == 'boolean' %}
        let {{ option.name.replace('-', '_') }} = args.get_flag("{{ option.name }}");
        println!("{{ option.name }}: {}", {{ option.name.replace('-', '_') }});
        {%- elif option.multiple %}
        if let Some({{ option.name.replace('-', '_') }}_values) = args.get_many::<String>("{{ option.name }}") {
            let {{ option.name.replace('-', '_') }}: Vec<&str> = {{ option.name.replace('-', '_') }}_values.collect();
            println!("{{ option.name }}: {:?}", {{ option.name.replace('-', '_') }});
        }
        {%- else %}
        if let Some({{ option.name.replace('-', '_') }}) = args.get_one::<String>("{{ option.name }}") {
            println!("{{ option.name }}: {}", {{ option.name.replace('-', '_') }});
        }
        {%- endif %}
        {%- endfor %}
        {%- endif %}
        
        // Return Ok(()) for success, Err(...) for error
        Ok(())
    }}
}}

{%- endfor %}

/// Initialize and register all hooks
pub fn register_hooks(manager: &mut crate::HookManager) {
{%- for command in cli.root_command.subcommands %}
    manager.register_hook("{{ command.hook_name }}".to_string(), {{ command.name.title().replace('-', '') }}Hook);
{%- endfor %}
}

// Add any utility functions or structures here
"#)
}

// Global hook manager
static mut HOOK_MANAGER: Option<HookManager> = None;
static INIT_HOOK_MANAGER: std::sync::Once = std::sync::Once::new();

pub fn get_hook_manager() -> &'static mut HookManager {
    unsafe {
        INIT_HOOK_MANAGER.call_once(|| {
            HOOK_MANAGER = Some(HookManager::new());
        });
        HOOK_MANAGER.as_mut().unwrap()
    }
}

pub fn execute_hook(name: &str, args: &ArgMatches) -> HookResult {
    get_hook_manager().execute_hook(name, args)
}

pub fn has_hook(name: &str) -> bool {
    get_hook_manager().has_hook(name)
}

{%- endif -%}