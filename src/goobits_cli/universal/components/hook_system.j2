{# Universal Hook System Template
   
   This template generates the hook system integration that allows
   users to implement business logic in their preferred language
   without modifying the generated CLI code.
   
   Variables expected:
   - language: Target language
   - project: Project metadata
   - cli: CLI schema with commands
#}

{%- if language == 'python' -%}
"""
Hook system interface for {{ project.name }}

This module defines the interface between the generated CLI and user-defined hooks.
Users should implement hook functions in app_hooks.py to provide business logic.
"""

import importlib
import inspect
import sys
from typing import Any, Callable, Dict, Optional
from pathlib import Path

class HookManager:
    """Manages loading and execution of user-defined hooks."""
    
    def __init__(self, hooks_module_name: str = "app_hooks"):
        self.hooks_module_name = hooks_module_name
        self.hooks_module = None
        self.hooks_cache: Dict[str, Callable] = {}
        self.load_hooks()
    
    def load_hooks(self) -> None:
        """Load the hooks module."""
        try:
            # Try to import the hooks module
            self.hooks_module = importlib.import_module(self.hooks_module_name)
            
            # Cache all hook functions
            for name, obj in inspect.getmembers(self.hooks_module):
                if (inspect.isfunction(obj) and 
                    name.startswith('on_') and 
                    not name.startswith('_')):
                    self.hooks_cache[name] = obj
                    
        except ImportError:
            # Hooks module doesn't exist yet
            self.hooks_module = None
            self.hooks_cache = {}
    
    def reload_hooks(self) -> None:
        """Reload the hooks module (useful for development)."""
        if self.hooks_module:
            importlib.reload(self.hooks_module)
        else:
            self.load_hooks()
    
    def has_hook(self, hook_name: str) -> bool:
        """Check if a hook function exists."""
        return hook_name in self.hooks_cache
    
    def execute_hook(self, hook_name: str, *args, **kwargs) -> Any:
        """
        Execute a hook function.
        
        Args:
            hook_name: Name of the hook function
            *args: Positional arguments to pass to the hook
            **kwargs: Keyword arguments to pass to the hook
            
        Returns:
            The return value of the hook function
            
        Raises:
            HookNotFoundError: If the hook doesn't exist
            Exception: Any exception raised by the hook
        """
        if not self.has_hook(hook_name):
            raise HookNotFoundError(f"Hook '{hook_name}' not found")
        
        hook_func = self.hooks_cache[hook_name]
        
        try:
            return hook_func(*args, **kwargs)
        except Exception as e:
            # Re-raise with additional context
            raise HookExecutionError(f"Error executing hook '{hook_name}': {str(e)}") from e
    
    def get_hook_signature(self, hook_name: str) -> Optional[inspect.Signature]:
        """Get the signature of a hook function."""
        if hook_name in self.hooks_cache:
            return inspect.signature(self.hooks_cache[hook_name])
        return None
    
    def list_hooks(self) -> Dict[str, str]:
        """
        List all available hooks with their docstrings.
        
        Returns:
            Dictionary mapping hook names to their docstrings
        """
        hooks_info = {}
        for name, func in self.hooks_cache.items():
            docstring = inspect.getdoc(func) or "No description available"
            hooks_info[name] = docstring
        return hooks_info
    
    def generate_hooks_template(self) -> str:
        """Generate a template hooks file for the user."""
        template = f'''"""
Hook implementations for {{ project.name }}

This file contains the business logic for your CLI commands.
Implement the hook functions below to handle your CLI commands.

Each command in your CLI corresponds to a hook function named 'on_<command_name>'.
Command names with hyphens are converted to underscores.

Example:
- Command 'hello-world' -> Hook function 'on_hello_world'
- Command 'status' -> Hook function 'on_status'
"""

# Import any modules you need here
import sys
import os

{%- for command in cli.root_command.subcommands %}

def {{ command.hook_name }}({% for arg in command.arguments %}{{ arg.name }}{% if command.options or not loop.last %}, {% endif %}{% endfor %}{% for option in command.options %}{{ option.name.replace('-', '_') }}=None{% if not loop.last %}, {% endif %}{% endfor %}):
    """
    {{ command.description }}
    
    Args:
{%- for arg in command.arguments %}
        {{ arg.name }} ({% if arg.multiple %}list{% else %}str{% endif %}): {{ arg.description }}
{%- endfor %}
{%- for option in command.options %}
        {{ option.name.replace('-', '_') }} ({% if option.type == 'boolean' %}bool{% elif option.type == 'integer' %}int{% elif option.type == 'float' %}float{% else %}str{% endif %}): {{ option.description }}
{%- endfor %}
    """
    # TODO: Implement your business logic here
    print(f"Hook {{ command.hook_name }} called")
    {%- if command.arguments %}
    print(f"Arguments: {%- for arg in command.arguments %}{{ arg.name }}={{ '{' }}{{ arg.name }}{{ '}' }}{% if not loop.last %}, {% endif %}{% endfor %}")
    {%- endif %}
    {%- if command.options %}
    print(f"Options: {%- for opt in command.options %}{{ opt.name.replace('-', '_') }}={{ '{' }}{{ opt.name.replace('-', '_') }}{{ '}' }}{% if not loop.last %}, {% endif %}{% endfor %}")
    {%- endif %}
    
    # Return 0 for success, non-zero for error
    return 0

{%- endfor %}

# Add any utility functions or classes here
'''
        return template

class HookNotFoundError(Exception):
    """Raised when a requested hook function is not found."""
    pass

class HookExecutionError(Exception):
    """Raised when a hook function execution fails."""
    pass

# Global hook manager instance
_hook_manager = None

def get_hook_manager() -> HookManager:
    """Get the global hook manager instance."""
    global _hook_manager
    if _hook_manager is None:
        _hook_manager = HookManager()
    return _hook_manager

def execute_hook(hook_name: str, *args, **kwargs) -> Any:
    """Convenience function to execute a hook."""
    return get_hook_manager().execute_hook(hook_name, *args, **kwargs)

def has_hook(hook_name: str) -> bool:
    """Convenience function to check if a hook exists."""
    return get_hook_manager().has_hook(hook_name)

{%- elif language == 'nodejs' -%}
/**
 * Hook system interface for {{ project.name }}
 * 
 * This module defines the interface between the generated CLI and user-defined hooks.
 * Users should implement hook functions in hooks.js to provide business logic.
 */

const fs = require('fs');
const path = require('path');

class HookManager {
    constructor(hooksModulePath = './hooks.js') {
        this.hooksModulePath = hooksModulePath;
        this.hooks = {};
        this.loadHooks();
    }

    loadHooks() {
        try {
            // Clear require cache to allow reloading
            delete require.cache[require.resolve(this.hooksModulePath)];
            
            const hooksModule = require(this.hooksModulePath);
            this.hooks = {};
            
            // Cache all exported hook functions
            for (const [name, func] of Object.entries(hooksModule)) {
                if (typeof func === 'function' && name.startsWith('on')) {
                    this.hooks[name] = func;
                }
            }
        } catch (error) {
            if (error.code === 'MODULE_NOT_FOUND') {
                // Hooks module doesn't exist yet
                this.hooks = {};
            } else {
                console.warn(`Warning: Failed to load hooks: ${error.message}`);
                this.hooks = {};
            }
        }
    }

    reloadHooks() {
        this.loadHooks();
    }

    hasHook(hookName) {
        return hookName in this.hooks;
    }

    async executeHook(hookName, ...args) {
        if (!this.hasHook(hookName)) {
            throw new HookNotFoundError(`Hook '${hookName}' not found`);
        }

        const hookFunc = this.hooks[hookName];

        try {
            const result = await hookFunc(...args);
            return result;
        } catch (error) {
            throw new HookExecutionError(`Error executing hook '${hookName}': ${error.message}`);
        }
    }

    listHooks() {
        const hooksInfo = {};
        for (const [name, func] of Object.entries(this.hooks)) {
            // Try to extract function docstring/comments
            const funcString = func.toString();
            const commentMatch = funcString.match(/\/\*\*([\s\S]*?)\*\//);
            const description = commentMatch ? commentMatch[1].trim() : 'No description available';
            hooksInfo[name] = description;
        }
        return hooksInfo;
    }

    generateHooksTemplate() {
        return `/**
 * Hook implementations for {{ project.name }}
 * 
 * This file contains the business logic for your CLI commands.
 * Implement the hook functions below to handle your CLI commands.
 * 
 * Each command in your CLI corresponds to a hook function named 'on<CommandName>'.
 * Command names with hyphens are converted to camelCase.
 * 
 * Example:
 * - Command 'hello-world' -> Hook function 'onHelloWorld'
 * - Command 'status' -> Hook function 'onStatus'
 */

// Import any modules you need here
const fs = require('fs');
const path = require('path');

{%- for command in cli.root_command.subcommands %}

/**
 * {{ command.description }}
 * 
{%- for arg in command.arguments %}
 * @param {{ '{' }}{{ arg.name }}{{ '}' }} {{ arg.description }}
{%- endfor %}
 * @param {{ '{' }}Object{{ '}' }} options - Command options
{%- for option in command.options %}
 * @param {{ '{' }}{{ option.type | default('string') }}{{ '}' }} options.{{ option.name.replace('-', '_') }} - {{ option.description }}
{%- endfor %}
 * @returns {{ '{' }}Promise<void>{{ '}' }}
 */
async function {{ command.hook_name }}({% for arg in command.arguments %}{{ arg.name }}{% if not loop.last %}, {% endif %}{% endfor %}{% if command.arguments and command.options %}, {% endif %}{% if command.options %}options{% endif %}) {
    // TODO: Implement your business logic here
    console.log('Hook {{ command.hook_name }} called');
    {%- if command.arguments %}
    console.log('Arguments:', { {{ command.arguments | map(attribute='name') | join(', ') }} });
    {%- endif %}
    {%- if command.options %}
    console.log('Options:', options);
    {%- endif %}
    
    // You can return a value or throw an error
    // Returning nothing is equivalent to success
}

{%- endfor %}

// Export all hook functions
module.exports = {
{%- for command in cli.root_command.subcommands %}
    {{ command.hook_name }},
{%- endfor %}
};

// Add any utility functions or classes here
`;
    }
}

class HookNotFoundError extends Error {
    constructor(message) {
        super(message);
        this.name = 'HookNotFoundError';
    }
}

class HookExecutionError extends Error {
    constructor(message) {
        super(message);
        this.name = 'HookExecutionError';
    }
}

// Global hook manager instance
let _hookManager = null;

function getHookManager() {
    if (!_hookManager) {
        _hookManager = new HookManager();
    }
    return _hookManager;
}

async function executeHook(hookName, ...args) {
    return getHookManager().executeHook(hookName, ...args);
}

function hasHook(hookName) {
    return getHookManager().hasHook(hookName);
}

module.exports = {
    HookManager,
    HookNotFoundError,
    HookExecutionError,
    getHookManager,
    executeHook,
    hasHook
};

{%- elif language == 'typescript' -%}
/**
 * Hook system interface for {{ project.name }}
 * 
 * This module defines the interface between the generated CLI and user-defined hooks.
 * Users should implement hook functions in hooks.ts to provide business logic.
 */

import * as fs from 'fs';
import * as path from 'path';

type HookFunction = (...args: any[]) => Promise<any> | any;

export class HookManager {
    private hooksModulePath: string;
    private hooks: Record<string, HookFunction> = {};

    constructor(hooksModulePath: string = './hooks') {
        this.hooksModulePath = hooksModulePath;
        this.loadHooks();
    }

    public async loadHooks(): Promise<void> {
        try {
            // Dynamic import to support reloading
            const hooksModule = await import(`${this.hooksModulePath}?t=${Date.now()}`);
            this.hooks = {};
            
            // Cache all exported hook functions
            for (const [name, func] of Object.entries(hooksModule)) {
                if (typeof func === 'function' && name.startsWith('on')) {
                    this.hooks[name] = func as HookFunction;
                }
            }
        } catch (error) {
            if ((error as any).code === 'MODULE_NOT_FOUND') {
                // Hooks module doesn't exist yet
                this.hooks = {};
            } else {
                console.warn(`Warning: Failed to load hooks: ${(error as Error).message}`);
                this.hooks = {};
            }
        }
    }

    public async reloadHooks(): Promise<void> {
        await this.loadHooks();
    }

    public hasHook(hookName: string): boolean {
        return hookName in this.hooks;
    }

    public async executeHook(hookName: string, ...args: any[]): Promise<any> {
        if (!this.hasHook(hookName)) {
            throw new HookNotFoundError(`Hook '${hookName}' not found`);
        }

        const hookFunc = this.hooks[hookName];

        try {
            const result = await hookFunc(...args);
            return result;
        } catch (error) {
            throw new HookExecutionError(`Error executing hook '${hookName}': ${(error as Error).message}`);
        }
    }

    public listHooks(): Record<string, string> {
        const hooksInfo: Record<string, string> = {};
        for (const [name, func] of Object.entries(this.hooks)) {
            // Try to extract function docstring/comments
            const funcString = func.toString();
            const commentMatch = funcString.match(/\/\*\*([\s\S]*?)\*\//);
            const description = commentMatch ? commentMatch[1].trim() : 'No description available';
            hooksInfo[name] = description;
        }
        return hooksInfo;
    }

    public generateHooksTemplate(): string {
        return `/**
 * Hook implementations for {{ project.name }}
 * 
 * This file contains the business logic for your CLI commands.
 * Implement the hook functions below to handle your CLI commands.
 * 
 * Each command in your CLI corresponds to a hook function named 'on<CommandName>'.
 * Command names with hyphens are converted to camelCase.
 * 
 * Example:
 * - Command 'hello-world' -> Hook function 'onHelloWorld'
 * - Command 'status' -> Hook function 'onStatus'
 */

// Import any modules you need here
import * as fs from 'fs';
import * as path from 'path';

{%- for command in cli.root_command.subcommands %}

/**
 * {{ command.description }}
 * 
{%- for arg in command.arguments %}
 * @param {{ arg.name }} {{ arg.description }}
{%- endfor %}
 * @param options Command options
{%- for option in command.options %}
 * @param options.{{ option.name.replace('-', '_') }} {{ option.description }}
{%- endfor %}
 * @returns Promise<void>
 */
export async function {{ command.hook_name }}(
{%- for arg in command.arguments %}
    {{ arg.name }}: {% if arg.multiple %}string[]{% else %}string{% endif %}{% if command.options or not loop.last %},{% endif %}
{%- endfor %}
{%- if command.options %}
    options: {
{%- for option in command.options %}
        {{ option.name.replace('-', '_') }}?: {% if option.type == 'boolean' %}boolean{% elif option.type == 'integer' %}number{% elif option.type == 'float' %}number{% else %}string{% endif %};
{%- endfor %}
    }
{%- endif %}
): Promise<void> {
    // TODO: Implement your business logic here
    console.log('Hook {{ command.hook_name }} called');
    {%- if command.arguments %}
    console.log('Arguments:', { {{ command.arguments | map(attribute='name') | join(', ') }} });
    {%- endif %}
    {%- if command.options %}
    console.log('Options:', options);
    {%- endif %}
    
    // You can return a value or throw an error
    // Returning nothing is equivalent to success
}

{%- endfor %}

// Add any utility functions or classes here
`;
    }
}

export class HookNotFoundError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'HookNotFoundError';
    }
}

export class HookExecutionError extends Error {
    constructor(message: string) {
        super(message);
        this.name = 'HookExecutionError';
    }
}

// Global hook manager instance
let _hookManager: HookManager | null = null;

export function getHookManager(): HookManager {
    if (!_hookManager) {
        _hookManager = new HookManager();
    }
    return _hookManager;
}

export async function executeHook(hookName: string, ...args: any[]): Promise<any> {
    return getHookManager().executeHook(hookName, ...args);
}

export function hasHook(hookName: string): boolean {
    return getHookManager().hasHook(hookName);
}

{%- elif language == 'rust' -%}
//! Hook implementations for {{ project.name }}
//! 
//! This file contains the business logic for your CLI commands.
//! Implement the hook functions below to handle your CLI commands.
//! 
//! Each command in your CLI corresponds to a hook function.

use clap::ArgMatches;
use anyhow::{Result, anyhow};

{# Simple approach: Handle the known structure we have #}
{%- if cli and cli.root_command and cli.root_command.subcommands -%}

{# Generate hooks for top-level commands #}
{%- for command_config in cli.root_command.subcommands -%}

/// Hook function for '{{ command_config.name }}' command
/// {{ command_config.description if command_config.description is defined else 'No description' }}
pub fn on_{{ command_config.name | replace('-', '_') }}(matches: &ArgMatches) -> Result<()> {
    // TODO: Implement your business logic here
    println!("Executing {{ command_config.name }} command...");
    {% if command_config.arguments is defined and command_config.arguments %}
    
    // Extract arguments
    {% for arg in command_config.arguments %}
    {% if arg.multiple is defined and arg.multiple %}
    if let Some({{ arg.name | replace('-', '_') }}_values) = matches.get_many::<String>("{{ arg.name }}") {
        let {{ arg.name | replace('-', '_') }}: Vec<&String> = {{ arg.name | replace('-', '_') }}_values.collect();
        println!("{{ arg.name }}: {:?}", {{ arg.name | replace('-', '_') }});
    }
    {% else %}
    if let Some({{ arg.name | replace('-', '_') }}) = matches.get_one::<String>("{{ arg.name }}") {
        println!("{{ arg.name }}: {}", {{ arg.name | replace('-', '_') }});
    }
    {% endif %}
    {% endfor %}
    {% endif %}
    {% if command_config.options is defined and command_config.options %}
    
    // Extract options
    {% for option in command_config.options %}
    {% if option.type is defined and (option.type == 'boolean' or option.type == 'flag') %}
    let {{ option.name | replace('-', '_') }} = matches.get_flag("{{ option.name }}");
    println!("{{ option.name }}: {}", {{ option.name | replace('-', '_') }});
    {% elif option.multiple is defined and option.multiple %}
    if let Some({{ option.name | replace('-', '_') }}_values) = matches.get_many::<String>("{{ option.name }}") {
        let {{ option.name | replace('-', '_') }}: Vec<&String> = {{ option.name | replace('-', '_') }}_values.collect();
        println!("{{ option.name }}: {:?}", {{ option.name | replace('-', '_') }});
    }
    {% else %}
    if let Some({{ option.name | replace('-', '_') }}) = matches.get_one::<String>("{{ option.name }}") {
        println!("{{ option.name }}: {}", {{ option.name | replace('-', '_') }});
    }
    {% endif %}
    {% endfor %}
    {% endif %}
    
    // Return Ok(()) for success, Err(...) for error
    Ok(())
}

{# Generate hooks for nested subcommands if they exist #}
{%- if command_config.subcommands is defined and command_config.subcommands -%}
  {%- if command_config.subcommands is mapping -%}
    {%- for subcommand_name, subcommand_config in command_config.subcommands.items() -%}

/// Hook function for '{{ command_config.name }} {{ subcommand_name }}' command
/// {{ subcommand_config.description if subcommand_config.description is defined else subcommand_config.desc if subcommand_config.desc is defined else 'No description' }}
pub fn on_{{ command_config.name | replace('-', '_') }}_{{ subcommand_name | replace('-', '_') }}(matches: &ArgMatches) -> Result<()> {
    // TODO: Implement your business logic here
    println!("Executing {{ command_config.name }} {{ subcommand_name }} command...");
    {% if subcommand_config.arguments is defined and subcommand_config.arguments %}
    
    // Extract arguments
    {% for arg in subcommand_config.arguments %}
    {% if arg.multiple is defined and arg.multiple %}
    if let Some({{ arg.name | replace('-', '_') }}_values) = matches.get_many::<String>("{{ arg.name }}") {
        let {{ arg.name | replace('-', '_') }}: Vec<&String> = {{ arg.name | replace('-', '_') }}_values.collect();
        println!("{{ arg.name }}: {:?}", {{ arg.name | replace('-', '_') }});
    }
    {% else %}
    if let Some({{ arg.name | replace('-', '_') }}) = matches.get_one::<String>("{{ arg.name }}") {
        println!("{{ arg.name }}: {}", {{ arg.name | replace('-', '_') }});
    }
    {% endif %}
    {% endfor %}
    {% endif %}
    {% if subcommand_config.options is defined and subcommand_config.options %}
    
    // Extract options
    {% for option in subcommand_config.options %}
    {% if option.type is defined and (option.type == 'boolean' or option.type == 'flag') %}
    let {{ option.name | replace('-', '_') }} = matches.get_flag("{{ option.name }}");
    println!("{{ option.name }}: {}", {{ option.name | replace('-', '_') }});
    {% elif option.multiple is defined and option.multiple %}
    if let Some({{ option.name | replace('-', '_') }}_values) = matches.get_many::<String>("{{ option.name }}") {
        let {{ option.name | replace('-', '_') }}: Vec<&String> = {{ option.name | replace('-', '_') }}_values.collect();
        println!("{{ option.name }}: {:?}", {{ option.name | replace('-', '_') }});
    }
    {% else %}
    if let Some({{ option.name | replace('-', '_') }}) = matches.get_one::<String>("{{ option.name }}") {
        println!("{{ option.name }}: {}", {{ option.name | replace('-', '_') }});
    }
    {% endif %}
    {% endfor %}
    {% endif %}
    
    // Return Ok(()) for success, Err(...) for error
    Ok(())
}

    {%- endfor -%}
  {%- else -%}
    {# Subcommands is a list #}
    {%- for subcommand_config in command_config.subcommands -%}

/// Hook function for '{{ command_config.name }} {{ subcommand_config.name }}' command
/// {{ subcommand_config.description if subcommand_config.description is defined else subcommand_config.desc if subcommand_config.desc is defined else 'No description' }}
pub fn on_{{ command_config.name | replace('-', '_') }}_{{ subcommand_config.name | replace('-', '_') }}(matches: &ArgMatches) -> Result<()> {
    // TODO: Implement your business logic here
    println!("Executing {{ command_config.name }} {{ subcommand_config.name }} command...");
    {% if subcommand_config.arguments is defined and subcommand_config.arguments %}
    
    // Extract arguments
    {% for arg in subcommand_config.arguments %}
    {% if arg.multiple is defined and arg.multiple %}
    if let Some({{ arg.name | replace('-', '_') }}_values) = matches.get_many::<String>("{{ arg.name }}") {
        let {{ arg.name | replace('-', '_') }}: Vec<&String> = {{ arg.name | replace('-', '_') }}_values.collect();
        println!("{{ arg.name }}: {:?}", {{ arg.name | replace('-', '_') }});
    }
    {% else %}
    if let Some({{ arg.name | replace('-', '_') }}) = matches.get_one::<String>("{{ arg.name }}") {
        println!("{{ arg.name }}: {}", {{ arg.name | replace('-', '_') }});
    }
    {% endif %}
    {% endfor %}
    {% endif %}
    {% if subcommand_config.options is defined and subcommand_config.options %}
    
    // Extract options
    {% for option in subcommand_config.options %}
    {% if option.type is defined and (option.type == 'boolean' or option.type == 'flag') %}
    let {{ option.name | replace('-', '_') }} = matches.get_flag("{{ option.name }}");
    println!("{{ option.name }}: {}", {{ option.name | replace('-', '_') }});
    {% elif option.multiple is defined and option.multiple %}
    if let Some({{ option.name | replace('-', '_') }}_values) = matches.get_many::<String>("{{ option.name }}") {
        let {{ option.name | replace('-', '_') }}: Vec<&String> = {{ option.name | replace('-', '_') }}_values.collect();
        println!("{{ option.name }}: {:?}", {{ option.name | replace('-', '_') }});
    }
    {% else %}
    if let Some({{ option.name | replace('-', '_') }}) = matches.get_one::<String>("{{ option.name }}") {
        println!("{{ option.name }}: {}", {{ option.name | replace('-', '_') }});
    }
    {% endif %}
    {% endfor %}
    {% endif %}
    
    // Return Ok(()) for success, Err(...) for error
    Ok(())
}

    {%- endfor -%}
  {%- endif -%}
{%- endif -%}
{%- endfor -%}
{%- endif %}

/// Simple hook manager for compatibility with other templates
pub struct HookManager;

impl HookManager {
    /// Create a new hook manager
    pub fn new() -> Self {
        Self
    }
    
    /// Execute a hook by name
    pub fn execute_hook(&self, name: &str, matches: &ArgMatches) -> Result<()> {
        match name {
{% if cli and cli.root_command and cli.root_command.subcommands %}

{% for command_config in cli.root_command.subcommands %}
            "on_{{ command_config.name | replace('-', '_') }}" => on_{{ command_config.name | replace('-', '_') }}(matches),
{% if command_config.subcommands is defined and command_config.subcommands %}
  {% if command_config.subcommands is mapping %}
    {% for subcommand_name, subcommand_config in command_config.subcommands.items() %}
            "on_{{ command_config.name | replace('-', '_') }}_{{ subcommand_name | replace('-', '_') }}" => on_{{ command_config.name | replace('-', '_') }}_{{ subcommand_name | replace('-', '_') }}(matches),
    {% endfor %}
  {% else %}
    {% for subcommand_config in command_config.subcommands %}
            "on_{{ command_config.name | replace('-', '_') }}_{{ subcommand_config.name | replace('-', '_') }}" => on_{{ command_config.name | replace('-', '_') }}_{{ subcommand_config.name | replace('-', '_') }}(matches),
    {% endfor %}
  {% endif %}
{% endif %}
{% endfor %}
{% endif %}
            _ => Err(anyhow::anyhow!("Unknown hook: {}", name)),
        }
    }
}

impl Default for HookManager {
    fn default() -> Self {
        Self::new()
    }
}

// Add any utility functions or structures here

{%- endif -%}