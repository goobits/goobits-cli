{#
Universal Component: Daemon helper utilities for TypeScript
This template generates TypeScript utilities for daemon process management.
#}
/**
 * Daemon helper utilities for {{ project.name }} CLI
 * Generated by Goobits CLI Framework
 */

import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';
import { spawn, ChildProcess } from 'child_process';

export interface DaemonOptions {
  name: string;
  command: string;
  args?: string[];
  cwd?: string;
  env?: Record<string, string>;
  pidFile?: string;
  logFile?: string;
  errorFile?: string;
  restartOnCrash?: boolean;
  maxRestarts?: number;
  restartDelay?: number;
}

export interface DaemonStatus {
  running: boolean;
  pid?: number;
  startTime?: Date;
  restarts?: number;
  uptime?: number;
}

export class DaemonManager {
  private options: Required<DaemonOptions>;
  private process?: ChildProcess;
  private restartCount: number = 0;
  private startTime?: Date;

  constructor(options: DaemonOptions) {
    const defaultPidDir = path.join(os.tmpdir(), 'daemons');
    const defaultLogDir = path.join(os.tmpdir(), 'logs');
    
    // Ensure directories exist
    if (!fs.existsSync(defaultPidDir)) {
      fs.mkdirSync(defaultPidDir, { recursive: true });
    }
    if (!fs.existsSync(defaultLogDir)) {
      fs.mkdirSync(defaultLogDir, { recursive: true });
    }

    this.options = {
      name: options.name,
      command: options.command,
      args: options.args || [],
      cwd: options.cwd || process.cwd(),
      env: { ...process.env, ...options.env },
      pidFile: options.pidFile || path.join(defaultPidDir, `${options.name}.pid`),
      logFile: options.logFile || path.join(defaultLogDir, `${options.name}.log`),
      errorFile: options.errorFile || path.join(defaultLogDir, `${options.name}.error.log`),
      restartOnCrash: options.restartOnCrash !== false,
      maxRestarts: options.maxRestarts || 5,
      restartDelay: options.restartDelay || 1000,
    };
  }

  public async start(): Promise<void> {
    if (await this.isRunning()) {
      throw new Error(`Daemon '${this.options.name}' is already running`);
    }

    const logStream = fs.createWriteStream(this.options.logFile, { flags: 'a' });
    const errorStream = fs.createWriteStream(this.options.errorFile, { flags: 'a' });

    this.process = spawn(this.options.command, this.options.args, {
      cwd: this.options.cwd,
      env: this.options.env,
      detached: true,
      stdio: ['ignore', logStream.fd, errorStream.fd],
    });

    this.startTime = new Date();
    this.restartCount = 0;

    // Unref so parent process can exit
    this.process.unref();

    // Write PID file
    fs.writeFileSync(this.options.pidFile, this.process.pid!.toString());

    // Setup process event handlers
    this.process.on('exit', (code, signal) => {
      this.handleProcessExit(code, signal);
    });

    this.process.on('error', (error) => {
      console.error(`Daemon '${this.options.name}' error:`, error);
    });

    // Log startup
    logStream.write(`[${new Date().toISOString()}] Daemon started with PID ${this.process.pid}\n`);
  }

  public async stop(): Promise<void> {
    const pid = await this.getPid();
    
    if (!pid) {
      throw new Error(`Daemon '${this.options.name}' is not running`);
    }

    try {
      // Send SIGTERM first
      process.kill(pid, 'SIGTERM');
      
      // Wait a bit and check if process is still running
      await this.sleep(2000);
      
      if (this.isProcessRunning(pid)) {
        // Force kill with SIGKILL
        process.kill(pid, 'SIGKILL');
        await this.sleep(1000);
      }

      // Clean up PID file
      if (fs.existsSync(this.options.pidFile)) {
        fs.unlinkSync(this.options.pidFile);
      }

    } catch (error) {
      if ((error as any).code === 'ESRCH') {
        // Process doesn't exist, clean up PID file
        if (fs.existsSync(this.options.pidFile)) {
          fs.unlinkSync(this.options.pidFile);
        }
      } else {
        throw error;
      }
    }
  }

  public async restart(): Promise<void> {
    if (await this.isRunning()) {
      await this.stop();
    }
    
    // Wait a bit before restarting
    await this.sleep(1000);
    await this.start();
  }

  public async status(): Promise<DaemonStatus> {
    const pid = await this.getPid();
    const running = pid ? this.isProcessRunning(pid) : false;

    const status: DaemonStatus = {
      running,
      pid: running ? pid : undefined,
      startTime: this.startTime,
      restarts: this.restartCount,
    };

    if (running && this.startTime) {
      status.uptime = Date.now() - this.startTime.getTime();
    }

    return status;
  }

  public async isRunning(): Promise<boolean> {
    const pid = await this.getPid();
    return pid ? this.isProcessRunning(pid) : false;
  }

  public async getPid(): Promise<number | null> {
    try {
      if (fs.existsSync(this.options.pidFile)) {
        const pidStr = fs.readFileSync(this.options.pidFile, 'utf8').trim();
        return parseInt(pidStr, 10);
      }
    } catch (error) {
      // PID file doesn't exist or is invalid
    }
    return null;
  }

  public async logs(tail: number = 100): Promise<string> {
    try {
      if (fs.existsSync(this.options.logFile)) {
        const content = fs.readFileSync(this.options.logFile, 'utf8');
        const lines = content.split('\n').filter(line => line.trim());
        return lines.slice(-tail).join('\n');
      }
    } catch (error) {
      throw new Error(`Failed to read log file: ${error}`);
    }
    return '';
  }

  public async errorLogs(tail: number = 100): Promise<string> {
    try {
      if (fs.existsSync(this.options.errorFile)) {
        const content = fs.readFileSync(this.options.errorFile, 'utf8');
        const lines = content.split('\n').filter(line => line.trim());
        return lines.slice(-tail).join('\n');
      }
    } catch (error) {
      throw new Error(`Failed to read error log file: ${error}`);
    }
    return '';
  }

  private isProcessRunning(pid: number): boolean {
    try {
      // Send signal 0 to check if process exists
      process.kill(pid, 0);
      return true;
    } catch (error) {
      return false;
    }
  }

  private handleProcessExit(code: number | null, signal: string | null): void {
    const logStream = fs.createWriteStream(this.options.logFile, { flags: 'a' });
    logStream.write(
      `[${new Date().toISOString()}] Process exited with code ${code} and signal ${signal}\n`
    );

    // Clean up PID file
    if (fs.existsSync(this.options.pidFile)) {
      fs.unlinkSync(this.options.pidFile);
    }

    // Handle restart logic
    if (this.options.restartOnCrash && code !== 0 && this.restartCount < this.options.maxRestarts) {
      this.restartCount++;
      logStream.write(
        `[${new Date().toISOString()}] Restarting daemon (attempt ${this.restartCount}/${this.options.maxRestarts})\n`
      );
      
      setTimeout(() => {
        this.start().catch((error) => {
          console.error(`Failed to restart daemon: ${error}`);
        });
      }, this.options.restartDelay);
    }

    logStream.end();
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}

// Convenience functions
export function createDaemon(options: DaemonOptions): DaemonManager {
  return new DaemonManager(options);
}

export async function startDaemon(options: DaemonOptions): Promise<DaemonManager> {
  const daemon = new DaemonManager(options);
  await daemon.start();
  return daemon;
}

export async function stopDaemon(nameOrManager: string | DaemonManager): Promise<void> {
  if (typeof nameOrManager === 'string') {
    const daemon = new DaemonManager({ name: nameOrManager, command: '' });
    await daemon.stop();
  } else {
    await nameOrManager.stop();
  }
}

export async function getDaemonStatus(nameOrManager: string | DaemonManager): Promise<DaemonStatus> {
  if (typeof nameOrManager === 'string') {
    const daemon = new DaemonManager({ name: nameOrManager, command: '' });
    return await daemon.status();
  } else {
    return await nameOrManager.status();
  }
}