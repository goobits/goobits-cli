{#
Universal Logger Component Template
===================================

This template provides a language-agnostic logging interface that generates
consistent logging functionality across all supported languages (Python, Node.js, TypeScript, Rust).

Features:
- Environment variable configuration (LOG_LEVEL, LOG_OUTPUT)
- Structured logging (JSON for production, readable for development)
- Context management appropriate for each language
- Container-friendly output routing (INFO/DEBUG to stdout, WARN/ERROR to stderr)
- Cross-language consistency in log format and behavior

Language-specific implementations are in separate templates that extend this interface.
#}

{% if language == 'python' %}
{# Python Logger Implementation - Inline to avoid include issues #}
"""
Structured logging infrastructure for {{ project.name }}.

This module provides structured logging with context management for enhanced observability.
Environment variables:
- LOG_LEVEL: Set logging level (DEBUG, INFO, WARNING, ERROR) - default: INFO
- LOG_OUTPUT: Set output destination (stdout, stderr, file:<path>) - default: stdout
- ENVIRONMENT: Set environment (production/development) - affects format
"""

import json
import logging
import os
import sys
from contextvars import ContextVar
from typing import Dict, Any, Optional
from pathlib import Path

# Context variables for structured logging
_log_context: ContextVar[Dict[str, Any]] = ContextVar('log_context', default={})

class StructuredFormatter(logging.Formatter):
    """Custom formatter that outputs structured logs based on environment."""
    
    def __init__(self):
        super().__init__()
        self.environment = os.getenv('ENVIRONMENT', 'development')
        self.is_production = self.environment.lower() in ('production', 'prod')
    
    def format(self, record: logging.LogRecord) -> str:
        """Format log record as JSON for production or readable format for development."""
        
        # Get current context
        context = _log_context.get({})
        
        # Build log data
        log_data = {
            'timestamp': self.formatTime(record),
            'level': record.levelname,
            'logger': record.name,
            'message': record.getMessage(),
            'module': record.module,
            'function': record.funcName,
            'line': record.lineno,
        }
        
        # Add context if available
        if context:
            log_data['context'] = context
        
        # Add exception info if present
        if record.exc_info:
            log_data['exception'] = {
                'type': record.exc_info[0].__name__ if record.exc_info[0] else None,
                'message': str(record.exc_info[1]) if record.exc_info[1] else None,
                'traceback': self.formatException(record.exc_info) if record.exc_info else None
            }
        
        # Add extra fields from log record
        extra_fields = {}
        for key, value in record.__dict__.items():
            if key not in ['name', 'msg', 'args', 'levelname', 'levelno', 'pathname', 
                          'filename', 'module', 'lineno', 'funcName', 'created', 
                          'msecs', 'relativeCreated', 'thread', 'threadName', 
                          'processName', 'process', 'message', 'exc_info', 'exc_text', 'stack_info']:
                extra_fields[key] = value
        
        if extra_fields:
            log_data['extra'] = extra_fields
        
        if self.is_production:
            # JSON format for production
            return json.dumps(log_data)
        else:
            # Human-readable format for development
            context_str = f" [{', '.join(f'{k}={v}' for k, v in context.items())}]" if context else ""
            extra_str = f" {extra_fields}" if extra_fields else ""
            
            base_msg = f"{log_data['timestamp']} {log_data['level']:8} {log_data['logger']:20} {log_data['message']}"
            
            if context_str or extra_str:
                base_msg += f"{context_str}{extra_str}"
            
            # Add exception info if present
            if record.exc_info:
                base_msg += f"\n{self.formatException(record.exc_info)}"
            
            return base_msg


def setup_logging() -> None:
    """
    Initialize structured logging for {{ project.name }}.
    
    Environment Variables:
    - LOG_LEVEL: Set logging level (DEBUG, INFO, WARNING, ERROR) - default: INFO
    - LOG_OUTPUT: Set output destination (stdout, stderr, file:<path>) - default: stdout  
    - ENVIRONMENT: Set environment (production/development) - affects format
    """
    
    # Get configuration from environment
    log_level = os.getenv('LOG_LEVEL', 'INFO').upper()
    log_output = os.getenv('LOG_OUTPUT', 'stdout').lower()
    
    # Configure logging level
    try:
        level = getattr(logging, log_level)
    except AttributeError:
        level = logging.INFO
        print(f"Warning: Invalid LOG_LEVEL '{log_level}', using INFO", file=sys.stderr)
    
    # Set up formatter
    formatter = StructuredFormatter()
    
    # Configure handlers based on LOG_OUTPUT
    handlers = []
    
    if log_output == 'stderr':
        # All logs to stderr
        handler = logging.StreamHandler(sys.stderr)
        handler.setFormatter(formatter)
        handlers.append(handler)
    elif log_output.startswith('file:'):
        # Log to file
        log_file = log_output[5:]  # Remove 'file:' prefix
        log_path = Path(log_file)
        
        # Ensure log directory exists
        log_path.parent.mkdir(parents=True, exist_ok=True)
        
        handler = logging.FileHandler(log_path)
        handler.setFormatter(formatter)
        handlers.append(handler)
    elif log_output == 'stdout':
        # Container-friendly: INFO/DEBUG to stdout, WARN/ERROR to stderr
        stdout_handler = logging.StreamHandler(sys.stdout)
        stdout_handler.setFormatter(formatter)
        stdout_handler.setLevel(logging.DEBUG)
        stdout_handler.addFilter(lambda record: record.levelno < logging.WARNING)
        
        stderr_handler = logging.StreamHandler(sys.stderr)
        stderr_handler.setFormatter(formatter)
        stderr_handler.setLevel(logging.WARNING)
        
        handlers.extend([stdout_handler, stderr_handler])
    else:
        # Default to stdout for unknown options
        handler = logging.StreamHandler(sys.stdout)
        handler.setFormatter(formatter)
        handlers.append(handler)
    
    # Configure root logger
    root_logger = logging.getLogger()
    
    # Clear existing handlers to avoid duplicates
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)
    
    # Add new handlers
    for handler in handlers:
        root_logger.addHandler(handler)
    
    root_logger.setLevel(level)
    
    # Log startup message
    logger = get_logger(__name__)
    logger.info(f"Logging initialized: level={log_level}, output={log_output}")


def get_logger(name: str) -> logging.Logger:
    """
    Get a logger instance for the specified name.
    
    Args:
        name: Logger name (typically __name__ from calling module)
    
    Returns:
        Configured logger instance
    """
    return logging.getLogger(name)


def set_context(**kwargs: Any) -> None:
    """
    Set logging context variables that will be included in all log messages.
    
    Args:
        **kwargs: Key-value pairs to add to logging context
    
    Example:
        set_context(operation_id="operation_123", user="admin")
    """
    current_context = _log_context.get({})
    updated_context = {**current_context, **kwargs}
    _log_context.set(updated_context)


def clear_context() -> None:
    """Clear all logging context variables."""
    _log_context.set({})


def update_context(**kwargs: Any) -> None:
    """
    Update existing context with new values.
    
    Args:
        **kwargs: Key-value pairs to update in logging context
    """
    current_context = _log_context.get({})
    current_context.update(kwargs)
    _log_context.set(current_context)


def get_context() -> Dict[str, Any]:
    """Get current logging context."""
    return _log_context.get({}).copy()


def remove_context_keys(*keys: str) -> None:
    """
    Remove specific keys from logging context.
    
    Args:
        *keys: Context keys to remove
    """
    current_context = _log_context.get({})
    for key in keys:
        current_context.pop(key, None)
    _log_context.set(current_context)
{% elif language == 'nodejs' %}
{# Node.js Logger Implementation #}
/**
 * Structured logging infrastructure for {{ project.name }}.
 * 
 * This module provides structured logging with context management using AsyncLocalStorage.
 * Environment variables:
 * - LOG_LEVEL: Set logging level (debug, info, warn, error) - default: info
 * - LOG_OUTPUT: Set output destination (stdout, stderr, file:<path>) - default: stdout
 * - ENVIRONMENT: Set environment (production/development) - affects format
 */

const { AsyncLocalStorage } = require('async_hooks');
const winston = require('winston');
const fs = require('fs');
const path = require('path');

// Context storage for async context management
const contextStorage = new AsyncLocalStorage();

// Custom formatter that outputs structured logs based on environment
const structuredFormatter = winston.format.printf(({ timestamp, level, message, ...meta }) => {
    const context = contextStorage.getStore() || {};
    const environment = process.env.ENVIRONMENT || 'development';
    const isProduction = environment.toLowerCase() === 'production' || environment.toLowerCase() === 'prod';
    
    const logData = {
        timestamp,
        level,
        message,
        ...meta
    };
    
    // Add context if available
    if (Object.keys(context).length > 0) {
        logData.context = context;
    }
    
    if (isProduction) {
        // JSON format for production
        return JSON.stringify(logData);
    } else {
        // Human-readable format for development
        const contextStr = Object.keys(context).length > 0 
            ? ` [${Object.entries(context).map(([k, v]) => `${k}=${v}`).join(', ')}]` 
            : '';
        
        const extraFields = Object.keys(meta).filter(key => 
            !['timestamp', 'level', 'message', 'context'].includes(key)
        );
        const extraStr = extraFields.length > 0 
            ? ` ${JSON.stringify(extraFields.reduce((acc, key) => ({ ...acc, [key]: meta[key] }), {}))}` 
            : '';
        
        return `${timestamp} ${level.toUpperCase().padEnd(8)} {{ project.name }}.${message}${contextStr}${extraStr}`;
    }
});

// Create logger instance
let logger = null;

/**
 * Initialize structured logging for {{ project.name }}.
 * 
 * Environment Variables:
 * - LOG_LEVEL: Set logging level (debug, info, warn, error) - default: info
 * - LOG_OUTPUT: Set output destination (stdout, stderr, file:<path>) - default: stdout
 * - ENVIRONMENT: Set environment (production/development) - affects format
 */
function setupLogging() {
    const logLevel = process.env.LOG_LEVEL || 'info';
    const logOutput = process.env.LOG_OUTPUT || 'stdout';
    
    const transports = [];
    
    if (logOutput === 'stderr') {
        // All logs to stderr
        transports.push(new winston.transports.Console({ 
            stderrLevels: ['error', 'warn', 'info', 'debug'],
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    } else if (logOutput.startsWith('file:')) {
        // Log to file
        const logFile = logOutput.substring(5); // Remove 'file:' prefix
        const logDir = path.dirname(logFile);
        
        // Ensure log directory exists
        if (!fs.existsSync(logDir)) {
            fs.mkdirSync(logDir, { recursive: true });
        }
        
        transports.push(new winston.transports.File({
            filename: logFile,
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    } else if (logOutput === 'stdout') {
        // Container-friendly: info/debug to stdout, warn/error to stderr
        transports.push(new winston.transports.Console({
            level: 'info',
            stderrLevels: ['error', 'warn'],
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    } else {
        // Default to stdout for unknown options
        transports.push(new winston.transports.Console({
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    }
    
    logger = winston.createLogger({
        level: logLevel,
        transports,
        exitOnError: false
    });
    
    // Log startup message
    logger.info(`Logging initialized: level=${logLevel}, output=${logOutput}`);
}

/**
 * Get a logger instance.
 * 
 * @param {string} name - Logger name (module name)
 * @returns {Object} Winston logger instance with context support
 */
function getLogger(name = 'main') {
    if (!logger) {
        setupLogging();
    }
    
    // Return logger with context-aware methods
    return {
        debug: (message, meta = {}) => logger.debug(message, { module: name, ...meta }),
        info: (message, meta = {}) => logger.info(message, { module: name, ...meta }),
        warn: (message, meta = {}) => logger.warn(message, { module: name, ...meta }),
        error: (message, meta = {}) => logger.error(message, { module: name, ...meta }),
        
        // Context management methods
        setContext: setContext,
        clearContext: clearContext,
        updateContext: updateContext,
        getContext: getContext,
        removeContextKeys: removeContextKeys
    };
}

/**
 * Set logging context variables that will be included in all log messages within the current async context.
 * 
 * @param {Object} contextData - Key-value pairs to add to logging context
 * @param {Function} callback - Function to execute with the context
 * 
 * @example
 * setContext({ operationId: 'op_123', user: 'admin' }, () => {
 *     logger.info('Operation started'); // Will include context automatically
 * });
 */
function setContext(contextData, callback) {
    if (typeof contextData === 'function' && !callback) {
        // If only one function is provided, treat it as callback with empty context
        callback = contextData;
        contextData = {};
    }
    
    const currentContext = contextStorage.getStore() || {};
    const newContext = { ...currentContext, ...contextData };
    
    if (callback) {
        return contextStorage.run(newContext, callback);
    } else {
        // For synchronous context setting (less recommended)
        return contextStorage.run(newContext, () => {});
    }
}

/**
 * Clear all logging context variables.
 */
function clearContext() {
    return contextStorage.run({}, () => {});
}

/**
 * Update existing context with new values.
 * 
 * @param {Object} contextData - Key-value pairs to update in logging context
 */
function updateContext(contextData) {
    const currentContext = contextStorage.getStore() || {};
    const updatedContext = { ...currentContext, ...contextData };
    return contextStorage.run(updatedContext, () => {});
}

/**
 * Get current logging context.
 * 
 * @returns {Object} Current context object
 */
function getContext() {
    return { ...(contextStorage.getStore() || {}) };
}

/**
 * Remove specific keys from logging context.
 * 
 * @param {...string} keys - Context keys to remove
 */
function removeContextKeys(...keys) {
    const currentContext = contextStorage.getStore() || {};
    const updatedContext = { ...currentContext };
    
    keys.forEach(key => {
        delete updatedContext[key];
    });
    
    return contextStorage.run(updatedContext, () => {});
}

// Export the logging interface
module.exports = {
    setupLogging,
    getLogger,
    setContext,
    clearContext,
    updateContext,
    getContext,
    removeContextKeys
};
{% elif language == 'typescript' %}
{# TypeScript Logger Implementation #}
/**
 * Structured logging infrastructure for {{ project.name }}.
 * 
 * This module provides structured logging with context management and full TypeScript support.
 * Environment variables:
 * - LOG_LEVEL: Set logging level (debug, info, warn, error) - default: info
 * - LOG_OUTPUT: Set output destination (stdout, stderr, file:<path>) - default: stdout
 * - ENVIRONMENT: Set environment (production/development) - affects format
 */

import { AsyncLocalStorage } from 'async_hooks';
import winston from 'winston';
import * as fs from 'fs';
import * as path from 'path';

// Type definitions
export interface LogContext {
    [key: string]: any;
}

export interface LogMeta {
    [key: string]: any;
}

export interface LoggerInstance {
    debug: (message: string, meta?: LogMeta) => void;
    info: (message: string, meta?: LogMeta) => void;
    warn: (message: string, meta?: LogMeta) => void;
    error: (message: string, meta?: LogMeta) => void;
    setContext: (contextData: LogContext, callback: () => void | Promise<void>) => void | Promise<void>;
    clearContext: () => void;
    updateContext: (contextData: LogContext) => void;
    getContext: () => LogContext;
    removeContextKeys: (...keys: string[]) => void;
}

export type LogLevel = 'debug' | 'info' | 'warn' | 'error';
export type LogOutput = 'stdout' | 'stderr' | string; // string for file:<path>
export type Environment = 'development' | 'production' | string;

// Context storage for async context management
const contextStorage = new AsyncLocalStorage<LogContext>();

// Custom formatter that outputs structured logs based on environment
const structuredFormatter = winston.format.printf(({ timestamp, level, message, ...meta }) => {
    const context = contextStorage.getStore() || {};
    const environment: Environment = process.env.ENVIRONMENT || 'development';
    const isProduction = environment.toLowerCase() === 'production' || environment.toLowerCase() === 'prod';
    
    const logData = {
        timestamp,
        level,
        message,
        ...meta
    };
    
    // Add context if available
    if (Object.keys(context).length > 0) {
        logData.context = context;
    }
    
    if (isProduction) {
        // JSON format for production
        return JSON.stringify(logData);
    } else {
        // Human-readable format for development
        const contextStr = Object.keys(context).length > 0 
            ? ` [${Object.entries(context).map(([k, v]) => `${k}=${v}`).join(', ')}]` 
            : '';
        
        const extraFields = Object.keys(meta).filter(key => 
            !['timestamp', 'level', 'message', 'context'].includes(key)
        );
        const extraStr = extraFields.length > 0 
            ? ` ${JSON.stringify(extraFields.reduce((acc, key) => ({ ...acc, [key]: meta[key] }), {}))}` 
            : '';
        
        return `${timestamp} ${(level as string).toUpperCase().padEnd(8)} {{ project.name }}.${message}${contextStr}${extraStr}`;
    }
});

// Create logger instance
let logger: winston.Logger | null = null;

/**
 * Initialize structured logging for {{ project.name }}.
 * 
 * Environment Variables:
 * - LOG_LEVEL: Set logging level (debug, info, warn, error) - default: info
 * - LOG_OUTPUT: Set output destination (stdout, stderr, file:<path>) - default: stdout
 * - ENVIRONMENT: Set environment (production/development) - affects format
 */
export function setupLogging(): void {
    const logLevel: LogLevel = (process.env.LOG_LEVEL as LogLevel) || 'info';
    const logOutput: LogOutput = process.env.LOG_OUTPUT || 'stdout';
    
    const transports: winston.transport[] = [];
    
    if (logOutput === 'stderr') {
        // All logs to stderr
        transports.push(new winston.transports.Console({ 
            stderrLevels: ['error', 'warn', 'info', 'debug'],
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    } else if (logOutput.startsWith('file:')) {
        // Log to file
        const logFile = logOutput.substring(5); // Remove 'file:' prefix
        const logDir = path.dirname(logFile);
        
        // Ensure log directory exists
        if (!fs.existsSync(logDir)) {
            fs.mkdirSync(logDir, { recursive: true });
        }
        
        transports.push(new winston.transports.File({
            filename: logFile,
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    } else if (logOutput === 'stdout') {
        // Container-friendly: info/debug to stdout, warn/error to stderr
        transports.push(new winston.transports.Console({
            level: 'info',
            stderrLevels: ['error', 'warn'],
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    } else {
        // Default to stdout for unknown options
        transports.push(new winston.transports.Console({
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    }
    
    logger = winston.createLogger({
        level: logLevel,
        transports,
        exitOnError: false
    });
    
    // Log startup message
    logger.info(`Logging initialized: level=${logLevel}, output=${logOutput}`);
}

/**
 * Get a logger instance with full TypeScript support.
 * 
 * @param name - Logger name (module name)
 * @returns Winston logger instance with context support
 */
export function getLogger(name: string = 'main'): LoggerInstance {
    if (!logger) {
        setupLogging();
    }
    
    // Return logger with context-aware methods and full typing
    return {
        debug: (message: string, meta: LogMeta = {}): void => 
            logger!.debug(message, { module: name, ...meta }),
        info: (message: string, meta: LogMeta = {}): void => 
            logger!.info(message, { module: name, ...meta }),
        warn: (message: string, meta: LogMeta = {}): void => 
            logger!.warn(message, { module: name, ...meta }),
        error: (message: string, meta: LogMeta = {}): void => 
            logger!.error(message, { module: name, ...meta }),
        
        // Context management methods
        setContext,
        clearContext,
        updateContext,
        getContext,
        removeContextKeys
    };
}

/**
 * Set logging context variables that will be included in all log messages within the current async context.
 * 
 * @param contextData - Key-value pairs to add to logging context
 * @param callback - Function to execute with the context
 * 
 * @example
 * ```typescript
 * setContext({ operationId: 'op_123', user: 'admin' }, () => {
 *     logger.info('Operation started'); // Will include context automatically
 * });
 * 
 * // Async version
 * await setContext({ operationId: 'op_123' }, async () => {
 *     await someAsyncOperation();
 *     logger.info('Operation completed'); // Context included
 * });
 * ```
 */
export function setContext(
    contextData: LogContext, 
    callback: () => void | Promise<void>
): void | Promise<void> {
    const currentContext = contextStorage.getStore() || {};
    const newContext = { ...currentContext, ...contextData };
    
    return contextStorage.run(newContext, callback);
}

/**
 * Set context with only callback (overload for empty context).
 */
export function setContext(callback: () => void | Promise<void>): void | Promise<void>;
export function setContext(
    contextDataOrCallback: LogContext | (() => void | Promise<void>), 
    callback?: () => void | Promise<void>
): void | Promise<void> {
    if (typeof contextDataOrCallback === 'function' && !callback) {
        // If only one function is provided, treat it as callback with empty context
        return contextStorage.run({}, contextDataOrCallback);
    }
    
    const contextData = contextDataOrCallback as LogContext;
    const cb = callback!;
    const currentContext = contextStorage.getStore() || {};
    const newContext = { ...currentContext, ...contextData };
    
    return contextStorage.run(newContext, cb);
}

/**
 * Clear all logging context variables.
 */
export function clearContext(): void {
    contextStorage.run({}, () => {});
}

/**
 * Update existing context with new values.
 * 
 * @param contextData - Key-value pairs to update in logging context
 */
export function updateContext(contextData: LogContext): void {
    const currentContext = contextStorage.getStore() || {};
    const updatedContext = { ...currentContext, ...contextData };
    contextStorage.run(updatedContext, () => {});
}

/**
 * Get current logging context.
 * 
 * @returns Current context object
 */
export function getContext(): LogContext {
    return { ...(contextStorage.getStore() || {}) };
}

/**
 * Remove specific keys from logging context.
 * 
 * @param keys - Context keys to remove
 */
export function removeContextKeys(...keys: string[]): void {
    const currentContext = contextStorage.getStore() || {};
    const updatedContext = { ...currentContext };
    
    keys.forEach(key => {
        delete updatedContext[key];
    });
    
    contextStorage.run(updatedContext, () => {});
}

// Default export for convenience
export default {
    setupLogging,
    getLogger,
    setContext,
    clearContext,
    updateContext,
    getContext,
    removeContextKeys
};
{% elif language == 'rust' %}
{# Rust Logger Implementation #}
//! Structured logging infrastructure for {{ project.name }}.
//! 
//! This module provides structured logging with context management and error handling.
//! Environment variables:
//! - LOG_LEVEL: Set logging level (debug, info, warn, error) - default: info
//! - LOG_OUTPUT: Set output destination (stdout, stderr, file:<path>) - default: stdout
//! - ENVIRONMENT: Set environment (production/development) - affects format

use std::collections::HashMap;
use std::env;
use std::fs::OpenOptions;
use std::io::{self, Write};
use std::path::Path;
use std::sync::Mutex;
use std::thread_local;

use serde_json::{json, Value};
use chrono::{DateTime, Utc};

/// Log levels supported by the logger
#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord)]
pub enum LogLevel {
    Debug = 0,
    Info = 1,
    Warn = 2,
    Error = 3,
}

impl std::fmt::Display for LogLevel {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            LogLevel::Debug => write!(f, "DEBUG"),
            LogLevel::Info => write!(f, "INFO"),
            LogLevel::Warn => write!(f, "WARN"),
            LogLevel::Error => write!(f, "ERROR"),
        }
    }
}

impl std::str::FromStr for LogLevel {
    type Err = String;
    
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s.to_lowercase().as_str() {
            "debug" => Ok(LogLevel::Debug),
            "info" => Ok(LogLevel::Info),
            "warn" => Ok(LogLevel::Warn),
            "error" => Ok(LogLevel::Error),
            _ => Err(format!("Invalid log level: {}", s)),
        }
    }
}

/// Log context type for structured logging
pub type LogContext = HashMap<String, Value>;

/// Thread-local storage for context
thread_local! {
    static LOG_CONTEXT: std::cell::RefCell<LogContext> = std::cell::RefCell::new(HashMap::new());
}

/// Logger configuration
pub struct LoggerConfig {
    pub level: LogLevel,
    pub output: LogOutput,
    pub environment: String,
}

/// Log output destinations
#[derive(Debug, Clone)]
pub enum LogOutput {
    Stdout,
    Stderr,
    File(String),
}

impl std::str::FromStr for LogOutput {
    type Err = String;
    
    fn from_str(s: &str) -> Result<Self, Self::Err> {
        match s {
            "stdout" => Ok(LogOutput::Stdout),
            "stderr" => Ok(LogOutput::Stderr),
            path if path.starts_with("file:") => {
                Ok(LogOutput::File(path[5..].to_string()))
            }
            _ => Err(format!("Invalid log output: {}", s)),
        }
    }
}

/// Global logger instance
static LOGGER: std::sync::OnceLock<Mutex<Logger>> = std::sync::OnceLock::new();

/// Main logger struct
pub struct Logger {
    config: LoggerConfig,
    file_handle: Option<std::fs::File>,
}

impl Logger {
    /// Create a new logger with the given configuration
    pub fn new(config: LoggerConfig) -> io::Result<Self> {
        let file_handle = match &config.output {
            LogOutput::File(path) => {
                // Ensure parent directory exists
                if let Some(parent) = Path::new(path).parent() {
                    std::fs::create_dir_all(parent)?;
                }
                Some(OpenOptions::new()
                    .create(true)
                    .append(true)
                    .open(path)?)
            }
            _ => None,
        };
        
        Ok(Logger {
            config,
            file_handle,
        })
    }
    
    /// Log a message with the given level
    pub fn log(&mut self, level: LogLevel, module: &str, message: &str, extra: Option<&LogContext>) -> io::Result<()> {
        // Check if we should log this level
        if level < self.config.level {
            return Ok(());
        }
        
        let timestamp = Utc::now();
        let context = get_context();
        let is_production = self.config.environment.to_lowercase() == "production" 
            || self.config.environment.to_lowercase() == "prod";
        
        let log_entry = if is_production {
            // JSON format for production
            let mut log_data = json!({
                "timestamp": timestamp.to_rfc3339(),
                "level": level.to_string(),
                "module": module,
                "message": message,
            });
            
            // Add context if available
            if !context.is_empty() {
                log_data["context"] = json!(context);
            }
            
            // Add extra fields if provided
            if let Some(extra_fields) = extra {
                for (key, value) in extra_fields {
                    log_data[key] = value.clone();
                }
            }
            
            serde_json::to_string(&log_data).unwrap_or_else(|_| "Failed to serialize log data".to_string())
        } else {
            // Human-readable format for development
            let context_str = if !context.is_empty() {
                let ctx_parts: Vec<String> = context.iter()
                    .map(|(k, v)| format!("{}={}", k, v))
                    .collect();
                format!(" [{}]", ctx_parts.join(", "))
            } else {
                String::new()
            };
            
            let extra_str = if let Some(extra_fields) = extra {
                if !extra_fields.is_empty() {
                    format!(" {}", serde_json::to_string(extra_fields).unwrap_or_default())
                } else {
                    String::new()
                }
            } else {
                String::new()
            };
            
            format!("{} {:8} {{ project.name }}.{}.{}{}{}\n",
                timestamp.format("%Y-%m-%d %H:%M:%S%.3f"),
                level.to_string(),
                module,
                message,
                context_str,
                extra_str
            )
        };
        
        // Write to appropriate output
        match &self.config.output {
            LogOutput::Stdout => {
                if level >= LogLevel::Warn {
                    // Warnings and errors to stderr for container compatibility
                    io::stderr().write_all(log_entry.as_bytes())?;
                    io::stderr().write_all(b"\n")?;
                } else {
                    // Info and debug to stdout
                    io::stdout().write_all(log_entry.as_bytes())?;
                    io::stdout().write_all(b"\n")?;
                }
            }
            LogOutput::Stderr => {
                io::stderr().write_all(log_entry.as_bytes())?;
                io::stderr().write_all(b"\n")?;
            }
            LogOutput::File(_) => {
                if let Some(ref mut file) = self.file_handle {
                    file.write_all(log_entry.as_bytes())?;
                    file.write_all(b"\n")?;
                    file.flush()?;
                }
            }
        }
        
        Ok(())
    }
}

/// Initialize structured logging for {{ project.name }}.
/// 
/// Environment Variables:
/// - LOG_LEVEL: Set logging level (debug, info, warn, error) - default: info
/// - LOG_OUTPUT: Set output destination (stdout, stderr, file:<path>) - default: stdout
/// - ENVIRONMENT: Set environment (production/development) - affects format
pub fn setup_logging() -> io::Result<()> {
    let log_level = env::var("LOG_LEVEL")
        .unwrap_or_else(|_| "info".to_string())
        .parse()
        .unwrap_or_else(|err| {
            eprintln!("Warning: Invalid LOG_LEVEL, using info: {}", err);
            LogLevel::Info
        });
    
    let log_output = env::var("LOG_OUTPUT")
        .unwrap_or_else(|_| "stdout".to_string())
        .parse()
        .unwrap_or_else(|err| {
            eprintln!("Warning: Invalid LOG_OUTPUT, using stdout: {}", err);
            LogOutput::Stdout
        });
    
    let environment = env::var("ENVIRONMENT").unwrap_or_else(|_| "development".to_string());
    
    // Create startup message before moving log_output
    let startup_context = json!({
        "level": log_level.to_string(),
        "output": format!("{:?}", log_output),
        "environment": environment
    });
    let startup_map: HashMap<String, Value> = startup_context.as_object().unwrap().clone().into_iter().collect();
    
    let config = LoggerConfig {
        level: log_level,
        output: log_output,
        environment: environment.clone(),
    };
    
    let logger = Logger::new(config)?;
    LOGGER.set(Mutex::new(logger)).map_err(|_| {
        io::Error::new(io::ErrorKind::AlreadyExists, "Logger already initialized")
    })?;
    
    // Log startup message
    info("logger", "Logging initialized", Some(&startup_map));
    
    Ok(())
}

/// Get a logger function for the specified module
pub fn get_logger(module_name: &str) -> impl Fn(LogLevel, &str, Option<&LogContext>) + '_ {
    move |level: LogLevel, message: &str, extra: Option<&LogContext>| {
        if let Some(logger_mutex) = LOGGER.get() {
            if let Ok(mut logger) = logger_mutex.lock() {
                if let Err(e) = logger.log(level, module_name, message, extra) {
                    eprintln!("Failed to write log: {}", e);
                }
            }
        }
    }
}

/// Log a debug message
pub fn debug(module: &str, message: &str, extra: Option<&LogContext>) {
    if let Some(logger_mutex) = LOGGER.get() {
        if let Ok(mut logger) = logger_mutex.lock() {
            let _ = logger.log(LogLevel::Debug, module, message, extra);
        }
    }
}

/// Log an info message
pub fn info(module: &str, message: &str, extra: Option<&LogContext>) {
    if let Some(logger_mutex) = LOGGER.get() {
        if let Ok(mut logger) = logger_mutex.lock() {
            let _ = logger.log(LogLevel::Info, module, message, extra);
        }
    }
}

/// Log a warning message
pub fn warn(module: &str, message: &str, extra: Option<&LogContext>) {
    if let Some(logger_mutex) = LOGGER.get() {
        if let Ok(mut logger) = logger_mutex.lock() {
            let _ = logger.log(LogLevel::Warn, module, message, extra);
        }
    }
}

/// Log an error message
pub fn error(module: &str, message: &str, extra: Option<&LogContext>) {
    if let Some(logger_mutex) = LOGGER.get() {
        if let Ok(mut logger) = logger_mutex.lock() {
            let _ = logger.log(LogLevel::Error, module, message, extra);
        }
    }
}

/// Set logging context variables that will be included in all log messages within the current thread.
/// 
/// # Arguments
/// * `context_data` - Key-value pairs to add to logging context
/// 
/// # Examples
/// ```rust
/// use std::collections::HashMap;
/// use serde_json::json;
/// 
/// let mut context = HashMap::new();
/// context.insert("operation_id".to_string(), json!("op_123"));
/// context.insert("user".to_string(), json!("admin"));
/// set_context(context);
/// 
/// info("main", "Operation started", None); // Will include context automatically
/// ```
pub fn set_context(context_data: LogContext) {
    LOG_CONTEXT.with(|ctx| {
        let mut current_context = ctx.borrow_mut();
        current_context.clear();
        for (key, value) in context_data {
            current_context.insert(key, value);
        }
    });
}

/// Clear all logging context variables
pub fn clear_context() {
    LOG_CONTEXT.with(|ctx| {
        ctx.borrow_mut().clear();
    });
}

/// Update existing context with new values
/// 
/// # Arguments
/// * `context_data` - Key-value pairs to update in logging context
pub fn update_context(context_data: LogContext) {
    LOG_CONTEXT.with(|ctx| {
        let mut current_context = ctx.borrow_mut();
        for (key, value) in context_data {
            current_context.insert(key, value);
        }
    });
}

/// Get current logging context
pub fn get_context() -> LogContext {
    LOG_CONTEXT.with(|ctx| ctx.borrow().clone())
}

/// Remove specific keys from logging context
/// 
/// # Arguments
/// * `keys` - Context keys to remove
pub fn remove_context_keys(keys: &[&str]) {
    LOG_CONTEXT.with(|ctx| {
        let mut current_context = ctx.borrow_mut();
        for key in keys {
            current_context.remove(*key);
        }
    });
}

/// Create a command context for logging
pub fn create_command_context(command: &str, args: &[&str]) -> LogContext {
    let mut context = HashMap::new();
    context.insert("command".to_string(), json!(command));
    if !args.is_empty() {
        context.insert("args".to_string(), json!(args));
    }
    context
}

/// Log an error with context
pub fn log_error(context: &str, err: &anyhow::Error) {
    error(context, &format!("{:#}", err), None);
}

/// Convenience macro for logging with automatic module detection
#[macro_export]
macro_rules! log {
    (debug, $msg:expr) => {
        debug(module_path!(), $msg, None)
    };
    (debug, $msg:expr, $extra:expr) => {
        debug(module_path!(), $msg, Some($extra))
    };
    (info, $msg:expr) => {
        info(module_path!(), $msg, None)
    };
    (info, $msg:expr, $extra:expr) => {
        info(module_path!(), $msg, Some($extra))
    };
    (warn, $msg:expr) => {
        warn(module_path!(), $msg, None)
    };
    (warn, $msg:expr, $extra:expr) => {
        warn(module_path!(), $msg, Some($extra))
    };
    (error, $msg:expr) => {
        error(module_path!(), $msg, None)
    };
    (error, $msg:expr, $extra:expr) => {
        error(module_path!(), $msg, Some($extra))
    };
}
{% else %}
{# Fallback for unknown languages #}
// Logger not implemented for language: {{ language }}
// Supported languages: python, nodejs, typescript, rust
//
// To add support for {{ language }}:
// 1. Create {{ language }}_logger.j2 template
// 2. Add {{ language }} support to this template
// 3. Update the language renderer to handle logger components
{% endif %}