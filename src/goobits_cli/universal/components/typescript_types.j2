/**
 * Type definitions for {{ project.name }}
 * Generated by Goobits CLI Framework v{{ generator_version }}
 */

// ============================================================================
// COMMAND TYPES
// ============================================================================

{%- if commander_commands and commander_commands.subcommands %}
  {%- for cmd_data in commander_commands.subcommands %}

export interface {{ cmd_data.name | capitalize }}Options {
    {%- for option in cmd_data.options | default([]) %}
    {{ option.name }}?: {{ 'boolean' if option.type == 'boolean' else 'string' if option.type == 'string' else 'number' if option.type == 'number' else 'any' }};
    {%- endfor %}
}

export interface {{ cmd_data.name | capitalize }}Arguments {
    {%- for arg in cmd_data.arguments | default([]) %}
    {{ arg.name }}: {{ 'string' if arg.type == 'string' else 'number' if arg.type == 'number' else 'any' }};
    {%- endfor %}
}

    {%- if cmd_data.subcommands %}
      {%- for sub_data in cmd_data.subcommands %}

export interface {{ cmd_data.name | capitalize }}{{ sub_data.name | capitalize }}Options {
    {%- for option in sub_data.options | default([]) %}
    {{ option.name }}?: {{ 'boolean' if option.type == 'boolean' else 'string' if option.type == 'string' else 'number' if option.type == 'number' else 'any' }};
    {%- endfor %}
}

export interface {{ cmd_data.name | capitalize }}{{ sub_data.name | capitalize }}Arguments {
    {%- for arg in sub_data.arguments | default([]) %}
    {{ arg.name }}: {{ 'string' if arg.type == 'string' else 'number' if arg.type == 'number' else 'any' }};
    {%- endfor %}
}
      {%- endfor %}
    {%- endif %}
  {%- endfor %}
{%- else %}
  {%- for command in cli.root_command.subcommands %}

export interface {{ command.name | capitalize }}Options {
    {%- for option in command.options | default([]) %}
    {{ option.name }}?: {{ 'boolean' if option.type == 'boolean' else 'string' if option.type == 'string' else 'number' if option.type == 'number' else 'any' }};
    {%- endfor %}
}

export interface {{ command.name | capitalize }}Arguments {
    {%- for arg in command.arguments | default([]) %}
    {{ arg.name }}: {{ 'string' if arg.type == 'string' else 'number' if arg.type == 'number' else 'any' }};
    {%- endfor %}
}
  {%- endfor %}
{%- endif %}

// ============================================================================
// CONFIGURATION TYPES
// ============================================================================

export interface Config {
    [key: string]: any;
    debug?: boolean;
    verbose?: boolean;
    outputFormat?: 'text' | 'json' | 'yaml';
    {%- if cli.default_config %}
      {%- for key, value in cli.default_config.items() %}
    {{ key }}?: {{ 'boolean' if value is sameas true or value is sameas false else 'string' if value is string else 'number' if value is number else 'any' }};
      {%- endfor %}
    {%- endif %}
}

export interface ConfigManager {
    loadConfig(): void;
    saveConfig(): boolean;
    get<T = any>(key: string, defaultValue?: T): T;
    set(key: string, value: any): void;
    update(updates: Partial<Config>): void;
}

// ============================================================================
// ERROR TYPES
// ============================================================================

export enum ExitCode {
    SUCCESS = 0,
    GENERAL_ERROR = 1,
    USAGE_ERROR = 2,
    CONFIG_ERROR = 3,
    NETWORK_ERROR = 4,
    PERMISSION_ERROR = 5,
    FILE_NOT_FOUND = 6
}

export interface CLIError extends Error {
    exitCode: number;
    details: Record<string, any>;
}

export interface ErrorHandler {
    handleError(error: Error | CLIError, context?: string | null): void;
    warn(message: string, details?: Record<string, any>): void;
}

// ============================================================================
// LOGGER TYPES
// ============================================================================

export interface Logger {
    debug(message: string, meta?: Record<string, any>): void;
    info(message: string, meta?: Record<string, any>): void;
    warn(message: string, meta?: Record<string, any>): void;
    error(message: string, meta?: Record<string, any>): void;
}

export interface LogContext {
    [key: string]: any;
    module?: string;
    operationId?: string;
    userId?: string;
}

// ============================================================================
// PROGRESS TYPES
// ============================================================================

export interface ProgressManager {
    start(text: string): void;
    update(text: string): void;
    succeed(text?: string): void;
    fail(text?: string): void;
    stop(): void;
}

// ============================================================================
// HOOK TYPES
// ============================================================================

export interface HookModule {
    {%- if commander_commands and commander_commands.subcommands %}
      {%- for cmd_data in commander_commands.subcommands %}
    on{{ cmd_data.name | capitalize }}?: (
        args: {{ cmd_data.name | capitalize }}Arguments,
        options: {{ cmd_data.name | capitalize }}Options,
        command: any
    ) => Promise<void>;
        {%- if cmd_data.subcommands %}
          {%- for sub_data in cmd_data.subcommands %}
    on{{ cmd_data.name | capitalize }}{{ sub_data.name | capitalize }}?: (
        args: {{ cmd_data.name | capitalize }}{{ sub_data.name | capitalize }}Arguments,
        options: {{ cmd_data.name | capitalize }}{{ sub_data.name | capitalize }}Options,
        command: any
    ) => Promise<void>;
          {%- endfor %}
        {%- endif %}
      {%- endfor %}
    {%- endif %}
}

// ============================================================================
// UTILITY TYPES
// ============================================================================

export type DeepPartial<T> = {
    [P in keyof T]?: T[P] extends object ? DeepPartial<T[P]> : T[P];
};

export type AsyncFunction<T = void> = (...args: any[]) => Promise<T>;

export type CommandHandler = AsyncFunction<void>;