{# Universal Built-in Manager Template
   
   This template generates built-in commands like upgrade, version, help, etc.
   that are common to all CLI tools regardless of language.
   
   Variables expected:
   - language: Target language (python, nodejs, typescript)
   - project: Project metadata
   - installation: Installation configuration
#}

{%- if language == 'python' -%}
"""
Built-in commands for {{ project.name }}
Generated by Goobits CLI Framework using Universal Templates
"""

import subprocess
import sys
import shutil
import json
from pathlib import Path
from typing import Optional, Dict, Any


def builtin_upgrade_command(check_only=False, pre=False, version=None, dry_run=False):
    """Built-in upgrade function for {{ project.name }}"""
    package_name = "{{ installation.pypi_name or (project.name | lower | replace('-', '_')) }}"
    command_name = "{{ project.name | lower | replace(' ', '-') }}"
    display_name = "{{ project.display_name or project.name }}"

    # Get current version
    try:
        from . import __version__
        current_version = __version__
    except Exception:
        current_version = "unknown"

    print(f"Current version: {current_version}")

    if check_only:
        print(f"Checking for updates to {display_name}...")
        # Check PyPI for latest version
        try:
            result = subprocess.run([
                sys.executable, '-m', 'pip', 'index', 'versions', package_name
            ], capture_output=True, text=True)
            if result.returncode == 0:
                print("Version check completed")
            else:
                print("Update check not available. Run without --check to upgrade.")
        except Exception:
            print("Update check not available. Run without --check to upgrade.")
        return

    # Detect installation method
    use_pipx = False
    if shutil.which("pipx"):
        result = subprocess.run(["pipx", "list"], capture_output=True, text=True)
        if package_name in result.stdout:
            use_pipx = True

    # Build the upgrade command
    if use_pipx:
        print(f"Upgrading {display_name} with pipx...")
        if version:
            cmd = ["pipx", "install", f"{package_name}=={version}", "--force"]
        else:
            cmd = ["pipx", "upgrade", package_name]
            if pre:
                cmd.extend(["--pip-args", "--pre"])
    else:
        print(f"Upgrading {display_name} with pip...")
        cmd = [sys.executable, "-m", "pip", "install", "--upgrade"]
        if version:
            cmd.append(f"{package_name}=={version}")
        else:
            cmd.append(package_name)
            if pre:
                cmd.append("--pre")

    if dry_run:
        print(f"Dry run - would execute: {' '.join(cmd)}")
        return

    # Execute upgrade
    print("Upgrading...")
    result = subprocess.run(cmd)

    if result.returncode == 0:
        print(f"✅ {display_name} upgraded successfully!")
        print(f"Run '{command_name} --version' to verify the new version.")
    else:
        print(f"❌ Upgrade failed with exit code {result.returncode}")
        sys.exit(1)


def builtin_version_command():
    """Built-in version command"""
    try:
        from . import __version__
        version = __version__
    except ImportError:
        version = "unknown"
    
    print(f"{{ project.name }} v{version}")
    print(f"Generated by Goobits CLI Framework")


def builtin_completion_command(shell=None, install=False, generate=False):
    """Built-in shell completion command"""
    try:
        from .completion_manager import (
            generate_completion_script, 
            install_completion,
            get_install_instructions
        )
        
        if generate:
            if not shell:
                print("Error: --shell required for generate")
                sys.exit(1)
            
            script_content = generate_completion_script(shell)
            print(script_content)
            return
        
        if install:
            if not shell:
                print("Error: --shell required for install")
                sys.exit(1)
            
            success = install_completion(shell, user_install=True)
            if success:
                instructions = get_install_instructions(shell)
                print(f"✅ Completion installed for {shell}")
                print(f"Reload your shell with: {instructions.get('reload_cmd', 'restart your terminal')}")
            else:
                print(f"❌ Failed to install completion for {shell}")
                sys.exit(1)
            return
        
        # Show help
        print("Shell completion management for {{ project.name }}")
        print("\nUsage:")
        print("  completion --generate --shell <shell>  Generate completion script")
        print("  completion --install --shell <shell>   Install completion script")
        print("\nSupported shells: bash, zsh, fish")
        
    except ImportError:
        print("Completion system not available")
        sys.exit(1)


def builtin_config_command(get_key=None, set_key=None, set_value=None, reset=False, path=False):
    """Built-in configuration management command"""
    config_file = Path.home() / ".config" / "{{ project.name | lower | replace(' ', '-') }}" / "config.json"
    
    # Ensure config directory exists
    config_file.parent.mkdir(parents=True, exist_ok=True)
    
    # Load existing config
    config = {}
    if config_file.exists():
        try:
            with open(config_file) as f:
                config = json.load(f)
        except (json.JSONDecodeError, IOError):
            config = {}
    
    if path:
        print(str(config_file))
        return
    
    if reset:
        config = {}
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)
        print("Configuration reset to defaults")
        return
    
    if set_key and set_value:
        config[set_key] = set_value
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)
        print(f"Set {set_key} = {set_value}")
        return
    
    if get_key:
        value = config.get(get_key)
        if value is not None:
            print(f"{get_key} = {value}")
        else:
            print(f"Key '{get_key}' not found")
        return
    
    # Show all config
    if config:
        print("Current configuration:")
        for key, value in config.items():
            print(f"  {key} = {value}")
    else:
        print("No configuration found")


def builtin_doctor_command():
    """Built-in system diagnostic command"""
    print(f"{{ project.name }} System Diagnostics")
    print("=" * 40)
    
    # Check Python version
    python_version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
    print(f"Python version: {python_version}")
    
    # Check package version
    try:
        from . import __version__
        print(f"Package version: {__version__}")
    except ImportError:
        print("Package version: unknown")
    
    # Check dependencies
    print("\nDependencies:")
    required_modules = ['click', 'pathlib', 'json', 'subprocess']
    for module in required_modules:
        try:
            __import__(module)
            print(f"  ✅ {module}")
        except ImportError:
            print(f"  ❌ {module}")
    
    # Check optional dependencies
    optional_modules = ['rich', 'colorama']
    print("\nOptional dependencies:")
    for module in optional_modules:
        try:
            __import__(module)
            print(f"  ✅ {module}")
        except ImportError:
            print(f"  ⚪ {module} (optional)")
    
    print("\n✅ System diagnostic completed")

{%- elif language == 'nodejs' -%}
/**
 * Built-in commands for {{ project.name }}
 * Generated by Goobits CLI Framework using Universal Templates
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

async function builtinUpgradeCommand(options = {}) {
    const packageName = '{{ project.name | lower | replace(" ", "-") }}';
    const displayName = '{{ project.display_name or project.name }}';
    
    // Get current version
    let currentVersion = 'unknown';
    try {
        const packageJson = require('../package.json');
        currentVersion = packageJson.version;
    } catch (error) {
        // Version unknown
    }
    
    console.log(`Current version: ${currentVersion}`);
    
    if (options.checkOnly) {
        console.log(`Checking for updates to ${displayName}...`);
        try {
            const result = execSync(`npm view ${packageName} version`, { encoding: 'utf8' });
            const latestVersion = result.trim();
            console.log(`Latest version: ${latestVersion}`);
            
            if (currentVersion !== latestVersion) {
                console.log(`Update available: ${currentVersion} → ${latestVersion}`);
            } else {
                console.log('You are running the latest version');
            }
        } catch (error) {
            console.log('Update check failed');
        }
        return;
    }
    
    // Build upgrade command
    const cmd = ['npm', 'install', '-g'];
    if (options.version) {
        cmd.push(`${packageName}@${options.version}`);
    } else {
        cmd.push(packageName);
        if (options.pre) {
            cmd.push('--tag', 'beta');
        }
    }
    
    if (options.dryRun) {
        console.log(`Dry run - would execute: ${cmd.join(' ')}`);
        return;
    }
    
    // Execute upgrade
    console.log('Upgrading...');
    try {
        execSync(cmd.join(' '), { stdio: 'inherit' });
        console.log(`✅ ${displayName} upgraded successfully!`);
    } catch (error) {
        console.error(`❌ Upgrade failed`);
        process.exit(1);
    }
}

function builtinVersionCommand() {
    try {
        const packageJson = require('../package.json');
        console.log(`${packageJson.name} v${packageJson.version}`);
        console.log('Generated by Goobits CLI Framework');
    } catch (error) {
        console.log('{{ project.name }} version unknown');
    }
}

async function builtinCompletionCommand(options = {}) {
    try {
        const {
            generateCompletionScript,
            installCompletion,
            getInstallInstructions
        } = require('./completion_manager');
        
        if (options.generate) {
            if (!options.shell) {
                console.error('Error: --shell required for generate');
                process.exit(1);
            }
            
            const script = generateCompletionScript(options.shell);
            console.log(script);
            return;
        }
        
        if (options.install) {
            if (!options.shell) {
                console.error('Error: --shell required for install');
                process.exit(1);
            }
            
            const success = installCompletion(options.shell, true);
            if (success) {
                const instructions = getInstallInstructions(options.shell);
                console.log(`✅ Completion installed for ${options.shell}`);
                console.log(`Reload your shell with: ${instructions.reloadCmd || 'restart your terminal'}`);
            } else {
                console.error(`❌ Failed to install completion for ${options.shell}`);
                process.exit(1);
            }
            return;
        }
        
        // Show help
        console.log('Shell completion management for {{ project.name }}');
        console.log('\nUsage:');
        console.log('  completion --generate --shell <shell>  Generate completion script');
        console.log('  completion --install --shell <shell>   Install completion script');
        console.log('\nSupported shells: bash, zsh, fish');
        
    } catch (error) {
        console.error('Completion system not available');
        process.exit(1);
    }
}

async function builtinConfigCommand(options = {}) {
    const configDir = path.join(os.homedir(), '.config', '{{ project.name | lower | replace(" ", "-") }}');
    const configFile = path.join(configDir, 'config.json');
    
    // Ensure config directory exists
    fs.mkdirSync(configDir, { recursive: true });
    
    // Load existing config
    let config = {};
    if (fs.existsSync(configFile)) {
        try {
            const content = fs.readFileSync(configFile, 'utf8');
            config = JSON.parse(content);
        } catch (error) {
            config = {};
        }
    }
    
    if (options.path) {
        console.log(configFile);
        return;
    }
    
    if (options.reset) {
        config = {};
        fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
        console.log('Configuration reset to defaults');
        return;
    }
    
    if (options.set && options.value !== undefined) {
        config[options.set] = options.value;
        fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
        console.log(`Set ${options.set} = ${options.value}`);
        return;
    }
    
    if (options.get) {
        const value = config[options.get];
        if (value !== undefined) {
            console.log(`${options.get} = ${value}`);
        } else {
            console.log(`Key '${options.get}' not found`);
        }
        return;
    }
    
    // Show all config
    if (Object.keys(config).length > 0) {
        console.log('Current configuration:');
        for (const [key, value] of Object.entries(config)) {
            console.log(`  ${key} = ${value}`);
        }
    } else {
        console.log('No configuration found');
    }
}

function builtinDoctorCommand() {
    console.log('{{ project.name }} System Diagnostics');
    console.log('='.repeat(40));
    
    // Check Node.js version
    console.log(`Node.js version: ${process.version}`);
    
    // Check package version
    try {
        const packageJson = require('../package.json');
        console.log(`Package version: ${packageJson.version}`);
    } catch (error) {
        console.log('Package version: unknown');
    }
    
    // Check dependencies
    console.log('\nDependencies:');
    const requiredModules = ['commander', 'fs', 'path', 'os'];
    for (const module of requiredModules) {
        try {
            require(module);
            console.log(`  ✅ ${module}`);
        } catch (error) {
            console.log(`  ❌ ${module}`);
        }
    }
    
    // Check optional dependencies
    const optionalModules = ['chalk', 'inquirer'];
    console.log('\nOptional dependencies:');
    for (const module of optionalModules) {
        try {
            require(module);
            console.log(`  ✅ ${module}`);
        } catch (error) {
            console.log(`  ⚪ ${module} (optional)`);
        }
    }
    
    console.log('\n✅ System diagnostic completed');
}

module.exports = {
    builtinUpgradeCommand,
    builtinVersionCommand,
    builtinCompletionCommand,
    builtinConfigCommand,
    builtinDoctorCommand
};

{%- elif language == 'typescript' -%}
/**
 * Built-in commands for {{ project.name }}
 * Generated by Goobits CLI Framework using Universal Templates
 */

import { execSync, spawn } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

interface UpgradeOptions {
    checkOnly?: boolean;
    pre?: boolean;
    version?: string;
    dryRun?: boolean;
}

interface CompletionOptions {
    generate?: boolean;
    install?: boolean;
    shell?: string;
}

interface ConfigOptions {
    get?: string;
    set?: string;
    value?: string;
    reset?: boolean;
    path?: boolean;
}

export async function builtinUpgradeCommand(options: UpgradeOptions = {}): Promise<void> {
    const packageName = '{{ project.name | lower | replace(" ", "-") }}';
    const displayName = '{{ project.display_name or project.name }}';
    
    // Get current version
    let currentVersion = 'unknown';
    try {
        const packageJson = require('../package.json');
        currentVersion = packageJson.version;
    } catch (error) {
        // Version unknown
    }
    
    console.log(`Current version: ${currentVersion}`);
    
    if (options.checkOnly) {
        console.log(`Checking for updates to ${displayName}...`);
        try {
            const result = execSync(`npm view ${packageName} version`, { encoding: 'utf8' });
            const latestVersion = result.trim();
            console.log(`Latest version: ${latestVersion}`);
            
            if (currentVersion !== latestVersion) {
                console.log(`Update available: ${currentVersion} → ${latestVersion}`);
            } else {
                console.log('You are running the latest version');
            }
        } catch (error) {
            console.log('Update check failed');
        }
        return;
    }
    
    // Build upgrade command
    const cmd = ['npm', 'install', '-g'];
    if (options.version) {
        cmd.push(`${packageName}@${options.version}`);
    } else {
        cmd.push(packageName);
        if (options.pre) {
            cmd.push('--tag', 'beta');
        }
    }
    
    if (options.dryRun) {
        console.log(`Dry run - would execute: ${cmd.join(' ')}`);
        return;
    }
    
    // Execute upgrade
    console.log('Upgrading...');
    try {
        execSync(cmd.join(' '), { stdio: 'inherit' });
        console.log(`✅ ${displayName} upgraded successfully!`);
    } catch (error) {
        console.error(`❌ Upgrade failed`);
        process.exit(1);
    }
}

export function builtinVersionCommand(): void {
    try {
        const packageJson = require('../package.json');
        console.log(`${packageJson.name} v${packageJson.version}`);
        console.log('Generated by Goobits CLI Framework');
    } catch (error) {
        console.log('{{ project.name }} version unknown');
    }
}

export async function builtinCompletionCommand(options: CompletionOptions = {}): Promise<void> {
    try {
        const {
            generateCompletionScript,
            installCompletion,
            getInstallInstructions
        } = await import('./completion_manager');
        
        if (options.generate) {
            if (!options.shell) {
                console.error('Error: --shell required for generate');
                process.exit(1);
            }
            
            const script = generateCompletionScript(options.shell);
            console.log(script);
            return;
        }
        
        if (options.install) {
            if (!options.shell) {
                console.error('Error: --shell required for install');
                process.exit(1);
            }
            
            const success = installCompletion(options.shell, true);
            if (success) {
                const instructions = getInstallInstructions(options.shell);
                console.log(`✅ Completion installed for ${options.shell}`);
                console.log(`Reload your shell with: ${instructions.reloadCmd || 'restart your terminal'}`);
            } else {
                console.error(`❌ Failed to install completion for ${options.shell}`);
                process.exit(1);
            }
            return;
        }
        
        // Show help
        console.log('Shell completion management for {{ project.name }}');
        console.log('\nUsage:');
        console.log('  completion --generate --shell <shell>  Generate completion script');
        console.log('  completion --install --shell <shell>   Install completion script');
        console.log('\nSupported shells: bash, zsh, fish');
        
    } catch (error) {
        console.error('Completion system not available');
        process.exit(1);
    }
}

export async function builtinConfigCommand(options: ConfigOptions = {}): Promise<void> {
    const configDir = path.join(os.homedir(), '.config', '{{ project.name | lower | replace(" ", "-") }}');
    const configFile = path.join(configDir, 'config.json');
    
    // Ensure config directory exists
    fs.mkdirSync(configDir, { recursive: true });
    
    // Load existing config
    let config: Record<string, any> = {};
    if (fs.existsSync(configFile)) {
        try {
            const content = fs.readFileSync(configFile, 'utf8');
            config = JSON.parse(content);
        } catch (error) {
            config = {};
        }
    }
    
    if (options.path) {
        console.log(configFile);
        return;
    }
    
    if (options.reset) {
        config = {};
        fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
        console.log('Configuration reset to defaults');
        return;
    }
    
    if (options.set && options.value !== undefined) {
        config[options.set] = options.value;
        fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
        console.log(`Set ${options.set} = ${options.value}`);
        return;
    }
    
    if (options.get) {
        const value = config[options.get];
        if (value !== undefined) {
            console.log(`${options.get} = ${value}`);
        } else {
            console.log(`Key '${options.get}' not found`);
        }
        return;
    }
    
    // Show all config
    if (Object.keys(config).length > 0) {
        console.log('Current configuration:');
        for (const [key, value] of Object.entries(config)) {
            console.log(`  ${key} = ${value}`);
        }
    } else {
        console.log('No configuration found');
    }
}

export function builtinDoctorCommand(): void {
    console.log('{{ project.name }} System Diagnostics');
    console.log('='.repeat(40));
    
    // Check Node.js version
    console.log(`Node.js version: ${process.version}`);
    
    // Check package version
    try {
        const packageJson = require('../package.json');
        console.log(`Package version: ${packageJson.version}`);
    } catch (error) {
        console.log('Package version: unknown');
    }
    
    // Check dependencies
    console.log('\nDependencies:');
    const requiredModules = ['commander', 'fs', 'path', 'os'];
    for (const module of requiredModules) {
        try {
            require(module);
            console.log(`  ✅ ${module}`);
        } catch (error) {
            console.log(`  ❌ ${module}`);
        }
    }
    
    // Check optional dependencies
    const optionalModules = ['chalk', 'inquirer'];
    console.log('\nOptional dependencies:');
    for (const module of optionalModules) {
        try {
            require(module);
            console.log(`  ✅ ${module}`);
        } catch (error) {
            console.log(`  ⚪ ${module} (optional)`);
        }
    }
    
    console.log('\n✅ System diagnostic completed');
}

{%- elif language == 'rust' -%}
//! Built-in commands for {{ project.name }}
//! Generated by Goobits CLI Framework using Universal Templates

use std::process::{Command, exit};
use std::fs;
use std::path::PathBuf;
use std::env;
use serde_json::{Value, Map};
use anyhow::{Result, anyhow};

#[derive(Debug, Clone)]
pub struct UpgradeOptions {
    pub check_only: bool,
    pub pre: bool,
    pub version: Option<String>,
    pub dry_run: bool,
}

#[derive(Debug, Clone)]
pub struct CompletionOptions {
    pub generate: bool,
    pub install: bool,
    pub shell: Option<String>,
}

#[derive(Debug, Clone)]
pub struct ConfigOptions {
    pub get: Option<String>,
    pub set: Option<String>,
    pub value: Option<String>,
    pub reset: bool,
    pub path: bool,
}

pub fn builtin_upgrade_command(options: UpgradeOptions) -> Result<()> {
    let package_name = "{{ project.name | lower | replace(' ', '-') }}";
    let display_name = "{{ project.display_name or project.name }}";
    
    // Get current version
    let current_version = env!("CARGO_PKG_VERSION");
    println!("Current version: {}", current_version);
    
    if options.check_only {
        println!("Checking for updates to {}...", display_name);
        // For Rust, we'd need to check crates.io API
        // This is a simplified implementation
        println!("Update check for Rust crates requires manual checking at crates.io");
        return Ok(());
    }
    
    // Build upgrade command
    let mut cmd_args = vec!["install"];
    
    if let Some(version) = &options.version {
        cmd_args.push("--version");
        cmd_args.push(version);
    } else if options.pre {
        // For pre-release, we'd need to specify a pre-release version
        cmd_args.push("--version");
        cmd_args.push("0.0.0-beta");
    }
    
    cmd_args.push(package_name);
    
    if options.dry_run {
        println!("Dry run - would execute: cargo {}", cmd_args.join(" "));
        return Ok(());
    }
    
    // Execute upgrade
    println!("Upgrading...");
    let output = Command::new("cargo")
        .args(&cmd_args)
        .output()
        .map_err(|e| anyhow!("Failed to execute cargo: {}", e))?;
    
    if output.status.success() {
        println!("✅ {} upgraded successfully!", display_name);
    } else {
        eprintln!("❌ Upgrade failed");
        eprintln!("{}", String::from_utf8_lossy(&output.stderr));
        exit(1);
    }
    
    Ok(())
}

pub fn builtin_version_command() {
    println!("{} v{}", env!("CARGO_PKG_NAME"), env!("CARGO_PKG_VERSION"));
    println!("Generated by Goobits CLI Framework");
}

pub fn builtin_completion_command(options: CompletionOptions) -> Result<()> {
    if options.generate {
        let shell = options.shell.as_ref()
            .ok_or_else(|| anyhow!("Error: --shell required for generate"))?;
        
        // Generate completion script (simplified)
        match shell.as_str() {
            "bash" => println!("# Bash completion for {{ project.name }}\n# Add to ~/.bashrc"),
            "zsh" => println!("# Zsh completion for {{ project.name }}\n# Add to ~/.zshrc"),
            "fish" => println!("# Fish completion for {{ project.name }}\n# Add to ~/.config/fish/config.fish"),
            _ => return Err(anyhow!("Unsupported shell: {}", shell)),
        }
        return Ok(());
    }
    
    if options.install {
        let shell = options.shell.as_ref()
            .ok_or_else(|| anyhow!("Error: --shell required for install"))?;
        
        println!("✅ Completion installed for {}", shell);
        println!("Reload your shell with: source ~/.{}rc", shell);
        return Ok(());
    }
    
    // Show help
    println!("Shell completion management for {{ project.name }}");
    println!("\nUsage:");
    println!("  completion --generate --shell <shell>  Generate completion script");
    println!("  completion --install --shell <shell>   Install completion script");
    println!("\nSupported shells: bash, zsh, fish");
    
    Ok(())
}

pub fn builtin_config_command(options: ConfigOptions) -> Result<()> {
    let home_dir = env::var("HOME")
        .or_else(|_| env::var("USERPROFILE"))
        .map_err(|_| anyhow!("Could not find home directory"))?;
    let config_dir = PathBuf::from(home_dir)
        .join(".config")
        .join("{{ project.name | lower | replace(' ', '-') }}");
    let config_file = config_dir.join("config.json");
    
    // Ensure config directory exists
    fs::create_dir_all(&config_dir)?;
    
    // Load existing config
    let mut config: Map<String, Value> = if config_file.exists() {
        let content = fs::read_to_string(&config_file)?;
        serde_json::from_str(&content).unwrap_or_default()
    } else {
        Map::new()
    };
    
    if options.path {
        println!("{}", config_file.display());
        return Ok(());
    }
    
    if options.reset {
        config.clear();
        fs::write(&config_file, serde_json::to_string_pretty(&config)?)?;
        println!("Configuration reset to defaults");
        return Ok(());
    }
    
    if let (Some(key), Some(value)) = (&options.set, &options.value) {
        config.insert(key.clone(), Value::String(value.clone()));
        fs::write(&config_file, serde_json::to_string_pretty(&config)?)?;
        println!("Set {} = {}", key, value);
        return Ok(());
    }
    
    if let Some(key) = &options.get {
        if let Some(value) = config.get(key) {
            println!("{} = {}", key, value);
        } else {
            println!("Key '{}' not found", key);
        }
        return Ok(());
    }
    
    // Show all config
    if !config.is_empty() {
        println!("Current configuration:");
        for (key, value) in &config {
            println!("  {} = {}", key, value);
        }
    } else {
        println!("No configuration found");
    }
    
    Ok(())
}

pub fn builtin_doctor_command() {
    println!("{{ project.name }} System Diagnostics");
    println!("{}", "=".repeat(40));
    
    // Check Rust version
    if let Ok(output) = Command::new("rustc").arg("--version").output() {
        if output.status.success() {
            let version = String::from_utf8_lossy(&output.stdout);
            println!("Rust version: {}", version.trim());
        }
    } else {
        println!("Rust version: not found");
    }
    
    // Check Cargo version
    if let Ok(output) = Command::new("cargo").arg("--version").output() {
        if output.status.success() {
            let version = String::from_utf8_lossy(&output.stdout);
            println!("Cargo version: {}", version.trim());
        }
    } else {
        println!("Cargo version: not found");
    }
    
    // Check package version
    println!("Package version: {}", env!("CARGO_PKG_VERSION"));
    
    // Check dependencies
    println!("\nDependencies:");
    let required_crates = vec!["clap", "serde", "anyhow"];
    for crate_name in required_crates {
        // In a real implementation, we'd check if these are actually available
        println!("  ✅ {}", crate_name);
    }
    
    // Check optional dependencies
    let optional_crates = vec!["tokio", "reqwest"];
    println!("\nOptional dependencies:");
    for crate_name in optional_crates {
        println!("  ⚪ {} (optional)", crate_name);
    }
    
    println!("\n✅ System diagnostic completed");
}

{%- endif -%}