{# Universal Built-in Manager Template
   
   This template generates built-in commands like upgrade, version, help, etc.
   that are common to all CLI tools regardless of language.
   
   Variables expected:
   - language: Target language (python, nodejs, typescript)
   - project: Project metadata
   - installation: Installation configuration
#}

{%- if language == 'python' -%}
"""
Built-in commands for {{ project.name }}
Generated by Goobits CLI Framework using Universal Templates
"""

import subprocess
import sys
import shutil
import json
from pathlib import Path
from typing import Optional, Dict, Any


def builtin_upgrade_command(check_only=False, pre=False, version=None, dry_run=False):
    """Built-in upgrade function for {{ project.name }}"""
    package_name = "{{ installation.pypi_name | default(project.name | lower | replace('-', '_')) }}"
    command_name = "{{ project.name | lower | replace(' ', '-') }}"
    display_name = "{{ project.display_name | default(project.name) }}"

    # Get current version
    try:
        from . import __version__
        current_version = __version__
    except Exception:
        current_version = "unknown"

    print(f"Current version: {current_version}")

    if check_only:
        print(f"Checking for updates to {display_name}...")
        # Check PyPI for latest version
        try:
            result = subprocess.run([
                sys.executable, '-m', 'pip', 'index', 'versions', package_name
            ], capture_output=True, text=True)
            if result.returncode == 0:
                print("Version check completed")
            else:
                print("Update check not available. Run without --check to upgrade.")
        except Exception:
            print("Update check not available. Run without --check to upgrade.")
        return

    # Detect installation method
    use_pipx = False
    if shutil.which("pipx"):
        result = subprocess.run(["pipx", "list"], capture_output=True, text=True)
        if package_name in result.stdout:
            use_pipx = True

    # Build the upgrade command
    if use_pipx:
        print(f"Upgrading {display_name} with pipx...")
        if version:
            cmd = ["pipx", "install", f"{package_name}=={version}", "--force"]
        else:
            cmd = ["pipx", "upgrade", package_name]
            if pre:
                cmd.extend(["--pip-args", "--pre"])
    else:
        print(f"Upgrading {display_name} with pip...")
        cmd = [sys.executable, "-m", "pip", "install", "--upgrade"]
        if version:
            cmd.append(f"{package_name}=={version}")
        else:
            cmd.append(package_name)
            if pre:
                cmd.append("--pre")

    if dry_run:
        print(f"Dry run - would execute: {' '.join(cmd)}")
        return

    # Execute upgrade
    print("Upgrading...")
    result = subprocess.run(cmd)

    if result.returncode == 0:
        print(f"✅ {display_name} upgraded successfully!")
        print(f"Run '{command_name} --version' to verify the new version.")
    else:
        print(f"❌ Upgrade failed with exit code {result.returncode}")
        sys.exit(1)


def builtin_version_command():
    """Built-in version command"""
    try:
        from . import __version__
        version = __version__
    except ImportError:
        version = "unknown"
    
    print(f"{{ project.name }} v{version}")
    print(f"Generated by Goobits CLI Framework")


def builtin_completion_command(shell=None, install=False, generate=False):
    """Built-in shell completion command"""
    try:
        from .completion_manager import (
            generate_completion_script, 
            install_completion,
            get_install_instructions
        )
        
        if generate:
            if not shell:
                print("Error: --shell required for generate")
                sys.exit(1)
            
            script_content = generate_completion_script(shell)
            print(script_content)
            return
        
        if install:
            if not shell:
                print("Error: --shell required for install")
                sys.exit(1)
            
            success = install_completion(shell, user_install=True)
            if success:
                instructions = get_install_instructions(shell)
                print(f"✅ Completion installed for {shell}")
                print(f"Reload your shell with: {instructions.get('reload_cmd', 'restart your terminal')}")
            else:
                print(f"❌ Failed to install completion for {shell}")
                sys.exit(1)
            return
        
        # Show help
        print("Shell completion management for {{ project.name }}")
        print("\nUsage:")
        print("  completion --generate --shell <shell>  Generate completion script")
        print("  completion --install --shell <shell>   Install completion script")
        print("\nSupported shells: bash, zsh, fish")
        
    except ImportError:
        print("Completion system not available")
        sys.exit(1)


def builtin_config_command(get_key=None, set_key=None, set_value=None, reset=False, path=False):
    """Built-in configuration management command"""
    config_file = Path.home() / ".config" / "{{ project.name | lower | replace(' ', '-') }}" / "config.json"
    
    # Ensure config directory exists
    config_file.parent.mkdir(parents=True, exist_ok=True)
    
    # Load existing config
    config = {}
    if config_file.exists():
        try:
            with open(config_file) as f:
                config = json.load(f)
        except (json.JSONDecodeError, IOError):
            config = {}
    
    if path:
        print(str(config_file))
        return
    
    if reset:
        config = {}
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)
        print("Configuration reset to defaults")
        return
    
    if set_key and set_value:
        config[set_key] = set_value
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)
        print(f"Set {set_key} = {set_value}")
        return
    
    if get_key:
        value = config.get(get_key)
        if value is not None:
            print(f"{get_key} = {value}")
        else:
            print(f"Key '{get_key}' not found")
        return
    
    # Show all config
    if config:
        print("Current configuration:")
        for key, value in config.items():
            print(f"  {key} = {value}")
    else:
        print("No configuration found")


def builtin_doctor_command():
    """Built-in system diagnostic command"""
    print(f"{{ project.name }} System Diagnostics")
    print("=" * 40)
    
    # Check Python version
    python_version = f"{sys.version_info.major}.{sys.version_info.minor}.{sys.version_info.micro}"
    print(f"Python version: {python_version}")
    
    # Check package version
    try:
        from . import __version__
        print(f"Package version: {__version__}")
    except ImportError:
        print("Package version: unknown")
    
    # Check dependencies
    print("\nDependencies:")
    required_modules = ['click', 'pathlib', 'json', 'subprocess']
    for module in required_modules:
        try:
            __import__(module)
            print(f"  ✅ {module}")
        except ImportError:
            print(f"  ❌ {module}")
    
    # Check optional dependencies
    optional_modules = ['rich', 'colorama']
    print("\nOptional dependencies:")
    for module in optional_modules:
        try:
            __import__(module)
            print(f"  ✅ {module}")
        except ImportError:
            print(f"  ⚪ {module} (optional)")
    
    print("\n✅ System diagnostic completed")

{%- elif language == 'nodejs' -%}
/**
 * Built-in commands for {{ project.name }}
 * Generated by Goobits CLI Framework using Universal Templates
 */

const { execSync, spawn } = require('child_process');
const fs = require('fs');
const path = require('path');
const os = require('os');

async function builtinUpgradeCommand(options = {}) {
    const packageName = '{{ project.name | lower | replace(" ", "-") }}';
    const displayName = '{{ project.display_name | default(project.name) }}';
    
    // Get current version
    let currentVersion = 'unknown';
    try {
        const packageJson = require('../package.json');
        currentVersion = packageJson.version;
    } catch (error) {
        // Version unknown
    }
    
    console.log(`Current version: ${currentVersion}`);
    
    if (options.checkOnly) {
        console.log(`Checking for updates to ${displayName}...`);
        try {
            const result = execSync(`npm view ${packageName} version`, { encoding: 'utf8' });
            const latestVersion = result.trim();
            console.log(`Latest version: ${latestVersion}`);
            
            if (currentVersion !== latestVersion) {
                console.log(`Update available: ${currentVersion} → ${latestVersion}`);
            } else {
                console.log('You are running the latest version');
            }
        } catch (error) {
            console.log('Update check failed');
        }
        return;
    }
    
    // Build upgrade command
    const cmd = ['npm', 'install', '-g'];
    if (options.version) {
        cmd.push(`${packageName}@${options.version}`);
    } else {
        cmd.push(packageName);
        if (options.pre) {
            cmd.push('--tag', 'beta');
        }
    }
    
    if (options.dryRun) {
        console.log(`Dry run - would execute: ${cmd.join(' ')}`);
        return;
    }
    
    // Execute upgrade
    console.log('Upgrading...');
    try {
        execSync(cmd.join(' '), { stdio: 'inherit' });
        console.log(`✅ ${displayName} upgraded successfully!`);
    } catch (error) {
        console.error(`❌ Upgrade failed`);
        process.exit(1);
    }
}

function builtinVersionCommand() {
    try {
        const packageJson = require('../package.json');
        console.log(`${packageJson.name} v${packageJson.version}`);
        console.log('Generated by Goobits CLI Framework');
    } catch (error) {
        console.log('{{ project.name }} version unknown');
    }
}

async function builtinCompletionCommand(options = {}) {
    try {
        const {
            generateCompletionScript,
            installCompletion,
            getInstallInstructions
        } = require('./completion_manager');
        
        if (options.generate) {
            if (!options.shell) {
                console.error('Error: --shell required for generate');
                process.exit(1);
            }
            
            const script = generateCompletionScript(options.shell);
            console.log(script);
            return;
        }
        
        if (options.install) {
            if (!options.shell) {
                console.error('Error: --shell required for install');
                process.exit(1);
            }
            
            const success = installCompletion(options.shell, true);
            if (success) {
                const instructions = getInstallInstructions(options.shell);
                console.log(`✅ Completion installed for ${options.shell}`);
                console.log(`Reload your shell with: ${instructions.reloadCmd || 'restart your terminal'}`);
            } else {
                console.error(`❌ Failed to install completion for ${options.shell}`);
                process.exit(1);
            }
            return;
        }
        
        // Show help
        console.log('Shell completion management for {{ project.name }}');
        console.log('\nUsage:');
        console.log('  completion --generate --shell <shell>  Generate completion script');
        console.log('  completion --install --shell <shell>   Install completion script');
        console.log('\nSupported shells: bash, zsh, fish');
        
    } catch (error) {
        console.error('Completion system not available');
        process.exit(1);
    }
}

async function builtinConfigCommand(options = {}) {
    const configDir = path.join(os.homedir(), '.config', '{{ project.name | lower | replace(" ", "-") }}');
    const configFile = path.join(configDir, 'config.json');
    
    // Ensure config directory exists
    fs.mkdirSync(configDir, { recursive: true });
    
    // Load existing config
    let config = {};
    if (fs.existsSync(configFile)) {
        try {
            const content = fs.readFileSync(configFile, 'utf8');
            config = JSON.parse(content);
        } catch (error) {
            config = {};
        }
    }
    
    if (options.path) {
        console.log(configFile);
        return;
    }
    
    if (options.reset) {
        config = {};
        fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
        console.log('Configuration reset to defaults');
        return;
    }
    
    if (options.set && options.value !== undefined) {
        config[options.set] = options.value;
        fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
        console.log(`Set ${options.set} = ${options.value}`);
        return;
    }
    
    if (options.get) {
        const value = config[options.get];
        if (value !== undefined) {
            console.log(`${options.get} = ${value}`);
        } else {
            console.log(`Key '${options.get}' not found`);
        }
        return;
    }
    
    // Show all config
    if (Object.keys(config).length > 0) {
        console.log('Current configuration:');
        for (const [key, value] of Object.entries(config)) {
            console.log(`  ${key} = ${value}`);
        }
    } else {
        console.log('No configuration found');
    }
}

function builtinDoctorCommand() {
    console.log('{{ project.name }} System Diagnostics');
    console.log('='.repeat(40));
    
    // Check Node.js version
    console.log(`Node.js version: ${process.version}`);
    
    // Check package version
    try {
        const packageJson = require('../package.json');
        console.log(`Package version: ${packageJson.version}`);
    } catch (error) {
        console.log('Package version: unknown');
    }
    
    // Check dependencies
    console.log('\nDependencies:');
    const requiredModules = ['commander', 'fs', 'path', 'os'];
    for (const module of requiredModules) {
        try {
            require(module);
            console.log(`  ✅ ${module}`);
        } catch (error) {
            console.log(`  ❌ ${module}`);
        }
    }
    
    // Check optional dependencies
    const optionalModules = ['chalk', 'inquirer'];
    console.log('\nOptional dependencies:');
    for (const module of optionalModules) {
        try {
            require(module);
            console.log(`  ✅ ${module}`);
        } catch (error) {
            console.log(`  ⚪ ${module} (optional)`);
        }
    }
    
    console.log('\n✅ System diagnostic completed');
}

module.exports = {
    builtinUpgradeCommand,
    builtinVersionCommand,
    builtinCompletionCommand,
    builtinConfigCommand,
    builtinDoctorCommand
};

{%- elif language == 'typescript' -%}
/**
 * Built-in commands for {{ project.name }}
 * Generated by Goobits CLI Framework using Universal Templates
 */

import { execSync, spawn } from 'child_process';
import * as fs from 'fs';
import * as path from 'path';
import * as os from 'os';

interface UpgradeOptions {
    checkOnly?: boolean;
    pre?: boolean;
    version?: string;
    dryRun?: boolean;
}

interface CompletionOptions {
    generate?: boolean;
    install?: boolean;
    shell?: string;
}

interface ConfigOptions {
    get?: string;
    set?: string;
    value?: string;
    reset?: boolean;
    path?: boolean;
}

export async function builtinUpgradeCommand(options: UpgradeOptions = {}): Promise<void> {
    const packageName = '{{ project.name | lower | replace(" ", "-") }}';
    const displayName = '{{ project.display_name | default(project.name) }}';
    
    // Get current version
    let currentVersion = 'unknown';
    try {
        const packageJson = require('../package.json');
        currentVersion = packageJson.version;
    } catch (error) {
        // Version unknown
    }
    
    console.log(`Current version: ${currentVersion}`);
    
    if (options.checkOnly) {
        console.log(`Checking for updates to ${displayName}...`);
        try {
            const result = execSync(`npm view ${packageName} version`, { encoding: 'utf8' });
            const latestVersion = result.trim();
            console.log(`Latest version: ${latestVersion}`);
            
            if (currentVersion !== latestVersion) {
                console.log(`Update available: ${currentVersion} → ${latestVersion}`);
            } else {
                console.log('You are running the latest version');
            }
        } catch (error) {
            console.log('Update check failed');
        }
        return;
    }
    
    // Build upgrade command
    const cmd = ['npm', 'install', '-g'];
    if (options.version) {
        cmd.push(`${packageName}@${options.version}`);
    } else {
        cmd.push(packageName);
        if (options.pre) {
            cmd.push('--tag', 'beta');
        }
    }
    
    if (options.dryRun) {
        console.log(`Dry run - would execute: ${cmd.join(' ')}`);
        return;
    }
    
    // Execute upgrade
    console.log('Upgrading...');
    try {
        execSync(cmd.join(' '), { stdio: 'inherit' });
        console.log(`✅ ${displayName} upgraded successfully!`);
    } catch (error) {
        console.error(`❌ Upgrade failed`);
        process.exit(1);
    }
}

export function builtinVersionCommand(): void {
    try {
        const packageJson = require('../package.json');
        console.log(`${packageJson.name} v${packageJson.version}`);
        console.log('Generated by Goobits CLI Framework');
    } catch (error) {
        console.log('{{ project.name }} version unknown');
    }
}

export async function builtinCompletionCommand(options: CompletionOptions = {}): Promise<void> {
    try {
        const {
            generateCompletionScript,
            installCompletion,
            getInstallInstructions
        } = await import('./completion_manager');
        
        if (options.generate) {
            if (!options.shell) {
                console.error('Error: --shell required for generate');
                process.exit(1);
            }
            
            const script = generateCompletionScript(options.shell);
            console.log(script);
            return;
        }
        
        if (options.install) {
            if (!options.shell) {
                console.error('Error: --shell required for install');
                process.exit(1);
            }
            
            const success = installCompletion(options.shell, true);
            if (success) {
                const instructions = getInstallInstructions(options.shell);
                console.log(`✅ Completion installed for ${options.shell}`);
                console.log(`Reload your shell with: ${instructions.reloadCmd || 'restart your terminal'}`);
            } else {
                console.error(`❌ Failed to install completion for ${options.shell}`);
                process.exit(1);
            }
            return;
        }
        
        // Show help
        console.log('Shell completion management for {{ project.name }}');
        console.log('\nUsage:');
        console.log('  completion --generate --shell <shell>  Generate completion script');
        console.log('  completion --install --shell <shell>   Install completion script');
        console.log('\nSupported shells: bash, zsh, fish');
        
    } catch (error) {
        console.error('Completion system not available');
        process.exit(1);
    }
}

export async function builtinConfigCommand(options: ConfigOptions = {}): Promise<void> {
    const configDir = path.join(os.homedir(), '.config', '{{ project.name | lower | replace(" ", "-") }}');
    const configFile = path.join(configDir, 'config.json');
    
    // Ensure config directory exists
    fs.mkdirSync(configDir, { recursive: true });
    
    // Load existing config
    let config: Record<string, any> = {};
    if (fs.existsSync(configFile)) {
        try {
            const content = fs.readFileSync(configFile, 'utf8');
            config = JSON.parse(content);
        } catch (error) {
            config = {};
        }
    }
    
    if (options.path) {
        console.log(configFile);
        return;
    }
    
    if (options.reset) {
        config = {};
        fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
        console.log('Configuration reset to defaults');
        return;
    }
    
    if (options.set && options.value !== undefined) {
        config[options.set] = options.value;
        fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
        console.log(`Set ${options.set} = ${options.value}`);
        return;
    }
    
    if (options.get) {
        const value = config[options.get];
        if (value !== undefined) {
            console.log(`${options.get} = ${value}`);
        } else {
            console.log(`Key '${options.get}' not found`);
        }
        return;
    }
    
    // Show all config
    if (Object.keys(config).length > 0) {
        console.log('Current configuration:');
        for (const [key, value] of Object.entries(config)) {
            console.log(`  ${key} = ${value}`);
        }
    } else {
        console.log('No configuration found');
    }
}

export function builtinDoctorCommand(): void {
    console.log('{{ project.name }} System Diagnostics');
    console.log('='.repeat(40));
    
    // Check Node.js version
    console.log(`Node.js version: ${process.version}`);
    
    // Check package version
    try {
        const packageJson = require('../package.json');
        console.log(`Package version: ${packageJson.version}`);
    } catch (error) {
        console.log('Package version: unknown');
    }
    
    // Check dependencies
    console.log('\nDependencies:');
    const requiredModules = ['commander', 'fs', 'path', 'os'];
    for (const module of requiredModules) {
        try {
            require(module);
            console.log(`  ✅ ${module}`);
        } catch (error) {
            console.log(`  ❌ ${module}`);
        }
    }
    
    // Check optional dependencies
    const optionalModules = ['chalk', 'inquirer'];
    console.log('\nOptional dependencies:');
    for (const module of optionalModules) {
        try {
            require(module);
            console.log(`  ✅ ${module}`);
        } catch (error) {
            console.log(`  ⚪ ${module} (optional)`);
        }
    }
    
    console.log('\n✅ System diagnostic completed');
}

{%- endif -%}