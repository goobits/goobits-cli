#!/usr/bin/env node
/**
 * {{ project.name }} - {{ project.description }}
 * Generated by Goobits CLI Framework v{{ generator_version }}
 * 
 * This is a consolidated TypeScript CLI file with all utilities embedded.
 * Generated from: {{ config_filename }}
 */

import { Command } from 'commander';
import chalk from 'chalk';
import ora, { Ora } from 'ora';
import { readFileSync, writeFileSync, existsSync, mkdirSync } from 'fs';
import { join, dirname } from 'path';
import { homedir } from 'os';
import yaml from 'js-yaml';
import { fileURLToPath } from 'url';
import { AsyncLocalStorage } from 'async_hooks';
import winston from 'winston';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// ============================================================================
// TYPE DEFINITIONS
// ============================================================================

interface Config {
    [key: string]: any;
    debug?: boolean;
    outputFormat?: string;
    verbose?: boolean;
}

interface CLIError extends Error {
    exitCode: number;
    details: Record<string, any>;
}

interface ErrorHandler {
    handleError(error: Error | CLIError, context?: string | null): void;
    warn(message: string, details?: Record<string, any>): void;
}

interface Logger {
    debug(message: string, meta?: Record<string, any>): void;
    info(message: string, meta?: Record<string, any>): void;
    warn(message: string, meta?: Record<string, any>): void;
    error(message: string, meta?: Record<string, any>): void;
}

interface HookModule {
    {%- if commander_commands and commander_commands.subcommands %}
      {%- for cmd_data in commander_commands.subcommands %}
    on{{ cmd_data.name | capitalize }}?: (...args: any[]) => Promise<void>;
        {%- if cmd_data.subcommands %}
          {%- for sub_data in cmd_data.subcommands %}
    on{{ sub_data.name | capitalize }}?: (...args: any[]) => Promise<void>;
          {%- endfor %}
        {%- endif %}
      {%- endfor %}
    {%- endif %}
}

// ============================================================================
// EMBEDDED CONFIGURATION MANAGER
// ============================================================================

class ConfigManager {
    private configFile: string;
    private config: Config;

    constructor(configFile: string | null = null) {
        this.configFile = configFile || this._getDefaultConfigPath();
        this.config = {
            debug: false,
            outputFormat: 'text'
        };
        this.loadConfig();
    }

    private _getDefaultConfigPath(): string {
        const configDir = join(homedir(), '.config', '{{ cli.root_command.name | default(project.command_name) | default('cli') }}');
        if (!existsSync(configDir)) {
            mkdirSync(configDir, { recursive: true });
        }
        return join(configDir, 'config.yaml');
    }

    public loadConfig(): void {
        if (existsSync(this.configFile)) {
            try {
                const content = readFileSync(this.configFile, 'utf8');
                const loaded = yaml.load(content) as Config || {};
                this.config = { ...this.config, ...loaded };
            } catch (error: any) {
                console.warn(`Warning: Failed to load config from ${this.configFile}: ${error.message}`);
            }
        }
        
        // Environment variable overrides
        for (const key of Object.keys(this.config)) {
            const envKey = `{{ (cli.root_command.name | default(project.command_name) | default('cli')).upper().replace('-', '_') }}_${key.toUpperCase()}`;
            if (process.env[envKey]) {
                const value = process.env[envKey];
                this.config[key] = value === 'true' ? true : 
                                   value === 'false' ? false : 
                                   isNaN(Number(value)) ? value : Number(value);
            }
        }
    }

    public saveConfig(): boolean {
        try {
            const content = yaml.dump(this.config, { indent: 2 });
            writeFileSync(this.configFile, content, 'utf8');
            return true;
        } catch (error: any) {
            console.error(`Failed to save config: ${error.message}`);
            return false;
        }
    }

    public get<T = any>(key: string, defaultValue?: T): T {
        return (this.config[key] !== undefined ? this.config[key] : defaultValue) as T;
    }

    public set(key: string, value: any): void {
        this.config[key] = value;
    }

    public update(updates: Partial<Config>): void {
        this.config = { ...this.config, ...updates };
    }
}

// ============================================================================
// EMBEDDED ERROR HANDLER
// ============================================================================

enum ExitCode {
    SUCCESS = 0,
    GENERAL_ERROR = 1,
    USAGE_ERROR = 2,
    CONFIG_ERROR = 3,
    NETWORK_ERROR = 4,
    PERMISSION_ERROR = 5,
    FILE_NOT_FOUND = 6
}

class CliError extends Error implements CLIError {
    public exitCode: number;
    public details: Record<string, any>;

    constructor(message: string, exitCode: number = ExitCode.GENERAL_ERROR, details: Record<string, any> = {}) {
        super(message);
        this.name = 'CliError';
        this.exitCode = exitCode;
        this.details = details;
        Error.captureStackTrace(this, CliError);
    }
}

class ErrorHandlerImpl implements ErrorHandler {
    private debug: boolean;
    private verbose: boolean;

    constructor(options: { debug?: boolean; verbose?: boolean } = {}) {
        this.debug = options.debug || false;
        this.verbose = options.verbose || options.debug || false;
    }

    public handleError(error: Error | CLIError, context: string | null = null): void {
        if (this.isCliError(error)) {
            this._handleCliError(error as CLIError, context);
        } else {
            this._handleUnexpectedError(error, context);
        }
    }

    private isCliError(error: any): error is CLIError {
        return error && typeof error.exitCode === 'number' && error.details !== undefined;
    }

    private _handleCliError(error: CLIError, context: string | null): void {
        let message = chalk.red(`Error: ${error.message}`);
        if (context) {
            message = `${context}: ${message}`;
        }
        console.error(message);

        if (this.verbose && Object.keys(error.details).length > 0) {
            console.error('Additional details:');
            for (const [key, value] of Object.entries(error.details)) {
                console.error(`  ${key}: ${value}`);
            }
        }

        if (this.verbose) {
            console.error(error.stack);
        }

        process.exit(error.exitCode);
    }

    private _handleUnexpectedError(error: Error, context: string | null): void {
        let message = chalk.red(`Unexpected error: ${error.message}`);
        if (context) {
            message = `${context}: ${message}`;
        }
        console.error(message);

        if (this.verbose) {
            console.error(error.stack);
        } else {
            console.error(chalk.gray('Run with --verbose for more details'));
        }

        process.exit(ExitCode.GENERAL_ERROR);
    }

    public warn(message: string, details: Record<string, any> = {}): void {
        console.error(chalk.yellow(`Warning: ${message}`));
        if (this.verbose && Object.keys(details).length > 0) {
            for (const [key, value] of Object.entries(details)) {
                console.error(`  ${key}: ${value}`);
            }
        }
    }
}

// ============================================================================
// EMBEDDED LOGGER
// ============================================================================

const contextStorage = new AsyncLocalStorage<Record<string, any>>();

const structuredFormatter = winston.format.printf(({ timestamp, level, message, ...meta }) => {
    const context = contextStorage.getStore() || {};
    const environment = process.env.ENVIRONMENT || 'development';
    const isProduction = environment.toLowerCase() === 'production';
    
    const logData: any = {
        timestamp,
        level,
        message,
        ...meta
    };
    
    if (Object.keys(context).length > 0) {
        logData.context = context;
    }
    
    if (isProduction) {
        return JSON.stringify(logData);
    } else {
        const contextStr = Object.keys(context).length > 0 
            ? ` [${Object.entries(context).map(([k, v]) => `${k}=${v}`).join(', ')}]` 
            : '';
        
        const extraFields = Object.keys(meta).filter(key => 
            !['timestamp', 'level', 'message', 'context'].includes(key)
        );
        const extraStr = extraFields.length > 0 
            ? ` ${JSON.stringify(extraFields.reduce((acc, key) => ({ ...acc, [key]: meta[key] }), {}))}` 
            : '';
        
        return `${timestamp} ${level.toUpperCase().padEnd(8)} {{ project.name }}.${message}${contextStr}${extraStr}`;
    }
});

let logger: winston.Logger | null = null;

function setupLogging(): void {
    const logLevel = process.env.LOG_LEVEL || 'info';
    const logOutput = process.env.LOG_OUTPUT || 'stdout';
    
    const transports: winston.transport[] = [];
    
    if (logOutput === 'stderr') {
        transports.push(new winston.transports.Console({ 
            stderrLevels: ['error', 'warn', 'info', 'debug'],
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    } else if (logOutput.startsWith('file:')) {
        const logFile = logOutput.substring(5);
        const logDir = dirname(logFile);
        
        if (!existsSync(logDir)) {
            mkdirSync(logDir, { recursive: true });
        }
        
        transports.push(new winston.transports.File({
            filename: logFile,
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    } else {
        transports.push(new winston.transports.Console({
            level: 'info',
            stderrLevels: ['error', 'warn'],
            format: winston.format.combine(
                winston.format.timestamp(),
                structuredFormatter
            )
        }));
    }
    
    logger = winston.createLogger({
        level: logLevel,
        transports,
        exitOnError: false
    });
    
    logger.info(`Logging initialized: level=${logLevel}, output=${logOutput}`);
}

function getLogger(name: string = 'main'): Logger {
    if (!logger) {
        setupLogging();
    }
    
    return {
        debug: (message: string, meta: Record<string, any> = {}) => logger!.debug(message, { module: name, ...meta }),
        info: (message: string, meta: Record<string, any> = {}) => logger!.info(message, { module: name, ...meta }),
        warn: (message: string, meta: Record<string, any> = {}) => logger!.warn(message, { module: name, ...meta }),
        error: (message: string, meta: Record<string, any> = {}) => logger!.error(message, { module: name, ...meta })
    };
}

// ============================================================================
// EMBEDDED PROGRESS UTILITIES
// ============================================================================

class ProgressManager {
    private spinner: Ora | null = null;

    start(text: string): void {
        this.spinner = ora(text).start();
    }

    update(text: string): void {
        if (this.spinner) {
            this.spinner.text = text;
        }
    }

    succeed(text?: string): void {
        if (this.spinner) {
            this.spinner.succeed(text);
            this.spinner = null;
        }
    }

    fail(text?: string): void {
        if (this.spinner) {
            this.spinner.fail(text);
            this.spinner = null;
        }
    }

    stop(): void {
        if (this.spinner) {
            this.spinner.stop();
            this.spinner = null;
        }
    }
}

// ============================================================================
// EMBEDDED COMPLETION ENGINE
// ============================================================================

function generateCompletion(program: Command, shell: string = 'bash'): string {
    const commands: string[] = [];
    
    function extractCommands(cmd: Command, prefix: string = ''): void {
        const name = prefix ? `${prefix} ${cmd.name()}` : cmd.name();
        commands.push(name);
        
        cmd.commands.forEach((subCmd: Command) => {
            extractCommands(subCmd, name);
        });
    }
    
    extractCommands(program);
    
    if (shell === 'bash') {
        return `#!/bin/bash
_{{ (cli.root_command.name | default(project.command_name) | default('cli')).replace('-', '_') }}_completions() {
    local cur prev commands
    cur="\${COMP_WORDS[COMP_CWORD]}"
    prev="\${COMP_WORDS[COMP_CWORD-1]}"
    commands="${commands.join(' ')}"
    
    if [[ \${COMP_CWORD} -eq 1 ]]; then
        COMPREPLY=( $(compgen -W "\${commands}" -- \${cur}) )
    fi
}

complete -F _{{ (cli.root_command.name | default(project.command_name) | default('cli')).replace('-', '_') }}_completions {{ cli.root_command.name | default(project.command_name) | default('cli') }}`;
    }
    
    return '# Completion not implemented for this shell';
}

// ============================================================================
// HOOK SYSTEM
// ============================================================================

let hooks: HookModule | null = null;

async function loadHooks(): Promise<void> {
    try {
        const hookModule = await import('./src/hooks.js');
        hooks = hookModule as HookModule;
    } catch (error: any) {
        if (error.code === 'ERR_MODULE_NOT_FOUND') {
            console.error(chalk.red('Hook implementation not found.'));
            console.error('Please create \'src/hooks.ts\' with your command implementations.');
            console.error('Example:');
            console.error(chalk.gray(`
export async function onBuild(args: any): Promise<void> {
    console.log('Build command:', args);
}
            `));
        } else {
            console.error(chalk.red(`Failed to load hooks: ${error.message}`));
        }
        process.exit(2);
    }
}

// ============================================================================
// CLI SETUP
// ============================================================================

// Initialize components
const configManager = new ConfigManager();
const errorHandler = new ErrorHandlerImpl({ 
    verbose: configManager.get<boolean>('verbose', false),
    debug: configManager.get<boolean>('debug', false)
});
const log = getLogger('cli');
const progress = new ProgressManager();

// Create main program
const program = new Command();

program
    .name('{{ cli.root_command.name | default(project.command_name) | default('cli') }}')
    .description('{{ cli.description | default(project.description) }}')
    .version('{{ cli.version | default(project.version) | default("1.0.0") }}');

// Global options
{%- for option in cli.global_options | default([]) %}
program.option(
    '{{ option.short | default("") }}{{ ", " if option.short else "" }}{{ option.long }}{{ " <value>" if option.type != "boolean" else "" }}',
    '{{ option.description }}'
    {%- if option.default is defined %},
    {{ option.default | tojson }}
    {%- endif %}
);
{%- endfor %}

// Commands - use processed commander structure

{% if commander_commands and commander_commands.subcommands %}
  {% for cmd_data in commander_commands.subcommands %}

    {%- if cmd_data.subcommands and cmd_data.subcommands|length > 0 %}
// Command with subcommands: {{ cmd_data.name }}
const {{ cmd_data.name }}Command = program
    .command('{{ cmd_data.name }}')
    .description('{{ cmd_data.description }}')
    {%- for arg in cmd_data.arguments | default([]) %}
    .argument('{{ arg.pattern }}', '{{ arg.description }}')
    {%- endfor %}
    {%- for option in cmd_data.options | default([]) %}
    .option(
        '{{ option.flags }}',
        '{{ option.description }}'
        {%- if option.default is defined %},
        {{ option.default | tojson }}
        {%- endif %}
    )
    {%- endfor %}
    .action(async (...args: any[]) => {
        try {
            // Load hooks if not already loaded
            if (!hooks) {
                await loadHooks();
            }
            
            // Call the hook function
            const hookName = '{{ cmd_data.hook_name | default("on_" + cmd_data.name) }}';
            if (hooks && typeof (hooks as any)[hookName] === 'function') {
                await (hooks as any)[hookName](...args);
            } else {
                console.error(chalk.red(`Hook function '${hookName}' not found in src/hooks.ts`));
                process.exit(1);
            }
        } catch (error: any) {
            errorHandler.handleError(error, '{{ cmd_data.name }} command');
        }
    });

// Add subcommands
    {% for sub_data in cmd_data.subcommands %}
{{ cmd_data.name }}Command
    .command('{{ sub_data.name }}')
    .description('{{ sub_data.description }}')
    .action(async (...args: any[]) => {
        try {
            if (!hooks) {
                await loadHooks();
            }
            const hookName = '{{ sub_data.hook_name | default("on_" + sub_data.name) }}';
            if (hooks && typeof (hooks as any)[hookName] === 'function') {
                await (hooks as any)[hookName](...args);
            } else {
                console.error(chalk.red(`Hook function '${hookName}' not found in src/hooks.ts`));
                process.exit(1);
            }
        } catch (error: any) {
            errorHandler.handleError(error, '{{ sub_data.name }} command');
        }
    });
    {% endfor %}
    {%- else %}
// Simple command: {{ cmd_data.name }}
program
    .command('{{ cmd_data.name }}')
    .description('{{ cmd_data.description }}')
    {%- for arg in cmd_data.arguments | default([]) %}
    .argument('{{ arg.pattern }}', '{{ arg.description }}')
    {%- endfor %}
    {%- for option in cmd_data.options | default([]) %}
    .option(
        '{{ option.flags }}',
        '{{ option.description }}'
        {%- if option.default is defined %},
        {{ option.default | tojson }}
        {%- endif %}
    )
    {%- endfor %}
    .action(async (...args: any[]) => {
        try {
            // Load hooks if not already loaded
            if (!hooks) {
                await loadHooks();
            }
            
            // Call the hook function
            const hookName = '{{ cmd_data.hook_name | default("on_" + cmd_data.name) }}';
            if (hooks && typeof (hooks as any)[hookName] === 'function') {
                await (hooks as any)[hookName](...args);
            } else {
                console.error(chalk.red(`Hook function '${hookName}' not found in src/hooks.ts`));
                process.exit(1);
            }
        } catch (error: any) {
            errorHandler.handleError(error, '{{ cmd_data.name }} command');
        }
    });
    {%- endif %}

  {% endfor %}
{%- else %}
// No commands defined
{%- endif %}

// Interactive mode support
{%- if cli.features and cli.features.interactive_mode and cli.features.interactive_mode.enabled %}
program.option('--interactive', 'Run in interactive mode');

if (process.argv.includes('--interactive')) {
    console.log(chalk.cyan('Interactive mode is enabled but not yet implemented.'));
    console.log('This feature will be available in a future version.');
    process.exit(0);
}
{%- endif %}

// Error handlers
process.on('SIGINT', () => {
    console.error(chalk.yellow('\nOperation cancelled by user'));
    process.exit(ExitCode.GENERAL_ERROR);
});

process.on('uncaughtException', (error: Error) => {
    console.error(chalk.red('Uncaught Exception:'), error);
    process.exit(ExitCode.GENERAL_ERROR);
});

process.on('unhandledRejection', (reason: any, promise: Promise<any>) => {
    console.error(chalk.red('Unhandled Rejection at:'), promise, 'reason:', reason);
    process.exit(ExitCode.GENERAL_ERROR);
});

// Parse arguments
program.parse(process.argv);