"""

Configuration management for Goobits CLI Framework

Generated by goobits-cli

"""

import json
import os
import sys
from pathlib import Path
from typing import Any, Dict, Optional, Union

from .logging import get_logger

# Custom Exception Classes for Configuration Management


class ConfigError(Exception):
    """Base configuration error."""

    def __init__(
        self,
        message: str,
        suggestion: Optional[str] = None,
        config_path: Optional[Path] = None,
    ):
        self.message = message

        self.suggestion = suggestion

        self.config_path = config_path

        super().__init__(self.message)


class ConfigFileError(ConfigError):
    """Configuration file access or format error."""

    def __init__(
        self, message: str, config_path: Path, suggestion: Optional[str] = None
    ):
        super().__init__(message, suggestion, config_path)


class ConfigValidationError(ConfigError):
    """Configuration validation error."""

    def __init__(
        self,
        message: str,
        key: str,
        value: Any = None,
        suggestion: Optional[str] = None,
    ):
        self.key = key

        self.value = value

        super().__init__(message, suggestion)


# Optional dependencies

try:
    import yaml

    HAS_YAML = True

except ImportError:
    HAS_YAML = False

try:
    if sys.version_info >= (3, 11):
        import tomllib

    else:
        import tomli as tomllib

    HAS_TOML = True

except ImportError:
    HAS_TOML = False


class ConfigManager:
    """Configuration manager for Goobits CLI Framework"""

    def __init__(self):
        self.package_name: str = "goobits-cli"

        self.config_dir_name: str = "goobits-cli"

        self.config_file_name: str = "config.json"

        self._config: Optional[Dict[str, Any]] = None

        self._config_path: Optional[Path] = None

        self.logger = get_logger(__name__)

    def get_config_dir(self) -> Path:
        """Get the configuration directory path based on platform"""

        home_dir = Path.home()

        if os.name == "nt":  # Windows
            # Windows: Use APPDATA or fallback to home

            app_data = os.environ.get("APPDATA")

            if app_data:
                return Path(str(app_data)) / self.config_dir_name

            return home_dir / self.config_dir_name

        elif sys.platform == "darwin":  # macOS
            # macOS: Use ~/Library/Application Support

            return home_dir / "Library" / "Application Support" / self.config_dir_name

        else:  # Linux and others
            # Linux: Use XDG_CONFIG_HOME or ~/.config

            xdg_config = os.environ.get("XDG_CONFIG_HOME")

            if xdg_config:
                return Path(str(xdg_config)) / self.config_dir_name

            return home_dir / ".config" / self.config_dir_name

    def get_config_path(self) -> Path:
        """Get the full path to the configuration file"""

        if not self._config_path:
            self._config_path = self.get_config_dir() / self.config_file_name

        return self._config_path

    def ensure_config_dir(self) -> None:
        """Ensure the configuration directory exists with enhanced error handling."""

        config_dir = self.get_config_dir()

        try:
            config_dir.mkdir(parents=True, exist_ok=True)

            self.logger.debug(f"Ensured config directory exists: {config_dir}")

        except PermissionError:
            raise ConfigFileError(
                "Permission denied creating configuration directory",
                config_dir,
                f"Ensure you have write permissions for {config_dir.parent}",
            )

        except OSError as e:
            raise ConfigFileError(
                f"Failed to create configuration directory: {str(e)}",
                config_dir,
                "Check disk space and parent directory permissions",
            ) from e

    def load(self) -> Dict[str, Any]:
        """Load configuration from file with enhanced error handling."""

        config_path = self.get_config_path()

        try:
            if config_path.exists():
                try:
                    data = config_path.read_text(encoding="utf-8")

                    self._config = json.loads(data)

                    self.logger.debug(f"Loaded configuration from {config_path}")

                except json.JSONDecodeError as e:
                    raise ConfigFileError(
                        f"Invalid JSON in configuration file: {str(e)}",
                        config_path,
                        "Check the JSON syntax in your configuration file",
                    ) from e

                except PermissionError:
                    raise ConfigFileError(
                        "Permission denied reading configuration file",
                        config_path,
                        f"Ensure you have read permissions for {config_path}",
                    )

                except UnicodeDecodeError as e:
                    raise ConfigFileError(
                        f"Unable to decode configuration file: {str(e)}",
                        config_path,
                        "Ensure the file is saved with UTF-8 encoding",
                    ) from e

            else:
                # Create default config if file doesn't exist

                self._config = self.get_defaults()

                if not self.save():
                    self.logger.warning("Failed to save default configuration")

                else:
                    self.logger.info(f"Created default configuration at {config_path}")

        except ConfigError:
            raise  # Re-raise our custom errors

        except Exception as e:
            self.logger.error(f"Unexpected error loading config: {e}")

            self._config = self.get_defaults()

        return self._config

    def save(self) -> bool:
        """Save configuration to file with enhanced error handling."""

        if self._config is None:
            self.logger.warning("No configuration to save")

            return False

        try:
            self.ensure_config_dir()

            config_path = self.get_config_path()

            # Validate that config can be serialized

            try:
                json_data = json.dumps(self._config, indent=2)

            except (TypeError, ValueError) as e:
                raise ConfigValidationError(
                    f"Configuration contains non-serializable data: {str(e)}",
                    key="<root>",
                    suggestion="Remove or convert non-JSON-serializable values (functions, classes, etc.)",
                ) from e

            # Write to temp file first, then move (atomic operation)

            temp_path = config_path.with_suffix(".tmp")

            try:
                temp_path.write_text(json_data, encoding="utf-8")

                temp_path.replace(config_path)

                self.logger.debug(f"Saved configuration to {config_path}")

                return True

            except PermissionError:
                if temp_path.exists():
                    temp_path.unlink(missing_ok=True)

                raise ConfigFileError(
                    "Permission denied writing configuration file",
                    config_path,
                    f"Ensure you have write permissions for {config_path.parent}",
                )

            except OSError as e:
                if temp_path.exists():
                    temp_path.unlink(missing_ok=True)

                raise ConfigFileError(
                    f"Failed to write configuration file: {str(e)}",
                    config_path,
                    "Check disk space and file permissions",
                ) from e

        except ConfigError:
            raise  # Re-raise our custom errors

        except Exception as e:
            self.logger.error(f"Unexpected error saving config: {e}")

            return False

    def get(self, key: str, default_value: Any = None) -> Any:
        """Get configuration value by key (supports nested keys with dot notation)"""

        if not self._config:
            self.load()

        if not key:
            return self._config

        # Support nested keys (e.g., 'api.endpoint')

        keys = key.split(".")

        value = self._config

        for k in keys:
            if isinstance(value, dict) and k in value:
                value = value[k]

            else:
                return default_value

        return value

    def set(self, key: str, value: Any) -> bool:
        """Set configuration value by key with validation (supports nested keys with dot notation)."""

        if not key:
            raise ConfigValidationError(
                "Configuration key cannot be empty",
                key="<empty>",
                suggestion="Provide a valid configuration key",
            )

        if not self._config:
            self.load()

        # Validate the value can be serialized

        try:
            json.dumps(value)

        except (TypeError, ValueError) as e:
            raise ConfigValidationError(
                f"Configuration value is not JSON serializable: {str(e)}",
                key=key,
                value=str(value),
                suggestion="Use only JSON-compatible types (str, int, float, bool, list, dict)",
            ) from e

        keys = key.split(".")

        if self._config is None:
            raise RuntimeError("Configuration not loaded")
        current = self._config

        # Navigate to the nested location

        for i in range(len(keys) - 1):
            k = keys[i]

            if k not in current or not isinstance(current[k], dict):
                current[k] = {}

            current = current[k]

        # Set the value

        old_value = current.get(keys[-1])

        current[keys[-1]] = value

        # Auto-save with rollback on failure

        if not self.save():
            # Rollback the change

            if old_value is not None:
                current[keys[-1]] = old_value

            else:
                current.pop(keys[-1], None)

            return False

        self.logger.debug(f"Set configuration {key} = {value}")

        return True

    def delete(self, key: str) -> bool:
        """Delete configuration value by key"""

        if not self._config:
            self.load()

        keys = key.split(".")

        if self._config is None:
            raise RuntimeError("Configuration not loaded")
        current = self._config

        # Navigate to the parent of the key to delete

        for i in range(len(keys) - 1):
            k = keys[i]

            if k not in current or not isinstance(current[k], dict):
                return False  # Key doesn't exist

            current = current[k]

        # Delete the key

        if keys[-1] in current:
            del current[keys[-1]]

            # Auto-save

            return self.save()

        return False

    def reset(self) -> bool:
        """Reset configuration to defaults"""

        self._config = self.get_defaults()

        return self.save()

    def get_defaults(self) -> Dict[str, Any]:
        """Get default configuration"""

        return {
            "version": "1.0.0",
            # Add your default configuration here
        }

    def merge_with_env(self) -> None:
        """Merge configuration with environment variables"""

        prefix = "GOOBITS_CLI_"

        for key, value in os.environ.items():
            if key.startswith(prefix):
                config_key = key[len(prefix) :].lower().replace("_", ".")

                # Try to parse as JSON, fallback to string

                try:
                    parsed_value = json.loads(value)

                except json.JSONDecodeError:
                    parsed_value = value

                self.set(config_key, parsed_value)


class RCConfigLoader(ConfigManager):
    """Configuration loader that supports RC files in multiple formats"""

    def __init__(self):
        super().__init__()

        self.rc_file_names = [
            f".{self.package_name}rc",
            f".{self.package_name}rc.json",
            f".{self.package_name}rc.yaml",
            f".{self.package_name}rc.yml",
            f".{self.package_name}rc.toml",
            f"{self.package_name}.config.json",
            f"{self.package_name}.config.yaml",
            f"{self.package_name}.config.yml",
            f"{self.package_name}.config.toml",
        ]

    def find_rc_file(
        self, start_dir: Optional[Union[str, Path]] = None
    ) -> Optional[Path]:
        """Find RC file in current directory or parent directories"""

        if start_dir is None:
            start_dir = Path.cwd()

        else:
            start_dir = Path(start_dir)

        current_dir = start_dir

        # Also check home directory

        search_dirs = []

        # Walk up the directory tree

        while current_dir != current_dir.parent:
            search_dirs.append(current_dir)

            current_dir = current_dir.parent

        # Add home directory

        search_dirs.append(Path.home())

        for directory in search_dirs:
            for file_name in self.rc_file_names:
                file_path: Path = directory / file_name

                if file_path.exists() and file_path.is_file():
                    return file_path

        return None

    def load_rc_file(self, rc_path: Optional[Path] = None) -> Optional[Dict[str, Any]]:
        """Load configuration from RC file"""

        if rc_path is None:
            rc_path = self.find_rc_file()

        if not rc_path or not rc_path.exists():
            return None

        try:
            content = rc_path.read_text(encoding="utf-8")

            suffix = rc_path.suffix.lower()

            if suffix in [".yaml", ".yml"]:
                if not HAS_YAML:
                    self.logger.warning(
                        "PyYAML not installed. Install it to use YAML config files: "
                        "pip install PyYAML"
                    )

                    return None

                result = yaml.safe_load(content)
                return dict(result) if isinstance(result, dict) else None

            elif suffix == ".toml":
                if not HAS_TOML:
                    self.logger.warning(
                        "tomli/tomllib not available. Install tomli for Python < 3.11: "
                        "pip install tomli"
                    )

                    return None

                result = tomllib.loads(content)
                return dict(result) if isinstance(result, dict) else None

            else:
                # Default to JSON

                result = json.loads(content)
                return dict(result) if isinstance(result, dict) else None

        except json.JSONDecodeError as e:
            raise ConfigFileError(
                f"Invalid JSON in RC file: {str(e)}",
                rc_path,
                "Check the JSON syntax in your RC file",
            ) from e

        except Exception as e:
            self.logger.error(f"Error loading RC file {rc_path}: {e}")

            return None

    def load(self) -> Dict[str, Any]:
        """Enhanced load method that checks RC files first"""

        # First try RC file

        rc_config = self.load_rc_file()

        if rc_config:
            defaults = self.get_defaults()

            # Merge defaults with RC config (RC config takes precedence)

            self._config = {**defaults, **rc_config}

            return self._config

        # Fall back to regular config file

        return super().load()


# Create singleton instance

config_manager = RCConfigLoader()


def get_config() -> RCConfigLoader:
    """Get the global configuration manager instance"""

    return config_manager


def load_config() -> Dict[str, Any]:
    """Load and return configuration"""

    return config_manager.load()


def get_config_value(key: str, default: Any = None) -> Any:
    """Get a configuration value"""

    return config_manager.get(key, default)


def set_config_value(key: str, value: Any) -> bool:
    """Set a configuration value"""

    return config_manager.set(key, value)
