"""
Language-Specific Configuration Adapters
=======================================

This module contains the language-specific code generators for configuration
management, extracted from the config_manager.j2 template.
"""

from abc import ABC, abstractmethod
from typing import Any, List
from .config_framework import ConfigSchema, ConfigProperty


class ConfigAdapter(ABC):
    """Abstract base class for language-specific config adapters."""
    
    @abstractmethod
    def generate_code(self, config_schema: ConfigSchema) -> str:
        """Generate language-specific configuration management code."""
        pass
    
    @abstractmethod
    def get_import_statements(self, config_schema: ConfigSchema) -> str:
        """Generate import statements for configuration management."""
        pass
    
    @abstractmethod
    def get_config_class(self, config_schema: ConfigSchema) -> str:
        """Generate configuration data class/structure."""
        pass
    
    @abstractmethod
    def get_manager_class(self, config_schema: ConfigSchema) -> str:
        """Generate configuration manager class."""
        pass


class PythonConfigAdapter(ConfigAdapter):
    """
    Python configuration adapter extracted from lines 12-123 of config_manager.j2.
    
    Generates Python configuration management using dataclasses, pathlib, and yaml.
    """
    
    def generate_code(self, config_schema: ConfigSchema) -> str:
        """Generate complete Python configuration management implementation."""
        
        imports = self.get_import_statements(config_schema)
        config_class = self.get_config_class(config_schema)
        manager_class = self.get_manager_class(config_schema)
        
        return f'''"""
Configuration management for {config_schema.config_dir_name}.

This module provides configuration loading from files and environment variables.
Generated by Goobits Config Framework v3.0.1
"""

{imports}

{config_class}

{manager_class}
'''
    
    def get_import_statements(self, config_schema: ConfigSchema) -> str:
        """Generate Python import statements."""
        imports = [
            "import os",
            "import json",
            "from pathlib import Path",
            "from typing import Dict, Any, Optional",
            "from dataclasses import dataclass, asdict"
        ]
        
        if config_schema.format.value in ['yaml', 'yml']:
            imports.append("import yaml")
        
        return "\n".join(imports)
    
    def get_config_class(self, config_schema: ConfigSchema) -> str:
        """Generate Python Config dataclass."""
        
        fields = []
        for prop in config_schema.properties:
            python_type = self._get_python_type(prop.type)
            default_value = self._format_python_default(prop.default, prop.type)
            
            if prop.description:
                fields.append(f"    # {prop.description}")
            fields.append(f"    {prop.name}: {python_type} = {default_value}")
        
        return f'''@dataclass
class Config:
    """Configuration data structure."""
    
{chr(10).join(fields) if fields else "    pass"}'''
    
    def get_manager_class(self, config_schema: ConfigSchema) -> str:
        """Generate Python ConfigManager class."""
        
        config_file_ext = config_schema.format.value
        env_prefix = config_schema.env_prefix
        
        return f'''class ConfigManager:
    """Manages configuration loading and saving."""
    
    def __init__(self, config_file: Optional[str] = None):
        self.config_file = config_file or self._get_default_config_path()
        self.config = Config()
        self.load_config()
    
    def _get_default_config_path(self) -> str:
        """Get the default configuration file path."""
        config_dir = Path.home() / ".config" / "{config_schema.config_dir_name}"
        config_dir.mkdir(parents=True, exist_ok=True)
        return str(config_dir / "config.{config_file_ext}")
    
    def load_config(self) -> None:
        """Load configuration from file and environment variables."""
        # Load from config file if it exists
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    if self.config_file.endswith('.json'):
                        data = json.load(f)
                    else:
                        data = yaml.safe_load(f)
                
                if data:
                    for key, value in data.items():
                        if hasattr(self.config, key):
                            setattr(self.config, key, value)
            except Exception as e:
                print(f"Warning: Failed to load config file {{self.config_file}}: {{e}}")
        
        # Override with environment variables
        env_prefix = "{env_prefix}_"
        for key in asdict(self.config).keys():
            env_key = f"{{env_prefix}}{{key.upper()}}"
            if env_key in os.environ:
                value = os.environ[env_key]
                # Convert string values to appropriate types
                if hasattr(self.config, key):
                    current_value = getattr(self.config, key)
                    if isinstance(current_value, bool):
                        value = value.lower() in ('true', '1', 'yes', 'on')
                    elif isinstance(current_value, int):
                        value = int(value)
                    elif isinstance(current_value, float):
                        value = float(value)
                    setattr(self.config, key, value)
    
    def save_config(self) -> bool:
        """Save configuration to file."""
        try:
            config_data = asdict(self.config)
            with open(self.config_file, 'w') as f:
                if self.config_file.endswith('.json'):
                    json.dump(config_data, f, indent=2)
                else:
                    yaml.safe_dump(config_data, f, default_flow_style=False)
            return True
        except Exception as e:
            print(f"Failed to save config: {{e}}")
            return False
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get configuration value."""
        return getattr(self.config, key, default)
    
    def set(self, key: str, value: Any) -> None:
        """Set configuration value."""
        if hasattr(self.config, key):
            setattr(self.config, key, value)
        else:
            raise KeyError(f"Unknown configuration key: {{key}}")
    
    def update(self, **kwargs) -> None:
        """Update multiple configuration values."""
        for key, value in kwargs.items():
            self.set(key, value)'''
    
    def _get_python_type(self, prop_type: str) -> str:
        """Convert generic type to Python type annotation."""
        type_map = {
            'str': 'str',
            'string': 'str', 
            'int': 'int',
            'integer': 'int',
            'float': 'float',
            'number': 'float',
            'bool': 'bool',
            'boolean': 'bool',
            'list': 'List[Any]',
            'array': 'List[Any]',
            'dict': 'Dict[str, Any]',
            'object': 'Dict[str, Any]'
        }
        return type_map.get(prop_type, 'Any')
    
    def _format_python_default(self, value: Any, prop_type: str) -> str:
        """Format default value for Python code."""
        if value is None:
            return "None"
        elif isinstance(value, str):
            return repr(value)
        elif isinstance(value, bool):
            return str(value)
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, list):
            return str(value)
        elif isinstance(value, dict):
            return str(value)
        else:
            return repr(value)


class NodeJSConfigAdapter(ConfigAdapter):
    """
    Node.js configuration adapter extracted from lines 124-244 of config_manager.j2.
    
    Generates Node.js configuration management using ES6 classes and js-yaml.
    """
    
    def generate_code(self, config_schema: ConfigSchema) -> str:
        """Generate complete Node.js configuration management implementation."""
        
        imports = self.get_import_statements(config_schema)
        manager_class = self.get_manager_class(config_schema)
        
        return f'''/**
 * Configuration management for {config_schema.config_dir_name}
 * Generated by Goobits Config Framework v3.0.1
 */

{imports}

{manager_class}

module.exports = {{ ConfigManager }};'''
    
    def get_import_statements(self, config_schema: ConfigSchema) -> str:
        """Generate Node.js import statements."""
        imports = [
            "const fs = require('fs');",
            "const path = require('path');",
            "const os = require('os');"
        ]
        
        if config_schema.format.value in ['yaml', 'yml']:
            imports.append("const yaml = require('js-yaml');")
        
        return "\n".join(imports)
    
    def get_config_class(self, config_schema: ConfigSchema) -> str:
        """Generate Node.js config object."""
        # Node.js doesn't need a separate config class, 
        # properties are defined in constructor
        return ""
    
    def get_manager_class(self, config_schema: ConfigSchema) -> str:
        """Generate Node.js ConfigManager class."""
        
        # Generate default config object
        default_config = []
        for prop in config_schema.properties:
            js_value = self._format_js_default(prop.default, prop.type)
            comment = f" // {prop.description}" if prop.description else ""
            default_config.append(f"            {prop.name}: {js_value},{comment}")
        
        config_obj = "\n".join(default_config) if default_config else "            // No configuration properties defined"
        config_file_ext = config_schema.format.value
        env_prefix = config_schema.env_prefix
        
        return f'''class ConfigManager {{
    constructor(configFile = null) {{
        this.configFile = configFile || this._getDefaultConfigPath();
        this.config = {{
{config_obj}
        }};
        this.loadConfig();
    }}

    _getDefaultConfigPath() {{
        const configDir = path.join(os.homedir(), '.config', '{config_schema.config_dir_name}');
        if (!fs.existsSync(configDir)) {{
            fs.mkdirSync(configDir, {{ recursive: true }});
        }}
        return path.join(configDir, 'config.{config_file_ext}');
    }}

    loadConfig() {{
        // Load from config file if it exists
        if (fs.existsSync(this.configFile)) {{
            try {{
                const content = fs.readFileSync(this.configFile, 'utf8');
                let data;
                
                if (this.configFile.endsWith('.json')) {{
                    data = JSON.parse(content);
                }} else {{
                    data = yaml.load(content);
                }}
                
                if (data) {{
                    Object.assign(this.config, data);
                }}
            }} catch (error) {{
                console.warn(`Warning: Failed to load config file ${{this.configFile}}: ${{error.message}}`);
            }}
        }}
        
        // Override with environment variables
        const envPrefix = '{env_prefix}_';
        Object.keys(this.config).forEach(key => {{
            const envKey = `${{envPrefix}}${{key.toUpperCase()}}`;
            if (process.env[envKey]) {{
                let value = process.env[envKey];
                // Convert string values to appropriate types
                const currentValue = this.config[key];
                if (typeof currentValue === 'boolean') {{
                    value = ['true', '1', 'yes', 'on'].includes(value.toLowerCase());
                }} else if (typeof currentValue === 'number') {{
                    value = Number(value);
                }}
                this.config[key] = value;
            }}
        }});
    }}

    saveConfig() {{
        try {{
            let content;
            if (this.configFile.endsWith('.json')) {{
                content = JSON.stringify(this.config, null, 2);
            }} else {{
                content = yaml.dump(this.config);
            }}
            fs.writeFileSync(this.configFile, content, 'utf8');
            return true;
        }} catch (error) {{
            console.error(`Failed to save config: ${{error.message}}`);
            return false;
        }}
    }}

    get(key, defaultValue = null) {{
        return this.config[key] !== undefined ? this.config[key] : defaultValue;
    }}

    set(key, value) {{
        if (key in this.config) {{
            this.config[key] = value;
        }} else {{
            throw new Error(`Unknown configuration key: ${{key}}`);
        }}
    }}

    update(values) {{
        Object.keys(values).forEach(key => {{
            this.set(key, values[key]);
        }});
    }}
}}'''
    
    def _format_js_default(self, value: Any, prop_type: str) -> str:
        """Format default value for JavaScript code."""
        if value is None:
            return "null"
        elif isinstance(value, str):
            return f"'{value}'"
        elif isinstance(value, bool):
            return str(value).lower()
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, list):
            return str(value).replace("'", '"')
        elif isinstance(value, dict):
            return str(value).replace("'", '"')
        else:
            return f"'{value}'"


class TypeScriptConfigAdapter(ConfigAdapter):
    """
    TypeScript configuration adapter extracted from lines 245-378 of config_manager.j2.
    
    Generates TypeScript configuration management with type definitions and interfaces.
    """
    
    def generate_code(self, config_schema: ConfigSchema) -> str:
        """Generate complete TypeScript configuration management implementation."""
        
        imports = self.get_import_statements(config_schema)
        config_interface = self.get_config_interface(config_schema)
        manager_class = self.get_manager_class(config_schema)
        
        return f'''/**
 * Configuration management for {config_schema.config_dir_name}
 * Generated by Goobits Config Framework v3.0.1
 */

{imports}

{config_interface}

{manager_class}

export {{ ConfigManager, Config }};'''
    
    def get_import_statements(self, config_schema: ConfigSchema) -> str:
        """Generate TypeScript import statements."""
        imports = [
            "import * as fs from 'fs';",
            "import * as path from 'path';",
            "import * as os from 'os';"
        ]
        
        if config_schema.format.value in ['yaml', 'yml']:
            imports.append("import * as yaml from 'js-yaml';")
        
        return "\n".join(imports)
    
    def get_config_class(self, config_schema: ConfigSchema) -> str:
        """TypeScript uses interfaces instead of classes for config structure."""
        return self.get_config_interface(config_schema)
    
    def get_config_interface(self, config_schema: ConfigSchema) -> str:
        """Generate TypeScript Config interface."""
        
        properties = []
        for prop in config_schema.properties:
            ts_type = self._get_typescript_type(prop.type)
            optional = "" if prop.required else "?"
            comment = f"  /** {prop.description} */" if prop.description else ""
            
            if comment:
                properties.append(comment)
            properties.append(f"  {prop.name}{optional}: {ts_type};")
        
        return f'''interface Config {{
{chr(10).join(properties) if properties else "  // No configuration properties defined"}
}}'''
    
    def get_manager_class(self, config_schema: ConfigSchema) -> str:
        """Generate TypeScript ConfigManager class."""
        
        # Generate default config object
        default_config = []
        for prop in config_schema.properties:
            ts_value = self._format_ts_default(prop.default, prop.type)
            comment = f" // {prop.description}" if prop.description else ""
            default_config.append(f"      {prop.name}: {ts_value},{comment}")
        
        config_obj = "\n".join(default_config) if default_config else "      // No configuration properties defined"
        config_file_ext = config_schema.format.value
        env_prefix = config_schema.env_prefix
        
        return f'''class ConfigManager {{
    private configFile: string;
    public config: Config;

    constructor(configFile?: string) {{
        this.configFile = configFile || this.getDefaultConfigPath();
        this.config = {{
{config_obj}
        }};
        this.loadConfig();
    }}

    private getDefaultConfigPath(): string {{
        const configDir = path.join(os.homedir(), '.config', '{config_schema.config_dir_name}');
        if (!fs.existsSync(configDir)) {{
            fs.mkdirSync(configDir, {{ recursive: true }});
        }}
        return path.join(configDir, 'config.{config_file_ext}');
    }}

    loadConfig(): void {{
        // Load from config file if it exists
        if (fs.existsSync(this.configFile)) {{
            try {{
                const content = fs.readFileSync(this.configFile, 'utf8');
                let data: any;
                
                if (this.configFile.endsWith('.json')) {{
                    data = JSON.parse(content);
                }} else {{
                    data = yaml.load(content);
                }}
                
                if (data) {{
                    Object.assign(this.config, data);
                }}
            }} catch (error) {{
                console.warn(`Warning: Failed to load config file ${{this.configFile}}: ${{error}}`);
            }}
        }}
        
        // Override with environment variables
        const envPrefix = '{env_prefix}_';
        Object.keys(this.config).forEach((key: string) => {{
            const envKey = `${{envPrefix}}${{key.toUpperCase()}}`;
            if (process.env[envKey]) {{
                let value: any = process.env[envKey];
                // Convert string values to appropriate types
                const currentValue = (this.config as any)[key];
                if (typeof currentValue === 'boolean') {{
                    value = ['true', '1', 'yes', 'on'].includes(value.toLowerCase());
                }} else if (typeof currentValue === 'number') {{
                    value = Number(value);
                }}
                (this.config as any)[key] = value;
            }}
        }});
    }}

    saveConfig(): boolean {{
        try {{
            let content: string;
            if (this.configFile.endsWith('.json')) {{
                content = JSON.stringify(this.config, null, 2);
            }} else {{
                content = yaml.dump(this.config);
            }}
            fs.writeFileSync(this.configFile, content, 'utf8');
            return true;
        }} catch (error) {{
            console.error(`Failed to save config: ${{error}}`);
            return false;
        }}
    }}

    get<K extends keyof Config>(key: K): Config[K];
    get(key: string, defaultValue?: any): any {{
        return (this.config as any)[key] !== undefined ? (this.config as any)[key] : defaultValue;
    }}

    set<K extends keyof Config>(key: K, value: Config[K]): void;
    set(key: string, value: any): void {{
        if (key in this.config) {{
            (this.config as any)[key] = value;
        }} else {{
            throw new Error(`Unknown configuration key: ${{key}}`);
        }}
    }}

    update(values: Partial<Config>): void {{
        Object.keys(values).forEach(key => {{
            this.set(key, (values as any)[key]);
        }});
    }}
}}'''
    
    def _get_typescript_type(self, prop_type: str) -> str:
        """Convert generic type to TypeScript type annotation."""
        type_map = {
            'str': 'string',
            'string': 'string',
            'int': 'number', 
            'integer': 'number',
            'float': 'number',
            'number': 'number',
            'bool': 'boolean',
            'boolean': 'boolean',
            'list': 'any[]',
            'array': 'any[]',
            'dict': 'Record<string, any>',
            'object': 'Record<string, any>'
        }
        return type_map.get(prop_type, 'any')
    
    def _format_ts_default(self, value: Any, prop_type: str) -> str:
        """Format default value for TypeScript code."""
        if value is None:
            return "null"
        elif isinstance(value, str):
            return f"'{value}'"
        elif isinstance(value, bool):
            return str(value).lower()
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, list):
            return str(value).replace("'", '"')
        elif isinstance(value, dict):
            return str(value).replace("'", '"')
        else:
            return f"'{value}'"


class RustConfigAdapter(ConfigAdapter):
    """
    Rust configuration adapter extracted from lines 379-524 of config_manager.j2.
    
    Generates Rust configuration management using serde and structs.
    """
    
    def generate_code(self, config_schema: ConfigSchema) -> str:
        """Generate complete Rust configuration management implementation."""
        
        imports = self.get_import_statements(config_schema)
        config_struct = self.get_config_struct(config_schema)
        manager_impl = self.get_manager_impl(config_schema)
        
        return f'''//! Configuration management for {config_schema.config_dir_name}
//! Generated by Goobits Config Framework v3.0.1

{imports}

{config_struct}

{manager_impl}'''
    
    def get_import_statements(self, config_schema: ConfigSchema) -> str:
        """Generate Rust import statements."""
        imports = [
            "use serde::{Deserialize, Serialize};",
            "use std::collections::HashMap;",
            "use std::env;",
            "use std::fs;", 
            "use std::path::PathBuf;"
        ]
        
        if config_schema.format.value in ['yaml', 'yml']:
            imports.append("use serde_yaml;")
        elif config_schema.format.value == 'toml':
            imports.append("use toml;")
        
        return "\n".join(imports)
    
    def get_config_class(self, config_schema: ConfigSchema) -> str:
        """Rust uses structs instead of classes."""
        return self.get_config_struct(config_schema)
    
    def get_config_struct(self, config_schema: ConfigSchema) -> str:
        """Generate Rust Config struct."""
        
        fields = []
        for prop in config_schema.properties:
            rust_type = self._get_rust_type(prop.type)
            comment = f"    /// {prop.description}" if prop.description else ""
            
            if comment:
                fields.append(comment)
            fields.append(f"    pub {prop.name}: {rust_type},")
        
        # Generate Default implementation
        defaults = []
        for prop in config_schema.properties:
            rust_value = self._format_rust_default(prop.default, prop.type)
            defaults.append(f"            {prop.name}: {rust_value},")
        
        return f'''#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Config {{
{chr(10).join(fields) if fields else "    // No configuration properties defined"}
}}

impl Default for Config {{
    fn default() -> Self {{
        Self {{
{chr(10).join(defaults) if defaults else "            // No default values"}
        }}
    }}
}}'''
    
    def get_manager_class(self, config_schema: ConfigSchema) -> str:
        """Generate Rust ConfigManager implementation.""" 
        return self.get_manager_impl(config_schema)
    
    def get_manager_impl(self, config_schema: ConfigSchema) -> str:
        """Generate Rust ConfigManager impl."""
        
        config_file_ext = config_schema.format.value
        env_prefix = config_schema.env_prefix
        
        # Format loading logic based on file format
        if config_schema.format.value in ['yaml', 'yml']:
            parse_logic = "serde_yaml::from_str(&content)"
        elif config_schema.format.value == 'toml':
            parse_logic = "toml::from_str(&content)"
        else:  # JSON
            parse_logic = "serde_json::from_str(&content)"
        
        return f'''pub struct ConfigManager {{
    config_file: PathBuf,
    pub config: Config,
}}

impl ConfigManager {{
    pub fn new(config_file: Option<PathBuf>) -> Self {{
        let config_file = config_file.unwrap_or_else(|| Self::get_default_config_path());
        let mut manager = Self {{
            config_file,
            config: Config::default(),
        }};
        manager.load_config();
        manager
    }}

    fn get_default_config_path() -> PathBuf {{
        let home_dir = env::var("HOME").unwrap_or_else(|_| "/tmp".to_string());
        let mut config_dir = PathBuf::from(home_dir);
        config_dir.push(".config");
        config_dir.push("{config_schema.config_dir_name}");
        
        if let Err(e) = fs::create_dir_all(&config_dir) {{
            eprintln!("Warning: Failed to create config directory: {{}}", e);
        }}
        
        config_dir.push("config.{config_file_ext}")
    }}

    pub fn load_config(&mut self) {{
        // Load from config file if it exists
        if self.config_file.exists() {{
            match fs::read_to_string(&self.config_file) {{
                Ok(content) => {{
                    match {parse_logic} {{
                        Ok(config) => self.config = config,
                        Err(e) => eprintln!("Warning: Failed to parse config file: {{}}", e),
                    }}
                }}
                Err(e) => eprintln!("Warning: Failed to read config file: {{}}", e),
            }}
        }}
        
        // Override with environment variables
        let env_prefix = "{env_prefix}_";
        for (key, value) in env::vars() {{
            if let Some(config_key) = key.strip_prefix(env_prefix) {{
                self.set_env_value(config_key.to_lowercase().as_str(), &value);
            }}
        }}
    }}

    fn set_env_value(&mut self, key: &str, value: &str) {{
        match key {{
{self._generate_env_setters(config_schema.properties)}
            _ => {{}} // Unknown environment variable
        }}
    }}

    pub fn save_config(&self) -> Result<(), Box<dyn std::error::Error>> {{
        let content = match "{config_file_ext}" {{
            "yaml" | "yml" => serde_yaml::to_string(&self.config)?,
            "toml" => toml::to_string(&self.config)?,
            _ => serde_json::to_string_pretty(&self.config)?,
        }};
        fs::write(&self.config_file, content)?;
        Ok(())
    }}

    pub fn get<T>(&self) -> &T
    where
        T: ?Sized,
        Config: AsRef<T>,
    {{
        self.config.as_ref()
    }}

    pub fn set_debug(&mut self, value: bool) {{
        self.config.debug = value;
    }}
}}'''
    
    def _get_rust_type(self, prop_type: str) -> str:
        """Convert generic type to Rust type annotation."""
        type_map = {
            'str': 'String',
            'string': 'String',
            'int': 'i32',
            'integer': 'i32', 
            'float': 'f64',
            'number': 'f64',
            'bool': 'bool',
            'boolean': 'bool',
            'list': 'Vec<String>',
            'array': 'Vec<String>',
            'dict': 'HashMap<String, String>',
            'object': 'HashMap<String, String>'
        }
        return type_map.get(prop_type, 'String')
    
    def _format_rust_default(self, value: Any, prop_type: str) -> str:
        """Format default value for Rust code."""
        if value is None:
            return "Default::default()"
        elif isinstance(value, str):
            return f'"{value}".to_string()'
        elif isinstance(value, bool):
            return str(value).lower()
        elif isinstance(value, (int, float)):
            return str(value)
        elif isinstance(value, list):
            if not value:
                return "Vec::new()"
            else:
                items = [f'"{item}".to_string()' if isinstance(item, str) else str(item) for item in value]
                return f"vec![{', '.join(items)}]"
        elif isinstance(value, dict):
            if not value:
                return "HashMap::new()"
            else:
                return "HashMap::new()  // TODO: populate with default values"
        else:
            return f'"{value}".to_string()'
    
    def _generate_env_setters(self, properties: List[ConfigProperty]) -> str:
        """Generate environment variable setters for each property."""
        setters = []
        for prop in properties:
            if prop.type in ['bool', 'boolean']:
                setters.append(f'''            "{prop.name}" => {{
                self.config.{prop.name} = ["true", "1", "yes", "on"].contains(&value.to_lowercase().as_str());
            }}''')
            elif prop.type in ['int', 'integer']:
                setters.append(f'''            "{prop.name}" => {{
                if let Ok(val) = value.parse::<i32>() {{
                    self.config.{prop.name} = val;
                }}
            }}''')
            elif prop.type in ['float', 'number']:
                setters.append(f'''            "{prop.name}" => {{
                if let Ok(val) = value.parse::<f64>() {{
                    self.config.{prop.name} = val;
                }}
            }}''')
            else:  # String or other types
                setters.append(f'''            "{prop.name}" => {{
                self.config.{prop.name} = value.to_string();
            }}''')
        
        return "\n".join(setters) if setters else "            // No configuration properties to set"