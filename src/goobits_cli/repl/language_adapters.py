"""
Language Adapters
=================

Language-specific REPL adapters extracted from repl_loop.j2 template.
Each adapter generates REPL integration code for its target language.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any


class REPLAdapter(ABC):
    """Base class for language-specific REPL adapters."""
    
    def __init__(self, language: str):
        self.language = language
    
    @abstractmethod
    def generate_repl_code(self, config: Dict[str, Any]) -> str:
        """Generate REPL code for the language."""
        pass
    
    @abstractmethod
    def generate_session_manager_code(self, config: Dict[str, Any]) -> str:
        """Generate session management code for the language."""
        pass


class PythonREPLAdapter(REPLAdapter):
    """Python REPL adapter."""
    
    def __init__(self):
        super().__init__('python')
    
    def generate_repl_code(self, config: Dict[str, Any]) -> str:
        """Generate Python REPL code."""
        project_name = config.get('project', {}).get('name', 'CLI')
        cli_name = project_name.lower().replace(' ', '-').replace('_', '-')
        class_name = project_name.replace('-', '').replace(' ', '').title()
        
        # Build command information
        commands = config.get('cli', {}).get('commands', {})
        command_lines = []
        for cmd_name, cmd_data in commands.items():
            hook_name = cmd_data.get('hook_name', f"on_{cmd_name.replace('-', '_')}")
            command_lines.extend([
                f'            "{cmd_name}": {{',
                f'                "description": "{cmd_data.get("description", "No description")}",',
                f'                "hook_name": "{hook_name}",',
                f'                "arguments": {cmd_data.get("arguments", [])},',
                f'                "options": {cmd_data.get("options", [])}',
                '            },'
            ])
        
        return f'''#!/usr/bin/env python3
"""
Enhanced REPL for {project_name}
Generated by Goobits CLI Framework
"""

import sys
import os
import time
from typing import Dict, List, Any, Optional

# REPL Framework imports
try:
    import readline
    READLINE_AVAILABLE = True
except ImportError:
    READLINE_AVAILABLE = False

try:
    from .{cli_name.replace("-", "_")}_cli import cli
    from .hooks import *  # Import all hook functions
except ImportError:
    # Fallback imports
    from {cli_name.replace("-", "_")}_cli import cli
    try:
        from hooks import *
    except ImportError:
        pass


class {class_name}REPL:
    """Enhanced REPL with multi-line support and smart completion."""
    
    def __init__(self, cli_config: Dict[str, Any]):
        self.cli_config = cli_config
        self.prompt = "{cli_name}> "
        self.continuation_prompt = "{cli_name}... "
        self.multi_line_buffer = ""
        self.is_multi_line = False
        self.session_vars = {{}}
        self.command_count = 0
        
        # Setup readline if available
        if READLINE_AVAILABLE:
            self._setup_readline()
    
    def _setup_readline(self):
        """Setup readline for enhanced input handling."""
        history_file = os.path.expanduser("~/.{cli_name}_repl_history")
        
        # Load history
        try:
            if os.path.exists(history_file):
                readline.read_history_file(history_file)
        except (OSError, IOError):
            pass
        
        # Save history on exit
        import atexit
        atexit.register(lambda: readline.write_history_file(history_file) if READLINE_AVAILABLE else None)
        
        # Setup completion
        readline.set_completer(self._completer)
        readline.parse_and_bind("tab: complete")
        readline.set_history_length(1000)
    
    def _completer(self, text: str, state: int):
        """Provide tab completion for commands."""
        if state == 0:
            commands = list(self.cli_config.get("commands", {{}}).keys())
            commands.extend(["help", "exit", "quit", "history"])
            self.matches = [cmd for cmd in commands if cmd.startswith(text)]
        
        try:
            return self.matches[state]
        except IndexError:
            return None
    
    def run(self):
        """Start the REPL loop."""
        print(f"Welcome to {project_name} Enhanced REPL mode.")
        print("Features: Multi-line commands (\\\\), Tab completion, Command history")
        print("Type 'help' for commands, 'exit' to quit.")
        print()
        
        while True:
            try:
                if self.is_multi_line:
                    line = input(self.continuation_prompt)
                else:
                    line = input(self.prompt)
                
                if not self._handle_input(line):
                    break
                    
            except (EOFError, KeyboardInterrupt):
                print("\\nGoodbye!")
                break
            except Exception as e:
                print(f"Error: {{e}}")
    
    def _handle_input(self, line: str) -> bool:
        """Handle a line of input. Returns False to exit."""
        line = line.strip()
        
        if not line:
            return True
        
        # Handle multi-line continuation
        if line.endswith("\\\\"):
            self.multi_line_buffer += line[:-1] + " "
            self.is_multi_line = True
            return True
        
        # Complete multi-line command
        if self.is_multi_line:
            line = self.multi_line_buffer + line
            self.multi_line_buffer = ""
            self.is_multi_line = False
        
        # Handle builtin commands
        if line in ("exit", "quit"):
            return False
        elif line == "help":
            self._show_help()
            return True
        elif line == "history":
            self._show_history()
            return True
        elif line.startswith("!"):
            self._execute_system_command(line[1:])
            return True
        
        # Execute CLI command
        self._execute_command(line)
        return True
    
    def _execute_command(self, command_line: str):
        """Execute a CLI command."""
        self.command_count += 1
        start_time = time.time()
        
        try:
            tokens = command_line.split()
            if not tokens:
                return
            
            command_name = tokens[0]
            args = tokens[1:]
            
            commands = self.cli_config.get("commands", {{}})
            if command_name not in commands:
                print(f"Unknown command: {{command_name}}")
                print("Type 'help' for available commands")
                return
            
            cmd_info = commands[command_name]
            hook_name = cmd_info.get("hook_name", f"on_{{command_name.replace('-', '_')}}")
            
            if hook_name in globals():
                hook_func = globals()[hook_name]
                result = self._call_hook(hook_func, args)
                
                if result is not None:
                    print(result)
            else:
                print(f"Command '{{command_name}}' executed successfully")
                print(f"To implement custom behavior, add '{{hook_name}}' function to hooks.py")
            
            execution_time = time.time() - start_time
            if execution_time > 0.1:
                print(f"Executed in {{execution_time:.3f}}s")
            
        except Exception as e:
            print(f"Error executing command: {{e}}")
    
    def _call_hook(self, hook_func, args):
        """Call a hook function with appropriate arguments."""
        import inspect
        
        try:
            sig = inspect.signature(hook_func)
            param_count = len(sig.parameters)
            
            if param_count == 0:
                return hook_func()
            elif param_count == 1:
                return hook_func(args)
            else:
                bound_args = sig.bind(*args)
                bound_args.apply_defaults()
                return hook_func(*bound_args.args, **bound_args.kwargs)
        except Exception:
            return hook_func(args)
    
    def _execute_system_command(self, command: str):
        """Execute a system command."""
        try:
            import subprocess
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=30
            )
            
            if result.stdout:
                print(result.stdout)
            if result.stderr:
                print(f"STDERR: {{result.stderr}}")
            
        except subprocess.TimeoutExpired:
            print("Command timed out (30s limit)")
        except Exception as e:
            print(f"System command error: {{e}}")
    
    def _show_help(self):
        """Show available commands."""
        print("Available commands:")
        commands = self.cli_config.get("commands", {{}})
        
        for name, info in commands.items():
            desc = info.get("description", "No description")
            print(f"  {{name:<20}} {{desc}}")
        
        print()
        print("Builtin commands:")
        print("  help                Show this help")
        print("  history             Show command history")
        print("  exit, quit          Exit REPL")
        print("  !<command>          Execute system command")
        print()
        print("Features:")
        print("  Multi-line: End line with \\\\ to continue")
        print("  Tab completion: Press TAB for command completion")
        print("  History: Use UP/DOWN arrows for command history")
    
    def _show_history(self):
        """Show command history."""
        if READLINE_AVAILABLE and readline.get_current_history_length() > 0:
            print("Recent commands:")
            history_len = readline.get_current_history_length()
            for i in range(max(0, history_len - 10), history_len):
                item = readline.get_history_item(i + 1)
                if item:
                    print(f"  {{i + 1:3}}: {{item}}")
        else:
            print("No command history available")


def run_enhanced_repl():
    """Launch the enhanced REPL."""
    cli_config = {{
        "name": "{cli_name}",
        "description": "{project_name} CLI",
        "commands": {{
{chr(10).join(command_lines)}
        }}
    }}
    
    repl = {class_name}REPL(cli_config)
    repl.run()


if __name__ == "__main__":
    run_enhanced_repl()
'''
    
    def generate_session_manager_code(self, config: Dict[str, Any]) -> str:
        """Generate Python session management code."""
        return '''
# Session management utilities for Python REPL
import time
from typing import Dict, Any

class REPLSession:
    def __init__(self):
        self.start_time = time.time()
        self.variables = {}
        self.command_count = 0
    
    def get_uptime(self) -> float:
        return time.time() - self.start_time
    
    def set_variable(self, name: str, value: Any):
        self.variables[name] = value
    
    def get_variable(self, name: str, default=None):
        return self.variables.get(name, default)
'''


class NodeJSREPLAdapter(REPLAdapter):
    """Node.js REPL adapter."""
    
    def __init__(self):
        super().__init__('nodejs')
    
    def generate_repl_code(self, config: Dict[str, Any]) -> str:
        """Generate Node.js REPL code."""
        project_name = config.get('project', {}).get('name', 'CLI')
        cli_name = project_name.lower().replace(' ', '-').replace('_', '-')
        
        return f'''#!/usr/bin/env node
/**
 * Enhanced REPL for {project_name}
 * Generated by Goobits CLI Framework
 */

const readline = require('readline');
const fs = require('fs');
const path = require('path');

let hooks = {{}};
try {{
    hooks = require('./hooks');
}} catch (error) {{
    // No hooks file available
}}

class EnhancedREPL {{
    constructor() {{
        this.prompt = '{cli_name}> ';
        this.continuationPrompt = '{cli_name}... ';
        this.multiLineBuffer = '';
        this.isMultiLine = false;
        this.sessionVars = {{}};
        this.commandCount = 0;
        
        this.rl = readline.createInterface({{
            input: process.stdin,
            output: process.stdout,
            prompt: this.prompt,
            completer: this.completer.bind(this)
        }});
        
        this.setupHistory();
        this.setupCommands();
    }}
    
    setupHistory() {{
        const homeDir = process.env.HOME || process.env.USERPROFILE;
        this.historyFile = path.join(homeDir, '.{cli_name}_repl_history');
        
        // Load history
        try {{
            if (fs.existsSync(this.historyFile)) {{
                const history = fs.readFileSync(this.historyFile, 'utf8')
                    .split('\\n')
                    .filter(line => line.trim())
                    .slice(-100);
                
                history.forEach(line => {{
                    this.rl.history.push(line);
                }});
            }}
        }} catch (error) {{
            // Ignore history loading errors
        }}
        
        // Save history on exit
        process.on('exit', () => {{
            this.saveHistory();
        }});
        
        process.on('SIGINT', () => {{
            this.saveHistory();
            process.exit(0);
        }});
    }}
    
    saveHistory() {{
        try {{
            const historyToSave = this.rl.history
                .slice(0, 100)
                .reverse()
                .join('\\n');
            fs.writeFileSync(this.historyFile, historyToSave);
        }} catch (error) {{
            // Ignore history saving errors
        }}
    }}
    
    setupCommands() {{
        // Commands would be configured here from the CLI config
        this.commands = {{
            'help': {{ description: 'Show available commands', handler: this.showHelp.bind(this) }},
            'history': {{ description: 'Show command history', handler: this.showHistory.bind(this) }},
            'exit': {{ description: 'Exit REPL', handler: this.exit.bind(this) }},
            'quit': {{ description: 'Exit REPL', handler: this.exit.bind(this) }}
        }};
    }}
    
    completer(line) {{
        const completions = Object.keys(this.commands);
        const hits = completions.filter(c => c.startsWith(line));
        return [hits.length ? hits : completions, line];
    }}
    
    async start() {{
        console.log('Welcome to {project_name} Enhanced REPL mode.');
        console.log('Features: Multi-line commands (\\\\), Tab completion, Command history');
        console.log("Type 'help' for commands, 'exit' to quit.");
        console.log();
        
        this.rl.prompt();
        
        this.rl.on('line', async (line) => {{
            await this.handleLine(line);
        }});
        
        this.rl.on('close', () => {{
            console.log('\\nGoodbye!');
            process.exit(0);
        }});
    }}
    
    async handleLine(line) {{
        line = line.trim();
        
        if (!line) {{
            this.rl.prompt();
            return;
        }}
        
        // Handle multi-line continuation
        if (line.endsWith('\\\\')) {{
            this.multiLineBuffer += line.slice(0, -1) + ' ';
            this.isMultiLine = true;
            this.rl.setPrompt(this.continuationPrompt);
            this.rl.prompt();
            return;
        }}
        
        // Complete multi-line command
        if (this.isMultiLine) {{
            line = this.multiLineBuffer + line;
            this.multiLineBuffer = '';
            this.isMultiLine = false;
            this.rl.setPrompt(this.prompt);
        }}
        
        // Handle system commands
        if (line.startsWith('!')) {{
            await this.executeSystemCommand(line.slice(1));
            this.rl.prompt();
            return;
        }}
        
        // Parse and execute command
        const tokens = line.split(/\\s+/);
        const commandName = tokens[0];
        const args = tokens.slice(1);
        
        if (this.commands[commandName]) {{
            try {{
                await this.commands[commandName].handler(args);
            }} catch (error) {{
                console.error(`Error executing ${{commandName}}:`, error.message);
            }}
        }} else {{
            console.log(`Unknown command: ${{commandName}}`);
            console.log("Type 'help' for available commands");
        }}
        
        this.rl.prompt();
    }}
    
    showHelp() {{
        console.log('Available commands:');
        Object.entries(this.commands).forEach(([name, info]) => {{
            console.log(`  ${{name.padEnd(20)}} ${{info.description}}`);
        }});
        console.log();
        console.log('Features:');
        console.log('  Multi-line: End line with \\\\ to continue');
        console.log('  System: Prefix with ! to run shell commands');
        console.log('  Tab completion: Press TAB for command completion');
    }}
    
    showHistory() {{
        console.log('Recent commands:');
        const history = this.rl.history.slice(0, 10).reverse();
        history.forEach((cmd, i) => {{
            console.log(`  ${{(i + 1).toString().padStart(3)}}: ${{cmd}}`);
        }});
    }}
    
    exit() {{
        console.log('\\nGoodbye!');
        this.rl.close();
    }}
}}

async function runEnhancedREPL() {{
    const repl = new EnhancedREPL();
    await repl.start();
}}

if (require.main === module) {{
    runEnhancedREPL().catch(console.error);
}}

module.exports = {{ runEnhancedREPL }};
'''
    
    def generate_session_manager_code(self, config: Dict[str, Any]) -> str:
        """Generate Node.js session management code.""" 
        return '''
// Session management utilities for Node.js REPL
class REPLSession {
    constructor() {
        this.startTime = Date.now();
        this.variables = {};
        this.commandCount = 0;
    }
    
    getUptime() {
        return Date.now() - this.startTime;
    }
    
    setVariable(name, value) {
        this.variables[name] = value;
    }
    
    getVariable(name, defaultValue = null) {
        return this.variables[name] || defaultValue;
    }
}

module.exports = { REPLSession };
'''


class TypeScriptREPLAdapter(REPLAdapter):
    """TypeScript REPL adapter."""
    
    def __init__(self):
        super().__init__('typescript')
    
    def generate_repl_code(self, config: Dict[str, Any]) -> str:
        """Generate TypeScript REPL code."""
        project_name = config.get('project', {}).get('name', 'CLI')
        cli_name = project_name.lower().replace(' ', '-').replace('_', '-')
        
        return f'''#!/usr/bin/env ts-node
/**
 * Enhanced REPL for {project_name}
 * Generated by Goobits CLI Framework
 */

import * as readline from 'readline';
import * as fs from 'fs';
import * as path from 'path';

interface CommandInfo {{
    description: string;
    handler: (args: string[]) => Promise<void>;
}}

let hooks: any = {{}};
try {{
    hooks = require('./hooks');
}} catch (error) {{
    // No hooks file available
}}

class EnhancedREPL {{
    private rl: readline.Interface;
    private prompt: string;
    private continuationPrompt: string;
    private multiLineBuffer: string;
    private isMultiLine: boolean;
    private sessionVars: {{ [key: string]: any }};
    private commandCount: number;
    private commands: {{ [key: string]: CommandInfo }};
    private historyFile: string;
    
    constructor() {{
        this.prompt = '{cli_name}> ';
        this.continuationPrompt = '{cli_name}... ';
        this.multiLineBuffer = '';
        this.isMultiLine = false;
        this.sessionVars = {{}};
        this.commandCount = 0;
        
        this.rl = readline.createInterface({{
            input: process.stdin,
            output: process.stdout,
            prompt: this.prompt,
            completer: this.completer.bind(this)
        }});
        
        this.setupHistory();
        this.setupCommands();
    }}
    
    private setupHistory(): void {{
        const homeDir = process.env.HOME || process.env.USERPROFILE || '.';
        this.historyFile = path.join(homeDir, '.{cli_name}_repl_history');
        
        // Load history
        try {{
            if (fs.existsSync(this.historyFile)) {{
                const history = fs.readFileSync(this.historyFile, 'utf8')
                    .split('\\n')
                    .filter((line: string) => line.trim())
                    .slice(-100);
                
                history.forEach((line: string) => {{
                    (this.rl as any).history.push(line);
                }});
            }}
        }} catch (error) {{
            // Ignore history loading errors
        }}
        
        // Save history on exit
        process.on('exit', () => {{
            this.saveHistory();
        }});
        
        process.on('SIGINT', () => {{
            this.saveHistory();
            process.exit(0);
        }});
    }}
    
    private saveHistory(): void {{
        try {{
            const historyToSave = (this.rl as any).history
                .slice(0, 100)
                .reverse()
                .join('\\n');
            fs.writeFileSync(this.historyFile, historyToSave);
        }} catch (error) {{
            // Ignore history saving errors
        }}
    }}
    
    private setupCommands(): void {{
        this.commands = {{
            'help': {{
                description: 'Show available commands',
                handler: async () => this.showHelp()
            }},
            'history': {{
                description: 'Show command history',
                handler: async () => this.showHistory()
            }},
            'exit': {{
                description: 'Exit REPL',
                handler: async () => this.exit()
            }},
            'quit': {{
                description: 'Exit REPL',
                handler: async () => this.exit()
            }}
        }};
    }}
    
    private completer(line: string): [string[], string] {{
        const completions = Object.keys(this.commands);
        const hits = completions.filter(c => c.startsWith(line));
        return [hits.length ? hits : completions, line];
    }}
    
    public async start(): Promise<void> {{
        console.log('Welcome to {project_name} Enhanced REPL mode.');
        console.log('Features: Multi-line commands (\\\\), Tab completion, Command history');
        console.log("Type 'help' for commands, 'exit' to quit.");
        console.log();
        
        this.rl.prompt();
        
        this.rl.on('line', async (line: string) => {{
            await this.handleLine(line);
        }});
        
        this.rl.on('close', () => {{
            console.log('\\nGoodbye!');
            process.exit(0);
        }});
    }}
    
    private async handleLine(line: string): Promise<void> {{
        line = line.trim();
        
        if (!line) {{
            this.rl.prompt();
            return;
        }}
        
        // Handle multi-line continuation
        if (line.endsWith('\\\\')) {{
            this.multiLineBuffer += line.slice(0, -1) + ' ';
            this.isMultiLine = true;
            this.rl.setPrompt(this.continuationPrompt);
            this.rl.prompt();
            return;
        }}
        
        // Complete multi-line command
        if (this.isMultiLine) {{
            line = this.multiLineBuffer + line;
            this.multiLineBuffer = '';
            this.isMultiLine = false;
            this.rl.setPrompt(this.prompt);
        }}
        
        // Parse and execute command
        const tokens = line.split(/\\s+/);
        const commandName = tokens[0];
        const args = tokens.slice(1);
        
        if (this.commands[commandName]) {{
            try {{
                await this.commands[commandName].handler(args);
            }} catch (error: any) {{
                console.error(`Error executing ${{commandName}}:`, error.message);
            }}
        }} else {{
            console.log(`Unknown command: ${{commandName}}`);
            console.log("Type 'help' for available commands");
        }}
        
        this.rl.prompt();
    }}
    
    private showHelp(): void {{
        console.log('Available commands:');
        Object.entries(this.commands).forEach(([name, info]) => {{
            console.log(`  ${{name.padEnd(20)}} ${{info.description}}`);
        }});
        console.log();
        console.log('Features:');
        console.log('  Multi-line: End line with \\\\ to continue');
        console.log('  Tab completion: Press TAB for command completion');
    }}
    
    private showHistory(): void {{
        console.log('Recent commands:');
        const history = (this.rl as any).history.slice(0, 10).reverse();
        history.forEach((cmd: string, i: number) => {{
            console.log(`  ${{(i + 1).toString().padStart(3)}}: ${{cmd}}`);
        }});
    }}
    
    private exit(): void {{
        console.log('\\nGoodbye!');
        this.rl.close();
    }}
}}

async function runEnhancedREPL(): Promise<void> {{
    const repl = new EnhancedREPL();
    await repl.start();
}}

if (require.main === module) {{
    runEnhancedREPL().catch(console.error);
}}

export {{ runEnhancedREPL }};
'''
    
    def generate_session_manager_code(self, config: Dict[str, Any]) -> str:
        """Generate TypeScript session management code."""
        return '''
// Session management utilities for TypeScript REPL
export class REPLSession {
    private startTime: number;
    private variables: { [key: string]: any };
    private commandCount: number;
    
    constructor() {
        this.startTime = Date.now();
        this.variables = {};
        this.commandCount = 0;
    }
    
    getUptime(): number {
        return Date.now() - this.startTime;
    }
    
    setVariable(name: string, value: any): void {
        this.variables[name] = value;
    }
    
    getVariable(name: string, defaultValue: any = null): any {
        return this.variables[name] || defaultValue;
    }
}
'''


class RustREPLAdapter(REPLAdapter):
    """Rust REPL adapter."""
    
    def __init__(self):
        super().__init__('rust')
    
    def generate_repl_code(self, config: Dict[str, Any]) -> str:
        """Generate Rust REPL code."""
        project_name = config.get('project', {}).get('name', 'CLI')
        cli_name = project_name.lower().replace(' ', '-').replace('_', '-')
        
        return f'''//! Enhanced REPL for {project_name}
//! Generated by Goobits CLI Framework

use std::collections::HashMap;
use std::io::{{self, Write}};
use std::process::Command;
use std::time::Instant;

#[derive(Debug, Clone)]
pub struct CommandInfo {{
    pub description: String,
    pub hook_name: String,
}}

pub struct REPLSession {{
    pub variables: HashMap<String, String>,
    pub command_count: usize,
    pub start_time: Instant,
}}

impl REPLSession {{
    pub fn new() -> Self {{
        Self {{
            variables: HashMap::new(),
            command_count: 0,
            start_time: Instant::now(),
        }}
    }}
    
    pub fn get_uptime(&self) -> std::time::Duration {{
        self.start_time.elapsed()
    }}
}}

pub struct EnhancedREPL {{
    prompt: String,
    continuation_prompt: String,
    multi_line_buffer: String,
    is_multi_line: bool,
    commands: HashMap<String, CommandInfo>,
    session: REPLSession,
}}

impl EnhancedREPL {{
    pub fn new() -> Self {{
        let mut commands = HashMap::new();
        
        commands.insert("help".to_string(), CommandInfo {{
            description: "Show available commands".to_string(),
            hook_name: "help".to_string(),
        }});
        commands.insert("exit".to_string(), CommandInfo {{
            description: "Exit REPL".to_string(),
            hook_name: "exit".to_string(),
        }});
        commands.insert("quit".to_string(), CommandInfo {{
            description: "Exit REPL".to_string(),
            hook_name: "quit".to_string(),
        }});
        commands.insert("history".to_string(), CommandInfo {{
            description: "Show command history".to_string(),
            hook_name: "history".to_string(),
        }});
        
        Self {{
            prompt: "{cli_name}> ".to_string(),
            continuation_prompt: "{cli_name}... ".to_string(),
            multi_line_buffer: String::new(),
            is_multi_line: false,
            commands,
            session: REPLSession::new(),
        }}
    }}
    
    pub fn run(&mut self) -> io::Result<()> {{
        println!("Welcome to {project_name} Enhanced REPL mode.");
        println!("Features: Multi-line commands (\\\\), Command history");
        println!("Type 'help' for commands, 'exit' to quit.");
        println!();
        
        loop {{
            // Show prompt
            let prompt = if self.is_multi_line {{
                &self.continuation_prompt
            }} else {{
                &self.prompt
            }};
            
            print!("{{}}", prompt);
            io::stdout().flush()?;
            
            // Read input
            let mut input = String::new();
            match io::stdin().read_line(&mut input) {{
                Ok(0) => break, // EOF
                Ok(_) => {{
                    let line = input.trim().to_string();
                    
                    if !self.handle_line(line)? {{
                        break;
                    }}
                }}
                Err(e) => {{
                    eprintln!("Error reading input: {{}}", e);
                    break;
                }}
            }}
        }}
        
        println!("\\nGoodbye!");
        Ok(())
    }}
    
    fn handle_line(&mut self, line: String) -> io::Result<bool> {{
        if line.is_empty() {{
            return Ok(true);
        }}
        
        // Handle multi-line continuation
        if line.ends_with("\\\\") {{
            let line_without_backslash = &line[..line.len()-1];
            self.multi_line_buffer.push_str(line_without_backslash);
            self.multi_line_buffer.push(' ');
            self.is_multi_line = true;
            return Ok(true);
        }}
        
        // Complete multi-line command
        let complete_line = if self.is_multi_line {{
            let result = format!("{{}}{{}}", self.multi_line_buffer, line);
            self.multi_line_buffer.clear();
            self.is_multi_line = false;
            result
        }} else {{
            line
        }};
        
        // Handle system commands
        if complete_line.starts_with('!') {{
            self.execute_system_command(&complete_line[1..]);
            return Ok(true);
        }}
        
        // Parse command
        let tokens: Vec<&str> = complete_line.split_whitespace().collect();
        if tokens.is_empty() {{
            return Ok(true);
        }}
        
        let command_name = tokens[0];
        let _args = &tokens[1..];
        
        // Handle builtin commands
        match command_name {{
            "exit" | "quit" => return Ok(false),
            "help" => self.show_help(),
            "history" => self.show_history(),
            _ => {{
                if self.commands.contains_key(command_name) {{
                    self.execute_command(command_name);
                }} else {{
                    println!("Unknown command: {{}}", command_name);
                    println!("Type 'help' for available commands");
                }}
            }}
        }}
        
        Ok(true)
    }}
    
    fn execute_command(&mut self, command_name: &str) {{
        self.session.command_count += 1;
        let start_time = Instant::now();
        
        if let Some(cmd_info) = self.commands.get(command_name) {{
            println!("Command '{{}}' executed successfully", command_name);
            println!("To implement custom behavior, add '{{}}' function to hooks.rs", cmd_info.hook_name);
            
            let execution_time = start_time.elapsed();
            if execution_time.as_millis() > 100 {{
                println!("Executed in {{:?}}", execution_time);
            }}
        }}
    }}
    
    fn execute_system_command(&self, command: &str) {{
        match Command::new("sh")
            .arg("-c")
            .arg(command)
            .status() {{
            Ok(status) => {{
                if !status.success() {{
                    println!("Command exited with code: {{:?}}", status.code());
                }}
            }}
            Err(e) => {{
                eprintln!("Failed to execute system command: {{}}", e);
            }}
        }}
    }}
    
    fn show_help(&self) {{
        println!("Available commands:");
        for (name, info) in &self.commands {{
            println!("  {{:<20}} {{}}", name, info.description);
        }}
        println!();
        println!("Features:");
        println!("  Multi-line: End line with \\\\ to continue");
        println!("  System: Prefix with ! to run shell commands");
    }}
    
    fn show_history(&self) {{
        println!("Session info:");
        println!("  Commands executed: {{}}", self.session.command_count);
        println!("  Uptime: {{:?}}", self.session.get_uptime());
    }}
}}

pub fn run_enhanced_repl() -> io::Result<()> {{
    let mut repl = EnhancedREPL::new();
    repl.run()
}}

#[cfg(feature = "binary")]
fn main() -> io::Result<()> {{
    run_enhanced_repl()
}}
'''
    
    def generate_session_manager_code(self, config: Dict[str, Any]) -> str:
        """Generate Rust session management code."""
        return '''
//! Session management utilities for Rust REPL
use std::collections::HashMap;
use std::time::Instant;

pub struct REPLSession {
    pub variables: HashMap<String, String>,
    pub command_count: usize,
    pub start_time: Instant,
}

impl REPLSession {
    pub fn new() -> Self {
        Self {
            variables: HashMap::new(),
            command_count: 0,
            start_time: Instant::now(),
        }
    }
    
    pub fn get_uptime(&self) -> std::time::Duration {
        self.start_time.elapsed()
    }
    
    pub fn set_variable(&mut self, name: String, value: String) {
        self.variables.insert(name, value);
    }
    
    pub fn get_variable(&self, name: &str) -> Option<&String> {
        self.variables.get(name)
    }
}
'''