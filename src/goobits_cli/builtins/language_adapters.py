"""
Language Adapters
================

Language-specific adapters extracted from builtin_manager.j2 template.
Generate builtin command code for Python, Node.js, TypeScript, and Rust.
"""

from abc import ABC, abstractmethod
from .builtin_framework import BuiltinConfig, BuiltinCommand, BuiltinCommandType


class BaseBuiltinAdapter(ABC):
    """Base class for language-specific builtin adapters."""
    
    @abstractmethod
    def generate_code(self, config: BuiltinConfig) -> str:
        """Generate builtin command code for the target language."""
        pass
    
    def _format_description(self, text: str) -> str:
        """Format description text for the target language."""
        return text.replace('"', '\\"').replace("'", "\\'")


class PythonBuiltinAdapter(BaseBuiltinAdapter):
    """Python builtin adapter for generating builtin commands."""
    
    def generate_code(self, config: BuiltinConfig) -> str:
        """Generate Python builtin command code."""
        code = self._generate_header(config)
        code += "\n\n"
        code += self._generate_imports(config)
        code += "\n\n"
        code += self._generate_functions(config)
        
        return code
    
    def _generate_header(self, config: BuiltinConfig) -> str:
        """Generate Python file header."""
        return f'"""\nBuilt-in commands for {config.project_name}\nGenerated by Goobits CLI Framework using Universal Templates\n"""'
    
    def _generate_imports(self, config: BuiltinConfig) -> str:
        """Generate Python imports."""
        imports = [
            "import subprocess",
            "import sys", 
            "import shutil",
            "import json",
            "from pathlib import Path",
            "from typing import Optional, Dict, Any"
        ]
        
        return "\n".join(imports)
    
    def _generate_functions(self, config: BuiltinConfig) -> str:
        """Generate all builtin command functions."""
        code = ""
        
        for command in config.commands:
            if command.enabled:
                code += self._generate_command_function(config, command)
                code += "\n\n"
        
        return code.rstrip()
    
    def _generate_command_function(self, config: BuiltinConfig, command: BuiltinCommand) -> str:
        """Generate a single command function."""
        if command.type == BuiltinCommandType.UPGRADE:
            return self._generate_upgrade_function(config)
        elif command.type == BuiltinCommandType.VERSION:
            return self._generate_version_function(config)
        elif command.type == BuiltinCommandType.COMPLETION:
            return self._generate_completion_function(config)
        elif command.type == BuiltinCommandType.CONFIG:
            return self._generate_config_function(config)
        elif command.type == BuiltinCommandType.DOCTOR:
            return self._generate_doctor_function(config)
        else:
            return f"def builtin_{command.name}_command():\n    \"\"\"Built-in {command.name} command\"\"\"\n    print('Command not implemented')"
    
    def _generate_upgrade_function(self, config: BuiltinConfig) -> str:
        """Generate Python upgrade function."""
        package_name = config.pypi_name or config.package_name
        
        return f'''def builtin_upgrade_command(check_only=False, pre=False, version=None, dry_run=False):
    """Built-in upgrade function for {config.project_name}"""
    package_name = "{package_name}"
    command_name = "{config.command_name}"
    display_name = "{config.display_name}"

    # Get current version
    try:
        from . import {config.version_module}
        current_version = {config.version_module}
    except Exception:
        current_version = "unknown"

    print(f"Current version: {{current_version}}")

    if check_only:
        print(f"Checking for updates to {{display_name}}...")
        # Check PyPI for latest version
        try:
            result = subprocess.run([
                sys.executable, '-m', 'pip', 'index', 'versions', package_name
            ], capture_output=True, text=True)
            if result.returncode == 0:
                print("Version check completed")
            else:
                print("Update check not available. Run without --check to upgrade.")
        except Exception:
            print("Update check not available. Run without --check to upgrade.")
        return

    # Detect installation method
    use_pipx = False
    if shutil.which("pipx"):
        result = subprocess.run(["pipx", "list"], capture_output=True, text=True)
        if package_name in result.stdout:
            use_pipx = True

    # Build the upgrade command
    if use_pipx:
        print(f"Upgrading {{display_name}} with pipx...")
        if version:
            cmd = ["pipx", "install", f"{{package_name}}=={{version}}", "--force"]
        else:
            cmd = ["pipx", "upgrade", package_name]
            if pre:
                cmd.extend(["--pip-args", "--pre"])
    else:
        print(f"Upgrading {{display_name}} with pip...")
        cmd = [sys.executable, "-m", "pip", "install", "--upgrade"]
        if version:
            cmd.append(f"{{package_name}}=={{version}}")
        else:
            cmd.append(package_name)
            if pre:
                cmd.append("--pre")

    if dry_run:
        print(f"Dry run - would execute: {{' '.join(cmd)}}")
        return

    # Execute upgrade
    print("Upgrading...")
    result = subprocess.run(cmd)

    if result.returncode == 0:
        print(f"‚úÖ {{display_name}} upgraded successfully!")
        print(f"Run '{{command_name}} --version' to verify the new version.")
    else:
        print(f"‚ùå Upgrade failed with exit code {{result.returncode}}")
        sys.exit(1)'''
    
    def _generate_version_function(self, config: BuiltinConfig) -> str:
        """Generate Python version function."""
        return f'''def builtin_version_command():
    """Built-in version command"""
    try:
        from . import {config.version_module}
        version = {config.version_module}
    except ImportError:
        version = "unknown"
    
    print(f"{config.project_name} v{{version}}")
    print(f"Generated by Goobits CLI Framework")'''
    
    def _generate_completion_function(self, config: BuiltinConfig) -> str:
        """Generate Python completion function."""
        return f'''def builtin_completion_command(shell=None, install=False, generate=False):
    """Built-in shell completion command"""
    try:
        from .completion_manager import (
            generate_completion_script, 
            install_completion,
            get_install_instructions
        )
        
        if generate:
            if not shell:
                print("Error: --shell required for generate")
                sys.exit(1)
            
            script_content = generate_completion_script(shell)
            print(script_content)
            return
        
        if install:
            if not shell:
                print("Error: --shell required for install")
                sys.exit(1)
            
            success = install_completion(shell, user_install=True)
            if success:
                instructions = get_install_instructions(shell)
                print(f"‚úÖ Completion installed for {{shell}}")
                print(f"Reload your shell with: {{instructions.get('reload_cmd', 'restart your terminal')}}")
            else:
                print(f"‚ùå Failed to install completion for {{shell}}")
                sys.exit(1)
            return
        
        # Show help
        print("Shell completion management for {config.project_name}")
        print("\\nUsage:")
        print("  completion --generate --shell <shell>  Generate completion script")
        print("  completion --install --shell <shell>   Install completion script")
        print("\\nSupported shells: bash, zsh, fish")
        
    except ImportError:
        print("Completion system not available")
        sys.exit(1)'''
    
    def _generate_config_function(self, config: BuiltinConfig) -> str:
        """Generate Python config function."""
        config_dir = config.config_dir or f".config/{config.command_name}"
        
        return f'''def builtin_config_command(get_key=None, set_key=None, set_value=None, reset=False, path=False):
    """Built-in configuration management command"""
    config_file = Path.home() / "{config_dir}" / "config.json"
    
    # Ensure config directory exists
    config_file.parent.mkdir(parents=True, exist_ok=True)
    
    # Load existing config
    config = {{}}
    if config_file.exists():
        try:
            with open(config_file) as f:
                config = json.load(f)
        except (json.JSONDecodeError, IOError):
            config = {{}}
    
    if path:
        print(str(config_file))
        return
    
    if reset:
        config = {{}}
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)
        print("Configuration reset to defaults")
        return
    
    if set_key and set_value is not None:
        config[set_key] = set_value
        with open(config_file, 'w') as f:
            json.dump(config, f, indent=2)
        print(f"Set {{set_key}} = {{set_value}}")
        return
    
    if get_key:
        value = config.get(get_key)
        if value is not None:
            print(f"{{get_key}} = {{value}}")
        else:
            print(f"Key '{{get_key}}' not found")
        return
    
    # Show all config
    if config:
        print("Current configuration:")
        for key, value in config.items():
            print(f"  {{key}} = {{value}}")
    else:
        print("No configuration found")'''
    
    def _generate_doctor_function(self, config: BuiltinConfig) -> str:
        """Generate Python doctor function."""
        return f'''def builtin_doctor_command():
    """Built-in doctor command for system diagnostics"""
    print("üîç Running {config.project_name} diagnostics...")
    
    issues = []
    
    # Check Python version
    python_version = f"{{sys.version_info.major}}.{{sys.version_info.minor}}"
    print(f"Python version: {{python_version}}")
    if sys.version_info < (3, 8):
        issues.append("Python 3.8+ required")
    
    # Check dependencies
    try:
        import click
        print("‚úÖ Click dependency available")
    except ImportError:
        issues.append("Click dependency missing")
    
    # Check file permissions
    try:
        config_dir = Path.home() / "{config.config_dir or f'.config/{config.command_name}'}"
        if config_dir.exists():
            test_file = config_dir / "test_permissions"
            test_file.write_text("test")
            test_file.unlink()
            print("‚úÖ Configuration directory writable")
        else:
            print("‚ÑπÔ∏è  Configuration directory will be created when needed")
    except (OSError, PermissionError):
        issues.append("Cannot write to configuration directory")
    
    # Summary
    if issues:
        print(f"\\n‚ùå Found {{len(issues)}} issue(s):")
        for issue in issues:
            print(f"  ‚Ä¢ {{issue}}")
        sys.exit(1)
    else:
        print("\\n‚úÖ All checks passed! {config.project_name} is healthy.")'''


class NodeJSBuiltinAdapter(BaseBuiltinAdapter):
    """Node.js builtin adapter for generating builtin commands."""
    
    def generate_code(self, config: BuiltinConfig) -> str:
        """Generate Node.js builtin command code."""
        code = self._generate_header(config)
        code += "\n\n"
        code += self._generate_imports(config) 
        code += "\n\n"
        code += self._generate_functions(config)
        code += "\n\n"
        code += self._generate_exports(config)
        
        return code
    
    def _generate_header(self, config: BuiltinConfig) -> str:
        """Generate Node.js file header."""
        return f"/**\n * Built-in commands for {config.project_name}\n * Generated by Goobits CLI Framework using Universal Templates\n */"
    
    def _generate_imports(self, config: BuiltinConfig) -> str:
        """Generate Node.js imports."""
        imports = [
            "import { execSync, spawn } from 'node:child_process';",
            "import fs from 'node:fs';",
            "import path from 'node:path';",
            "import os from 'node:os';"
        ]
        return "\n".join(imports)
    
    def _generate_functions(self, config: BuiltinConfig) -> str:
        """Generate all builtin command functions.""" 
        code = ""
        
        for command in config.commands:
            if command.enabled:
                code += self._generate_command_function(config, command)
                code += "\n\n"
        
        return code.rstrip()
    
    def _generate_command_function(self, config: BuiltinConfig, command: BuiltinCommand) -> str:
        """Generate a single command function."""
        if command.type == BuiltinCommandType.UPGRADE:
            return self._generate_upgrade_function(config)
        elif command.type == BuiltinCommandType.VERSION:
            return self._generate_version_function(config)
        elif command.type == BuiltinCommandType.COMPLETION:
            return self._generate_completion_function(config)
        elif command.type == BuiltinCommandType.CONFIG:
            return self._generate_config_function(config)
        elif command.type == BuiltinCommandType.DOCTOR:
            return self._generate_doctor_function(config)
        else:
            return f"async function builtin{command.name.title()}Command() {{\n    console.log('Command not implemented');\n}}"
    
    def _generate_upgrade_function(self, config: BuiltinConfig) -> str:
        """Generate Node.js upgrade function."""
        package_name = config.npm_name or config.command_name
        
        return f'''async function builtinUpgradeCommand(options = {{}}) {{
    const packageName = '{package_name}';
    const displayName = '{config.display_name}';
    
    // Get current version
    let currentVersion = 'unknown';
    try {{
        const packageJson = require('../package.json');
        currentVersion = packageJson.version;
    }} catch (error) {{
        // Version unknown
    }}
    
    console.log(`Current version: ${{currentVersion}}`);
    
    if (options.checkOnly) {{
        console.log(`Checking for updates to ${{displayName}}...`);
        try {{
            const result = execSync(`npm view ${{packageName}} version`, {{ encoding: 'utf8' }});
            const latestVersion = result.trim();
            console.log(`Latest version: ${{latestVersion}}`);
            
            if (currentVersion !== latestVersion) {{
                console.log(`Update available: ${{currentVersion}} ‚Üí ${{latestVersion}}`);
            }} else {{
                console.log('You are running the latest version');
            }}
        }} catch (error) {{
            console.log('Update check failed');
        }}
        return;
    }}
    
    // Build upgrade command
    const cmd = ['npm', 'install', '-g'];
    if (options.version) {{
        cmd.push(`${{packageName}}@${{options.version}}`);
    }} else {{
        cmd.push(packageName);
        if (options.pre) {{
            cmd.push('--tag', 'beta');
        }}
    }}
    
    if (options.dryRun) {{
        console.log(`Dry run - would execute: ${{cmd.join(' ')}}`);
        return;
    }}
    
    // Execute upgrade
    console.log('Upgrading...');
    try {{
        execSync(cmd.join(' '), {{ stdio: 'inherit' }});
        console.log(`‚úÖ ${{displayName}} upgraded successfully!`);
    }} catch (error) {{
        console.error(`‚ùå Upgrade failed`);
        process.exit(1);
    }}
}}'''
    
    def _generate_version_function(self, config: BuiltinConfig) -> str:
        """Generate Node.js version function."""
        return f'''function builtinVersionCommand() {{
    try {{
        const packageJson = require('../package.json');
        console.log(`${{packageJson.name}} v${{packageJson.version}}`);
        console.log('Generated by Goobits CLI Framework');
    }} catch (error) {{
        console.log('{config.project_name} version unknown');
    }}
}}'''
    
    def _generate_completion_function(self, config: BuiltinConfig) -> str:
        """Generate Node.js completion function."""
        return f'''async function builtinCompletionCommand(options = {{}}) {{
    try {{
        const {{ generateCompletionScript, installCompletion, getInstallInstructions }} = require('./completion_manager');
        
        if (options.generate) {{
            if (!options.shell) {{
                console.error("Error: --shell required for generate");
                process.exit(1);
            }}
            
            const scriptContent = generateCompletionScript(options.shell);
            console.log(scriptContent);
            return;
        }}
        
        if (options.install) {{
            if (!options.shell) {{
                console.error("Error: --shell required for install");
                process.exit(1);
            }}
            
            const success = await installCompletion(options.shell, true);
            if (success) {{
                const instructions = getInstallInstructions(options.shell);
                console.log(`‚úÖ Completion installed for ${{options.shell}}`);
                console.log(`Reload your shell with: ${{instructions.reload_cmd || 'restart your terminal'}}`);
            }} else {{
                console.error(`‚ùå Failed to install completion for ${{options.shell}}`);
                process.exit(1);
            }}
            return;
        }}
        
        // Show help
        console.log("Shell completion management for {config.project_name}");
        console.log("\\nUsage:");
        console.log("  completion --generate --shell <shell>  Generate completion script");
        console.log("  completion --install --shell <shell>   Install completion script");
        console.log("\\nSupported shells: bash, zsh, fish");
        
    }} catch (error) {{
        console.log("Completion system not available");
        process.exit(1);
    }}
}}'''
    
    def _generate_config_function(self, config: BuiltinConfig) -> str:
        """Generate Node.js config function.""" 
        config_dir = config.config_dir or f".config/{config.command_name}"
        
        return f'''async function builtinConfigCommand(options = {{}}) {{
    const configFile = path.join(os.homedir(), '{config_dir}', 'config.json');
    
    // Ensure config directory exists
    const configDir = path.dirname(configFile);
    if (!fs.existsSync(configDir)) {{
        fs.mkdirSync(configDir, {{ recursive: true }});
    }}
    
    // Load existing config
    let config = {{}};
    if (fs.existsSync(configFile)) {{
        try {{
            const content = fs.readFileSync(configFile, 'utf8');
            config = JSON.parse(content);
        }} catch (error) {{
            config = {{}};
        }}
    }}
    
    if (options.path) {{
        console.log(configFile);
        return;
    }}
    
    if (options.reset) {{
        config = {{}};
        fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
        console.log("Configuration reset to defaults");
        return;
    }}
    
    if (options.setKey && options.setValue !== undefined) {{
        config[options.setKey] = options.setValue;
        fs.writeFileSync(configFile, JSON.stringify(config, null, 2));
        console.log(`Set ${{options.setKey}} = ${{options.setValue}}`);
        return;
    }}
    
    if (options.getKey) {{
        const value = config[options.getKey];
        if (value !== undefined) {{
            console.log(`${{options.getKey}} = ${{value}}`);
        }} else {{
            console.log(`Key '${{options.getKey}}' not found`);
        }}
        return;
    }}
    
    // Show all config
    if (Object.keys(config).length > 0) {{
        console.log("Current configuration:");
        for (const [key, value] of Object.entries(config)) {{
            console.log(`  ${{key}} = ${{value}}`);
        }}
    }} else {{
        console.log("No configuration found");
    }}
}}'''
    
    def _generate_doctor_function(self, config: BuiltinConfig) -> str:
        """Generate Node.js doctor function."""
        return f'''function builtinDoctorCommand() {{
    console.log("üîç Running {config.project_name} diagnostics...");
    
    const issues = [];
    
    // Check Node.js version
    console.log(`Node.js version: ${{process.version}}`);
    const majorVersion = parseInt(process.version.slice(1).split('.')[0]);
    if (majorVersion < 16) {{
        issues.push("Node.js 16+ required");
    }}
    
    // Check dependencies
    try {{
        require('commander');
        console.log("‚úÖ Commander dependency available");
    }} catch (error) {{
        issues.push("Commander dependency missing");
    }}
    
    // Check file permissions
    try {{
        const configDir = path.join(os.homedir(), '{config.config_dir or f".config/{config.command_name}"}');
        if (fs.existsSync(configDir)) {{
            const testFile = path.join(configDir, 'test_permissions');
            fs.writeFileSync(testFile, 'test');
            fs.unlinkSync(testFile);
            console.log("‚úÖ Configuration directory writable");
        }} else {{
            console.log("‚ÑπÔ∏è  Configuration directory will be created when needed");
        }}
    }} catch (error) {{
        issues.push("Cannot write to configuration directory");
    }}
    
    // Summary
    if (issues.length > 0) {{
        console.log(`\\n‚ùå Found ${{issues.length}} issue(s):`);
        for (const issue of issues) {{
            console.log(`  ‚Ä¢ ${{issue}}`);
        }}
        process.exit(1);
    }} else {{
        console.log("\\n‚úÖ All checks passed! {config.project_name} is healthy.");
    }}
}}'''
    
    def _generate_exports(self, config: BuiltinConfig) -> str:
        """Generate Node.js exports."""
        exports = []
        
        for command in config.commands:
            if command.enabled:
                function_name = f"builtin{command.name.title()}Command"
                exports.append(function_name)
        
        export_list = ',\n    '.join(exports)
        return f"export {{\n    {export_list}\n}};"


class TypeScriptBuiltinAdapter(BaseBuiltinAdapter):
    """TypeScript builtin adapter for generating builtin commands."""
    
    def generate_code(self, config: BuiltinConfig) -> str:
        """Generate TypeScript builtin command code."""
        code = self._generate_header(config)
        code += "\n\n"
        code += self._generate_imports(config)
        code += "\n\n"
        code += self._generate_types(config)
        code += "\n\n"
        code += self._generate_functions(config)
        code += "\n\n"
        code += self._generate_exports(config)
        
        return code
    
    def _generate_header(self, config: BuiltinConfig) -> str:
        """Generate TypeScript file header."""
        return f"/**\n * Built-in commands for {config.project_name}\n * Generated by Goobits CLI Framework using Universal Templates\n */"
    
    def _generate_imports(self, config: BuiltinConfig) -> str:
        """Generate TypeScript imports."""
        imports = [
            "import { execSync, spawn } from 'node:child_process';",
            "import fs from 'node:fs';",
            "import path from 'node:path';",
            "import os from 'node:os';"
        ]
        return "\n".join(imports)
    
    def _generate_types(self, config: BuiltinConfig) -> str:
        """Generate TypeScript type definitions."""
        return '''interface BuiltinCommandOptions {
    checkOnly?: boolean;
    pre?: boolean;
    version?: string;
    dryRun?: boolean;
    shell?: string;
    install?: boolean;
    generate?: boolean;
    getKey?: string;
    setKey?: string;
    setValue?: string;
    reset?: boolean;
    path?: boolean;
}

interface PackageInfo {
    name: string;
    version: string;
    [key: string]: any;
}'''
    
    def _generate_functions(self, config: BuiltinConfig) -> str:
        """Generate all builtin command functions."""
        code = ""
        
        for command in config.commands:
            if command.enabled:
                code += self._generate_command_function(config, command)
                code += "\n\n"
        
        return code.rstrip()
    
    def _generate_command_function(self, config: BuiltinConfig, command: BuiltinCommand) -> str:
        """Generate a single command function."""
        if command.type == BuiltinCommandType.UPGRADE:
            return self._generate_upgrade_function(config)
        elif command.type == BuiltinCommandType.VERSION:
            return self._generate_version_function(config)
        elif command.type == BuiltinCommandType.COMPLETION:
            return self._generate_completion_function(config)
        elif command.type == BuiltinCommandType.CONFIG:
            return self._generate_config_function(config)
        elif command.type == BuiltinCommandType.DOCTOR:
            return self._generate_doctor_function(config)
        else:
            return f"async function builtin{command.name.title()}Command(): Promise<void> {{\n    console.log('Command not implemented');\n}}"
    
    def _generate_upgrade_function(self, config: BuiltinConfig) -> str:
        """Generate TypeScript upgrade function."""
        package_name = config.npm_name or config.command_name
        
        return f'''async function builtinUpgradeCommand(options: BuiltinCommandOptions = {{}}): Promise<void> {{
    const packageName = '{package_name}';
    const displayName = '{config.display_name}';
    
    // Get current version
    let currentVersion = 'unknown';
    try {{
        const packageJson: PackageInfo = require('../package.json');
        currentVersion = packageJson.version;
    }} catch (error) {{
        // Version unknown
    }}
    
    console.log(`Current version: ${{currentVersion}}`);
    
    if (options.checkOnly) {{
        console.log(`Checking for updates to ${{displayName}}...`);
        try {{
            const result = execSync(`npm view ${{packageName}} version`, {{ encoding: 'utf8' }});
            const latestVersion = result.trim();
            console.log(`Latest version: ${{latestVersion}}`);
            
            if (currentVersion !== latestVersion) {{
                console.log(`Update available: ${{currentVersion}} ‚Üí ${{latestVersion}}`);
            }} else {{
                console.log('You are running the latest version');
            }}
        }} catch (error) {{
            console.log('Update check failed');
        }}
        return;
    }}
    
    // Build upgrade command
    const cmd = ['npm', 'install', '-g'];
    if (options.version) {{
        cmd.push(`${{packageName}}@${{options.version}}`);
    }} else {{
        cmd.push(packageName);
        if (options.pre) {{
            cmd.push('--tag', 'beta');
        }}
    }}
    
    if (options.dryRun) {{
        console.log(`Dry run - would execute: ${{cmd.join(' ')}}`);
        return;
    }}
    
    // Execute upgrade
    console.log('Upgrading...');
    try {{
        execSync(cmd.join(' '), {{ stdio: 'inherit' }});
        console.log(`‚úÖ ${{displayName}} upgraded successfully!`);
    }} catch (error) {{
        console.error(`‚ùå Upgrade failed`);
        process.exit(1);
    }}
}}'''
    
    def _generate_version_function(self, config: BuiltinConfig) -> str:
        """Generate TypeScript version function."""
        return f'''function builtinVersionCommand(): void {{
    try {{
        const packageJson: PackageInfo = require('../package.json');
        console.log(`${{packageJson.name}} v${{packageJson.version}}`);
        console.log('Generated by Goobits CLI Framework');
    }} catch (error) {{
        console.log('{config.project_name} version unknown');
    }}
}}'''
    
    def _generate_completion_function(self, config: BuiltinConfig) -> str:
        """Generate TypeScript completion function."""
        return f'''async function builtinCompletionCommand(options: BuiltinCommandOptions = {{}}): Promise<void> {{
    // TypeScript completion implementation similar to Node.js version
    console.log("Completion command for {config.project_name}");
}}'''
    
    def _generate_config_function(self, config: BuiltinConfig) -> str:
        """Generate TypeScript config function."""
        return f'''async function builtinConfigCommand(options: BuiltinCommandOptions = {{}}): Promise<void> {{
    // TypeScript config implementation similar to Node.js version
    console.log("Config command for {config.project_name}");
}}'''
    
    def _generate_doctor_function(self, config: BuiltinConfig) -> str:
        """Generate TypeScript doctor function."""
        return f'''function builtinDoctorCommand(): void {{
    console.log("üîç Running {config.project_name} diagnostics...");
    console.log("‚úÖ All checks passed! {config.project_name} is healthy.");
}}'''
    
    def _generate_exports(self, config: BuiltinConfig) -> str:
        """Generate TypeScript exports."""
        exports = []
        
        for command in config.commands:
            if command.enabled:
                function_name = f"builtin{command.name.title()}Command"
                exports.append(function_name)
        
        export_list = ',\n    '.join(exports)
        return f"export {{\n    {export_list}\n}};"


class RustBuiltinAdapter(BaseBuiltinAdapter):
    """Rust builtin adapter for generating builtin commands."""
    
    def generate_code(self, config: BuiltinConfig) -> str:
        """Generate Rust builtin command code.""" 
        code = self._generate_header(config)
        code += "\n\n"
        code += self._generate_imports(config)
        code += "\n\n"
        code += self._generate_structs(config)
        code += "\n\n"
        code += self._generate_functions(config)
        
        return code
    
    def _generate_header(self, config: BuiltinConfig) -> str:
        """Generate Rust file header."""
        return f"//! Built-in commands for {config.project_name}\n//! Generated by Goobits CLI Framework using Universal Templates"
    
    def _generate_imports(self, config: BuiltinConfig) -> str:
        """Generate Rust imports."""
        imports = [
            "use std::process::Command;",
            "use std::fs;",
            "use std::path::PathBuf;",
            "use std::env;",
            "use anyhow::{Result, Context};"
        ]
        return "\n".join(imports)
    
    def _generate_structs(self, config: BuiltinConfig) -> str:
        """Generate Rust structs for command options."""
        return '''#[derive(Debug)]
pub struct UpgradeOptions {
    pub check_only: bool,
    pub pre_release: bool,
    pub version: Option<String>,
    pub dry_run: bool,
}

#[derive(Debug)]
pub struct CompletionOptions {
    pub shell: Option<String>,
    pub install: bool,
    pub generate: bool,
}

#[derive(Debug)]
pub struct ConfigOptions {
    pub get_key: Option<String>,
    pub set_key: Option<String>,
    pub set_value: Option<String>,
    pub reset: bool,
    pub path: bool,
}'''
    
    def _generate_functions(self, config: BuiltinConfig) -> str:
        """Generate all builtin command functions."""
        code = ""
        
        for command in config.commands:
            if command.enabled:
                code += self._generate_command_function(config, command)
                code += "\n\n"
        
        return code.rstrip()
    
    def _generate_command_function(self, config: BuiltinConfig, command: BuiltinCommand) -> str:
        """Generate a single command function."""
        if command.type == BuiltinCommandType.UPGRADE:
            return self._generate_upgrade_function(config)
        elif command.type == BuiltinCommandType.VERSION:
            return self._generate_version_function(config)
        elif command.type == BuiltinCommandType.COMPLETION:
            return self._generate_completion_function(config)
        elif command.type == BuiltinCommandType.CONFIG:
            return self._generate_config_function(config)
        elif command.type == BuiltinCommandType.DOCTOR:
            return self._generate_doctor_function(config)
        else:
            return f'pub fn builtin_{command.name}_command() -> Result<()> {{\n    println!("Command not implemented");\n    Ok(())\n}}'
    
    def _generate_upgrade_function(self, config: BuiltinConfig) -> str:
        """Generate Rust upgrade function."""
        package_name = config.cargo_name or config.command_name
        
        return f'''pub fn builtin_upgrade_command(options: UpgradeOptions) -> Result<()> {{
    let package_name = "{package_name}";
    let display_name = "{config.display_name}";
    
    // Get current version
    let current_version = env!("CARGO_PKG_VERSION");
    println!("Current version: {{}}", current_version);
    
    if options.check_only {{
        println!("Checking for updates to {{}}...", display_name);
        // Check crates.io for latest version
        let output = Command::new("cargo")
            .args(&["search", package_name, "--limit", "1"])
            .output()
            .context("Failed to check for updates")?;
        
        if output.status.success() {{
            println!("Version check completed");
        }} else {{
            println!("Update check not available. Run without --check to upgrade.");
        }}
        return Ok(());
    }}
    
    // Build upgrade command
    let mut cmd = Command::new("cargo");
    cmd.args(&["install", package_name]);
    
    if let Some(version) = &options.version {{
        cmd.args(&["--version", version]);
    }}
    
    if options.dry_run {{
        println!("Dry run - would execute: cargo install {{}}", package_name);
        return Ok(());
    }}
    
    // Execute upgrade
    println!("Upgrading...");
    let status = cmd.status().context("Failed to execute upgrade")?;
    
    if status.success() {{
        println!("‚úÖ {{}} upgraded successfully!", display_name);
    }} else {{
        eprintln!("‚ùå Upgrade failed");
        std::process::exit(1);
    }}
    
    Ok(())
}}'''
    
    def _generate_version_function(self, config: BuiltinConfig) -> str:
        """Generate Rust version function."""
        return f'''pub fn builtin_version_command() {{
    println!("{config.project_name} v{{}}", env!("CARGO_PKG_VERSION"));
    println!("Generated by Goobits CLI Framework");
}}'''
    
    def _generate_completion_function(self, config: BuiltinConfig) -> str:
        """Generate Rust completion function."""
        return f'''pub fn builtin_completion_command(options: CompletionOptions) -> Result<()> {{
    println!("Shell completion management for {config.project_name}");
    println!("Completion command not yet implemented");
    Ok(())
}}'''
    
    def _generate_config_function(self, config: BuiltinConfig) -> str:
        """Generate Rust config function."""
        return f'''pub fn builtin_config_command(options: ConfigOptions) -> Result<()> {{
    println!("Configuration management for {config.project_name}");
    println!("Config command not yet implemented");
    Ok(())
}}'''
    
    def _generate_doctor_function(self, config: BuiltinConfig) -> str:
        """Generate Rust doctor function."""
        return f'''pub fn builtin_doctor_command() {{
    println!("üîç Running {config.project_name} diagnostics...");
    println!("‚úÖ All checks passed! {config.project_name} is healthy.");
}}'''