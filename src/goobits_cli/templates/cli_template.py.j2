#!/usr/bin/env python3
"""Auto-generated from {{ file_name }}"""
import os
import sys
import logging
import importlib.util
from pathlib import Path
import rich_click as click
from rich_click import RichGroup, RichCommand
from typing import Optional, Dict, Any


# Enhanced Error Handling Classes
class CLIError(Exception):
    """Base exception for CLI errors."""
    def __init__(self, message: str, exit_code: int = 1, suggestion: Optional[str] = None):
        self.message = message
        self.exit_code = exit_code
        self.suggestion = suggestion
        super().__init__(self.message)


class ConfigError(CLIError):
    """Configuration-related error."""
    def __init__(self, message: str, suggestion: Optional[str] = None):
        super().__init__(message, exit_code=2, suggestion=suggestion)


class HookError(CLIError):
    """Hook execution error."""
    def __init__(self, message: str, hook_name: Optional[str] = None):
        self.hook_name = hook_name
        super().__init__(message, exit_code=3, suggestion=f"Check the '{hook_name}' function in your app_hooks.py file" if hook_name else None)


class DependencyError(CLIError):
    """Missing dependency error."""
    def __init__(self, message: str, dependency: str, install_command: Optional[str] = None):
        self.dependency = dependency
        self.install_command = install_command
        suggestion = f"Install with: {install_command}" if install_command else f"Install the '{dependency}' package"
        super().__init__(message, exit_code=4, suggestion=suggestion)


# Global error handler
def handle_cli_error(error: Exception, debug: bool = False) -> int:
    """Handle CLI errors with appropriate messages and exit codes."""
    if isinstance(error, CLIError):
        click.echo(f"‚ùå Error: {error.message}", err=True)
        if error.suggestion:
            click.echo(f"üí° Suggestion: {error.suggestion}", err=True)
        if debug:
            import traceback
            click.echo("\nüîç Debug traceback:", err=True)
            click.echo(traceback.format_exc(), err=True)
        return error.exit_code
    else:
        # Unexpected errors
        click.echo(f"‚ùå Unexpected error: {str(error)}", err=True)
        click.echo("üí° This may be a bug. Please report it with the following details:", err=True)
        if debug:
            import traceback
            click.echo(traceback.format_exc(), err=True)
        else:
            click.echo(f"   Error type: {type(error).__name__}", err=True)
            click.echo(f"   Error message: {str(error)}", err=True)
            click.echo("   Run with --debug for full traceback", err=True)
        return 1


# Set up logging
logging.basicConfig(
    level=logging.WARNING,
    format='%(levelname)s: %(message)s',
    handlers=[
        logging.StreamHandler(sys.stderr)
    ]
)
logger = logging.getLogger(__name__)

# Import generated helper modules with enhanced error handling
_missing_dependencies = []

try:
    from .config_manager import get_config, load_config, get_config_value, set_config_value
    HAS_CONFIG_MANAGER = True
except ImportError as e:
    HAS_CONFIG_MANAGER = False
    logger.debug(f"Config manager not available: {e}")
    _missing_dependencies.append("config_manager")

try:
    from .progress_helper import (
        get_progress_helper, spinner, progress_bar, simple_progress,
        print_success, print_error, print_warning, print_info,
        with_spinner, with_progress
    )
    HAS_PROGRESS_HELPER = True
except ImportError as e:
    HAS_PROGRESS_HELPER = False
    logger.debug(f"Progress helper not available: {e}")
    _missing_dependencies.append("progress_helper")

try:
    from .prompts_helper import (
        get_prompts_helper, text, password, confirm, select, multiselect,
        integer, float_input, path
    )
    HAS_PROMPTS_HELPER = True
except ImportError as e:
    HAS_PROMPTS_HELPER = False
    logger.debug(f"Prompts helper not available: {e}")
    _missing_dependencies.append("prompts_helper")

try:
    from .completion_helper import (
        get_completion_helper, generate_completion_script, install_completion,
        get_install_instructions
    )
    HAS_COMPLETION_HELPER = True
except ImportError as e:
    HAS_COMPLETION_HELPER = False
    logger.debug(f"Completion helper not available: {e}")
    _missing_dependencies.append("completion_helper")

# Log missing dependencies for debugging
if _missing_dependencies:
    logger.debug(f"Missing helper modules: {', '.join(_missing_dependencies)}")

# Initialize global helpers with error handling
try:
    if HAS_CONFIG_MANAGER:
        config = get_config()
    else:
        config = None
except Exception as e:
    logger.warning(f"Failed to initialize config manager: {e}")
    config = None
    HAS_CONFIG_MANAGER = False

try:
    if HAS_PROGRESS_HELPER:
        progress = get_progress_helper()
    else:
        progress = None
except Exception as e:
    logger.warning(f"Failed to initialize progress helper: {e}")
    progress = None
    HAS_PROGRESS_HELPER = False

try:
    if HAS_PROMPTS_HELPER:
        prompts = get_prompts_helper()
    else:
        prompts = None
except Exception as e:
    logger.warning(f"Failed to initialize prompts helper: {e}")
    prompts = None
    HAS_PROMPTS_HELPER = False

try:
    if HAS_COMPLETION_HELPER:
        completion = get_completion_helper()
    else:
        completion = None
except Exception as e:
    logger.warning(f"Failed to initialize completion helper: {e}")
    completion = None
    HAS_COMPLETION_HELPER = False

# Set up rich-click configuration globally
click.rich_click.USE_RICH_MARKUP = True  
click.rich_click.USE_MARKDOWN = False  # Disable markdown to avoid conflicts
click.rich_click.MARKUP_MODE = "rich"

# Environment variables for additional control
os.environ["RICH_CLICK_USE_RICH_MARKUP"] = "1"
os.environ["RICH_CLICK_FORCE_TERMINAL"] = "1"
click.rich_click.SHOW_ARGUMENTS = True
click.rich_click.GROUP_ARGUMENTS_OPTIONS = True
click.rich_click.SHOW_METAVARS_COLUMN = {{ cli.config.show_metavars_column if cli.config else False }}
click.rich_click.APPEND_METAVARS_HELP = {{ cli.config.append_metavars_help if cli.config else True }}
click.rich_click.STYLE_ERRORS_SUGGESTION = "#ff5555"
click.rich_click.ERRORS_SUGGESTION = "Try running the '--help' flag for more information."
click.rich_click.ERRORS_EPILOGUE = "To find out more, visit {{ project_url | default('https://github.com/your-org/your-project') }}"
click.rich_click.MAX_WIDTH = 120  # Set reasonable width
click.rich_click.WIDTH = 120  # Set consistent width
click.rich_click.COLOR_SYSTEM = "auto"
click.rich_click.SHOW_SUBCOMMAND_ALIASES = True
click.rich_click.ALIGN_OPTIONS_SWITCHES = True
click.rich_click.STYLE_OPTION = "#ff79c6"      # Dracula Pink - for option flags
click.rich_click.STYLE_SWITCH = "#50fa7b"      # Dracula Green - for switches
click.rich_click.STYLE_METAVAR = "#8BE9FD not bold"   # Light cyan - for argument types (OPTIONS, COMMAND)  
click.rich_click.STYLE_METAVAR_SEPARATOR = "#6272a4"  # Dracula Comment
click.rich_click.STYLE_HEADER_TEXT = "bold yellow"    # Bold yellow - for section headers
click.rich_click.STYLE_EPILOGUE_TEXT = "#6272a4"      # Dracula Comment
click.rich_click.STYLE_FOOTER_TEXT = "#6272a4"        # Dracula Comment
click.rich_click.STYLE_USAGE = "#BD93F9"              # Purple - for "Usage:" line
click.rich_click.STYLE_USAGE_COMMAND = "bold"         # Bold for main command name
click.rich_click.STYLE_DEPRECATED = "#ff5555"         # Dracula Red
click.rich_click.STYLE_HELPTEXT_FIRST_LINE = "#f8f8f2" # Dracula Foreground
click.rich_click.STYLE_HELPTEXT = "#B3B8C0"           # Light gray - for help descriptions
click.rich_click.STYLE_OPTION_DEFAULT = "#ffb86c"     # Dracula Orange
click.rich_click.STYLE_REQUIRED_SHORT = "#ff5555"     # Dracula Red
click.rich_click.STYLE_REQUIRED_LONG = "#ff5555"      # Dracula Red
click.rich_click.STYLE_OPTIONS_PANEL_BORDER = "dim"   # Dim for subtle borders
click.rich_click.STYLE_COMMANDS_PANEL_BORDER = "dim"  # Dim for subtle borders
click.rich_click.STYLE_COMMAND = "#50fa7b"            # Dracula Green - for command names in list
click.rich_click.STYLE_COMMANDS_TABLE_COLUMN_WIDTH_RATIO = (1, 3)  # Command:Description ratio (1/4 : 3/4)

{% if cli.command_groups %}
# Command groups will be set after main function is defined
{% endif %}

# Hooks system - try to import app_hooks module
app_hooks = None
{% if hooks_path %}
# Using configured hooks path: {{ hooks_path }}
try:
    # First try as a module import (e.g., "ttt.app_hooks")
    module_path = "{{ hooks_path }}".replace(".py", "").replace("/", ".")
    if module_path.startswith("src."):
        module_path = module_path[4:]  # Remove 'src.' prefix
    
    try:
        app_hooks = importlib.import_module(module_path)
    except ImportError:
        # If module import fails, try relative import
        try:
            from . import app_hooks
        except ImportError:
            # If relative import fails, try file-based import as last resort
            script_dir = Path(__file__).parent.parent.parent
            hooks_file = script_dir / "{{ hooks_path }}"
            
            if hooks_file.exists():
                spec = importlib.util.spec_from_file_location("app_hooks", hooks_file)
                app_hooks = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(app_hooks)
except Exception:
    # No hooks module found, use default behavior
    pass
{% else %}
# No hooks path configured, try default locations
try:
    # Try to import from the project root directory
    script_dir = Path(__file__).parent.parent.parent
    hooks_path = script_dir / "app_hooks.py"
    
    if hooks_path.exists():
        spec = importlib.util.spec_from_file_location("app_hooks", hooks_path)
        app_hooks = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(app_hooks)
    else:
        # Try to import from Python path
        import app_hooks
except (ImportError, FileNotFoundError):
    # No hooks module found, use default behavior
    pass
{% endif %}

# Built-in commands
{% if cli %}
def builtin_upgrade_command(check_only=False, pre=False, version=None, dry_run=False):
    """Built-in upgrade function for {{ display_name }} - uses enhanced setup.sh script."""
    import subprocess
    import sys
    from pathlib import Path

    if check_only:
        print(f"Checking for updates to {{ display_name }}...")
        print("Update check not yet implemented. Run without --check to upgrade.")
        return

    if dry_run:
        print("Dry run - would execute: pipx upgrade {{ package_name }}")
        return

    # Find the setup.sh script - look in common locations
    setup_script = None
    search_paths = [
        Path(__file__).parent / "setup.sh",  # Package directory (installed packages)
        Path(__file__).parent.parent / "setup.sh",  # Development mode 
        Path.home() / ".local" / "share" / "{{ installation.pypi_name | default(package_name) }}" / "setup.sh",  # User data
        # Remove Path.cwd() to prevent cross-contamination
    ]
    
    for path in search_paths:
        if path.exists():
            setup_script = path
            break
    
    if setup_script is None:
        # Fallback to basic upgrade if setup.sh not found
        print(f"Enhanced setup script not found. Using basic upgrade for {{ display_name }}...")
        import shutil
        
        package_name = "{{ package_name }}"
        pypi_name = "{% if installation and installation.pypi_name %}{{ installation.pypi_name }}{% else %}{{ package_name }}{% endif %}"
        
        if shutil.which("pipx"):
            result = subprocess.run(["pipx", "list"], capture_output=True, text=True)
            if package_name in result.stdout or pypi_name in result.stdout:
                cmd = ["pipx", "upgrade", pypi_name]
            else:
                cmd = [sys.executable, "-m", "pip", "install", "--upgrade", pypi_name]
        else:
            cmd = [sys.executable, "-m", "pip", "install", "--upgrade", pypi_name]
        
        result = subprocess.run(cmd)
        if result.returncode == 0:
            print(f"‚úÖ {{ display_name }} upgraded successfully!")
            print(f"Run '{{ command_name }} --version' to verify the new version.")
        else:
            print(f"‚ùå Upgrade failed with exit code {result.returncode}")
            sys.exit(1)
        return

    # Use the enhanced setup.sh script
    result = subprocess.run([str(setup_script), "upgrade"])
    sys.exit(result.returncode)
{% endif %}

def load_plugins(cli_group):
    """Load plugins from the conventional plugin directory."""
    # Define plugin directories to search
    plugin_dirs = [
        # User-specific plugin directory
        Path.home() / ".config" / "{{ package_name }}" / "plugins",
        # Local plugin directory (same as script)
        Path(__file__).parent / "plugins",
    ]
    
    for plugin_dir in plugin_dirs:
        if not plugin_dir.exists():
            continue
            
        # Add plugin directory to Python path
        sys.path.insert(0, str(plugin_dir))
        
        # Scan for plugin files
        for plugin_file in plugin_dir.glob("*.py"):
            if plugin_file.name.startswith("_"):
                continue
                
            # Skip core system files that aren't plugins
            if plugin_file.name in ["loader.py", "__init__.py"]:
                continue
                
            plugin_name = plugin_file.stem
            
            try:
                # Import the plugin module
                spec = importlib.util.spec_from_file_location(plugin_name, plugin_file)
                plugin_module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(plugin_module)
                
                # Call register_plugin if it exists
                if hasattr(plugin_module, "register_plugin"):
                    plugin_module.register_plugin(cli_group)
                    click.echo(f"Loaded plugin: {plugin_name}", err=True)
            except Exception as e:
                click.echo(f"Failed to load plugin {plugin_name}: {e}", err=True)

{% macro render_option(opt) -%}
@click.option(
    {%- if opt.short %}"-{{ opt.short }}", {% endif %}"--{{ opt.name }}"
    {%- if opt.type == "flag" %},
    is_flag=True
    {%- elif opt.choices %},
    type=click.Choice({{ opt.choices }})
    {%- else %},
    type={% if opt.type == "str" %}str{% elif opt.type == "int" %}int{% elif opt.type == "float" %}float{% elif opt.type == "bool" %}bool{% else %}str{% endif %}
    {%- endif %}
    {%- if opt.multiple %},
    multiple=True
    {%- endif %}
    {%- if opt.default is not none %},
    default={% if opt.default is sameas true %}True{% elif opt.default is sameas false %}False{% elif opt.default is number %}{{ opt.default }}{% else %}"{{ opt.default }}"{% endif %}
    {%- endif %},
    help="{{ opt.desc }}"
)
{%- endmacro %}

{% macro render_argument(arg) -%}
@click.argument(
    "{{ arg.name|upper|replace('-', '_') }}"
    {%- if arg.nargs %},
    nargs={% if arg.nargs == "*" %}-1{% elif arg.nargs == "?" %}1{% else %}{{ arg.nargs }}{% endif %}
    {%- if arg.nargs == "?" %},
    required=False{% endif %}
    {%- endif %}
    {%- if arg.required is defined and not arg.required %},
    required=False{% endif %}
    {%- if arg.required is defined and arg.required and arg.nargs and arg.nargs != "*" %},
    required=True{% endif %}
    {%- if not arg.required is defined and arg.nargs and arg.nargs != "*" %},
    required=True{% endif %}
    {%- if arg.choices %},
    type=click.Choice({{ arg.choices }})
    {%- endif %}
)
{%- endmacro %}

{% macro render_command(cmd_name, cmd_data, is_subcommand=False) -%}
{% if not is_subcommand %}@main.command(){% else %}@{{ cmd_name }}.command(){% endif %}
@click.pass_context
{% for arg in (cmd_data.args or []) %}
{{ render_argument(arg) }}
{% endfor %}
{% for opt in (cmd_data.options or []) %}
{{ render_option(opt) }}
{% endfor %}
def {{ cmd_name }}(ctx{% if cmd_data.args or cmd_data.options %}, {% endif %}{% if cmd_data.args %}{{ (cmd_data.args|map(attribute='name')|map('lower')|map('replace', '-', '_')|list + (cmd_data.options|map(attribute='name')|map('replace', '-', '_')|list))|join(', ') }}{% else %}{{ (cmd_data.options or [])|map(attribute='name')|map('replace', '-', '_')|join(', ') }}{% endif %}):
    """{% if cmd_data.icon %}{{ cmd_data.icon | format_icon }}{% endif %}{{ cmd_data.desc }}"""
    {% if cmd_data.lifecycle == "managed" %}
    # Managed command - expect an instance of ManagedCommand
    command_instance_name = f"{{ cmd_name }}_command"
    if app_hooks and hasattr(app_hooks, command_instance_name):
        # Get the command instance
        command_instance = getattr(app_hooks, command_instance_name)
        
        # Prepare arguments including global options
        kwargs = {}
        kwargs['command_name'] = '{{ cmd_name }}'  # Pass command name for daemon management
        {% if cmd_data.args %}
        {% for arg in cmd_data.args %}
        kwargs['{{ arg.name|lower|replace('-', '_') }}'] = {{ arg.name|lower|replace('-', '_') }}
        {% endfor %}
        {% endif %}
        {% if cmd_data.options %}
        {% for opt in cmd_data.options %}
        {# Handle hyphenated parameters correctly #}
        {% set param_name = opt.name|replace('-', '_') %}
        {% set var_name = opt.name|replace('-', '_') %}
        kwargs['{{ param_name }}'] = {{ var_name }}
        {% endfor %}
        {% endif %}
        
        # Add global options from context
        {% if cli.options %}
        if ctx.obj:
            {% for option in cli.options %}
            kwargs['{{ option.name|replace('-', '_') }}'] = ctx.obj.get('{{ option.name }}')
            {% endfor %}
        {% endif %}
        
        # Call execute() method on the ManagedCommand instance
        result = command_instance.execute(**kwargs)
        return result
    else:
        click.echo(f"Error: Managed command '{{ cmd_name }}' requires '{{ cmd_name }}_command' instance in app_hooks.py")
        sys.exit(1)
    {% else %}
    # Check for built-in commands first
    {% if cmd_name == 'build' or cmd_name == 'init' %}
    # Built-in commands (build, init)
    try:
        from pathlib import Path
        import sys
        
        # Add the parent directory to sys.path to find goobits_cli
        parent_dir = Path(__file__).parent.parent.parent
        if str(parent_dir) not in sys.path:
            sys.path.insert(0, str(parent_dir))
        
        {% if cmd_name == 'build' %}
        from goobits_cli.main import build
        
        # Use current directory's goobits.yaml if no config path specified
        config_file = Path(config_path) if config_path else Path("goobits.yaml")
        output_dir_path = Path(output_dir) if output_dir else None
        
        build(config_file, output_dir_path, output, backup, universal_templates=False)
        click.echo("‚úÖ Build completed successfully!")
        click.echo("   - Generated setup.sh")
        click.echo("   - Updated CLI files")
        
        {% elif cmd_name == 'init' %}
        from goobits_cli.main import init
        
        init(project_name, template, force)
        click.echo("‚úÖ Init completed successfully!")
        click.echo("   - Created goobits.yaml")
        
        {% endif %}
            
    except ImportError as e:
        click.echo(f"‚ùå {{ cmd_name.title() }} error: Could not import framework functions: {e}")
        return False
    except Exception as e:
        click.echo(f"‚ùå {{ cmd_name.title() }} error: {e}")
        return False
    
    return True
    {% else %}
    # Standard command - use the existing hook pattern
    hook_name = f"on_{{ cmd_name }}"
    if app_hooks and hasattr(app_hooks, hook_name):
        # Call the hook with all parameters
        hook_func = getattr(app_hooks, hook_name)
        
        # Prepare arguments including global options
        kwargs = {}
        kwargs['command_name'] = '{{ cmd_name }}'  # Pass command name for all commands
        {% if cmd_data.args %}
        {% for arg in cmd_data.args %}
        kwargs['{{ arg.name|lower|replace('-', '_') }}'] = {{ arg.name|lower|replace('-', '_') }}
        {% endfor %}
        {% endif %}
        {% if cmd_data.options %}
        {% for opt in cmd_data.options %}
        {# Handle hyphenated parameters correctly #}
        {% set param_name = opt.name|replace('-', '_') %}
        {% set var_name = opt.name|replace('-', '_') %}
        kwargs['{{ param_name }}'] = {{ var_name }}
        {% endfor %}
        {% endif %}
        
        # Add global options from context
        {% if cli.options %}
        if ctx.obj:
            {% for option in cli.options %}
            kwargs['{{ option.name|replace('-', '_') }}'] = ctx.obj.get('{{ option.name }}')
            {% endfor %}
        {% endif %}
        
        result = hook_func(**kwargs)
        return result
    else:
        # Default placeholder behavior
        click.echo(f"Executing {{ cmd_name }} command...")
        {% if cmd_data.args %}
        {% for arg in cmd_data.args %}
        click.echo(f"  {{ arg.name }}: {{ '{' }}{{ arg.name|lower|replace('-', '_') }}{{ '}' }}")
        {% endfor %}
        {% endif %}
        {% if cmd_data.options %}
        {% for opt in cmd_data.options %}
        click.echo(f"  {{ opt.name }}: {{ '{' }}{{ opt.name|replace('-', '_') }}{{ '}' }}")
        {% endfor %}
        {% endif %}
    {% endif %}
    {% endif %}
{%- endmacro %}

def get_version():
    """Get version from pyproject.toml or __init__.py"""
    import re
    
    try:
        # Try to get version from pyproject.toml FIRST (most authoritative)
        # Look in multiple possible locations
        possible_paths = [
            Path(__file__).parent.parent / "pyproject.toml",  # For flat structure
            Path(__file__).parent.parent.parent / "pyproject.toml",  # For src/ structure
        ]
        toml_path = None
        for path in possible_paths:
            if path.exists():
                toml_path = path
                break
        if toml_path:
            content = toml_path.read_text()
            match = re.search(r'version\s*=\s*["\']([^"\']+)["\']', content)
            if match:
                return match.group(1)
    except Exception:
        pass
    
    try:
        # Fallback to __init__.py
        init_path = Path(__file__).parent / "__init__.py"
        if init_path.exists():
            content = init_path.read_text()
            match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
            if match:
                return match.group(1)
    except Exception:
        pass
        
    # Final fallback{% if cli.version %}
    return "{{ cli.version }}"{% else %}
    return "1.0.0"{% endif %}

{% if cli.enable_help_json %}
def show_help_json(ctx, param, value):
    """Callback for --help-json option."""
    if not value or ctx.resilient_parsing:
        return
    # The triple quotes are important to correctly handle the multi-line JSON string
    click.echo('''{{ cli_config_json }}''')
    ctx.exit()
{% endif %}

def start_interactive_mode(ctx, param, value):
    """Callback for --interactive option."""
    if not value or ctx.resilient_parsing:
        return
    
    try:
        # Try to import interactive mode module
        import importlib.util
        import os
        
        # Get the directory where this CLI script is located
        cli_dir = Path(__file__).parent
        interactive_file = cli_dir / "enhanced_interactive_mode.py"
        
        if interactive_file.exists():
            spec = importlib.util.spec_from_file_location("enhanced_interactive_mode", interactive_file)
            interactive_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(interactive_module)
            interactive_module.start_enhanced_interactive()
            # If we get here, interactive mode completed successfully, exit cleanly
            import sys
            sys.exit(0)
        else:
            click.echo("‚ùå Interactive mode not available. enhanced_interactive_mode.py not found.")
            ctx.exit(1)
    except SystemExit:
        # Interactive mode exited, let it pass through
        import sys
        sys.exit(0)
    except Exception as e:
        click.echo(f"‚ùå Error starting interactive mode: {e}")
        ctx.exit(1)

{# Find the default command #}
{% set ns = namespace(default_cmd=None) %}
{% for cmd_name, cmd_data in cli.commands.items() %}
  {% if cmd_data.is_default %}
    {% set ns.default_cmd = cmd_name %}
  {% endif %}
{% endfor %}

{% if ns.default_cmd %}
class DefaultGroup(RichGroup):
    """Allow a default command to be invoked without being specified."""
    
    def __init__(self, *args, default=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.default_command = default
    
    def main(self, *args, **kwargs):
        """Override main to handle stdin input when no command is provided."""
        import sys
        import os
        import stat
        
        # Check if we need to inject the default command due to stdin input
        if len(sys.argv) == 1 and self.default_command:  # Only script name provided
            # Check if stdin is coming from a pipe or redirection
            has_stdin = False
            try:
                # Check if stdin is a pipe or file (not a terminal)
                stdin_stat = os.fstat(sys.stdin.fileno())
                has_stdin = stat.S_ISFIFO(stdin_stat.st_mode) or stat.S_ISREG(stdin_stat.st_mode)
            except Exception:
                # Fallback to isatty check
                has_stdin = not sys.stdin.isatty()
            
            if has_stdin:
                # Inject the default command into sys.argv
                sys.argv.append(self.default_command)
        
        return super().main(*args, **kwargs)
    
    def resolve_command(self, ctx, args):
        import sys
        import os
        
        try:
            # Try normal command resolution first
            return super().resolve_command(ctx, args)
        except click.UsageError:
            # If no command found and we have a default, use it
            # Check if stdin is coming from a pipe or redirection
            has_stdin = False
            try:
                # Check if stdin is a pipe or file (not a terminal)
                stdin_stat = os.fstat(sys.stdin.fileno())
                # Use S_ISFIFO to check if it's a pipe, or S_ISREG to check if it's a regular file
                import stat
                has_stdin = stat.S_ISFIFO(stdin_stat.st_mode) or stat.S_ISREG(stdin_stat.st_mode)
            except Exception as e:
                # Fallback to isatty check
                has_stdin = not sys.stdin.isatty()
            
            is_help_request = any(arg in ['--help-all', '--help-json'] for arg in args)
            
            if self.default_command and not is_help_request:
                # Trigger default command if:
                # 1. We have args (existing behavior)
                # 2. We have stdin input (new behavior for pipes)
                if args or has_stdin:
                    cmd = self.commands.get(self.default_command)
                    if cmd:
                        # Return command name, command object, and all args
                        return self.default_command, cmd, args
            raise
{% endif %}

{% if ns.default_cmd %}
@click.group(cls=DefaultGroup, default='{{ ns.default_cmd }}', context_settings={"help_option_names": ["-h", "--help"], "max_content_width": 120})
{% else %}
@click.group(cls=RichGroup, context_settings={"help_option_names": ["-h", "--help"], "max_content_width": 120})
{% endif %}
@click.version_option(version=get_version(), prog_name="{{ cli.name }}")
@click.pass_context
{% if cli.enable_help_json %}
@click.option('--help-json', is_flag=True, callback=show_help_json, is_eager=True, help='Output CLI structure as JSON.', hidden=True)
{% endif %}
{% if cli.enable_recursive_help %}
@click.option('--help-all', is_flag=True, is_eager=True, help='Show help for all commands.', hidden=True)
{% endif %}
@click.option('--interactive', is_flag=True, is_eager=True, callback=start_interactive_mode, help='Launch interactive mode for running commands interactively.')
{% if cli.options %}
{% for option in cli.options %}
{{ render_option(option) }}
{% endfor %}
{% endif %}
def main(ctx{% if cli.enable_help_json %}, help_json=False{% endif %}{% if cli.enable_recursive_help %}, help_all=False{% endif %}{% if cli.options %}{% for option in cli.options %}, {{ option.name.replace('-', '_') }}{% if option.type == 'flag' %}=False{% else %}=None{% endif %}{% endfor %}{% endif %}):
    """{% if cli.icon %}{{ cli.icon | format_icon }}{% endif %}[bold color(6)]{{ cli.name }}{% if cli.display_version %}{% if cli.version %} v{{ cli.version }}{% elif version %} v{{ version }}{% else %} {version}{% endif %}{% endif %}[/bold color(6)] - {{ cli.tagline }}

    {% if cli.description %}
    \b
    [#B3B8C0]{{ cli.description }}[/#B3B8C0]
    {% endif %}

    {% if cli.header_sections %}
    {% for section in cli.header_sections %}
    [bold yellow]{{ section.title }}[/bold yellow]
    {%- set aligned_items = section.items | align_header_items %}
    {% for item in aligned_items %}
    {% if item.style == 'example' %}
    [green]   {{ item.item_aligned }}[/green] [italic][#B3B8C0]# {{ item.desc }}[/#B3B8C0][/italic]
    {% elif item.style == 'command' %}
    [green]   {{ item.item_aligned }}[/green]  {{ item.desc }}
    {% elif item.style == 'setup' %}
    [#B3B8C0]   {{ item.item + ":" }}{{ " " * (item.item_aligned|length - item.item|length - 1) }}[/#B3B8C0][green]{{ item.desc }}[/green]
    {%- endif %}
    {%- endfor %}
    [green] [/green]
    {% endfor %}
    {% endif %}
    {% if cli.footer_note %}
    [#B3B8C0]{{ cli.footer_note }}[/#B3B8C0]
    {% endif %}
    """
    {% if cli.enable_recursive_help %}
    if help_all:
        # Print main help
        click.echo(ctx.get_help())
        click.echo() # Add a blank line for spacing

        # Get a list of all command names
        commands_to_show = sorted(ctx.command.list_commands(ctx))

        for cmd_name in commands_to_show:
            command = ctx.command.get_command(ctx, cmd_name)

            # Create a new context for the subcommand
            sub_ctx = click.Context(command, info_name=cmd_name, parent=ctx)

            # Print a separator and the subcommand's help
            click.echo("="*20 + f" HELP FOR: {cmd_name} " + "="*20)
            click.echo(sub_ctx.get_help())
            click.echo() # Add a blank line for spacing

        # Exit after printing all help
        ctx.exit()
    {% endif %}
    
    # Store global options in context for use by commands
    {% if cli.options %}
    if ctx.obj is None:
        ctx.obj = {}
    {% for option in cli.options %}
    ctx.obj['{{ option.name }}'] = {{ option.name.replace('-', '_') }}
    {% endfor %}
    {% endif %}

    pass

# Replace the version placeholder with dynamic version in the main command docstring
{% if cli.display_version and not cli.version and not version %}
main.callback.__doc__ = main.callback.__doc__.replace("{version}", "v" + get_version())
{% endif %}

{% if cli.command_groups %}
# Set command groups after main function is defined
{%- set defined_commands = cli.commands.keys() | list %}
click.rich_click.COMMAND_GROUPS = {
    "main": [
        {% for group in cli.command_groups %}
        {
            "name": "{{ group.name }}",
            "commands": {{ group.commands | select('in', defined_commands) | list }},
        },
        {% endfor %}
    ]
}
{% endif %}

# Built-in upgrade command (enabled by default)
{% if cli and (cli.enable_upgrade_command is not defined or cli.enable_upgrade_command) %}
@main.command()
@click.option('--check', is_flag=True, help='Check for updates without installing')
@click.option('--version', type=str, help='Install specific version')
@click.option('--pre', is_flag=True, help='Include pre-release versions')
@click.option('--dry-run', is_flag=True, help='Show what would be done without doing it')
def upgrade(check, version, pre, dry_run):
    """Upgrade {{ display_name }} to the latest version."""
    builtin_upgrade_command(check_only=check, version=version, pre=pre, dry_run=dry_run)
{% endif %}

{% for cmd_name, cmd_data in cli.commands.items() %}
{% if not cmd_data.subcommands %}
{{ render_command(cmd_name, cmd_data) }}
{% else %}
@main.group()
def {{ cmd_name }}():
    """{% if cmd_data.icon %}{{ cmd_data.icon | format_icon }}{% endif %}{{ cmd_data.desc }}"""
    pass

{% for subcmd_name, subcmd_data in cmd_data.subcommands.items() %}
@{{ cmd_name }}.command()
@click.pass_context
{% for arg in (subcmd_data.args or []) %}
{{ render_argument(arg) }}
{% endfor %}
{% for opt in (subcmd_data.options or []) %}
{{ render_option(opt) }}
{% endfor %}
def {{ subcmd_name }}(ctx{% if subcmd_data.args or subcmd_data.options %}, {% endif %}{% if subcmd_data.args %}{{ (subcmd_data.args|map(attribute='name')|map('lower')|map('replace', '-', '_')|list + (subcmd_data.options|map(attribute='name')|map('replace', '-', '_')|list))|join(', ') }}{% else %}{{ (subcmd_data.options or [])|map(attribute='name')|map('replace', '-', '_')|join(', ') }}{% endif %}):
    """{% if subcmd_data.icon %}{{ subcmd_data.icon | format_icon }}{% endif %}{{ subcmd_data.desc }}"""
    # Check if hook function exists
    hook_name = f"on_{{ cmd_name }}_{{ subcmd_name }}"
    if app_hooks and hasattr(app_hooks, hook_name):
        # Call the hook with all parameters
        hook_func = getattr(app_hooks, hook_name)
        
        # Prepare arguments including global options
        kwargs = {}
        kwargs['command_name'] = '{{ subcmd_name }}'  # Pass command name for all commands
        {% if subcmd_data.args %}
        {% for arg in subcmd_data.args %}
        kwargs['{{ arg.name|lower|replace('-', '_') }}'] = {{ arg.name|lower|replace('-', '_') }}
        {% endfor %}
        {% endif %}
        {% if subcmd_data.options %}
        {% for opt in subcmd_data.options %}
        kwargs['{{ opt.name|replace('-', '_') }}'] = {{ opt.name|replace('-', '_') }}
        {% endfor %}
        {% endif %}
        
        # Add global options from context
        {% if cli.options %}
        if ctx.obj:
            {% for option in cli.options %}
            kwargs['{{ option.name|replace('-', '_') }}'] = ctx.obj.get('{{ option.name }}')
            {% endfor %}
        {% endif %}
        
        result = hook_func(**kwargs)
        return result
    else:
        # Default placeholder behavior
        click.echo(f"Executing {{ subcmd_name }} command...")
        {% if subcmd_data.args %}
        {% for arg in subcmd_data.args %}
        click.echo(f"  {{ arg.name }}: {{ '{' }}{{ arg.name|lower|replace('-', '_') }}{{ '}' }}")
        {% endfor %}
        {% endif %}
        {% if subcmd_data.options %}
        {% for opt in subcmd_data.options %}
        click.echo(f"  {{ opt.name }}: {{ '{' }}{{ opt.name|replace('-', '_') }}{{ '}' }}")
        {% endfor %}
        {% endif %}
{% endfor %}
{% endif %}

{% endfor %}

{# Auto-generate daemon management commands for managed commands #}
{% set ns = namespace(has_managed=false) %}
{% for cmd_name, cmd_data in cli.commands.items() %}
{% if cmd_data.lifecycle == "managed" %}
{% set ns.has_managed = true %}
{% endif %}
{% endfor %}
{% if ns.has_managed %}
@main.command()
@click.pass_context
@click.argument(
    "command_name",
    required=True
)
@click.option("--timeout",
    type=int,
    default=10,
    help="Timeout in seconds for graceful shutdown"
)
@click.option("--json",
    is_flag=True,
    help="Output in JSON format"
)
def daemonstop(ctx, command_name, timeout, json):
    """‚èπÔ∏è Stop a running daemon process"""
    from src.gubits.daemon import DaemonHelper
    
    daemon_helper = DaemonHelper(command_name)
    
    # Check if daemon is running
    if not daemon_helper.is_running():
        msg = f"No daemon running for command '{command_name}'"
        if json:
            import json as json_module
            click.echo(json_module.dumps({"status": "not_running", "message": msg}))
        else:
            click.echo(f"‚ö†Ô∏è  {msg}")
        return {"status": "not_running"}
    
    # Get PID before stopping
    pid = daemon_helper.get_pid()
    
    # Stop the daemon
    if daemon_helper.stop(timeout=timeout):
        if json:
            import json as json_module
            click.echo(json_module.dumps({
                "status": "stopped",
                "command": command_name,
                "pid": pid,
                "message": f"Successfully stopped daemon for '{command_name}'"
            }))
        else:
            click.echo(f"‚úÖ Successfully stopped daemon '{command_name}' (PID: {pid})")
        return {"status": "stopped", "pid": pid}
    else:
        error_msg = f"Failed to stop daemon '{command_name}' (PID: {pid})"
        if json:
            import json as json_module
            click.echo(json_module.dumps({"status": "error", "message": error_msg}))
        else:
            click.echo(f"‚ùå {error_msg}")
        return {"status": "error", "message": error_msg}


@main.command()
@click.pass_context
@click.argument(
    "command_name",
    required=True
)
@click.option("--json",
    is_flag=True,
    help="Output in JSON format"
)
def daemonstatus(ctx, command_name, json):
    """üìä Check status of a daemon process"""
    from src.gubits.daemon import DaemonHelper
    
    daemon_helper = DaemonHelper(command_name)
    
    # Get daemon stats
    stats = daemon_helper.get_daemon_stats()
    
    if json:
        import json as json_module
        click.echo(json_module.dumps(stats, indent=2))
    else:
        is_running = stats['running']
        status_emoji = 'üü¢' if is_running else 'üî¥'
        status_text = 'Running' if is_running else 'Stopped'
        
        click.echo(f"üìä Daemon Status for '{command_name}': {status_emoji} {status_text}")
        
        if is_running:
            click.echo(f"   PID: {stats['pid']}")
            click.echo(f"   PID File: {stats['pid_file']}")
        else:
            click.echo(f"   PID File: {stats['pid_file']} (not found or stale)")
            
    return stats


@main.group()
def daemon():
    """üîß Daemon system integration commands"""
    pass


@daemon.command()
@click.pass_context
@click.argument(
    "command_name",
    required=True
)
@click.option("--user",
    is_flag=True,
    default=True,
    help="Install as user service (default)"
)
@click.option("--system",
    is_flag=True,
    help="Install as system service (requires sudo)"
)
def install(ctx, command_name, user, system):
    """üîß Generate systemd service file for daemon management"""
    import shutil
    import subprocess
    from pathlib import Path
    
    # Determine CLI executable path
    cli_executable = shutil.which("{{ cli.name|lower|replace(' ', '') }}")
    if not cli_executable:
        # Fallback to sys.executable with -m approach
        cli_executable = f"{sys.executable} -m {{ cli.name|lower|replace(' ', '_') }}"
    
    # Determine installation type
    if system:
        service_dir = Path("/etc/systemd/system")
        service_type = "system"
        install_cmd_prefix = "sudo "
    else:
        service_dir = Path.home() / ".config" / "systemd" / "user"
        service_type = "user"
        install_cmd_prefix = ""
    
    # Ensure service directory exists
    if not service_dir.exists():
        try:
            service_dir.mkdir(parents=True, exist_ok=True)
        except PermissionError:
            click.echo(f"‚ùå Permission denied creating directory: {service_dir}")
            click.echo(f"   Try running with sudo for system services")
            sys.exit(1)
    
    # Generate service file name
    service_name = f"{{ cli.name|lower|replace(' ', '-') }}-{command_name}.service"
    service_file_path = service_dir / service_name
    
    # Determine PID file path
    if system:
        pid_file_path = f"/run/{{ cli.name|lower|replace(' ', '-') }}-{command_name}.pid"
        working_dir = "/var/lib/{{ cli.name|lower|replace(' ', '-') }}"
    else:
        runtime_dir = os.environ.get('XDG_RUNTIME_DIR', f"/run/user/{os.getuid()}")
        pid_file_path = f"{runtime_dir}/{{ cli.name|lower|replace(' ', '-') }}-{command_name}.pid"
        working_dir = str(Path.home())
    
    # Generate systemd unit file content
    service_content = f"""# Auto-generated by goobits for the '{command_name}' command
# Service file for {{ cli.name }} daemon management
[Unit]
Description=goobits-managed daemon for the '{command_name}' command
After=network.target
Wants=network.target

[Service]
Type=forking
ExecStart={cli_executable} {command_name} --daemon
PIDFile={pid_file_path}
Restart=on-failure
RestartSec=5
WorkingDirectory={working_dir}
"""

    # Add user-specific settings
    if not system:
        service_content += """
# User service settings
User=%i
Group=%i
"""

    service_content += """
[Install]
WantedBy={"default.target" if not system else "multi-user.target"}
"""
    
    # Write service file
    try:
        with open(service_file_path, 'w') as f:
            f.write(service_content)
        click.echo(f"‚úÖ Generated systemd service file: {service_file_path}")
    except PermissionError:
        click.echo(f"‚ùå Permission denied writing to: {service_file_path}")
        if not system:
            click.echo(f"   Try: mkdir -p {service_dir}")
        sys.exit(1)
    
    # Print usage instructions
    click.echo(f"")
    click.echo(f"üîß Systemd service '{service_name}' created successfully!")
    click.echo(f"")
    click.echo(f"üìã To enable and start the service:")
    if system:
        click.echo(f"   sudo systemctl daemon-reload")
        click.echo(f"   sudo systemctl enable {service_name}")
        click.echo(f"   sudo systemctl start {service_name}")
        click.echo(f"")
        click.echo(f"üìä To check status:")
        click.echo(f"   sudo systemctl status {service_name}")
        click.echo(f"")
        click.echo(f"üõë To stop and disable:")
        click.echo(f"   sudo systemctl stop {service_name}")
        click.echo(f"   sudo systemctl disable {service_name}")
    else:
        click.echo(f"   systemctl --user daemon-reload")
        click.echo(f"   systemctl --user enable {service_name}")
        click.echo(f"   systemctl --user start {service_name}")
        click.echo(f"")
        click.echo(f"üìä To check status:")
        click.echo(f"   systemctl --user status {service_name}")
        click.echo(f"")
        click.echo(f"üõë To stop and disable:")
        click.echo(f"   systemctl --user stop {service_name}")
        click.echo(f"   systemctl --user disable {service_name}")
    
    click.echo(f"")
    click.echo(f"üìù Service file location: {service_file_path}")
    
    return {"status": "service_created", "service_file": str(service_file_path), "service_name": service_name}

{% endif %}

# Shell completion commands
@main.group()
def completion():
    """üîß Shell completion management"""
    pass

# Internal completion command (hidden from help)
@main.command()
@click.argument('shell', type=click.Choice(['bash', 'zsh', 'fish']))
@click.argument('current_line')
@click.argument('cursor_pos', type=int, required=False)
@click.option('--debug', is_flag=True, help='Debug completion engine')
def _completion(shell, current_line, cursor_pos, debug):
    """Internal completion command - called by shell completion scripts"""
    try:
        # Import completion engine
        import os
        import sys
        from pathlib import Path
        
        # Add completion_engine to path
        engine_path = Path(__file__).parent / "completion_engine.py"
        
        if engine_path.exists():
            # Import and run the completion engine
            import importlib.util
            spec = importlib.util.spec_from_file_location("completion_engine", engine_path)
            completion_engine = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(completion_engine)
            
            # Get completions
            engine = completion_engine.CompletionEngine()
            completions = engine.get_completions(shell, current_line, cursor_pos)
            
            # Output completions
            for completion in completions:
                click.echo(completion)
                
        elif debug:
            click.echo("completion_engine.py not found", err=True)
            
    except Exception as e:
        if debug:
            click.echo(f"Completion error: {e}", err=True)
        # Silently fail in production to avoid breaking shell completion

# Add this command with underscore to hide it from help
_completion.hidden = True

@completion.command()
@click.argument('shell', type=click.Choice(['bash', 'zsh', 'fish']))
@click.option('--output', '-o', type=click.Path(), help='Output file path')
def generate(shell, output):
    """Generate shell completion script"""
    if not HAS_COMPLETION_HELPER:
        click.echo("‚ùå Completion helper not available. Missing completion_helper module.")
        return
    
    try:
        script_content = generate_completion_script(shell)
        
        if output:
            output_path = Path(output)
            output_path.write_text(script_content)
            click.echo(f"‚úÖ {shell.title()} completion script saved to: {output_path}")
        else:
            click.echo(script_content)
    except Exception as e:
        click.echo(f"‚ùå Error generating {shell} completion: {e}")

@completion.command()
@click.argument('shell', type=click.Choice(['bash', 'zsh', 'fish']))
@click.option('--user', is_flag=True, default=True, help='Install for current user (default)')
@click.option('--system', is_flag=True, help='Install system-wide (requires sudo)')
def install(shell, user, system):
    """Install shell completion script"""
    if not HAS_COMPLETION_HELPER:
        click.echo("‚ùå Completion helper not available. Missing completion_helper module.")
        return
    
    try:
        user_install = not system
        success = install_completion(shell, user_install)
        
        if success:
            click.echo(f"‚úÖ {shell.title()} completion installed successfully!")
            
            instructions = get_install_instructions(shell)
            if instructions and 'reload_cmd' in instructions:
                click.echo(f"üí° Reload your shell: {instructions['reload_cmd']}")
        else:
            click.echo(f"‚ùå Failed to install {shell} completion")
            
    except Exception as e:
        click.echo(f"‚ùå Error installing {shell} completion: {e}")

@completion.command()
@click.argument('shell', type=click.Choice(['bash', 'zsh', 'fish']))
def instructions(shell):
    """Show installation instructions for shell completion"""
    if not HAS_COMPLETION_HELPER:
        click.echo("‚ùå Completion helper not available. Missing completion_helper module.")
        return
    
    instructions = get_install_instructions(shell)
    if not instructions:
        click.echo(f"‚ùå No instructions available for {shell}")
        return
    
    click.echo(f"üìã {shell.title()} completion installation instructions:")
    click.echo()
    
    click.echo("üè† User installation (recommended):")
    click.echo(f"   mkdir -p {Path(instructions['user_script_path']).parent}")
    click.echo(f"   {{ cli.name | lower | replace(' ', '-') }} completion generate {shell} > completion.{shell}")
    click.echo(f"   cp completion.{shell} {instructions['user_script_path']}")
    click.echo()
    
    click.echo("üåê System-wide installation:")
    click.echo(f"   {{ cli.name | lower | replace(' ', '-') }} completion generate {shell} > completion.{shell}")
    click.echo(f"   {instructions['install_cmd']}")
    click.echo()
    
    click.echo("üîÑ Reload shell:")
    click.echo(f"   {instructions['reload_cmd']}")

# Configuration management commands
@main.group()
def config():
    """‚öôÔ∏è Configuration management"""
    pass

@config.command()
@click.argument('key', required=False)
def get(key):
    """Get configuration value"""
    if not HAS_CONFIG_MANAGER:
        click.echo("‚ùå Configuration manager not available.")
        return
    
    try:
        if key:
            value = get_config_value(key)
            if value is not None:
                click.echo(f"{key}: {value}")
            else:
                click.echo(f"‚ùå Configuration key '{key}' not found")
        else:
            # Show all configuration
            config_data = load_config()
            import json
            click.echo(json.dumps(config_data, indent=2))
    except Exception as e:
        click.echo(f"‚ùå Error getting configuration: {e}")

@config.command()
@click.argument('key')
@click.argument('value')
def set(key, value):
    """Set configuration value"""
    if not HAS_CONFIG_MANAGER:
        click.echo("‚ùå Configuration manager not available.")
        return
    
    try:
        # Try to parse value as JSON for complex types
        import json
        try:
            parsed_value = json.loads(value)
        except json.JSONDecodeError:
            parsed_value = value
        
        success = set_config_value(key, parsed_value)
        if success:
            click.echo(f"‚úÖ Set {key} = {parsed_value}")
        else:
            click.echo(f"‚ùå Failed to set configuration value")
    except Exception as e:
        click.echo(f"‚ùå Error setting configuration: {e}")

@config.command()
def reset():
    """Reset configuration to defaults"""
    if not HAS_CONFIG_MANAGER:
        click.echo("‚ùå Configuration manager not available.")
        return
    
    try:
        if HAS_PROMPTS_HELPER:
            if confirm("Are you sure you want to reset all configuration to defaults?"):
                config.reset()
                click.echo("‚úÖ Configuration reset to defaults")
            else:
                click.echo("‚ùå Reset cancelled")
        else:
            config.reset()
            click.echo("‚úÖ Configuration reset to defaults")
    except Exception as e:
        click.echo(f"‚ùå Error resetting configuration: {e}")

@config.command()
def path():
    """Show configuration file path"""
    if not HAS_CONFIG_MANAGER:
        click.echo("‚ùå Configuration manager not available.")
        return
    
    try:
        config_path = config.get_config_path()
        click.echo(f"üìÅ Configuration file: {config_path}")
        
        # Check for RC files
        rc_file = config.find_rc_file()
        if rc_file:
            click.echo(f"üìÑ Active RC file: {rc_file}")
    except Exception as e:
        click.echo(f"‚ùå Error getting configuration path: {e}")

def cli_entry():
    """Entry point for the CLI when installed via pipx."""
    try:
        # Load plugins before running the CLI
        load_plugins(main)
        main()
    except KeyboardInterrupt:
        click.echo("\n‚èπÔ∏è  Operation cancelled by user", err=True)
        sys.exit(130)  # Standard exit code for Ctrl+C
    except Exception as e:
        # Get debug flag from command line args
        debug = '--debug' in sys.argv
        exit_code = handle_cli_error(e, debug)
        sys.exit(exit_code)

if __name__ == "__main__":
    cli_entry()