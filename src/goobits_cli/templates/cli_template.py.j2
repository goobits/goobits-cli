#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                           AUTO-GENERATED FILE                                ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  Generated by: goobits-cli v{{ version or '3.0.0' }}                        ‚ïë
‚ïë  Generated from: {{ file_name }}                                            ‚ïë
‚ïë  Generated on: {% raw %}{{ datetime.now().strftime('%Y-%m-%d %H:%M:%S') }}{% endraw %}  ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  ‚ö†Ô∏è  DO NOT EDIT THIS FILE MANUALLY                                         ‚ïë
‚ïë  Changes will be overwritten on next generation                             ‚ïë
‚ïë                                                                              ‚ïë
‚ïë  To modify this CLI, edit the source configuration file:                    ‚ïë
‚ïë  {{ file_name }}                                                            ‚ïë
‚ïë                                                                              ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

{{ display_name }} CLI - Python Implementation
Auto-generated from {{ file_name }}
"""
import os
import sys
import time
import logging
import importlib.util
from pathlib import Path
import rich_click as click
from rich_click import RichGroup, RichCommand
from typing import Optional, Dict, Any


# Enhanced Error Handling Classes
class CLIError(Exception):
    """Base exception for CLI errors."""
    def __init__(self, message: str, exit_code: int = 1, suggestion: Optional[str] = None):
        self.message = message
        self.exit_code = exit_code
        self.suggestion = suggestion
        super().__init__(self.message)


class ConfigError(CLIError):
    """Configuration-related error."""
    def __init__(self, message: str, suggestion: Optional[str] = None):
        super().__init__(message, exit_code=2, suggestion=suggestion)


class HookError(CLIError):
    """Hook execution error."""
    def __init__(self, message: str, hook_name: Optional[str] = None):
        self.hook_name = hook_name
        super().__init__(message, exit_code=3, suggestion=f"Check the '{hook_name}' function in your cli_hooks.py file" if hook_name else None)


class DependencyError(CLIError):
    """Missing dependency error."""
    def __init__(self, message: str, dependency: str, install_command: Optional[str] = None):
        self.dependency = dependency
        self.install_command = install_command
        suggestion = f"Install with: {install_command}" if install_command else f"Install the '{dependency}' package"
        super().__init__(message, exit_code=4, suggestion=suggestion)


# Global error handler
def handle_cli_error(error: Exception, verbose: bool = False) -> int:
    """Handle CLI errors with appropriate messages and exit codes."""
    if isinstance(error, CLIError):
        click.echo(f"‚ùå Error: {error.message}", err=True)
        if error.suggestion:
            click.echo(f"üí° Suggestion: {error.suggestion}", err=True)
        if verbose:
            import traceback
            click.echo("\nüîç Debug traceback:", err=True)
            click.echo(traceback.format_exc(), err=True)
        return error.exit_code
    else:
        # Unexpected errors
        click.echo(f"‚ùå Unexpected error: {str(error)}", err=True)
        click.echo("üí° This may be a bug. Please report it with the following details:", err=True)
        if verbose:
            import traceback
            click.echo(traceback.format_exc(), err=True)
        else:
            click.echo(f"   Error type: {type(error).__name__}", err=True)
            click.echo(f"   Error message: {str(error)}", err=True)
            click.echo("   Run with --verbose for full traceback", err=True)
        return 1


# Structured logging setup - Centralized CLI logging infrastructure
def setup_cli_logging():
    """
    Initialize structured logging for {{ display_name }}.
    
    Environment Variables:
    - {{ command_name | upper }}_LOG_LEVEL: Set logging level (DEBUG, INFO, WARNING, ERROR) - default: INFO
    - {{ command_name | upper }}_LOG_OUTPUT: Set output destination (stdout, stderr, file:<path>) - default: stdout
    - LOG_LEVEL: Global log level fallback
    - LOG_OUTPUT: Global log output fallback  
    - ENVIRONMENT: Set environment (production/development) - affects format
    """
    import json
    from pathlib import Path
    from contextvars import ContextVar
    from typing import Dict, Any
    
    # Context variables for structured logging
    global _log_context
    _log_context: ContextVar[Dict[str, Any]] = ContextVar('log_context', default={})
    
    class StructuredFormatter(logging.Formatter):
        """Custom formatter that outputs structured logs based on environment."""
        
        def __init__(self):
            super().__init__()
            self.environment = os.getenv('ENVIRONMENT', 'development')
            self.is_production = self.environment.lower() in ('production', 'prod')
        
        def format(self, record: logging.LogRecord) -> str:
            """Format log record as JSON for production or readable format for development."""
            
            # Get current context
            context = _log_context.get({})
            
            # Build log data
            log_data = {
                'timestamp': self.formatTime(record),
                'level': record.levelname,
                'logger': record.name,
                'message': record.getMessage(),
                'module': record.module,
                'function': record.funcName,
                'line': record.lineno,
            }
            
            # Add context if available
            if context:
                log_data['context'] = context
            
            # Add exception info if present
            if record.exc_info:
                log_data['exception'] = {
                    'type': record.exc_info[0].__name__ if record.exc_info[0] else None,
                    'message': str(record.exc_info[1]) if record.exc_info[1] else None,
                    'traceback': self.formatException(record.exc_info) if record.exc_info else None
                }
            
            # Add extra fields from log record
            extra_fields = {}
            for key, value in record.__dict__.items():
                if key not in ['name', 'msg', 'args', 'levelname', 'levelno', 'pathname', 
                              'filename', 'module', 'lineno', 'funcName', 'created', 
                              'msecs', 'relativeCreated', 'thread', 'threadName', 
                              'processName', 'process', 'message', 'exc_info', 'exc_text', 'stack_info']:
                    extra_fields[key] = value
            
            if extra_fields:
                log_data['extra'] = extra_fields
            
            if self.is_production:
                # JSON format for production
                return json.dumps(log_data)
            else:
                # Human-readable format for development
                context_str = f" [{', '.join(f'{k}={v}' for k, v in context.items())}]" if context else ""
                extra_str = f" {extra_fields}" if extra_fields else ""
                
                base_msg = f"{log_data['timestamp']} {log_data['level']:8} {log_data['logger']:20} {log_data['message']}"
                
                if context_str or extra_str:
                    base_msg += f"{context_str}{extra_str}"
                
                # Add exception info if present
                if record.exc_info:
                    base_msg += f"\n{self.formatException(record.exc_info)}"
                
                return base_msg
    
    # Get configuration from environment with CLI-specific prefixes
    log_level = (os.getenv('{{ command_name | upper }}_LOG_LEVEL') or 
                 os.getenv('LOG_LEVEL', 'INFO')).upper()
    log_output = (os.getenv('{{ command_name | upper }}_LOG_OUTPUT') or 
                  os.getenv('LOG_OUTPUT', 'stdout')).lower()
    
    # Configure logging level
    try:
        level = getattr(logging, log_level)
    except AttributeError:
        level = logging.INFO
        print(f"Warning: Invalid LOG_LEVEL '{log_level}', using INFO", file=sys.stderr)
    
    # Set up formatter
    formatter = StructuredFormatter()
    
    # Configure handlers based on LOG_OUTPUT
    handlers = []
    
    if log_output == 'stderr':
        # All logs to stderr
        handler = logging.StreamHandler(sys.stderr)
        handler.setFormatter(formatter)
        handlers.append(handler)
    elif log_output.startswith('file:'):
        # Log to file
        log_file = log_output[5:]  # Remove 'file:' prefix
        log_path = Path(log_file)
        
        # Ensure log directory exists
        log_path.parent.mkdir(parents=True, exist_ok=True)
        
        handler = logging.FileHandler(log_path)
        handler.setFormatter(formatter)
        handlers.append(handler)
    elif log_output == 'stdout':
        # Container-friendly: INFO/DEBUG to stdout, WARN/ERROR to stderr
        stdout_handler = logging.StreamHandler(sys.stdout)
        stdout_handler.setFormatter(formatter)
        stdout_handler.setLevel(logging.DEBUG)
        stdout_handler.addFilter(lambda record: record.levelno < logging.WARNING)
        
        stderr_handler = logging.StreamHandler(sys.stderr)
        stderr_handler.setFormatter(formatter)
        stderr_handler.setLevel(logging.WARNING)
        
        handlers.extend([stdout_handler, stderr_handler])
    else:
        # Default to stdout for unknown options
        handler = logging.StreamHandler(sys.stdout)
        handler.setFormatter(formatter)
        handlers.append(handler)
    
    # Configure root logger
    root_logger = logging.getLogger()
    
    # Clear existing handlers to avoid duplicates
    for handler in root_logger.handlers[:]:
        root_logger.removeHandler(handler)
    
    # Add new handlers
    for handler in handlers:
        root_logger.addHandler(handler)
    
    root_logger.setLevel(level)
    
    return level, log_output

# Context management functions for CLI logging
def set_cli_context(**kwargs):
    """Set logging context variables that will be included in all log messages."""
    current_context = _log_context.get({})
    updated_context = {**current_context, **kwargs}
    _log_context.set(updated_context)

def clear_cli_context():
    """Clear all logging context variables."""
    _log_context.set({})

def update_cli_context(**kwargs):
    """Update existing context with new values."""
    current_context = _log_context.get({})
    current_context.update(kwargs)
    _log_context.set(current_context)

# Initialize structured logging
_log_context = None  # Will be initialized in setup_cli_logging
logging_level, logging_output = setup_cli_logging()
logger = logging.getLogger(__name__)

# Log initialization message
logger.info(f"{{ display_name }} CLI initialized with structured logging: level={logging_level}, output={logging_output}")

# Make logging functions available to hook system
def get_cli_logger(name: str = None) -> logging.Logger:
    """Get a logger instance for use in hooks and CLI components."""
    return logging.getLogger(name or __name__)

def get_cli_logging_context():
    """Get current CLI logging context for use in hooks."""
    return _log_context.get({}) if _log_context else {}

# Export logging context functions for hook use
__all__ = ['get_cli_logger', 'get_cli_logging_context', 'set_cli_context', 'clear_cli_context', 'update_cli_context']

# Import generated helper modules with enhanced error handling
_missing_dependencies = []

try:
    from .config_manager import get_config, load_config, get_config_value, set_config_value
    HAS_CONFIG_MANAGER = True
except ImportError as e:
    HAS_CONFIG_MANAGER = False
    logger.debug(f"Config manager not available: {e}")
    _missing_dependencies.append("config_manager")

try:
    from .progress_helper import (
        get_progress_helper, spinner, progress_bar, simple_progress,
        print_success, print_error, print_warning, print_info,
        with_spinner, with_progress
    )
    HAS_PROGRESS_HELPER = True
except ImportError as e:
    HAS_PROGRESS_HELPER = False
    logger.debug(f"Progress helper not available: {e}")
    _missing_dependencies.append("progress_helper")

try:
    from .prompts_helper import (
        get_prompts_helper, text, password, confirm, select, multiselect,
        integer, float_input, path
    )
    HAS_PROMPTS_HELPER = True
except ImportError as e:
    HAS_PROMPTS_HELPER = False
    logger.debug(f"Prompts helper not available: {e}")
    _missing_dependencies.append("prompts_helper")

try:
    from .completion_helper import (
        get_completion_helper, generate_completion_script, install_completion,
        get_install_instructions
    )
    HAS_COMPLETION_HELPER = True
except ImportError as e:
    HAS_COMPLETION_HELPER = False
    logger.debug(f"Completion helper not available: {e}")
    _missing_dependencies.append("completion_helper")

# Log missing dependencies for debugging
if _missing_dependencies:
    logger.debug(f"Missing helper modules: {', '.join(_missing_dependencies)}")

# Initialize global helpers with error handling
try:
    if HAS_CONFIG_MANAGER:
        config = get_config()
    else:
        config = None
except Exception as e:
    logger.warning(f"Failed to initialize config manager: {e}")
    config = None
    HAS_CONFIG_MANAGER = False

try:
    if HAS_PROGRESS_HELPER:
        progress = get_progress_helper()
    else:
        progress = None
except Exception as e:
    logger.warning(f"Failed to initialize progress helper: {e}")
    progress = None
    HAS_PROGRESS_HELPER = False

try:
    if HAS_PROMPTS_HELPER:
        prompts = get_prompts_helper()
    else:
        prompts = None
except Exception as e:
    logger.warning(f"Failed to initialize prompts helper: {e}")
    prompts = None
    HAS_PROMPTS_HELPER = False

try:
    if HAS_COMPLETION_HELPER:
        completion = get_completion_helper()
    else:
        completion = None
except Exception as e:
    logger.warning(f"Failed to initialize completion helper: {e}")
    completion = None
    HAS_COMPLETION_HELPER = False

# Set up rich-click configuration globally
click.rich_click.USE_RICH_MARKUP = True  
click.rich_click.USE_MARKDOWN = False  # Disable markdown to avoid conflicts
click.rich_click.MARKUP_MODE = "rich"

# Environment variables for additional control
os.environ["RICH_CLICK_USE_RICH_MARKUP"] = "1"
os.environ["RICH_CLICK_FORCE_TERMINAL"] = "1"
click.rich_click.SHOW_ARGUMENTS = True
click.rich_click.GROUP_ARGUMENTS_OPTIONS = True
click.rich_click.SHOW_METAVARS_COLUMN = {{ cli.config.show_metavars_column if cli.config else False }}
click.rich_click.APPEND_METAVARS_HELP = {{ cli.config.append_metavars_help if cli.config else True }}
click.rich_click.STYLE_ERRORS_SUGGESTION = "#ff5555"
click.rich_click.ERRORS_SUGGESTION = "Try running the '--help' flag for more information."
click.rich_click.ERRORS_EPILOGUE = "To find out more, visit {{ project_url | default('https://github.com/your-org/your-project') }}"
click.rich_click.MAX_WIDTH = 120  # Set reasonable width
click.rich_click.WIDTH = 120  # Set consistent width
click.rich_click.COLOR_SYSTEM = "auto"
click.rich_click.SHOW_SUBCOMMAND_ALIASES = True
click.rich_click.ALIGN_OPTIONS_SWITCHES = True
click.rich_click.STYLE_OPTION = "#ff79c6"      # Dracula Pink - for option flags
click.rich_click.STYLE_SWITCH = "#50fa7b"      # Dracula Green - for switches
click.rich_click.STYLE_METAVAR = "#8BE9FD not bold"   # Light cyan - for argument types (OPTIONS, COMMAND)  
click.rich_click.STYLE_METAVAR_SEPARATOR = "#6272a4"  # Dracula Comment
click.rich_click.STYLE_HEADER_TEXT = "bold yellow"    # Bold yellow - for section headers
click.rich_click.STYLE_EPILOGUE_TEXT = "#6272a4"      # Dracula Comment
click.rich_click.STYLE_FOOTER_TEXT = "#6272a4"        # Dracula Comment
click.rich_click.STYLE_USAGE = "#BD93F9"              # Purple - for "Usage:" line
click.rich_click.STYLE_USAGE_COMMAND = "bold"         # Bold for main command name
click.rich_click.STYLE_DEPRECATED = "#ff5555"         # Dracula Red
click.rich_click.STYLE_HELPTEXT_FIRST_LINE = "#f8f8f2" # Dracula Foreground
click.rich_click.STYLE_HELPTEXT = "#B3B8C0"           # Light gray - for help descriptions
click.rich_click.STYLE_OPTION_DEFAULT = "#ffb86c"     # Dracula Orange
click.rich_click.STYLE_REQUIRED_SHORT = "#ff5555"     # Dracula Red
click.rich_click.STYLE_REQUIRED_LONG = "#ff5555"      # Dracula Red
click.rich_click.STYLE_OPTIONS_PANEL_BORDER = "dim"   # Dim for subtle borders
click.rich_click.STYLE_COMMANDS_PANEL_BORDER = "dim"  # Dim for subtle borders
click.rich_click.STYLE_COMMAND = "#50fa7b"            # Dracula Green - for command names in list
click.rich_click.STYLE_COMMANDS_TABLE_COLUMN_WIDTH_RATIO = (1, 3)  # Command:Description ratio (1/4 : 3/4)

{% if cli.command_groups %}
# Command groups will be set after main function is defined
{% endif %}

# Helper function to convert file path to Python import path
def _path_to_import_path(file_path: str, package_name: str = "{{ package_name }}") -> tuple[str, str]:
    """Convert a file path like 'mypackage/cli/hooks.py' to import path 'mypackage.cli.hooks'"""
    # Remove .py extension
    clean_path = file_path.replace(".py", "")
    
    # Convert forward slashes to dots for Python import
    import_path = clean_path.replace("/", ".")
    
    # Remove 'src.' prefix if present
    if import_path.startswith("src."):
        import_path = import_path[4:]
    
    # Extract just the module name (e.g., 'hooks' from 'mypackage.cli.hooks')
    module_name = import_path.split(".")[-1]
    
    return import_path, module_name

# Robust hook discovery function
def _find_and_import_hooks():
    """Find and import hooks using package-relative imports with filesystem fallback"""
    {% if hooks_path %}
    # Using configured hooks path: {{ hooks_path }}
    configured_path = "{{ hooks_path }}"
    import_path, module_name = _path_to_import_path(configured_path)
    
    # Strategy 1: Try package-relative import (works from any directory when installed)
    try:
        return importlib.import_module(import_path)
    except ImportError:
        pass
    
    # Strategy 2: Try relative import from current package
    try:
        if "." in import_path:
            # Try importing from the base package
            package_parts = import_path.split(".")
            if len(package_parts) >= 2:
                relative_import = ".".join(package_parts[1:])  # Remove package name
                return importlib.import_module(f".{relative_import}", package="{{ package_name }}")
        else:
            # Direct relative import
            return importlib.import_module(f".{module_name}", package="{{ package_name }}")
    except ImportError:
        pass
    
    # Strategy 3: Try direct module name import (for simple cases)
    try:
        return importlib.import_module(module_name)
    except ImportError:
        pass
    
    # Strategy 4: File-based import as fallback (development mode)
    try:
        # Look for the file relative to the CLI script location
        cli_dir = Path(__file__).parent
        
        # Try multiple possible locations relative to CLI
        search_paths = [
            cli_dir / configured_path,                    # Same directory as CLI
            cli_dir.parent / configured_path,             # Parent of CLI directory  
            cli_dir.parent.parent / configured_path,      # Two levels up (src structure)
            cli_dir.parent.parent.parent / configured_path, # Three levels up (deep structure)
        ]
        
        for hooks_file in search_paths:
            if hooks_file.exists():
                spec = importlib.util.spec_from_file_location(module_name, hooks_file)
                if spec and spec.loader:
                    hooks_module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(hooks_module)
                    return hooks_module
    except (ImportError, AttributeError):
        pass  # Expected when hook file/function doesn't exist
    
    {% else %}
    # No hooks path configured, try default locations
    default_module_name = "cli_hooks"
    
    # Strategy 1: Try package-relative import
    try:
        return importlib.import_module(f"{{ package_name }}.{default_module_name}")
    except ImportError:
        pass
    
    # Strategy 2: Try relative import
    try:
        return importlib.import_module(f".{default_module_name}", package="{{ package_name }}")
    except ImportError:
        pass
    
    # Strategy 3: Try direct import from Python path
    try:
        return importlib.import_module(default_module_name)
    except ImportError:
        pass
    
    # Strategy 4: File-based fallback for development
    try:
        cli_dir = Path(__file__).parent
        search_paths = [
            cli_dir / f"{default_module_name}.py",
            cli_dir.parent / f"{default_module_name}.py",
            cli_dir.parent.parent / f"{default_module_name}.py",
            cli_dir.parent.parent.parent / f"{default_module_name}.py",
        ]
        
        for hooks_file in search_paths:
            if hooks_file.exists():
                spec = importlib.util.spec_from_file_location(default_module_name, hooks_file)
                if spec and spec.loader:
                    hooks_module = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(hooks_module)
                    return hooks_module
    except (ImportError, AttributeError):
        pass  # Expected when hook file/function doesn't exist
    {% endif %}
    
    return None

# Initialize hooks module
cli_hooks = _find_and_import_hooks()

# Built-in commands
{% if cli %}
def builtin_upgrade_command(check_only=False, pre=False, version=None, dry_run=False):
    """Built-in upgrade function for {{ display_name }} - uses enhanced setup.sh script."""
    import subprocess
    import sys
    from pathlib import Path

    if check_only:
        print(f"Checking for updates to {{ display_name }}...")
        print("Update check not yet implemented. Run without --check to upgrade.")
        return

    if dry_run:
        print("Dry run - would execute: pipx upgrade {{ package_name }}")
        return

    # Find the setup.sh script - look in common locations
    setup_script = None
    search_paths = [
        Path(__file__).parent / "setup.sh",  # Package directory (installed packages)
        Path(__file__).parent.parent / "setup.sh",  # Development mode 
        Path.home() / ".local" / "share" / "{{ installation.pypi_name | default(package_name) }}" / "setup.sh",  # User data
        # Remove Path.cwd() to prevent cross-contamination
    ]
    
    for path in search_paths:
        if path.exists():
            setup_script = path
            break
    
    if setup_script is None:
        # Fallback to basic upgrade if setup.sh not found
        print(f"Enhanced setup script not found. Using basic upgrade for {{ display_name }}...")
        import shutil
        
        package_name = "{{ package_name }}"
        pypi_name = "{% if installation and installation.pypi_name %}{{ installation.pypi_name }}{% else %}{{ package_name }}{% endif %}"
        
        if shutil.which("pipx"):
            result = subprocess.run(["pipx", "list"], capture_output=True, text=True)
            if package_name in result.stdout or pypi_name in result.stdout:
                cmd = ["pipx", "upgrade", pypi_name]
            else:
                cmd = [sys.executable, "-m", "pip", "install", "--upgrade", pypi_name]
        else:
            cmd = [sys.executable, "-m", "pip", "install", "--upgrade", pypi_name]
        
        result = subprocess.run(cmd)
        if result.returncode == 0:
            print(f"‚úÖ {{ display_name }} upgraded successfully!")
            print(f"Run '{{ command_name }} --version' to verify the new version.")
        else:
            print(f"‚ùå Upgrade failed with exit code {result.returncode}")
            sys.exit(1)
        return

    # Use the enhanced setup.sh script
    result = subprocess.run([str(setup_script), "upgrade"])
    sys.exit(result.returncode)
{% endif %}

def load_plugins(cli_group):
    """Load plugins from the conventional plugin directory."""
    # Define plugin directories to search
    plugin_dirs = [
        # User-specific plugin directory
        Path.home() / ".config" / "{{ package_name }}" / "plugins",
        # Local plugin directory (same as script)
        Path(__file__).parent / "plugins",
    ]
    
    for plugin_dir in plugin_dirs:
        if not plugin_dir.exists():
            continue
            
        # Add plugin directory to Python path
        sys.path.insert(0, str(plugin_dir))
        
        # Scan for plugin files
        for plugin_file in plugin_dir.glob("*.py"):
            if plugin_file.name.startswith("_"):
                continue
                
            # Skip core system files that aren't plugins
            if plugin_file.name in ["loader.py", "__init__.py"]:
                continue
                
            plugin_name = plugin_file.stem
            
            try:
                # Import the plugin module
                spec = importlib.util.spec_from_file_location(plugin_name, plugin_file)
                plugin_module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(plugin_module)
                
                # Call register_plugin if it exists
                if hasattr(plugin_module, "register_plugin"):
                    plugin_module.register_plugin(cli_group)
                    click.echo(f"Loaded plugin: {plugin_name}", err=True)
            except Exception as e:
                click.echo(f"Failed to load plugin {plugin_name}: {e}", err=True)

{% macro render_option(opt) -%}
@click.option(
    {%- if opt.short %}"-{{ opt.short }}", {% endif %}"--{{ opt.name }}"
    {%- if opt.type == "flag" %},
    is_flag=True
    {%- elif opt.choices %},
    type=click.Choice({{ opt.choices }})
    {%- else %},
    type={% if opt.type == "str" %}str{% elif opt.type == "int" %}int{% elif opt.type == "float" %}float{% elif opt.type == "bool" %}bool{% else %}str{% endif %}
    {%- endif %}
    {%- if opt.multiple %},
    multiple=True
    {%- endif %}
    {%- if opt.default is not none %},
    default={% if opt.default is sameas true %}True{% elif opt.default is sameas false %}False{% elif opt.default is number %}{{ opt.default }}{% else %}"{{ opt.default }}"{% endif %}
    {%- endif %},
    help="{{ opt.desc }}"
)
{%- endmacro %}

{% macro render_argument(arg) -%}
@click.argument(
    "{{ arg.name|upper|replace('-', '_') }}"
    {%- if arg.nargs %},
    nargs={% if arg.nargs == "*" %}-1{% elif arg.nargs == "?" %}1{% else %}{{ arg.nargs }}{% endif %}
    {%- if arg.nargs == "?" %},
    required=False{% endif %}
    {%- endif %}
    {%- if arg.required is defined and not arg.required %},
    required=False{% endif %}
    {%- if arg.required is defined and arg.required and arg.nargs and arg.nargs != "*" %},
    required=True{% endif %}
    {%- if not arg.required is defined and arg.nargs and arg.nargs != "*" %},
    required=True{% endif %}
    {%- if arg.choices %},
    type=click.Choice({{ arg.choices }})
    {%- endif %}
)
{%- endmacro %}

{% macro render_command(cmd_name, cmd_data, is_subcommand=False) -%}
{% if not is_subcommand %}@main.command(){% else %}@{{ cmd_name }}.command(){% endif %}
@click.pass_context
{% for arg in (cmd_data.args or []) %}
{{ render_argument(arg) }}
{% endfor %}
{% for opt in (cmd_data.options or []) %}
{{ render_option(opt) }}
{% endfor %}
def {{ cmd_name }}(ctx{% if cmd_data.args or cmd_data.options %}, {% endif %}{% if cmd_data.args %}{{ (cmd_data.args|map(attribute='name')|map('lower')|map('replace', '-', '_')|list + (cmd_data.options|map(attribute='name')|map('replace', '-', '_')|list))|join(', ') }}{% else %}{{ (cmd_data.options or [])|map(attribute='name')|map('replace', '-', '_')|join(', ') }}{% endif %}):
    """{% if cmd_data.icon %}{{ cmd_data.icon | format_icon }}{% endif %}{{ cmd_data.desc }}"""
    {% if cmd_data.lifecycle == "managed" %}
    # Managed command - expect an instance of ManagedCommand with context management
    command_instance_name = f"{{ cmd_name }}_command"
    if cli_hooks and hasattr(cli_hooks, command_instance_name):
        # Set managed command execution context
        set_cli_context(
            command='{{ cmd_name }}',
            operation_type='managed_command_execution',
            lifecycle='managed',
            {% if cmd_data.args %}
            command_args={ {% for arg in cmd_data.args %}'{{ arg.name|lower|replace('-', '_') }}': {{ arg.name|lower|replace('-', '_') }}{% if not loop.last %}, {% endif %}{% endfor %} },
            {% endif %}
            {% if cmd_data.options %}
            command_options={ {% for opt in cmd_data.options %}'{{ opt.name|replace('-', '_') }}': {{ opt.name|replace('-', '_') }}{% if not loop.last %}, {% endif %}{% endfor %} }
            {% endif %}
        )
        
        logger.info(f"Executing managed command: {{ cmd_name }}", extra={
            'command': '{{ cmd_name }}',
            'lifecycle': 'managed',
            'instance_name': command_instance_name
        })
        
        # Get the command instance
        command_instance = getattr(cli_hooks, command_instance_name)
        
        # Prepare arguments including global options and logging utilities
        kwargs = {
            # Logging infrastructure available to managed commands
            'logger': get_cli_logger(),
            'set_context': set_cli_context,
            'update_context': update_cli_context,
            'clear_context': clear_cli_context,
            'get_context': get_cli_logging_context,
        }
        kwargs['command_name'] = '{{ cmd_name }}'  # Pass command name for daemon management
        {% if cmd_data.args %}
        {% for arg in cmd_data.args %}
        kwargs['{{ arg.name|lower|replace('-', '_') }}'] = {{ arg.name|lower|replace('-', '_') }}
        {% endfor %}
        {% endif %}
        {% if cmd_data.options %}
        {% for opt in cmd_data.options %}
        {# Handle hyphenated parameters correctly #}
        {% set param_name = opt.name|replace('-', '_') %}
        {% set var_name = opt.name|replace('-', '_') %}
        kwargs['{{ param_name }}'] = {{ var_name }}
        {% endfor %}
        {% endif %}
        
        # Add global options from context
        {% if cli.options %}
        if ctx.obj:
            {% for option in cli.options %}
            kwargs['{{ option.name|replace('-', '_') }}'] = ctx.obj.get('{{ option.name }}')
            {% endfor %}
        {% endif %}
        
        try:
            # Call execute() method on the ManagedCommand instance
            result = command_instance.execute(**kwargs)
            logger.info(f"Managed command {{ cmd_name }} completed successfully")
            return result
        except Exception as e:
            logger.error(f"Managed command {{ cmd_name }} failed: {str(e)}", extra={
                'command': '{{ cmd_name }}',
                'lifecycle': 'managed',
                'error_type': type(e).__name__,
                'instance_name': command_instance_name
            }, exc_info=True)
            raise
        finally:
            # Clear managed command-specific context
            update_cli_context(
                command=None,
                operation_type=None,
                lifecycle=None,
                command_args=None,
                command_options=None
            )
    else:
        click.echo(f"Error: Managed command '{{ cmd_name }}' requires '{{ cmd_name }}_command' instance in cli_hooks.py")
        sys.exit(1)
    {% else %}
    # Check for built-in commands first
    {% if cmd_name == 'build' or cmd_name == 'init' %}
    # Built-in commands (build, init)
    try:
        from pathlib import Path
        import sys
        
        # Add the parent directory to sys.path to find goobits_cli
        parent_dir = Path(__file__).parent.parent.parent
        if str(parent_dir) not in sys.path:
            sys.path.insert(0, str(parent_dir))
        
        {% if cmd_name == 'build' %}
        from goobits_cli.main import build
        
        # Use current directory's goobits.yaml if no config path specified
        config_file = Path(config_path) if config_path else Path("goobits.yaml")
        output_dir_path = Path(output_dir) if output_dir else None
        
        build(config_file, output_dir_path, output, backup)
        click.echo("‚úÖ Build completed successfully!")
        click.echo("   - Generated setup.sh")
        click.echo("   - Updated CLI files")
        
        {% elif cmd_name == 'init' %}
        from goobits_cli.main import init
        
        init(project_name, template, force)
        click.echo("‚úÖ Init completed successfully!")
        click.echo("   - Created goobits.yaml")
        
        {% endif %}
            
    except ImportError as e:
        click.echo(f"‚ùå {{ cmd_name.title() }} error: Could not import framework functions: {e}")
        return False
    except Exception as e:
        click.echo(f"‚ùå {{ cmd_name.title() }} error: {e}")
        return False
    
    return True
    {% else %}
    # Standard command - use the existing hook pattern with context management
    hook_name = f"on_{{ cmd_name }}"
    if cli_hooks and hasattr(cli_hooks, hook_name):
        # Set command execution context
        set_cli_context(
            command='{{ cmd_name }}',
            operation_type='command_execution',
            {% if cmd_data.args %}
            command_args={ {% for arg in cmd_data.args %}'{{ arg.name|lower|replace('-', '_') }}': {{ arg.name|lower|replace('-', '_') }}{% if not loop.last %}, {% endif %}{% endfor %} },
            {% endif %}
            {% if cmd_data.options %}
            command_options={ {% for opt in cmd_data.options %}'{{ opt.name|replace('-', '_') }}': {{ opt.name|replace('-', '_') }}{% if not loop.last %}, {% endif %}{% endfor %} }
            {% endif %}
        )
        
        logger.info(f"Executing command: {{ cmd_name }}", extra={
            'command': '{{ cmd_name }}',
            'hook_function': hook_name
        })
        
        # Call the hook with all parameters (including logger)
        hook_func = getattr(cli_hooks, hook_name)
        
        # Prepare arguments including global options and logging utilities
        kwargs = {
            # Logging infrastructure available to hooks
            'logger': get_cli_logger(),
            'set_context': set_cli_context,
            'update_context': update_cli_context,
            'clear_context': clear_cli_context,
            'get_context': get_cli_logging_context,
        }
        kwargs['command_name'] = '{{ cmd_name }}'  # Pass command name for all commands
        {% if cmd_data.args %}
        {% for arg in cmd_data.args %}
        kwargs['{{ arg.name|lower|replace('-', '_') }}'] = {{ arg.name|lower|replace('-', '_') }}
        {% endfor %}
        {% endif %}
        {% if cmd_data.options %}
        {% for opt in cmd_data.options %}
        {# Handle hyphenated parameters correctly #}
        {% set param_name = opt.name|replace('-', '_') %}
        {% set var_name = opt.name|replace('-', '_') %}
        kwargs['{{ param_name }}'] = {{ var_name }}
        {% endfor %}
        {% endif %}
        
        # Add global options from context
        {% if cli.options %}
        if ctx.obj:
            {% for option in cli.options %}
            kwargs['{{ option.name|replace('-', '_') }}'] = ctx.obj.get('{{ option.name }}')
            {% endfor %}
        {% endif %}
        
        try:
            result = hook_func(**kwargs)
            logger.info(f"Command {{ cmd_name }} completed successfully")
            return result
        except Exception as e:
            logger.error(f"Command {{ cmd_name }} failed: {str(e)}", extra={
                'command': '{{ cmd_name }}',
                'error_type': type(e).__name__,
                'hook_function': hook_name
            }, exc_info=True)
            raise
        finally:
            # Clear command-specific context but keep CLI-level context
            update_cli_context(
                command=None,
                operation_type=None,
                command_args=None,
                command_options=None
            )
    else:
        # Default placeholder behavior
        click.echo(f"Executing {{ cmd_name }} command...")
        {% if cmd_data.args %}
        {% for arg in cmd_data.args %}
        click.echo(f"  {{ arg.name }}: {{ '{' }}{{ arg.name|lower|replace('-', '_') }}{{ '}' }}")
        {% endfor %}
        {% endif %}
        {% if cmd_data.options %}
        {% for opt in cmd_data.options %}
        click.echo(f"  {{ opt.name }}: {{ '{' }}{{ opt.name|replace('-', '_') }}{{ '}' }}")
        {% endfor %}
        {% endif %}
    {% endif %}
    {% endif %}
{%- endmacro %}

def get_version():
    """Get version from pyproject.toml or __init__.py"""
    import re
    
    try:
        # Try to get version from pyproject.toml FIRST (most authoritative)
        # Look in multiple possible locations
        possible_paths = [
            Path(__file__).parent.parent / "pyproject.toml",  # For flat structure
            Path(__file__).parent.parent.parent / "pyproject.toml",  # For src/ structure
        ]
        toml_path = None
        for path in possible_paths:
            if path.exists():
                toml_path = path
                break
        if toml_path:
            content = toml_path.read_text()
            match = re.search(r'version\s*=\s*["\']([^"\']+)["\']', content)
            if match:
                return match.group(1)
    except (FileNotFoundError, PermissionError, OSError):
        pass  # Expected when version file doesn't exist or can't be read
    
    try:
        # Fallback to __init__.py
        init_path = Path(__file__).parent / "__init__.py"
        if init_path.exists():
            content = init_path.read_text()
            match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
            if match:
                return match.group(1)
    except (FileNotFoundError, PermissionError, OSError):
        pass  # Expected when version file doesn't exist or can't be read
        
    # Final fallback
    return "1.0.0"

{% if cli.enable_help_json %}
def show_help_json(ctx, param, value):
    """Callback for --help-json option."""
    if not value or ctx.resilient_parsing:
        return
    # The triple quotes are important to correctly handle the multi-line JSON string
    click.echo('''{{ cli_config_json }}''')
    ctx.exit()
{% endif %}

def start_interactive_mode(ctx, param, value):
    """Callback for --interactive option with lazy loading."""
    if not value or ctx.resilient_parsing:
        return
    
    # Lazy load and start interactive mode only when --interactive flag is used
    try:
        _lazy_load_and_start_interactive()
        sys.exit(0)
    except Exception as e:
        click.echo(f"‚ùå Error starting interactive mode: {e}")
        ctx.exit(1)


def _lazy_load_and_start_interactive():
    """Lazy load interactive mode components only when needed."""
    import importlib.util
    import os
    
    # Get the directory where this CLI script is located
    cli_dir = Path(__file__).parent
    interactive_file = cli_dir / "enhanced_interactive_mode.py"
    
    if interactive_file.exists():
        # Only load the heavy interactive module when --interactive is actually used
        spec = importlib.util.spec_from_file_location("enhanced_interactive_mode", interactive_file)
        interactive_module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(interactive_module)
        interactive_module.start_enhanced_interactive()
    else:
        click.echo("‚ùå Interactive mode not available. enhanced_interactive_mode.py not found.")
        sys.exit(1)

{# Find the default command #}
{% set ns = namespace(default_cmd=None) %}
{% for cmd_name, cmd_data in cli.commands.items() %}
  {% if cmd_data.is_default %}
    {% set ns.default_cmd = cmd_name %}
  {% endif %}
{% endfor %}

class VersionedRichGroup(RichGroup):
    def format_usage(self, ctx, formatter):
        """Override to include version in usage."""
        pieces = self.collect_usage_pieces(ctx)
        formatter.write_usage(f"{{ cli.name | default('cli') }} v{get_version()}", " ".join(pieces))
    
    def format_help(self, ctx, formatter):
        """Override to add spacing after help."""
        super().format_help(ctx, formatter)
        formatter.write("\n")

{% if ns.default_cmd %}
class DefaultGroup(VersionedRichGroup):
    """Allow a default command to be invoked without being specified."""
    
    def __init__(self, *args, default=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.default_command = default
    
    def main(self, *args, **kwargs):
        """Override main to handle stdin input when no command is provided."""
        import sys
        import os
        import stat
        
        # Check if we need to inject the default command due to stdin input
        if len(sys.argv) == 1 and self.default_command:  # Only script name provided
            # Check if stdin is coming from a pipe or redirection
            has_stdin = False
            try:
                # Check if stdin is a pipe or file (not a terminal)
                stdin_stat = os.fstat(sys.stdin.fileno())
                has_stdin = stat.S_ISFIFO(stdin_stat.st_mode) or stat.S_ISREG(stdin_stat.st_mode)
            except (OSError, AttributeError):
                # Expected when stdin detection fails
                # Fallback to isatty check
                has_stdin = not sys.stdin.isatty()
            
            if has_stdin:
                # Inject the default command into sys.argv
                sys.argv.append(self.default_command)
        
        return super().main(*args, **kwargs)
    
    def resolve_command(self, ctx, args):
        import sys
        import os
        
        try:
            # Try normal command resolution first
            return super().resolve_command(ctx, args)
        except click.UsageError:
            # If no command found and we have a default, use it
            # Check if stdin is coming from a pipe or redirection
            has_stdin = False
            try:
                # Check if stdin is a pipe or file (not a terminal)
                stdin_stat = os.fstat(sys.stdin.fileno())
                # Use S_ISFIFO to check if it's a pipe, or S_ISREG to check if it's a regular file
                import stat
                has_stdin = stat.S_ISFIFO(stdin_stat.st_mode) or stat.S_ISREG(stdin_stat.st_mode)
            except Exception as e:
                # Fallback to isatty check
                has_stdin = not sys.stdin.isatty()
            
            is_help_request = any(arg in ['--help-all', '--help-json'] for arg in args)
            
            if self.default_command and not is_help_request:
                # Trigger default command if:
                # 1. We have args (existing behavior)
                # 2. We have stdin input (new behavior for pipes)
                if args or has_stdin:
                    cmd = self.commands.get(self.default_command)
                    if cmd:
                        # Return command name, command object, and all args
                        return self.default_command, cmd, args
            raise
{% endif %}

{% if ns.default_cmd %}
@click.group(cls=DefaultGroup, default='{{ ns.default_cmd }}', context_settings={"help_option_names": ["-h", "--help"], "max_content_width": 120})
{% else %}
@click.group(cls=VersionedRichGroup, context_settings={"help_option_names": ["-h", "--help"], "max_content_width": 120})
{% endif %}
@click.version_option(version=get_version(), prog_name="{{ cli.name }}")
@click.pass_context
{% if cli.enable_help_json %}
@click.option('--help-json', is_flag=True, callback=show_help_json, is_eager=True, help='Output CLI structure as JSON.', hidden=True)
{% endif %}
{% if cli.enable_recursive_help %}
@click.option('--help-all', is_flag=True, is_eager=True, help='Show help for all commands.', hidden=True)
{% endif %}
@click.option('--interactive', is_flag=True, is_eager=True, callback=start_interactive_mode, help='Launch interactive mode for running commands interactively.')
{% if cli.options %}
{% for option in cli.options %}
{{ render_option(option) }}
{% endfor %}
{% endif %}
def main(ctx{% if cli.enable_help_json %}, help_json=False{% endif %}{% if cli.enable_recursive_help %}, help_all=False{% endif %}, interactive=False{% if cli.options %}{% for option in cli.options %}, {{ option.name.replace('-', '_') }}{% if option.type == 'flag' %}=False{% else %}=None{% endif %}{% endfor %}{% endif %}):
    """{% if cli.icon %}{{ cli.icon | format_icon }}{% endif %}[bold color(6)]{{ cli.name }}{% if cli.display_version %} v{get_version()}{% endif %}[/bold color(6)] - {{ cli.tagline }}

    {% if cli.description %}
    \b
    [#B3B8C0]{{ cli.description }}[/#B3B8C0]
    {% endif %}

    {% if cli.header_sections %}
    {% for section in cli.header_sections %}
    [bold yellow]{{ section.title }}[/bold yellow]
    {%- set aligned_items = section.items | align_header_items %}
    {% for item in aligned_items %}
    {% if item.style == 'example' %}
    [green]   {{ item.item_aligned }}[/green] [italic][#B3B8C0]# {{ item.desc }}[/#B3B8C0][/italic]
    {% elif item.style == 'command' %}
    [green]   {{ item.item_aligned }}[/green]  {{ item.desc }}
    {% elif item.style == 'setup' %}
    [#B3B8C0]   {{ item.item + ":" }}{{ " " * (item.item_aligned|length - item.item|length - 1) }}[/#B3B8C0][green]{{ item.desc }}[/green]
    {%- endif %}
    {%- endfor %}
    [green] [/green]
    {% endfor %}
    {% endif %}
    {% if cli.footer_note %}
    [#B3B8C0]{{ cli.footer_note }}[/#B3B8C0]
    {% endif %}
    """
    {% if cli.enable_recursive_help %}
    if help_all:
        # Print main help
        click.echo(ctx.get_help())
        click.echo() # Add a blank line for spacing

        # Get a list of all command names
        commands_to_show = sorted(ctx.command.list_commands(ctx))

        for cmd_name in commands_to_show:
            command = ctx.command.get_command(ctx, cmd_name)

            # Create a new context for the subcommand
            sub_ctx = click.Context(command, info_name=cmd_name, parent=ctx)

            # Print a separator and the subcommand's help
            click.echo("="*20 + f" HELP FOR: {cmd_name} " + "="*20)
            click.echo(sub_ctx.get_help())
            click.echo() # Add a blank line for spacing

        # Exit after printing all help
        ctx.exit()
    {% endif %}
    
    # Store global options in context for use by commands
    {% if cli.options %}
    if ctx.obj is None:
        ctx.obj = {}
    {% for option in cli.options %}
    ctx.obj['{{ option.name }}'] = {{ option.name.replace('-', '_') }}
    {% endfor %}
    {% endif %}

    pass

# Replace the version placeholder with dynamic version in the main command docstring
main.callback.__doc__ = main.callback.__doc__.replace("{get_version()}", get_version())

{% if cli.command_groups %}
# Set command groups after main function is defined
{%- set defined_commands = cli.commands.keys() | list %}
click.rich_click.COMMAND_GROUPS = {
    "main": [
        {% for group in cli.command_groups %}
        {
            "name": "{{ group.name }}",
            "commands": {{ group.commands | select('in', defined_commands) | list }},
        },
        {% endfor %}
    ]
}
{% endif %}

# Built-in upgrade command (enabled by default)
{% if cli and (cli.enable_upgrade_command is not defined or cli.enable_upgrade_command) %}
@main.command()
@click.option('--check', is_flag=True, help='Check for updates without installing')
@click.option('--version', type=str, help='Install specific version')
@click.option('--pre', is_flag=True, help='Include pre-release versions')
@click.option('--dry-run', is_flag=True, help='Show what would be done without doing it')
def upgrade(check, version, pre, dry_run):
    """Upgrade {{ display_name }} to the latest version."""
    builtin_upgrade_command(check_only=check, version=version, pre=pre, dry_run=dry_run)
{% endif %}

{% for cmd_name, cmd_data in cli.commands.items() %}
{% if not cmd_data.subcommands %}
{{ render_command(cmd_name, cmd_data) }}
{% else %}
@main.group()
def {{ cmd_name }}():
    """{% if cmd_data.icon %}{{ cmd_data.icon | format_icon }}{% endif %}{{ cmd_data.desc }}"""
    pass

{% for subcmd_name, subcmd_data in cmd_data.subcommands.items() %}
@{{ cmd_name }}.command()
@click.pass_context
{% for arg in (subcmd_data.args or []) %}
{{ render_argument(arg) }}
{% endfor %}
{% for opt in (subcmd_data.options or []) %}
{{ render_option(opt) }}
{% endfor %}
def {{ subcmd_name }}(ctx{% if subcmd_data.args or subcmd_data.options %}, {% endif %}{% if subcmd_data.args %}{{ (subcmd_data.args|map(attribute='name')|map('lower')|map('replace', '-', '_')|list + (subcmd_data.options|map(attribute='name')|map('replace', '-', '_')|list))|join(', ') }}{% else %}{{ (subcmd_data.options or [])|map(attribute='name')|map('replace', '-', '_')|join(', ') }}{% endif %}):
    """{% if subcmd_data.icon %}{{ subcmd_data.icon | format_icon }}{% endif %}{{ subcmd_data.desc }}"""
    # Check if hook function exists with context management
    hook_name = f"on_{{ cmd_name }}_{{ subcmd_name }}"
    if cli_hooks and hasattr(cli_hooks, hook_name):
        # Set subcommand execution context
        set_cli_context(
            command=f'{{ cmd_name }}.{{ subcmd_name }}',
            operation_type='subcommand_execution',
            parent_command='{{ cmd_name }}',
            subcommand='{{ subcmd_name }}',
            {% if subcmd_data.args %}
            command_args={ {% for arg in subcmd_data.args %}'{{ arg.name|lower|replace('-', '_') }}': {{ arg.name|lower|replace('-', '_') }}{% if not loop.last %}, {% endif %}{% endfor %} },
            {% endif %}
            {% if subcmd_data.options %}
            command_options={ {% for opt in subcmd_data.options %}'{{ opt.name|replace('-', '_') }}': {{ opt.name|replace('-', '_') }}{% if not loop.last %}, {% endif %}{% endfor %} }
            {% endif %}
        )
        
        logger.info(f"Executing subcommand: {{ cmd_name }}.{{ subcmd_name }}", extra={
            'command': '{{ cmd_name }}',
            'subcommand': '{{ subcmd_name }}',
            'hook_function': hook_name
        })
        
        # Call the hook with all parameters (including logger)
        hook_func = getattr(cli_hooks, hook_name)
        
        # Prepare arguments including global options and logging utilities
        kwargs = {
            # Logging infrastructure available to hooks
            'logger': get_cli_logger(),
            'set_context': set_cli_context,
            'update_context': update_cli_context,
            'clear_context': clear_cli_context,
            'get_context': get_cli_logging_context,
        }
        kwargs['command_name'] = '{{ subcmd_name }}'  # Pass command name for all commands
        {% if subcmd_data.args %}
        {% for arg in subcmd_data.args %}
        kwargs['{{ arg.name|lower|replace('-', '_') }}'] = {{ arg.name|lower|replace('-', '_') }}
        {% endfor %}
        {% endif %}
        {% if subcmd_data.options %}
        {% for opt in subcmd_data.options %}
        kwargs['{{ opt.name|replace('-', '_') }}'] = {{ opt.name|replace('-', '_') }}
        {% endfor %}
        {% endif %}
        
        # Add global options from context
        {% if cli.options %}
        if ctx.obj:
            {% for option in cli.options %}
            kwargs['{{ option.name|replace('-', '_') }}'] = ctx.obj.get('{{ option.name }}')
            {% endfor %}
        {% endif %}
        
        try:
            result = hook_func(**kwargs)
            logger.info(f"Subcommand {{ cmd_name }}.{{ subcmd_name }} completed successfully")
            return result
        except Exception as e:
            logger.error(f"Subcommand {{ cmd_name }}.{{ subcmd_name }} failed: {str(e)}", extra={
                'command': '{{ cmd_name }}',
                'subcommand': '{{ subcmd_name }}',
                'error_type': type(e).__name__,
                'hook_function': hook_name
            }, exc_info=True)
            raise
        finally:
            # Clear subcommand-specific context
            update_cli_context(
                command=None,
                operation_type=None,
                parent_command=None,
                subcommand=None,
                command_args=None,
                command_options=None
            )
    else:
        # Default placeholder behavior
        click.echo(f"Executing {{ subcmd_name }} command...")
        {% if subcmd_data.args %}
        {% for arg in subcmd_data.args %}
        click.echo(f"  {{ arg.name }}: {{ '{' }}{{ arg.name|lower|replace('-', '_') }}{{ '}' }}")
        {% endfor %}
        {% endif %}
        {% if subcmd_data.options %}
        {% for opt in subcmd_data.options %}
        click.echo(f"  {{ opt.name }}: {{ '{' }}{{ opt.name|replace('-', '_') }}{{ '}' }}")
        {% endfor %}
        {% endif %}
{% endfor %}
{% endif %}

{% endfor %}

{# Auto-generate daemon management commands for managed commands #}
{% set ns = namespace(has_managed=false) %}
{% for cmd_name, cmd_data in cli.commands.items() %}
{% if cmd_data.lifecycle == "managed" %}
{% set ns.has_managed = true %}
{% endif %}
{% endfor %}
{% if ns.has_managed %}
@main.command()
@click.pass_context
@click.argument(
    "command_name",
    required=True
)
@click.option("--timeout",
    type=int,
    default=10,
    help="Timeout in seconds for graceful shutdown"
)
@click.option("--json",
    is_flag=True,
    help="Output in JSON format"
)
def daemonstop(ctx, command_name, timeout, json):
    """‚èπÔ∏è Stop a running daemon process"""
    from src.gubits.daemon import DaemonHelper
    
    daemon_helper = DaemonHelper(command_name)
    
    # Check if daemon is running
    if not daemon_helper.is_running():
        msg = f"No daemon running for command '{command_name}'"
        if json:
            import json as json_module
            click.echo(json_module.dumps({"status": "not_running", "message": msg}))
        else:
            click.echo(f"‚ö†Ô∏è  {msg}")
        return {"status": "not_running"}
    
    # Get PID before stopping
    pid = daemon_helper.get_pid()
    
    # Stop the daemon
    if daemon_helper.stop(timeout=timeout):
        if json:
            import json as json_module
            click.echo(json_module.dumps({
                "status": "stopped",
                "command": command_name,
                "pid": pid,
                "message": f"Successfully stopped daemon for '{command_name}'"
            }))
        else:
            click.echo(f"‚úÖ Successfully stopped daemon '{command_name}' (PID: {pid})")
        return {"status": "stopped", "pid": pid}
    else:
        error_msg = f"Failed to stop daemon '{command_name}' (PID: {pid})"
        if json:
            import json as json_module
            click.echo(json_module.dumps({"status": "error", "message": error_msg}))
        else:
            click.echo(f"‚ùå {error_msg}")
        return {"status": "error", "message": error_msg}


@main.command()
@click.pass_context
@click.argument(
    "command_name",
    required=True
)
@click.option("--json",
    is_flag=True,
    help="Output in JSON format"
)
def daemonstatus(ctx, command_name, json):
    """üìä Check status of a daemon process"""
    from src.gubits.daemon import DaemonHelper
    
    daemon_helper = DaemonHelper(command_name)
    
    # Get daemon stats
    stats = daemon_helper.get_daemon_stats()
    
    if json:
        import json as json_module
        click.echo(json_module.dumps(stats, indent=2))
    else:
        is_running = stats['running']
        status_emoji = 'üü¢' if is_running else 'üî¥'
        status_text = 'Running' if is_running else 'Stopped'
        
        click.echo(f"üìä Daemon Status for '{command_name}': {status_emoji} {status_text}")
        
        if is_running:
            click.echo(f"   PID: {stats['pid']}")
            click.echo(f"   PID File: {stats['pid_file']}")
        else:
            click.echo(f"   PID File: {stats['pid_file']} (not found or stale)")
            
    return stats


@main.group()
def daemon():
    """üîß Daemon system integration commands"""
    pass


@daemon.command()
@click.pass_context
@click.argument(
    "command_name",
    required=True
)
@click.option("--user",
    is_flag=True,
    default=True,
    help="Install as user service (default)"
)
@click.option("--system",
    is_flag=True,
    help="Install as system service (requires sudo)"
)
def install(ctx, command_name, user, system):
    """üîß Generate systemd service file for daemon management"""
    import shutil
    import subprocess
    from pathlib import Path
    
    # Determine CLI executable path
    cli_executable = shutil.which("{{ cli.name|lower|replace(' ', '') }}")
    if not cli_executable:
        # Fallback to sys.executable with -m approach
        cli_executable = f"{sys.executable} -m {{ cli.name|lower|replace(' ', '_') }}"
    
    # Determine installation type
    if system:
        service_dir = Path("/etc/systemd/system")
        service_type = "system"
        install_cmd_prefix = "sudo "
    else:
        service_dir = Path.home() / ".config" / "systemd" / "user"
        service_type = "user"
        install_cmd_prefix = ""
    
    # Ensure service directory exists
    if not service_dir.exists():
        try:
            service_dir.mkdir(parents=True, exist_ok=True)
        except PermissionError:
            click.echo(f"‚ùå Permission denied creating directory: {service_dir}")
            click.echo(f"   Try running with sudo for system services")
            sys.exit(1)
    
    # Generate service file name
    service_name = f"{{ cli.name|lower|replace(' ', '-') }}-{command_name}.service"
    service_file_path = service_dir / service_name
    
    # Determine PID file path
    if system:
        pid_file_path = f"/run/{{ cli.name|lower|replace(' ', '-') }}-{command_name}.pid"
        working_dir = "/var/lib/{{ cli.name|lower|replace(' ', '-') }}"
    else:
        runtime_dir = os.environ.get('XDG_RUNTIME_DIR', f"/run/user/{os.getuid()}")
        pid_file_path = f"{runtime_dir}/{{ cli.name|lower|replace(' ', '-') }}-{command_name}.pid"
        working_dir = str(Path.home())
    
    # Generate systemd unit file content
    service_content = f"""# Auto-generated by goobits for the '{command_name}' command
# Service file for {{ cli.name }} daemon management
[Unit]
Description=goobits-managed daemon for the '{command_name}' command
After=network.target
Wants=network.target

[Service]
Type=forking
ExecStart={cli_executable} {command_name} --daemon
PIDFile={pid_file_path}
Restart=on-failure
RestartSec=5
WorkingDirectory={working_dir}
"""

    # Add user-specific settings
    if not system:
        service_content += """
# User service settings
User=%i
Group=%i
"""

    service_content += """
[Install]
WantedBy={"default.target" if not system else "multi-user.target"}
"""
    
    # Write service file
    try:
        with open(service_file_path, 'w') as f:
            f.write(service_content)
        click.echo(f"‚úÖ Generated systemd service file: {service_file_path}")
    except PermissionError:
        click.echo(f"‚ùå Permission denied writing to: {service_file_path}")
        if not system:
            click.echo(f"   Try: mkdir -p {service_dir}")
        sys.exit(1)
    
    # Print usage instructions
    click.echo(f"")
    click.echo(f"üîß Systemd service '{service_name}' created successfully!")
    click.echo(f"")
    click.echo(f"üìã To enable and start the service:")
    if system:
        click.echo(f"   sudo systemctl daemon-reload")
        click.echo(f"   sudo systemctl enable {service_name}")
        click.echo(f"   sudo systemctl start {service_name}")
        click.echo(f"")
        click.echo(f"üìä To check status:")
        click.echo(f"   sudo systemctl status {service_name}")
        click.echo(f"")
        click.echo(f"üõë To stop and disable:")
        click.echo(f"   sudo systemctl stop {service_name}")
        click.echo(f"   sudo systemctl disable {service_name}")
    else:
        click.echo(f"   systemctl --user daemon-reload")
        click.echo(f"   systemctl --user enable {service_name}")
        click.echo(f"   systemctl --user start {service_name}")
        click.echo(f"")
        click.echo(f"üìä To check status:")
        click.echo(f"   systemctl --user status {service_name}")
        click.echo(f"")
        click.echo(f"üõë To stop and disable:")
        click.echo(f"   systemctl --user stop {service_name}")
        click.echo(f"   systemctl --user disable {service_name}")
    
    click.echo(f"")
    click.echo(f"üìù Service file location: {service_file_path}")
    
    return {"status": "service_created", "service_file": str(service_file_path), "service_name": service_name}

{% endif %}

# Shell completion commands
@main.group()
def completion():
    """üîß Shell completion management"""
    pass

# Internal completion command (hidden from help)
@main.command()
@click.argument('shell', type=click.Choice(['bash', 'zsh', 'fish']))
@click.argument('current_line')
@click.argument('cursor_pos', type=int, required=False)
@click.option('--debug', is_flag=True, help='Debug completion engine')
def _completion(shell, current_line, cursor_pos, debug):
    """Internal completion command - called by shell completion scripts"""
    try:
        # Import completion engine
        import os
        import sys
        from pathlib import Path
        
        # Add completion_engine to path
        engine_path = Path(__file__).parent / "completion_engine.py"
        
        if engine_path.exists():
            # Import and run the completion engine
            import importlib.util
            spec = importlib.util.spec_from_file_location("completion_engine", engine_path)
            completion_engine = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(completion_engine)
            
            # Get completions
            engine = completion_engine.CompletionEngine()
            completions = engine.get_completions(shell, current_line, cursor_pos)
            
            # Output completions
            for completion in completions:
                click.echo(completion)
                
        elif debug:
            click.echo("completion_engine.py not found", err=True)
            
    except Exception as e:
        if debug:
            click.echo(f"Completion error: {e}", err=True)
        # Silently fail in production to avoid breaking shell completion

# Add this command with underscore to hide it from help
_completion.hidden = True

@completion.command()
@click.argument('shell', type=click.Choice(['bash', 'zsh', 'fish']))
@click.option('--output', '-o', type=click.Path(), help='Output file path')
def generate(shell, output):
    """Generate shell completion script"""
    if not HAS_COMPLETION_HELPER:
        click.echo("‚ùå Completion helper not available. Missing completion_helper module.")
        return
    
    try:
        script_content = generate_completion_script(shell)
        
        if output:
            output_path = Path(output)
            output_path.write_text(script_content)
            click.echo(f"‚úÖ {shell.title()} completion script saved to: {output_path}")
        else:
            click.echo(script_content)
    except Exception as e:
        click.echo(f"‚ùå Error generating {shell} completion: {e}")

@completion.command()
@click.argument('shell', type=click.Choice(['bash', 'zsh', 'fish']))
@click.option('--user', is_flag=True, default=True, help='Install for current user (default)')
@click.option('--system', is_flag=True, help='Install system-wide (requires sudo)')
def install(shell, user, system):
    """Install shell completion script"""
    if not HAS_COMPLETION_HELPER:
        click.echo("‚ùå Completion helper not available. Missing completion_helper module.")
        return
    
    try:
        user_install = not system
        success = install_completion(shell, user_install)
        
        if success:
            click.echo(f"‚úÖ {shell.title()} completion installed successfully!")
            
            instructions = get_install_instructions(shell)
            if instructions and 'reload_cmd' in instructions:
                click.echo(f"üí° Reload your shell: {instructions['reload_cmd']}")
        else:
            click.echo(f"‚ùå Failed to install {shell} completion")
            
    except Exception as e:
        click.echo(f"‚ùå Error installing {shell} completion: {e}")

@completion.command()
@click.argument('shell', type=click.Choice(['bash', 'zsh', 'fish']))
def instructions(shell):
    """Show installation instructions for shell completion"""
    if not HAS_COMPLETION_HELPER:
        click.echo("‚ùå Completion helper not available. Missing completion_helper module.")
        return
    
    instructions = get_install_instructions(shell)
    if not instructions:
        click.echo(f"‚ùå No instructions available for {shell}")
        return
    
    click.echo(f"üìã {shell.title()} completion installation instructions:")
    click.echo()
    
    click.echo("üè† User installation (recommended):")
    click.echo(f"   mkdir -p {Path(instructions['user_script_path']).parent}")
    click.echo(f"   {{ cli.name | lower | replace(' ', '-') }} completion generate {shell} > completion.{shell}")
    click.echo(f"   cp completion.{shell} {instructions['user_script_path']}")
    click.echo()
    
    click.echo("üåê System-wide installation:")
    click.echo(f"   {{ cli.name | lower | replace(' ', '-') }} completion generate {shell} > completion.{shell}")
    click.echo(f"   {instructions['install_cmd']}")
    click.echo()
    
    click.echo("üîÑ Reload shell:")
    click.echo(f"   {instructions['reload_cmd']}")

# Configuration management commands
@main.group()
def config():
    """‚öôÔ∏è Configuration management"""
    pass

@config.command()
@click.argument('key', required=False)
def get(key):
    """Get configuration value"""
    if not HAS_CONFIG_MANAGER:
        click.echo("‚ùå Configuration manager not available.")
        return
    
    try:
        if key:
            value = get_config_value(key)
            if value is not None:
                click.echo(f"{key}: {value}")
            else:
                click.echo(f"‚ùå Configuration key '{key}' not found")
        else:
            # Show all configuration
            config_data = load_config()
            import json
            click.echo(json.dumps(config_data, indent=2))
    except Exception as e:
        click.echo(f"‚ùå Error getting configuration: {e}")

@config.command()
@click.argument('key')
@click.argument('value')
def set(key, value):
    """Set configuration value"""
    if not HAS_CONFIG_MANAGER:
        click.echo("‚ùå Configuration manager not available.")
        return
    
    try:
        # Try to parse value as JSON for complex types
        import json
        try:
            parsed_value = json.loads(value)
        except json.JSONDecodeError:
            parsed_value = value
        
        success = set_config_value(key, parsed_value)
        if success:
            click.echo(f"‚úÖ Set {key} = {parsed_value}")
        else:
            click.echo(f"‚ùå Failed to set configuration value")
    except Exception as e:
        click.echo(f"‚ùå Error setting configuration: {e}")

@config.command()
def reset():
    """Reset configuration to defaults"""
    if not HAS_CONFIG_MANAGER:
        click.echo("‚ùå Configuration manager not available.")
        return
    
    try:
        if HAS_PROMPTS_HELPER:
            if confirm("Are you sure you want to reset all configuration to defaults?"):
                config.reset()
                click.echo("‚úÖ Configuration reset to defaults")
            else:
                click.echo("‚ùå Reset cancelled")
        else:
            config.reset()
            click.echo("‚úÖ Configuration reset to defaults")
    except Exception as e:
        click.echo(f"‚ùå Error resetting configuration: {e}")

@config.command()
def path():
    """Show configuration file path"""
    if not HAS_CONFIG_MANAGER:
        click.echo("‚ùå Configuration manager not available.")
        return
    
    try:
        config_path = config.get_config_path()
        click.echo(f"üìÅ Configuration file: {config_path}")
        
        # Check for RC files
        rc_file = config.find_rc_file()
        if rc_file:
            click.echo(f"üìÑ Active RC file: {rc_file}")
    except Exception as e:
        click.echo(f"‚ùå Error getting configuration path: {e}")

def cli_entry():
    """Entry point for the CLI when installed via pipx."""
    try:
        # Set initial context
        set_cli_context(
            cli_name="{{ display_name }}",
            version=get_version(),
            session_id=f"cli_{int(time.time() * 1000)}"
        )
        
        # Load plugins before running the CLI
        load_plugins(main)
        
        logger.debug("Starting CLI execution", extra={'command_args': sys.argv})
        main()
        
    except KeyboardInterrupt:
        logger.info("CLI operation cancelled by user", extra={'signal': 'SIGINT'})
        click.echo("\n‚èπÔ∏è  Operation cancelled by user", err=True)
        clear_cli_context()
        sys.exit(130)  # Standard exit code for Ctrl+C
    except Exception as e:
        # Get verbose flag from context or command line args
        verbose = False
        try:
            # Try to get verbose from current Click context
            ctx = click.get_current_context()
            verbose = ctx.obj.get('verbose', False) if ctx.obj else False
        except RuntimeError:
            # No context available, fallback to command line args
            verbose = '--verbose' in sys.argv
        
        # Log the error with context
        logger.error(f"CLI execution failed: {str(e)}", extra={
            'error_type': type(e).__name__,
            'verbose': verbose,
            'command_args': sys.argv
        }, exc_info=verbose)
        
        exit_code = handle_cli_error(e, verbose)
        clear_cli_context()
        sys.exit(exit_code)
    finally:
        # Ensure context is cleared on exit
        clear_cli_context()

if __name__ == "__main__":
    cli_entry()