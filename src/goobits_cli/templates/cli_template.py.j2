#!/usr/bin/env python3
"""Auto-generated from {{ file_name }}"""
import os
import sys
import importlib.util
from pathlib import Path
import rich_click as click
from rich_click import RichGroup, RichCommand

# Set up rich-click configuration globally
click.rich_click.USE_RICH_MARKUP = True  
click.rich_click.USE_MARKDOWN = False  # Disable markdown to avoid conflicts
click.rich_click.MARKUP_MODE = "rich"

# Environment variables for additional control
os.environ["RICH_CLICK_USE_RICH_MARKUP"] = "1"
os.environ["RICH_CLICK_FORCE_TERMINAL"] = "1"
click.rich_click.SHOW_ARGUMENTS = True
click.rich_click.GROUP_ARGUMENTS_OPTIONS = True
click.rich_click.SHOW_METAVARS_COLUMN = {{ cli.config.show_metavars_column if cli.config else False }}
click.rich_click.APPEND_METAVARS_HELP = {{ cli.config.append_metavars_help if cli.config else True }}
click.rich_click.STYLE_ERRORS_SUGGESTION = "#ff5555"
click.rich_click.ERRORS_SUGGESTION = "Try running the '--help' flag for more information."
click.rich_click.ERRORS_EPILOGUE = "To find out more, visit https://github.com/anthropics/claude-code"
click.rich_click.MAX_WIDTH = 120  # Set reasonable width
click.rich_click.WIDTH = 120  # Set consistent width
click.rich_click.COLOR_SYSTEM = "auto"
click.rich_click.SHOW_SUBCOMMAND_ALIASES = True
click.rich_click.ALIGN_OPTIONS_SWITCHES = True
click.rich_click.STYLE_OPTION = "#ff79c6"      # Dracula Pink - for option flags
click.rich_click.STYLE_SWITCH = "#50fa7b"      # Dracula Green - for switches
click.rich_click.STYLE_METAVAR = "#8BE9FD not bold"   # Light cyan - for argument types (OPTIONS, COMMAND)  
click.rich_click.STYLE_METAVAR_SEPARATOR = "#6272a4"  # Dracula Comment
click.rich_click.STYLE_HEADER_TEXT = "bold yellow"    # Bold yellow - for section headers
click.rich_click.STYLE_EPILOGUE_TEXT = "#6272a4"      # Dracula Comment
click.rich_click.STYLE_FOOTER_TEXT = "#6272a4"        # Dracula Comment
click.rich_click.STYLE_USAGE = "#BD93F9"              # Purple - for "Usage:" line
click.rich_click.STYLE_USAGE_COMMAND = "bold"         # Bold for main command name
click.rich_click.STYLE_DEPRECATED = "#ff5555"         # Dracula Red
click.rich_click.STYLE_HELPTEXT_FIRST_LINE = "#f8f8f2" # Dracula Foreground
click.rich_click.STYLE_HELPTEXT = "#B3B8C0"           # Light gray - for help descriptions
click.rich_click.STYLE_OPTION_DEFAULT = "#ffb86c"     # Dracula Orange
click.rich_click.STYLE_REQUIRED_SHORT = "#ff5555"     # Dracula Red
click.rich_click.STYLE_REQUIRED_LONG = "#ff5555"      # Dracula Red
click.rich_click.STYLE_OPTIONS_PANEL_BORDER = "dim"   # Dim for subtle borders
click.rich_click.STYLE_COMMANDS_PANEL_BORDER = "dim"  # Dim for subtle borders
click.rich_click.STYLE_COMMAND = "#50fa7b"            # Dracula Green - for command names in list
click.rich_click.STYLE_COMMANDS_TABLE_COLUMN_WIDTH_RATIO = (1, 3)  # Command:Description ratio (1/4 : 3/4)

{% if cli.command_groups %}
# Command groups will be set after main function is defined
{% endif %}

# Hooks system - try to import app_hooks module
app_hooks = None
try:
    # Try to import from the project root directory
    script_dir = Path(__file__).parent.parent.parent
    hooks_path = script_dir / "app_hooks.py"
    
    if hooks_path.exists():
        spec = importlib.util.spec_from_file_location("app_hooks", hooks_path)
        app_hooks = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(app_hooks)
    else:
        # Try to import from Python path
        import app_hooks
except (ImportError, FileNotFoundError):
    # No hooks module found, use default behavior
    pass

# Built-in commands
{% if cli %}
def builtin_upgrade_command(check_only=False, pre=False, version=None, dry_run=False):
    """Built-in upgrade function for {{ display_name }} - uses enhanced setup.sh script."""
    import subprocess
    import sys
    from pathlib import Path

    if check_only:
        print(f"Checking for updates to {{ display_name }}...")
        print("Update check not yet implemented. Run without --check to upgrade.")
        return

    if dry_run:
        print("Dry run - would execute: pipx upgrade {{ package_name }}")
        return

    # Find the setup.sh script - look in common locations
    setup_script = None
    search_paths = [
        Path.cwd() / "setup.sh",  # Current directory
        Path(__file__).parent.parent / "setup.sh",  # Package directory
        Path.home() / ".local" / "share" / "{{ package_name }}" / "setup.sh",  # User data
    ]
    
    for path in search_paths:
        if path.exists():
            setup_script = path
            break
    
    if setup_script is None:
        # Fallback to basic upgrade if setup.sh not found
        print(f"Enhanced setup script not found. Using basic upgrade for {{ display_name }}...")
        import shutil
        
        package_name = "{{ package_name }}"
        pypi_name = "{% if installation and installation.pypi_name %}{{ installation.pypi_name }}{% else %}{{ package_name }}{% endif %}"
        
        if shutil.which("pipx"):
            result = subprocess.run(["pipx", "list"], capture_output=True, text=True)
            if package_name in result.stdout or pypi_name in result.stdout:
                cmd = ["pipx", "upgrade", pypi_name]
            else:
                cmd = [sys.executable, "-m", "pip", "install", "--upgrade", pypi_name]
        else:
            cmd = [sys.executable, "-m", "pip", "install", "--upgrade", pypi_name]
        
        result = subprocess.run(cmd)
        if result.returncode == 0:
            print(f"‚úÖ {{ display_name }} upgraded successfully!")
            print(f"Run '{{ command_name }} --version' to verify the new version.")
        else:
            print(f"‚ùå Upgrade failed with exit code {result.returncode}")
            sys.exit(1)
        return

    # Use the enhanced setup.sh script
    result = subprocess.run([str(setup_script), "upgrade"])
    sys.exit(result.returncode)
{% endif %}

def load_plugins(cli_group):
    """Load plugins from the conventional plugin directory."""
    # Define plugin directories to search
    plugin_dirs = [
        # User-specific plugin directory
        Path.home() / ".config" / "goobits" / "{{ cli.name }}" / "plugins",
        # Local plugin directory (same as script)
        Path(__file__).parent / "plugins",
    ]
    
    for plugin_dir in plugin_dirs:
        if not plugin_dir.exists():
            continue
            
        # Add plugin directory to Python path
        sys.path.insert(0, str(plugin_dir))
        
        # Scan for plugin files
        for plugin_file in plugin_dir.glob("*.py"):
            if plugin_file.name.startswith("_"):
                continue
                
            # Skip core system files that aren't plugins
            if plugin_file.name in ["loader.py", "__init__.py"]:
                continue
                
            plugin_name = plugin_file.stem
            
            try:
                # Import the plugin module
                spec = importlib.util.spec_from_file_location(plugin_name, plugin_file)
                plugin_module = importlib.util.module_from_spec(spec)
                spec.loader.exec_module(plugin_module)
                
                # Call register_plugin if it exists
                if hasattr(plugin_module, "register_plugin"):
                    plugin_module.register_plugin(cli_group)
                    click.echo(f"Loaded plugin: {plugin_name}", err=True)
            except Exception as e:
                click.echo(f"Failed to load plugin {plugin_name}: {e}", err=True)

{% macro render_option(opt) -%}
@click.option(
    {%- if opt.short %}"-{{ opt.short }}", {% endif %}"--{{ opt.name }}"
    {%- if opt.type == "flag" %},
    is_flag=True
    {%- elif opt.choices %},
    type=click.Choice({{ opt.choices }})
    {%- else %},
    type={% if opt.type == "str" %}str{% elif opt.type == "int" %}int{% elif opt.type == "float" %}float{% elif opt.type == "bool" %}bool{% else %}str{% endif %}
    {%- endif %}
    {%- if opt.multiple %},
    multiple=True
    {%- endif %}
    {%- if opt.default is not none %},
    default={% if opt.default is sameas true %}True{% elif opt.default is sameas false %}False{% elif opt.default is number %}{{ opt.default }}{% else %}"{{ opt.default }}"{% endif %}
    {%- endif %},
    help="{{ opt.desc }}"
)
{%- endmacro %}

{% macro render_argument(arg) -%}
@click.argument(
    "{{ arg.name|upper|replace('-', '_') }}"
    {%- if arg.nargs %},
    nargs={% if arg.nargs == "*" %}-1{% elif arg.nargs == "?" %}1{% else %}{{ arg.nargs }}{% endif %}
    {%- if arg.nargs == "?" %},
    required=False{% endif %}
    {%- endif %}
    {%- if arg.required is defined and not arg.required %},
    required=False{% endif %}
    {%- if arg.required is defined and arg.required and arg.nargs and arg.nargs != "*" %},
    required=True{% endif %}
    {%- if not arg.required is defined and arg.nargs and arg.nargs != "*" %},
    required=True{% endif %}
    {%- if arg.choices %},
    type=click.Choice({{ arg.choices }})
    {%- endif %}
)
{%- endmacro %}

{% macro render_command(cmd_name, cmd_data, is_subcommand=False) -%}
{% if not is_subcommand %}@main.command(){% else %}@{{ cmd_name }}.command(){% endif %}
@click.pass_context
{% for arg in (cmd_data.args or []) %}
{{ render_argument(arg) }}
{% endfor %}
{% for opt in (cmd_data.options or []) %}
{{ render_option(opt) }}
{% endfor %}
def {{ cmd_name }}(ctx{% if cmd_data.args or cmd_data.options %}, {% endif %}{% if cmd_data.args %}{{ (cmd_data.args|map(attribute='name')|map('lower')|map('replace', '-', '_')|list + (cmd_data.options|map(attribute='name')|map('replace', '-', '_')|list))|join(', ') }}{% else %}{{ (cmd_data.options or [])|map(attribute='name')|map('replace', '-', '_')|join(', ') }}{% endif %}):
    """{% if cmd_data.icon %}{{ cmd_data.icon | format_icon }}{% endif %}{{ cmd_data.desc }}"""
    {% if cmd_data.lifecycle == "managed" %}
    # Managed command - expect an instance of ManagedCommand
    command_instance_name = f"{{ cmd_name }}_command"
    if app_hooks and hasattr(app_hooks, command_instance_name):
        # Get the command instance
        command_instance = getattr(app_hooks, command_instance_name)
        
        # Prepare arguments including global options
        kwargs = {}
        kwargs['command_name'] = '{{ cmd_name }}'  # Pass command name for daemon management
        {% if cmd_data.args %}
        {% for arg in cmd_data.args %}
        kwargs['{{ arg.name|lower|replace('-', '_') }}'] = {{ arg.name|lower|replace('-', '_') }}
        {% endfor %}
        {% endif %}
        {% if cmd_data.options %}
        {% for opt in cmd_data.options %}
        {# Handle hyphenated parameters correctly #}
        {% set param_name = opt.name|replace('-', '_') %}
        {% set var_name = opt.name|replace('-', '_') %}
        kwargs['{{ param_name }}'] = {{ var_name }}
        {% endfor %}
        {% endif %}
        
        # Add global options from context
        {% if cli.options %}
        if ctx.obj:
            {% for option in cli.options %}
            kwargs['{{ option.name|replace('-', '_') }}'] = ctx.obj.get('{{ option.name }}')
            {% endfor %}
        {% endif %}
        
        # Call execute() method on the ManagedCommand instance
        result = command_instance.execute(**kwargs)
        return result
    else:
        click.echo(f"Error: Managed command '{{ cmd_name }}' requires '{{ cmd_name }}_command' instance in app_hooks.py")
        sys.exit(1)
    {% else %}
    # Check for built-in commands first
    {% if cmd_name == 'build' or cmd_name == 'init' %}
    # Built-in commands (build, init)
    try:
        from pathlib import Path
        import sys
        
        # Add the parent directory to sys.path to find goobits_cli
        parent_dir = Path(__file__).parent.parent.parent
        if str(parent_dir) not in sys.path:
            sys.path.insert(0, str(parent_dir))
        
        {% if cmd_name == 'build' %}
        from goobits_cli.main import build
        
        # Use current directory's goobits.yaml if no config path specified
        config_file = Path(config_path) if config_path else Path("goobits.yaml")
        output_dir_path = Path(output_dir) if output_dir else None
        
        build(config_file, output_dir_path, output, backup)
        click.echo("‚úÖ Build completed successfully!")
        click.echo("   - Generated setup.sh")
        click.echo("   - Updated CLI files")
        
        {% elif cmd_name == 'init' %}
        from goobits_cli.main import init
        
        init(project_name, template, force)
        click.echo("‚úÖ Init completed successfully!")
        click.echo("   - Created goobits.yaml")
        
        {% endif %}
            
    except ImportError as e:
        click.echo(f"‚ùå {{ cmd_name.title() }} error: Could not import framework functions: {e}")
        return False
    except Exception as e:
        click.echo(f"‚ùå {{ cmd_name.title() }} error: {e}")
        return False
    
    return True
    {% else %}
    # Standard command - use the existing hook pattern
    hook_name = f"on_{{ cmd_name }}"
    if app_hooks and hasattr(app_hooks, hook_name):
        # Call the hook with all parameters
        hook_func = getattr(app_hooks, hook_name)
        
        # Prepare arguments including global options
        kwargs = {}
        kwargs['command_name'] = '{{ cmd_name }}'  # Pass command name for all commands
        {% if cmd_data.args %}
        {% for arg in cmd_data.args %}
        kwargs['{{ arg.name|lower|replace('-', '_') }}'] = {{ arg.name|lower|replace('-', '_') }}
        {% endfor %}
        {% endif %}
        {% if cmd_data.options %}
        {% for opt in cmd_data.options %}
        {# Handle hyphenated parameters correctly #}
        {% set param_name = opt.name|replace('-', '_') %}
        {% set var_name = opt.name|replace('-', '_') %}
        kwargs['{{ param_name }}'] = {{ var_name }}
        {% endfor %}
        {% endif %}
        
        # Add global options from context
        {% if cli.options %}
        if ctx.obj:
            {% for option in cli.options %}
            kwargs['{{ option.name|replace('-', '_') }}'] = ctx.obj.get('{{ option.name }}')
            {% endfor %}
        {% endif %}
        
        result = hook_func(**kwargs)
        return result
    else:
        # Default placeholder behavior
        click.echo(f"Executing {{ cmd_name }} command...")
        {% if cmd_data.args %}
        {% for arg in cmd_data.args %}
        click.echo(f"  {{ arg.name }}: {{ '{' }}{{ arg.name|lower|replace('-', '_') }}{{ '}' }}")
        {% endfor %}
        {% endif %}
        {% if cmd_data.options %}
        {% for opt in cmd_data.options %}
        click.echo(f"  {{ opt.name }}: {{ '{' }}{{ opt.name|replace('-', '_') }}{{ '}' }}")
        {% endfor %}
        {% endif %}
    {% endif %}
    {% endif %}
{%- endmacro %}

def get_version():
    """Get version from pyproject.toml or __init__.py"""
    import re
    
    try:
        # Try to get version from pyproject.toml FIRST (most authoritative)
        toml_path = Path(__file__).parent.parent / "pyproject.toml"
        if toml_path.exists():
            content = toml_path.read_text()
            match = re.search(r'version\s*=\s*["\']([^"\']+)["\']', content)
            if match:
                return match.group(1)
    except Exception:
        pass
    
    try:
        # Fallback to __init__.py
        init_path = Path(__file__).parent / "__init__.py"
        if init_path.exists():
            content = init_path.read_text()
            match = re.search(r'__version__\s*=\s*["\']([^"\']+)["\']', content)
            if match:
                return match.group(1)
    except Exception:
        pass
        
    # Final fallback
    return "{{ cli.version or '1.0.0' }}"

{% if cli.enable_help_json %}
def show_help_json(ctx, param, value):
    """Callback for --help-json option."""
    if not value or ctx.resilient_parsing:
        return
    # The triple quotes are important to correctly handle the multi-line JSON string
    click.echo('''{{ cli_config_json }}''')
    ctx.exit()
{% endif %}

{# Find the default command #}
{% set ns = namespace(default_cmd=None) %}
{% for cmd_name, cmd_data in cli.commands.items() %}
  {% if cmd_data.is_default %}
    {% set ns.default_cmd = cmd_name %}
  {% endif %}
{% endfor %}

{% if ns.default_cmd %}
class DefaultGroup(RichGroup):
    """Allow a default command to be invoked without being specified."""
    
    def __init__(self, *args, default=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.default_command = default
    
    def main(self, *args, **kwargs):
        """Override main to handle stdin input when no command is provided."""
        import sys
        import os
        import stat
        
        # Check if we need to inject the default command due to stdin input
        if len(sys.argv) == 1 and self.default_command:  # Only script name provided
            # Check if stdin is coming from a pipe or redirection
            has_stdin = False
            try:
                # Check if stdin is a pipe or file (not a terminal)
                stdin_stat = os.fstat(sys.stdin.fileno())
                has_stdin = stat.S_ISFIFO(stdin_stat.st_mode) or stat.S_ISREG(stdin_stat.st_mode)
            except Exception:
                # Fallback to isatty check
                has_stdin = not sys.stdin.isatty()
            
            if has_stdin:
                # Inject the default command into sys.argv
                sys.argv.append(self.default_command)
        
        return super().main(*args, **kwargs)
    
    def resolve_command(self, ctx, args):
        import sys
        import os
        
        try:
            # Try normal command resolution first
            return super().resolve_command(ctx, args)
        except click.UsageError:
            # If no command found and we have a default, use it
            # Check if stdin is coming from a pipe or redirection
            has_stdin = False
            try:
                # Check if stdin is a pipe or file (not a terminal)
                stdin_stat = os.fstat(sys.stdin.fileno())
                # Use S_ISFIFO to check if it's a pipe, or S_ISREG to check if it's a regular file
                import stat
                has_stdin = stat.S_ISFIFO(stdin_stat.st_mode) or stat.S_ISREG(stdin_stat.st_mode)
            except Exception as e:
                # Fallback to isatty check
                has_stdin = not sys.stdin.isatty()
            
            is_help_request = any(arg in ['--help-all', '--help-json'] for arg in args)
            
            if self.default_command and not is_help_request:
                # Trigger default command if:
                # 1. We have args (existing behavior)
                # 2. We have stdin input (new behavior for pipes)
                if args or has_stdin:
                    cmd = self.commands.get(self.default_command)
                    if cmd:
                        # Return command name, command object, and all args
                        return self.default_command, cmd, args
            raise
{% endif %}

{% if ns.default_cmd %}
@click.group(cls=DefaultGroup, default='{{ ns.default_cmd }}', context_settings={"help_option_names": ["-h", "--help"], "max_content_width": 120})
{% else %}
@click.group(cls=RichGroup, context_settings={"help_option_names": ["-h", "--help"], "max_content_width": 120})
{% endif %}
@click.version_option(version=get_version(), prog_name="{{ cli.name }}")
@click.pass_context
{% if cli.enable_help_json %}
@click.option('--help-json', is_flag=True, callback=show_help_json, is_eager=True, help='Output CLI structure as JSON.', hidden=True)
{% endif %}
{% if cli.enable_recursive_help %}
@click.option('--help-all', is_flag=True, is_eager=True, help='Show help for all commands.', hidden=True)
{% endif %}
{% if cli.options %}
{% for option in cli.options %}
{{ render_option(option) }}
{% endfor %}
{% endif %}
def main(ctx{% if cli.enable_help_json %}, help_json=False{% endif %}{% if cli.enable_recursive_help %}, help_all=False{% endif %}{% if cli.options %}{% for option in cli.options %}, {{ option.name.replace('-', '_') }}{% if option.type == 'flag' %}=False{% else %}=None{% endif %}{% endfor %}{% endif %}):
    """{% if cli.icon %}{{ cli.icon | format_icon }}{% endif %}[bold color(6)]{{ cli.name }}{% if cli.display_version %} v{{ cli.version or '1.0.0' }}{% endif %}[/bold color(6)] - {{ cli.tagline }}

    {% if cli.description %}
    \b
    [#B3B8C0]{{ cli.description }}[/#B3B8C0]
    {% endif %}

    {% if cli.header_sections %}
    {%- for section in cli.header_sections %}
    \b
    [bold yellow]{{ section.title }}:[/bold yellow]
    {%- set aligned_items = section.items | align_header_items %}
    {% for item in aligned_items -%}
    {% if item.style == 'example' -%}
    [green]{{ item.item_aligned }}[/green] [italic][#B3B8C0]# {{ item.desc }}[/#B3B8C0][/italic]
    {%- elif item.style == 'command' -%}
    [green]{{ item.item_aligned }}[/green]  {{ item.desc }}
    {%- elif item.style == 'setup' -%}
    {{ item.item + ":" }}{{ " " * (item.item_aligned|length - item.item|length - 1) }}[green]{{ item.desc }}[/green]
    {%- endif %}
    {% endfor %}
    {% endfor %}
    {% endif %}
    {% if cli.footer_note %}
    \b
       [#B3B8C0]{{ cli.footer_note }}[/#B3B8C0]
    {% endif -%}
    """

    {% if cli.enable_recursive_help %}
    if help_all:
        # Print main help
        click.echo(ctx.get_help())
        click.echo() # Add a blank line for spacing

        # Get a list of all command names
        commands_to_show = sorted(ctx.command.list_commands(ctx))

        for cmd_name in commands_to_show:
            command = ctx.command.get_command(ctx, cmd_name)

            # Create a new context for the subcommand
            sub_ctx = click.Context(command, info_name=cmd_name, parent=ctx)

            # Print a separator and the subcommand's help
            click.echo("="*20 + f" HELP FOR: {cmd_name} " + "="*20)
            click.echo(sub_ctx.get_help())
            click.echo() # Add a blank line for spacing

        # Exit after printing all help
        ctx.exit()
    {% endif %}
    
    # Store global options in context for use by commands
    {% if cli.options %}
    if ctx.obj is None:
        ctx.obj = {}
    {% for option in cli.options %}
    ctx.obj['{{ option.name }}'] = {{ option.name.replace('-', '_') }}
    {% endfor %}
    {% endif %}

    pass

{% if cli.command_groups %}
# Set command groups after main function is defined
{%- set defined_commands = cli.commands.keys() | list %}
click.rich_click.COMMAND_GROUPS = {
    "main": [
        {% for group in cli.command_groups %}
        {
            "name": "{{ group.name }}",
            "commands": {{ group.commands | select('in', defined_commands) | list }},
        },
        {% endfor %}
    ]
}
{% endif %}

# Built-in upgrade command (enabled by default)
{% if cli and (cli.enable_upgrade_command is not defined or cli.enable_upgrade_command) %}
@main.command()
@click.option('--check', is_flag=True, help='Check for updates without installing')
@click.option('--version', type=str, help='Install specific version')
@click.option('--pre', is_flag=True, help='Include pre-release versions')
@click.option('--dry-run', is_flag=True, help='Show what would be done without doing it')
def upgrade(check, version, pre, dry_run):
    """Upgrade {{ display_name }} to the latest version."""
    builtin_upgrade_command(check_only=check, version=version, pre=pre, dry_run=dry_run)
{% endif %}

{% for cmd_name, cmd_data in cli.commands.items() %}
{% if not cmd_data.subcommands %}
{{ render_command(cmd_name, cmd_data) }}
{% else %}
@main.group()
def {{ cmd_name }}():
    """{% if cmd_data.icon %}{{ cmd_data.icon | format_icon }}{% endif %}{{ cmd_data.desc }}"""
    pass

{% for subcmd_name, subcmd_data in cmd_data.subcommands.items() %}
@{{ cmd_name }}.command()
@click.pass_context
{% for arg in (subcmd_data.args or []) %}
{{ render_argument(arg) }}
{% endfor %}
{% for opt in (subcmd_data.options or []) %}
{{ render_option(opt) }}
{% endfor %}
def {{ subcmd_name }}(ctx{% if subcmd_data.args or subcmd_data.options %}, {% endif %}{% if subcmd_data.args %}{{ (subcmd_data.args|map(attribute='name')|map('lower')|map('replace', '-', '_')|list + (subcmd_data.options|map(attribute='name')|map('replace', '-', '_')|list))|join(', ') }}{% else %}{{ (subcmd_data.options or [])|map(attribute='name')|map('replace', '-', '_')|join(', ') }}{% endif %}):
    """{% if subcmd_data.icon %}{{ subcmd_data.icon | format_icon }}{% endif %}{{ subcmd_data.desc }}"""
    # Check if hook function exists
    hook_name = f"on_{{ cmd_name }}_{{ subcmd_name }}"
    if app_hooks and hasattr(app_hooks, hook_name):
        # Call the hook with all parameters
        hook_func = getattr(app_hooks, hook_name)
        
        # Prepare arguments including global options
        kwargs = {}
        kwargs['command_name'] = '{{ subcmd_name }}'  # Pass command name for all commands
        {% if subcmd_data.args %}
        {% for arg in subcmd_data.args %}
        kwargs['{{ arg.name|lower|replace('-', '_') }}'] = {{ arg.name|lower|replace('-', '_') }}
        {% endfor %}
        {% endif %}
        {% if subcmd_data.options %}
        {% for opt in subcmd_data.options %}
        kwargs['{{ opt.name|replace('-', '_') }}'] = {{ opt.name|replace('-', '_') }}
        {% endfor %}
        {% endif %}
        
        # Add global options from context
        {% if cli.options %}
        if ctx.obj:
            {% for option in cli.options %}
            kwargs['{{ option.name|replace('-', '_') }}'] = ctx.obj.get('{{ option.name }}')
            {% endfor %}
        {% endif %}
        
        result = hook_func(**kwargs)
        return result
    else:
        # Default placeholder behavior
        click.echo(f"Executing {{ subcmd_name }} command...")
        {% if subcmd_data.args %}
        {% for arg in subcmd_data.args %}
        click.echo(f"  {{ arg.name }}: {{ '{' }}{{ arg.name|lower|replace('-', '_') }}{{ '}' }}")
        {% endfor %}
        {% endif %}
        {% if subcmd_data.options %}
        {% for opt in subcmd_data.options %}
        click.echo(f"  {{ opt.name }}: {{ '{' }}{{ opt.name|replace('-', '_') }}{{ '}' }}")
        {% endfor %}
        {% endif %}
{% endfor %}
{% endif %}

{% endfor %}

{# Auto-generate daemon management commands for managed commands #}
{% set ns = namespace(has_managed=false) %}
{% for cmd_name, cmd_data in cli.commands.items() %}
{% if cmd_data.lifecycle == "managed" %}
{% set ns.has_managed = true %}
{% endif %}
{% endfor %}
{% if ns.has_managed %}
@main.command()
@click.pass_context
@click.argument(
    "command_name",
    required=True
)
@click.option("--timeout",
    type=int,
    default=10,
    help="Timeout in seconds for graceful shutdown"
)
@click.option("--json",
    is_flag=True,
    help="Output in JSON format"
)
def daemonstop(ctx, command_name, timeout, json):
    """‚èπÔ∏è Stop a running daemon process"""
    from src.gubits.daemon import DaemonHelper
    
    daemon_helper = DaemonHelper(command_name)
    
    # Check if daemon is running
    if not daemon_helper.is_running():
        msg = f"No daemon running for command '{command_name}'"
        if json:
            import json as json_module
            click.echo(json_module.dumps({"status": "not_running", "message": msg}))
        else:
            click.echo(f"‚ö†Ô∏è  {msg}")
        return {"status": "not_running"}
    
    # Get PID before stopping
    pid = daemon_helper.get_pid()
    
    # Stop the daemon
    if daemon_helper.stop(timeout=timeout):
        if json:
            import json as json_module
            click.echo(json_module.dumps({
                "status": "stopped",
                "command": command_name,
                "pid": pid,
                "message": f"Successfully stopped daemon for '{command_name}'"
            }))
        else:
            click.echo(f"‚úÖ Successfully stopped daemon '{command_name}' (PID: {pid})")
        return {"status": "stopped", "pid": pid}
    else:
        error_msg = f"Failed to stop daemon '{command_name}' (PID: {pid})"
        if json:
            import json as json_module
            click.echo(json_module.dumps({"status": "error", "message": error_msg}))
        else:
            click.echo(f"‚ùå {error_msg}")
        return {"status": "error", "message": error_msg}


@main.command()
@click.pass_context
@click.argument(
    "command_name",
    required=True
)
@click.option("--json",
    is_flag=True,
    help="Output in JSON format"
)
def daemonstatus(ctx, command_name, json):
    """üìä Check status of a daemon process"""
    from src.gubits.daemon import DaemonHelper
    
    daemon_helper = DaemonHelper(command_name)
    
    # Get daemon stats
    stats = daemon_helper.get_daemon_stats()
    
    if json:
        import json as json_module
        click.echo(json_module.dumps(stats, indent=2))
    else:
        is_running = stats['running']
        status_emoji = 'üü¢' if is_running else 'üî¥'
        status_text = 'Running' if is_running else 'Stopped'
        
        click.echo(f"üìä Daemon Status for '{command_name}': {status_emoji} {status_text}")
        
        if is_running:
            click.echo(f"   PID: {stats['pid']}")
            click.echo(f"   PID File: {stats['pid_file']}")
        else:
            click.echo(f"   PID File: {stats['pid_file']} (not found or stale)")
            
    return stats


@main.group()
def daemon():
    """üîß Daemon system integration commands"""
    pass


@daemon.command()
@click.pass_context
@click.argument(
    "command_name",
    required=True
)
@click.option("--user",
    is_flag=True,
    default=True,
    help="Install as user service (default)"
)
@click.option("--system",
    is_flag=True,
    help="Install as system service (requires sudo)"
)
def install(ctx, command_name, user, system):
    """üîß Generate systemd service file for daemon management"""
    import shutil
    import subprocess
    from pathlib import Path
    
    # Determine CLI executable path
    cli_executable = shutil.which("{{ cli.name|lower|replace(' ', '') }}")
    if not cli_executable:
        # Fallback to sys.executable with -m approach
        cli_executable = f"{sys.executable} -m {{ cli.name|lower|replace(' ', '_') }}"
    
    # Determine installation type
    if system:
        service_dir = Path("/etc/systemd/system")
        service_type = "system"
        install_cmd_prefix = "sudo "
    else:
        service_dir = Path.home() / ".config" / "systemd" / "user"
        service_type = "user"
        install_cmd_prefix = ""
    
    # Ensure service directory exists
    if not service_dir.exists():
        try:
            service_dir.mkdir(parents=True, exist_ok=True)
        except PermissionError:
            click.echo(f"‚ùå Permission denied creating directory: {service_dir}")
            click.echo(f"   Try running with sudo for system services")
            sys.exit(1)
    
    # Generate service file name
    service_name = f"{{ cli.name|lower|replace(' ', '-') }}-{command_name}.service"
    service_file_path = service_dir / service_name
    
    # Determine PID file path
    if system:
        pid_file_path = f"/run/{{ cli.name|lower|replace(' ', '-') }}-{command_name}.pid"
        working_dir = "/var/lib/{{ cli.name|lower|replace(' ', '-') }}"
    else:
        runtime_dir = os.environ.get('XDG_RUNTIME_DIR', f"/run/user/{os.getuid()}")
        pid_file_path = f"{runtime_dir}/{{ cli.name|lower|replace(' ', '-') }}-{command_name}.pid"
        working_dir = str(Path.home())
    
    # Generate systemd unit file content
    service_content = f"""# Auto-generated by goobits for the '{command_name}' command
# Service file for {{ cli.name }} daemon management
[Unit]
Description=goobits-managed daemon for the '{command_name}' command
After=network.target
Wants=network.target

[Service]
Type=forking
ExecStart={cli_executable} {command_name} --daemon
PIDFile={pid_file_path}
Restart=on-failure
RestartSec=5
WorkingDirectory={working_dir}
"""

    # Add user-specific settings
    if not system:
        service_content += """
# User service settings
User=%i
Group=%i
"""

    service_content += """
[Install]
WantedBy={"default.target" if not system else "multi-user.target"}
"""
    
    # Write service file
    try:
        with open(service_file_path, 'w') as f:
            f.write(service_content)
        click.echo(f"‚úÖ Generated systemd service file: {service_file_path}")
    except PermissionError:
        click.echo(f"‚ùå Permission denied writing to: {service_file_path}")
        if not system:
            click.echo(f"   Try: mkdir -p {service_dir}")
        sys.exit(1)
    
    # Print usage instructions
    click.echo(f"")
    click.echo(f"üîß Systemd service '{service_name}' created successfully!")
    click.echo(f"")
    click.echo(f"üìã To enable and start the service:")
    if system:
        click.echo(f"   sudo systemctl daemon-reload")
        click.echo(f"   sudo systemctl enable {service_name}")
        click.echo(f"   sudo systemctl start {service_name}")
        click.echo(f"")
        click.echo(f"üìä To check status:")
        click.echo(f"   sudo systemctl status {service_name}")
        click.echo(f"")
        click.echo(f"üõë To stop and disable:")
        click.echo(f"   sudo systemctl stop {service_name}")
        click.echo(f"   sudo systemctl disable {service_name}")
    else:
        click.echo(f"   systemctl --user daemon-reload")
        click.echo(f"   systemctl --user enable {service_name}")
        click.echo(f"   systemctl --user start {service_name}")
        click.echo(f"")
        click.echo(f"üìä To check status:")
        click.echo(f"   systemctl --user status {service_name}")
        click.echo(f"")
        click.echo(f"üõë To stop and disable:")
        click.echo(f"   systemctl --user stop {service_name}")
        click.echo(f"   systemctl --user disable {service_name}")
    
    click.echo(f"")
    click.echo(f"üìù Service file location: {service_file_path}")
    
    return {"status": "service_created", "service_file": str(service_file_path), "service_name": service_name}

{% endif %}

def cli_entry():
    """Entry point for the CLI when installed via pipx."""
    # Load plugins before running the CLI
    load_plugins(main)
    main()

if __name__ == "__main__":
    cli_entry()