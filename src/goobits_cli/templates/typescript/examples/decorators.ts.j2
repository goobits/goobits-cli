/**
 * Example demonstrating decorator-based command definition
 * This file shows how to use the new decorator system for cleaner command syntax
 */

import { Command as CommanderCommand } from 'commander';
import {
  Command,
  Option,
  Argument,
  IsRequired,
  IsEmail,
  IsPath,
  IsNumber,
  IsString,
  IsIn,
  DecoratorCommandBuilder,
} from '../lib/decorators';

/**
 * Example command class using decorators
 * This demonstrates a modern, clean approach to defining CLI commands
 */
export class ExampleCommands {
  /**
   * Simple command with basic options
   */
  @Command({
    name: 'hello',
    description: 'Say hello to someone',
    icon: 'üëã',
  })
  async hello(
    @Argument({
      name: 'name',
      description: 'Name to greet',
      required: true,
    })
    @IsRequired({ message: 'Name is required' })
    @IsString({ minLength: 1, maxLength: 50 })
    name: string,

    @Option({
      name: 'greeting',
      short: 'g',
      description: 'Custom greeting',
      type: 'string',
      default: 'Hello',
    })
    @IsIn({
      values: ['Hello', 'Hi', 'Hey', 'Greetings'],
      message: 'Greeting must be one of: Hello, Hi, Hey, Greetings',
    })
    greeting: string,

    @Option({
      name: 'count',
      short: 'c',
      description: 'Number of times to greet',
      type: 'number',
      default: 1,
    })
    @IsNumber({ min: 1, max: 10, integer: true })
    count: number,

    @Option({
      name: 'uppercase',
      short: 'u',
      description: 'Use uppercase',
      type: 'flag',
    })
    uppercase: boolean
  ): Promise<void> {
    const message = `${greeting}, ${name}!`;
    const finalMessage = uppercase ? message.toUpperCase() : message;
    
    for (let i = 0; i < count; i++) {
      console.log(finalMessage);
    }
  }

  /**
   * Command with file operations
   */
  @Command({
    name: 'process-file',
    description: 'Process a file with various options',
    icon: 'üìÅ',
  })
  async processFile(
    @Argument({
      name: 'input',
      description: 'Input file path',
      required: true,
    })
    @IsRequired()
    @IsPath({ mustExist: true, type: 'file', readable: true })
    input: string,

    @Option({
      name: 'output',
      short: 'o',
      description: 'Output file path',
      type: 'string',
    })
    @IsPath({ type: 'file', writable: true })
    output: string,

    @Option({
      name: 'format',
      short: 'f',
      description: 'Output format',
      type: 'string',
      default: 'json',
    })
    @IsIn({
      values: ['json', 'yaml', 'xml', 'csv'],
      message: 'Format must be one of: json, yaml, xml, csv',
    })
    format: string,

    @Option({
      name: 'verbose',
      short: 'v',
      description: 'Verbose output',
      type: 'flag',
    })
    verbose: boolean
  ): Promise<void> {
    if (verbose) {
      console.log(`Processing file: ${input}`);
      console.log(`Output format: ${format}`);
      if (output) {
        console.log(`Output file: ${output}`);
      }
    }

    // Simulate file processing
    console.log(`‚úÖ File processed successfully in ${format} format`);
  }

  /**
   * Command with email validation
   */
  @Command({
    name: 'send-notification',
    description: 'Send a notification via email',
    icon: 'üìß',
  })
  async sendNotification(
    @Option({
      name: 'email',
      short: 'e',
      description: 'Email address to send notification to',
      type: 'string',
      required: true,
    })
    @IsRequired()
    @IsEmail({ domains: ['gmail.com', 'company.com'] })
    email: string,

    @Option({
      name: 'subject',
      short: 's',
      description: 'Email subject',
      type: 'string',
      default: 'CLI Notification',
    })
    @IsString({ minLength: 5, maxLength: 100 })
    subject: string,

    @Argument({
      name: 'message',
      description: 'Notification message',
      required: true,
    })
    @IsRequired()
    @IsString({ minLength: 10, maxLength: 500 })
    message: string,

    @Option({
      name: 'priority',
      short: 'p',
      description: 'Notification priority',
      type: 'string',
      default: 'normal',
    })
    @IsIn({
      values: ['low', 'normal', 'high', 'urgent'],
      message: 'Priority must be one of: low, normal, high, urgent',
    })
    priority: string
  ): Promise<void> {
    console.log(`üìß Sending notification to: ${email}`);
    console.log(`üìã Subject: ${subject}`);
    console.log(`üí¨ Message: ${message}`);
    console.log(`‚ö° Priority: ${priority}`);
    
    // Simulate sending email
    console.log('‚úÖ Notification sent successfully!');
  }

  /**
   * Default command (runs when no command is specified)
   */
  @Command({
    name: 'default',
    description: 'Default command that shows CLI information',
    isDefault: true,
  })
  async defaultCommand(): Promise<void> {
    console.log('üöÄ Welcome to {{ display_name }}!');
    console.log('');
    console.log('This CLI demonstrates advanced TypeScript features:');
    console.log('  ‚Ä¢ Decorator-based command definition');
    console.log('  ‚Ä¢ Strong typing with comprehensive interfaces');
    console.log('  ‚Ä¢ Built-in validation system');
    console.log('  ‚Ä¢ Plugin architecture');
    console.log('');
    console.log('Try running:');
    console.log('  {{ command_name }} hello "World" --greeting "Hi" --count 3');
    console.log('  {{ command_name }} process-file input.txt --format json --verbose');
    console.log('  {{ command_name }} send-notification --email user@company.com "Hello from CLI!"');
    console.log('');
    console.log('Use --help with any command for more information.');
  }
}

/**
 * Register decorator-based commands with Commander.js
 * This function should be called from your main CLI setup
 */
export function registerDecoratorCommands(program: CommanderCommand): void {
  const commands = new ExampleCommands();
  const builder = new DecoratorCommandBuilder();
  
  // Build and register all decorated commands
  builder.buildCommands(program, commands);
  
  console.log('‚úÖ Decorator-based commands registered successfully');
}

/**
 * Example of extending the validation system with custom validators
 */
export class CustomValidatedCommands {
  /**
   * Command demonstrating custom validation
   */
  @Command({
    name: 'deploy',
    description: 'Deploy application to environment',
    icon: 'üöÄ',
  })
  async deploy(
    @Argument({
      name: 'environment',
      description: 'Target environment',
      required: true,
    })
    @IsRequired()
    @IsIn({
      values: ['development', 'staging', 'production'],
      message: 'Environment must be one of: development, staging, production',
    })
    environment: string,

    @Option({
      name: 'version',
      short: 'v',
      description: 'Version to deploy',
      type: 'string',
      required: true,
    })
    @IsRequired()
    @IsString({
      pattern: /^\d+\.\d+\.\d+$/,
      patternDescription: 'semantic version (e.g., 1.2.3)',
    })
    version: string,

    @Option({
      name: 'config-file',
      short: 'c',
      description: 'Configuration file path',
      type: 'string',
    })
    @IsPath({
      mustExist: true,
      type: 'file',
      extensions: ['.json', '.yaml', '.yml'],
    })
    configFile: string,

    @Option({
      name: 'dry-run',
      description: 'Perform a dry run without actual deployment',
      type: 'flag',
    })
    dryRun: boolean
  ): Promise<void> {
    console.log(`üöÄ Deploying to ${environment} environment`);
    console.log(`üì¶ Version: ${version}`);
    
    if (configFile) {
      console.log(`‚öôÔ∏è  Using config: ${configFile}`);
    }
    
    if (dryRun) {
      console.log('üîç Dry run mode - no actual deployment');
      console.log('‚úÖ Deployment validation passed');
    } else {
      console.log('üîÑ Starting deployment...');
      // Simulate deployment progress
      console.log('‚úÖ Deployment completed successfully');
    }
  }
}

export default ExampleCommands;