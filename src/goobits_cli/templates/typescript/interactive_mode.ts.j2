#!/usr/bin/env node
/**
 * Enhanced TypeScript Interactive Mode for {{ display_name }}
 * Generated by Goobits CLI Framework
 * 
 * Features:
 * - Full type safety with TypeScript compiler integration
 * - Type-aware tab completion
 * - TypeScript expression evaluation
 * - Advanced error handling with type information
 */

import * as readline from 'readline';
import * as fs from 'fs';
import * as path from 'path';
import { CommandContext, HookRegistry } from './types/cli';

// Try to load TypeScript compiler API for enhanced features
let ts: any;
let hasTypeScriptCompiler = false;

try {
    ts = require('typescript');
    hasTypeScriptCompiler = true;
    if (process.env.DEBUG) console.debug('TypeScript compiler API loaded successfully');
} catch (e: any) {
    if (process.env.DEBUG) console.debug('TypeScript compiler API not available:', e.message);
}

// Import hooks with proper typing
let hooks: HookRegistry;
try {
    hooks = require('./hooks');
} catch (e) {
    console.warn('Warning: hooks module not found, using empty hooks');
    hooks = {};
}

// Enhanced command interface with type safety
interface TypedCommand<TContext extends CommandContext = CommandContext> {
    readonly name: string;
    readonly description: string;
    readonly handler: (args: string[], context?: Partial<TContext>) => Promise<void> | void;
    readonly argTypes?: readonly string[];
    readonly optionTypes?: Record<string, string>;
    readonly aliases?: readonly string[];
    readonly examples?: readonly string[];
}

// Type-aware completion provider interface
interface CompletionProvider {
    getCommandCompletions(text: string): string[];
    getOptionCompletions(command: string, text: string): string[];
    getValueCompletions(command: string, option: string, text: string): string[];
    getTypeCompletions(type: string, text: string): string[];
}

// Expression evaluation result
interface EvaluationResult {
    readonly success: boolean;
    readonly result?: unknown;
    readonly type?: string;
    readonly error?: string;
    readonly suggestions?: readonly string[];
}

class {{ display_name | replace('-', '') | replace(' ', '') | title }}Interactive {
    private readonly rl: readline.Interface;
    private readonly commands: Map<string, TypedCommand>;
    private readonly commandHistory: string[] = [];
    private readonly completionProvider: CompletionProvider;
    private readonly typeChecker: TypeChecker | null = null;

    constructor() {
        this.rl = readline.createInterface({
            input: process.stdin,
            output: process.stdout,
            prompt: '{{ cli.name }}> ',
            completer: this.enhancedCompleter.bind(this),
            history: [],
            historySize: 1000
        });

        this.commands = new Map();
        this.completionProvider = new EnhancedCompletionProvider();
        
        // Initialize TypeScript type checker if compiler is available
        if (hasTypeScriptCompiler) {
            this.typeChecker = new TypeChecker();
        }

        this.setupCommands();
        this.setupEventHandlers();
        this.loadCommandHistory();
    }

    private setupCommands(): void {
        // Built-in commands with enhanced type safety
        this.registerCommand({
            name: 'help',
            description: 'Show available commands with type information',
            handler: this.handleHelp.bind(this),
            aliases: ['?', 'h'],
            examples: ['help', 'help <command>']
        });

        this.registerCommand({
            name: 'exit',
            description: 'Exit interactive mode',
            handler: this.handleExit.bind(this),
            aliases: ['quit', 'q'],
            examples: ['exit', 'quit']
        });

        this.registerCommand({
            name: 'history',
            description: 'Show command history',
            handler: this.handleHistory.bind(this),
            examples: ['history', 'history 10']
        });

        this.registerCommand({
            name: 'clear',
            description: 'Clear the screen',
            handler: this.handleClear.bind(this),
            aliases: ['cls'],
            examples: ['clear']
        });

        this.registerCommand({
            name: 'types',
            description: 'Show available types and their definitions',
            handler: this.handleTypes.bind(this),
            examples: ['types', 'types <type-name>']
        });

        this.registerCommand({
            name: 'eval',
            description: 'Evaluate TypeScript expression with type checking',
            handler: this.handleEval.bind(this),
            argTypes: ['string'],
            examples: ['eval "2 + 2"', 'eval "Object.keys({a: 1, b: 2})"']
        });

        // CLI commands from configuration
        {% for command_name, command in cli.commands.items() %}
        this.registerCommand({
            name: '{{ command_name }}',
            description: '{{ command.desc }}',
            handler: this.handle{{ command_name | replace("-", "") | title }}.bind(this),
            {% if command.args -%}
            argTypes: [{% for arg in command.args %}'{{ arg.type | default('string') }}'{% if not loop.last %}, {% endif %}{% endfor %}],
            {% endif -%}
            {% if command.options -%}
            optionTypes: {
                {% for option in command.options -%}
                '{{ option.name }}': '{{ option.type | default('string') }}'{% if not loop.last %},{% endif %}
                {% endfor %}
            },
            {% endif -%}
            examples: [
                {% if command.examples -%}
                {% for example in command.examples -%}
                '{{ example }}'{% if not loop.last %},{% endif %}
                {% endfor %}
                {% else -%}
                '{{ command_name }}{% for arg in command.args %} <{{ arg.name }}>{% endfor %}'
                {% endif -%}
            ]
        });
        {% endfor %}
    }

    private setupEventHandlers(): void {
        this.rl.on('line', this.handleLine.bind(this));
        this.rl.on('close', this.handleClose.bind(this));
        this.rl.on('SIGINT', this.handleSigInt.bind(this));

        // Enhanced readline setup
        if (hasTypeScriptCompiler) {
            this.setupEnhancedFeatures();
        }
    }

    private setupEnhancedFeatures(): void {
        // Enable type-aware features when TypeScript compiler is available
        console.log('üéØ Enhanced TypeScript features enabled:');
        console.log('   ‚Ä¢ Type-aware tab completion');
        console.log('   ‚Ä¢ Expression evaluation with type checking');
        console.log('   ‚Ä¢ Advanced error diagnostics');
        console.log();
    }

    private loadCommandHistory(): void {
        const historyFile = path.join(process.cwd(), '.{{ cli.name }}_history');
        try {
            if (fs.existsSync(historyFile)) {
                const history = fs.readFileSync(historyFile, 'utf-8')
                    .split('\n')
                    .filter(line => line.trim())
                    .slice(-1000); // Keep last 1000 commands
                
                history.forEach(line => this.rl.history.push(line));
            }
        } catch (error) {
            // Ignore history loading errors
        }
    }

    private saveCommandHistory(): void {
        const historyFile = path.join(process.cwd(), '.{{ cli.name }}_history');
        try {
            const history = this.commandHistory.slice(-1000).join('\n') + '\n';
            fs.writeFileSync(historyFile, history);
        } catch (error) {
            // Ignore history saving errors
        }
    }

    start(): void {
        console.log('üöÄ Welcome to {{ display_name }} interactive mode');
        console.log('   Type "help" for commands, "exit" to quit');
        if (hasTypeScriptCompiler) {
            console.log('   Enhanced TypeScript features are available');
        }
        console.log();

        this.rl.prompt();
    }

    private registerCommand(command: TypedCommand): void {
        this.commands.set(command.name, command);
        
        // Register aliases
        if (command.aliases) {
            command.aliases.forEach(alias => {
                this.commands.set(alias, command);
            });
        }
    }

    private async handleLine(line: string): Promise<void> {
        const trimmed = line.trim();
        if (!trimmed) {
            this.rl.prompt();
            return;
        }

        this.commandHistory.push(trimmed);
        const [commandName, ...args] = this.parseCommandLine(trimmed);

        if (this.commands.has(commandName)) {
            const command = this.commands.get(commandName)!;
            try {
                await this.executeCommand(command, args);
            } catch (error) {
                this.handleCommandError(error as Error, commandName, args);
            }
        } else {
            console.error(`‚ùå Unknown command: ${commandName}`);
            console.log('üí° Type "help" for available commands');
        }

        this.rl.prompt();
    }

    private parseCommandLine(line: string): string[] {
        // Enhanced parsing with proper quote handling
        const args: string[] = [];
        let current = '';
        let inQuotes = false;
        let quoteChar = '';

        for (let i = 0; i < line.length; i++) {
            const char = line[i];
            
            if (!inQuotes && (char === '"' || char === "'")) {
                inQuotes = true;
                quoteChar = char;
            } else if (inQuotes && char === quoteChar) {
                inQuotes = false;
                quoteChar = '';
            } else if (!inQuotes && char === ' ') {
                if (current) {
                    args.push(current);
                    current = '';
                }
            } else {
                current += char;
            }
        }

        if (current) {
            args.push(current);
        }

        return args;
    }

    private async executeCommand(command: TypedCommand, args: string[]): Promise<void> {
        // Type validation if types are specified
        if (command.argTypes && hasTypeScriptCompiler && this.typeChecker) {
            const validationResult = this.typeChecker.validateArguments(args, command.argTypes);
            if (!validationResult.isValid) {
                console.error('‚ùå Type validation failed:');
                validationResult.errors.forEach(error => console.error(`   ${error}`));
                return;
            }
        }

        await command.handler(args);
    }

    private handleCommandError(error: Error, commandName: string, args: string[]): void {
        console.error(`‚ùå Error executing command '${commandName}':`, error.message);
        
        // Enhanced error handling with type information
        if (hasTypeScriptCompiler && this.typeChecker) {
            const suggestions = this.typeChecker.getSuggestions(error, commandName, args);
            if (suggestions.length > 0) {
                console.log('üí° Suggestions:');
                suggestions.forEach(suggestion => console.log(`   ‚Ä¢ ${suggestion}`));
            }
        }
    }

    private enhancedCompleter(line: string): [string[], string] {
        const completions = this.completionProvider.getCommandCompletions(line);
        const hits = completions.filter(c => c.startsWith(line));
        return [hits.length ? hits : completions, line];
    }

    private handleClose(): void {
        this.saveCommandHistory();
        console.log('\nüëã Goodbye!');
        process.exit(0);
    }

    private handleSigInt(): void {
        console.log('\nüí° Use "exit" to quit or press Ctrl+C again to force quit');
        this.rl.prompt();
    }

    // Built-in command handlers
    private handleHelp(args: string[]): void {
        if (args.length > 0) {
            const commandName = args[0];
            const command = this.commands.get(commandName);
            
            if (command) {
                console.log(`\nüìñ ${command.name}: ${command.description}`);
                
                if (command.argTypes) {
                    console.log(`   Arguments: ${command.argTypes.join(', ')}`);
                }
                
                if (command.optionTypes) {
                    console.log('   Options:');
                    Object.entries(command.optionTypes).forEach(([name, type]) => {
                        console.log(`     --${name}: ${type}`);
                    });
                }
                
                if (command.examples) {
                    console.log('   Examples:');
                    command.examples.forEach(example => console.log(`     ${example}`));
                }
                
                if (command.aliases && command.aliases.length > 0) {
                    console.log(`   Aliases: ${command.aliases.join(', ')}`);
                }
            } else {
                console.error(`‚ùå Unknown command: ${commandName}`);
            }
        } else {
            console.log('\nüìö Available commands:');
            
            const uniqueCommands = new Set<TypedCommand>();
            this.commands.forEach(command => uniqueCommands.add(command));
            
            Array.from(uniqueCommands)
                .sort((a, b) => a.name.localeCompare(b.name))
                .forEach(command => {
                    const typeInfo = command.argTypes ? ` (${command.argTypes.join(', ')})` : '';
                    console.log(`  ${command.name.padEnd(15)} ${command.description}${typeInfo}`);
                });
        }
        console.log();
    }

    private handleExit(): void {
        this.rl.close();
    }

    private handleHistory(args: string[]): void {
        const count = args.length > 0 ? parseInt(args[0]) : 20;
        const recentHistory = this.commandHistory.slice(-count);
        
        console.log(`\nüìú Recent command history (last ${recentHistory.length}):`);
        recentHistory.forEach((cmd, index) => {
            const lineNumber = this.commandHistory.length - recentHistory.length + index + 1;
            console.log(`  ${lineNumber.toString().padStart(4)}: ${cmd}`);
        });
        console.log();
    }

    private handleClear(): void {
        console.clear();
        console.log('üöÄ Welcome to {{ display_name }} interactive mode');
        console.log('   Type "help" for commands, "exit" to quit');
        if (hasTypeScriptCompiler) {
            console.log('   Enhanced TypeScript features are available');
        }
        console.log();
    }

    private handleTypes(args: string[]): void {
        if (!hasTypeScriptCompiler || !this.typeChecker) {
            console.log('‚ùå TypeScript compiler not available for type information');
            return;
        }

        if (args.length > 0) {
            const typeName = args[0];
            const typeInfo = this.typeChecker.getTypeInfo(typeName);
            if (typeInfo) {
                console.log(`\nüè∑Ô∏è  Type: ${typeName}`);
                console.log(`   ${typeInfo}`);
            } else {
                console.error(`‚ùå Type '${typeName}' not found`);
            }
        } else {
            console.log('\nüè∑Ô∏è  Available types:');
            const types = this.typeChecker.getAvailableTypes();
            types.forEach(type => console.log(`   ‚Ä¢ ${type}`));
        }
        console.log();
    }

    private async handleEval(args: string[]): Promise<void> {
        if (args.length === 0) {
            console.error('‚ùå Please provide an expression to evaluate');
            return;
        }

        const expression = args.join(' ');
        
        if (hasTypeScriptCompiler && this.typeChecker) {
            const result = await this.typeChecker.evaluateExpression(expression);
            
            if (result.success) {
                console.log(`‚úÖ Result: ${JSON.stringify(result.result, null, 2)}`);
                if (result.type) {
                    console.log(`üè∑Ô∏è  Type: ${result.type}`);
                }
            } else {
                console.error(`‚ùå Evaluation failed: ${result.error}`);
                if (result.suggestions) {
                    console.log('üí° Suggestions:');
                    result.suggestions.forEach(suggestion => console.log(`   ‚Ä¢ ${suggestion}`));
                }
            }
        } else {
            // Fallback evaluation without type checking
            try {
                const result = eval(expression);
                console.log(`‚úÖ Result: ${JSON.stringify(result, null, 2)}`);
                console.log(`üè∑Ô∏è  Type: ${typeof result}`);
            } catch (error) {
                console.error(`‚ùå Evaluation failed: ${(error as Error).message}`);
            }
        }
    }

    // CLI command handlers
    {% for command_name, command in cli.commands.items() %}
    
    private async handle{{ command_name | replace("-", "") | title }}(args: string[]): Promise<void> {
        const hookName = 'on{{ command_name | replace("-", "") | title }}' as keyof HookRegistry;
        const hook = hooks[hookName];
        
        if (typeof hook === 'function') {
            try {
                // Parse arguments with type validation
                const parsedContext = await this.parseCommandContext('{{ command_name }}', args);
                await (hook as Function)(parsedContext);
            } catch (error) {
                console.error(`‚ùå Error in ${hookName}:`, (error as Error).message);
                
                // Enhanced error handling
                if (hasTypeScriptCompiler && this.typeChecker) {
                    const suggestions = this.typeChecker.getSuggestions(error as Error, '{{ command_name }}', args);
                    if (suggestions.length > 0) {
                        console.log('üí° Suggestions:');
                        suggestions.forEach(suggestion => console.log(`   ‚Ä¢ ${suggestion}`));
                    }
                }
            }
        } else {
            console.error(`‚ùå Hook function '${hookName}' not implemented`);
        }
    }
    {% endfor %}

    private async parseCommandContext(commandName: string, args: string[]): Promise<CommandContext> {
        // Enhanced context parsing with type safety
        return {
            commandName,
            args: this.parseArgumentsToObject(commandName, args),
            options: this.parseOptionsToObject(commandName, args),
            globalOptions: {}
        };
    }

    private parseArgumentsToObject(commandName: string, args: string[]): Record<string, unknown> {
        // Parse positional arguments based on command definition
        const command = this.commands.get(commandName);
        const result: Record<string, unknown> = {};
        
        if (command?.argTypes) {
            command.argTypes.forEach((type, index) => {
                if (index < args.length && !args[index].startsWith('-')) {
                    const value = this.convertArgumentValue(args[index], type);
                    result[`arg${index}`] = value;
                }
            });
        }
        
        return result;
    }

    private parseOptionsToObject(commandName: string, args: string[]): Record<string, unknown> {
        // Parse options from command line
        const result: Record<string, unknown> = {};
        
        for (let i = 0; i < args.length; i++) {
            const arg = args[i];
            if (arg.startsWith('--')) {
                const optionName = arg.slice(2);
                const nextArg = i + 1 < args.length ? args[i + 1] : null;
                
                if (nextArg && !nextArg.startsWith('-')) {
                    result[optionName] = nextArg;
                    i++; // Skip next argument as it's the value
                } else {
                    result[optionName] = true; // Boolean flag
                }
            } else if (arg.startsWith('-') && arg.length === 2) {
                const shortOption = arg.slice(1);
                const nextArg = i + 1 < args.length ? args[i + 1] : null;
                
                if (nextArg && !nextArg.startsWith('-')) {
                    result[shortOption] = nextArg;
                    i++; // Skip next argument as it's the value
                } else {
                    result[shortOption] = true; // Boolean flag
                }
            }
        }
        
        return result;
    }

    private convertArgumentValue(value: string, type: string): unknown {
        switch (type) {
            case 'number':
                const num = Number(value);
                return isNaN(num) ? value : num;
            case 'boolean':
                return value.toLowerCase() === 'true';
            case 'string':
            default:
                return value;
        }
    }
}

// Enhanced completion provider implementation
class EnhancedCompletionProvider implements CompletionProvider {
    private readonly commandNames = [
        {% for command in cli.commands.items() -%}
        '{{ command_name }}',
        {% endfor -%}
        'help', 'exit', 'quit', 'history', 'clear', 'types', 'eval'
    ];

    getCommandCompletions(text: string): string[] {
        return this.commandNames.filter(cmd => cmd.startsWith(text));
    }

    getOptionCompletions(command: string, text: string): string[] {
        // Command-specific option completions
        const options: string[] = [];
        
        {% for command_name, command in cli.commands.items() %}
        if (command === '{{ command_name }}') {
            {% for option in command.options -%}
            options.push('--{{ option.name }}');
            {% if option.short -%}
            options.push('-{{ option.short }}');
            {% endif -%}
            {% endfor %}
        }
        {% endfor %}

        return options.filter(opt => opt.startsWith(text));
    }

    getValueCompletions(command: string, option: string, text: string): string[] {
        // Option value completions based on type
        {% for command_name, command in cli.commands.items() %}
        if (command === '{{ command_name }}') {
            {% for option in command.options -%}
            {% if option.choices -%}
            if (option === '--{{ option.name }}' || option === '-{{ option.short | default('') }}') {
                return [{% for choice in option.choices %}'{{ choice }}'{% if not loop.last %}, {% endif %}{% endfor %}]
                    .filter(val => val.startsWith(text));
            }
            {% endif -%}
            {% endfor %}
        }
        {% endfor %}

        return [];
    }

    getTypeCompletions(type: string, text: string): string[] {
        const typeValues: Record<string, string[]> = {
            'boolean': ['true', 'false'],
            'string': [],
            'number': []
        };

        return typeValues[type]?.filter(val => val.startsWith(text)) || [];
    }
}

// TypeScript type checker (when compiler is available)
class TypeChecker {
    private readonly program: any;
    private readonly typeChecker: any;

    constructor() {
        if (hasTypeScriptCompiler) {
            // Initialize TypeScript program for type checking
            const configPath = ts.findConfigFile('./', ts.sys.fileExists, 'tsconfig.json');
            const config = configPath ? ts.readConfigFile(configPath, ts.sys.readFile) : null;
            
            this.program = ts.createProgram([], config?.config || {});
            this.typeChecker = this.program.getTypeChecker();
        }
    }

    validateArguments(args: string[], expectedTypes: readonly string[]): { isValid: boolean; errors: string[] } {
        const errors: string[] = [];
        
        for (let i = 0; i < expectedTypes.length; i++) {
            const arg = args[i];
            const expectedType = expectedTypes[i];
            
            if (!arg) {
                errors.push(`Missing required argument ${i + 1} (expected ${expectedType})`);
                continue;
            }
            
            if (!this.isValueOfType(arg, expectedType)) {
                errors.push(`Argument ${i + 1} should be ${expectedType}, got: ${arg}`);
            }
        }
        
        return {
            isValid: errors.length === 0,
            errors
        };
    }

    private isValueOfType(value: string, type: string): boolean {
        switch (type) {
            case 'string':
                return true; // All values can be strings
            case 'number':
                return !isNaN(Number(value));
            case 'boolean':
                return ['true', 'false', '1', '0', 'yes', 'no'].includes(value.toLowerCase());
            default:
                return true;
        }
    }

    async evaluateExpression(expression: string): Promise<EvaluationResult> {
        try {
            // Type-safe expression evaluation
            const result = eval(expression);
            return {
                success: true,
                result,
                type: typeof result
            };
        } catch (error) {
            return {
                success: false,
                error: (error as Error).message,
                suggestions: this.getExpressionSuggestions(expression, error as Error)
            };
        }
    }

    getSuggestions(error: Error, commandName: string, args: string[]): string[] {
        const suggestions: string[] = [];
        const errorMessage = error.message.toLowerCase();
        
        if (errorMessage.includes('type')) {
            suggestions.push('Check the expected types for this command using "types"');
        }
        
        if (errorMessage.includes('undefined')) {
            suggestions.push('Ensure all required arguments are provided');
        }
        
        if (errorMessage.includes('not found') || errorMessage.includes('not implemented')) {
            suggestions.push(`Verify that the hook for '${commandName}' is implemented`);
        }
        
        return suggestions;
    }

    private getExpressionSuggestions(expression: string, error: Error): string[] {
        const suggestions: string[] = [];
        const errorMessage = error.message.toLowerCase();
        
        if (errorMessage.includes('syntax')) {
            suggestions.push('Check for syntax errors in the expression');
            suggestions.push('Use proper TypeScript syntax');
        }
        
        if (errorMessage.includes('undefined')) {
            suggestions.push('Check if variables are properly defined');
            suggestions.push('Use optional chaining (?.) for potentially undefined values');
        }
        
        return suggestions;
    }

    getTypeInfo(typeName: string): string | null {
        // Return type information (simplified implementation)
        const builtinTypes: Record<string, string> = {
            'string': 'Primitive string type',
            'number': 'Primitive number type (integers and floats)',
            'boolean': 'Primitive boolean type (true/false)',
            'object': 'Generic object type',
            'Array': 'Array type with elements',
            'Promise': 'Asynchronous operation result'
        };
        
        return builtinTypes[typeName] || null;
    }

    getAvailableTypes(): string[] {
        return [
            'string', 'number', 'boolean', 'object', 'Array', 'Promise',
            'unknown', 'any', 'void', 'null', 'undefined'
        ];
    }
}

// Main entry point
export function runInteractive(): void {
    const interactive = new {{ display_name | replace("-", "") | replace(" ", "") | title }}Interactive();
    interactive.start();
}

// Handle direct execution
if (require.main === module) {
    runInteractive();
}