/**
 * TypeScript error type definitions for {{ display_name }}
 * Provides strongly-typed error handling
 */

// Exit codes enum
export enum ExitCode {
  SUCCESS = 0,
  GENERAL_ERROR = 1,
  MISUSE = 2,
  CONFIG_ERROR = 3,
  HOOK_ERROR = 4,
  PLUGIN_ERROR = 5,
  DEPENDENCY_ERROR = 6,
  NETWORK_ERROR = 7,
  CANCELLED = 130
}

// Error severity levels
export enum ErrorSeverity {
  LOW = 'low',
  MEDIUM = 'medium',
  HIGH = 'high',
  CRITICAL = 'critical'
}

// Base error interface
export interface CLIErrorData {
  readonly name: string;
  readonly message: string;
  readonly code: ExitCode;
  readonly severity: ErrorSeverity;
  readonly timestamp: string;
  readonly cause?: Error;
  readonly context?: Record<string, unknown>;
}

// Result type for error handling
export type Result<T, E = CLIError> = {
  success: true;
  data: T;
} | {
  success: false;
  error: E;
};

// Error handler function types
export type ErrorHandler<T = void> = (error: CLIError) => T;
export type AsyncErrorHandler<T = void> = (error: CLIError) => Promise<T>;

// Error recovery strategy
export interface ErrorRecoveryStrategy<T = unknown> {
  canRecover(error: CLIError): boolean;
  recover(error: CLIError): Promise<T>;
  maxRetries?: number;
}

// Global error handler options
export interface GlobalErrorHandlerOptions {
  showStack?: boolean;
  colorize?: boolean;
  exitOnError?: boolean;
  logLevel?: 'debug' | 'info' | 'warn' | 'error';
}

// Error context for debugging
export interface ErrorContext {
  command?: string;
  subcommand?: string;
  args?: string[];
  options?: Record<string, unknown>;
  workingDirectory?: string;
  environment?: Record<string, string>;
}

// Validation error details
export interface ValidationErrorDetail {
  field: string;
  value: unknown;
  constraint: string;
  message: string;
}

// Dependency information
export interface DependencyInfo {
  name: string;
  version?: string;
  required: boolean;
  installCommand?: string;
}

// Error classes
export declare class CLIError extends Error {
  readonly code: ExitCode;
  readonly severity: ErrorSeverity;
  readonly timestamp: string;
  readonly cause?: Error;
  readonly context?: ErrorContext;

  constructor(
    message: string,
    code?: ExitCode,
    severity?: ErrorSeverity,
    cause?: Error,
    context?: ErrorContext
  );

  toJSON(): CLIErrorData;
  withContext(context: ErrorContext): CLIError;
  withCause(cause: Error): CLIError;
}

export declare class ConfigError extends CLIError {
  readonly configPath?: string;
  readonly configSection?: string;

  constructor(
    message: string,
    configPath?: string,
    configSection?: string,
    cause?: Error
  );
}

export declare class HookError extends CLIError {
  readonly hookName: string;
  readonly hookPhase?: string;

  constructor(
    hookName: string,
    message: string,
    hookPhase?: string,
    cause?: Error
  );
}

export declare class PluginError extends CLIError {
  readonly pluginName: string;
  readonly pluginVersion?: string;

  constructor(
    pluginName: string,
    message: string,
    pluginVersion?: string,
    cause?: Error
  );
}

export declare class ValidationError extends CLIError {
  readonly errors: ValidationErrorDetail[];

  constructor(errors: ValidationErrorDetail[], cause?: Error);
  constructor(field: string, value: unknown, message: string, cause?: Error);
}

export declare class DependencyError extends CLIError {
  readonly dependencies: DependencyInfo[];

  constructor(dependencies: DependencyInfo[], cause?: Error);
  constructor(dependency: string, message: string, cause?: Error);
}

export declare class NetworkError extends CLIError {
  readonly url?: string;
  readonly statusCode?: number;

  constructor(
    message: string,
    url?: string,
    statusCode?: number,
    cause?: Error
  );
}

export declare class CancelledError extends CLIError {
  constructor(message?: string);
}

export declare class SystemError extends CLIError {
  readonly system?: string;
  readonly command?: string;

  constructor(
    message: string,
    system?: string,
    command?: string,
    cause?: Error
  );
}

export declare class CommandError extends CLIError {
  readonly commandName: string;
  readonly exitCode?: number;

  constructor(
    commandName: string,
    message: string,
    exitCode?: number,
    cause?: Error
  );
}

export declare class FileSystemError extends CLIError {
  readonly filePath: string;
  readonly operation: 'read' | 'write' | 'delete' | 'create' | 'access' | 'stat';

  constructor(
    filePath: string,
    operation: 'read' | 'write' | 'delete' | 'create' | 'access' | 'stat',
    message: string,
    cause?: Error
  );
}

// Additional Result type variants
export type Success<T> = {
  success: true;
  data: T;
};

export type Failure<E> = {
  success: false;
  error: E;
};

// Error code enum
export enum CLIErrorCode {
  // General errors
  UNKNOWN = 'UNKNOWN',
  INVALID_INPUT = 'INVALID_INPUT',
  MISSING_DEPENDENCY = 'MISSING_DEPENDENCY',
  
  // Command errors
  COMMAND_NOT_FOUND = 'COMMAND_NOT_FOUND',
  COMMAND_FAILED = 'COMMAND_FAILED',
  INVALID_COMMAND = 'INVALID_COMMAND',
  
  // File system errors
  FILE_NOT_FOUND = 'FILE_NOT_FOUND',
  FILE_ACCESS_DENIED = 'FILE_ACCESS_DENIED',
  FILE_WRITE_ERROR = 'FILE_WRITE_ERROR',
  
  // System errors
  SYSTEM_ERROR = 'SYSTEM_ERROR',
  PERMISSION_DENIED = 'PERMISSION_DENIED',
  NETWORK_ERROR = 'NETWORK_ERROR',
  
  // Configuration errors
  CONFIG_NOT_FOUND = 'CONFIG_NOT_FOUND',
  CONFIG_INVALID = 'CONFIG_INVALID',
  CONFIG_PARSE_ERROR = 'CONFIG_PARSE_ERROR',
  
  // Hook errors
  HOOK_NOT_FOUND = 'HOOK_NOT_FOUND',
  HOOK_EXECUTION_ERROR = 'HOOK_EXECUTION_ERROR',
  
  // Plugin errors
  PLUGIN_NOT_FOUND = 'PLUGIN_NOT_FOUND',
  PLUGIN_LOAD_ERROR = 'PLUGIN_LOAD_ERROR',
  PLUGIN_EXECUTION_ERROR = 'PLUGIN_EXECUTION_ERROR',
  
  // Validation errors
  VALIDATION_ERROR = 'VALIDATION_ERROR',
  TYPE_ERROR = 'TYPE_ERROR'
}

// Error factory types
export type ErrorFactory<T extends CLIError> = (
  message: string,
  context?: {
    cause?: Error;
    metadata?: Record<string, unknown>;
  }
) => T;

// Error management interfaces
export interface ErrorManager {
  handleError(error: CLIError, context?: ErrorContext): void;
  formatError(error: CLIError): string;
  shouldExit(error: CLIError): boolean;
}

export interface ErrorFormatter {
  format(error: CLIError): string;
  formatStack(error: CLIError): string;
  formatSuggestions(error: CLIError): string[];
}

export interface ErrorRecovery<T = unknown> {
  canRecover(error: CLIError): boolean;
  recover(error: CLIError): Promise<T>;
}

// Base error class alias
export type BaseCLIError = CLIError;

// Utility functions
export declare function handleError(
  error: CLIError,
  options?: { exit?: boolean; log?: boolean }
): CLIError;

export declare function asyncErrorHandler<T extends (...args: any[]) => Promise<any>>(
  fn: T
): T;

export declare function errorHandler<T extends (...args: any[]) => any>(
  fn: T
): T;

export declare function setupGlobalErrorHandlers(
  options?: GlobalErrorHandlerOptions
): {
  handleError: ErrorHandler<CLIError>;
  asyncErrorHandler: typeof asyncErrorHandler;
  errorHandler: typeof errorHandler;
};

export declare function createResult<T>(data: T): Result<T, never>;
export declare function createError<E extends CLIError>(error: E): Result<never, E>;

export declare function isResult<T, E extends CLIError>(
  value: unknown
): value is Result<T, E>;

export declare function unwrapResult<T, E extends CLIError>(
  result: Result<T, E>
): T;

export declare function mapResult<T, U, E extends CLIError>(
  result: Result<T, E>,
  mapper: (data: T) => U
): Result<U, E>;

export declare function chainResult<T, U, E extends CLIError>(
  result: Result<T, E>,
  mapper: (data: T) => Result<U, E>
): Result<U, E>;

export declare function createErrorWithSuggestions(
  message: string,
  suggestions: string[]
): CLIError;

export declare function validateDependencies(
  dependencies: (string | DependencyInfo)[]
): Promise<void>;

export declare function retryOperation<T>(
  operation: () => Promise<T>,
  options?: {
    maxRetries?: number;
    baseDelay?: number;
    maxDelay?: number;
    backoffFactor?: number;
    strategy?: ErrorRecoveryStrategy<T>;
  }
): Promise<T>;

// Error creator functions
export declare function createSystemError(
  message: string,
  context?: {
    cause?: Error;
    metadata?: Record<string, unknown>;
  }
): SystemError;

export declare function createCommandError(
  message: string,
  context?: {
    cause?: Error;
    metadata?: Record<string, unknown>;
  }
): CommandError;

export declare function createFileSystemError(
  message: string,
  context?: {
    cause?: Error;
    metadata?: Record<string, unknown>;
  }
): FileSystemError;

export declare function createConfigError(
  message: string,
  context?: {
    cause?: Error;
    metadata?: Record<string, unknown>;
  }
): ConfigError;

export declare function createHookError(
  message: string,
  context?: {
    cause?: Error;
    metadata?: Record<string, unknown>;
  }
): HookError;

export declare function createPluginError(
  message: string,
  context?: {
    cause?: Error;
    metadata?: Record<string, unknown>;
  }
): PluginError;

export declare function createValidationError(
  message: string,
  context?: {
    cause?: Error;
    metadata?: Record<string, unknown>;
  }
): ValidationError;

export declare function createNetworkError(
  message: string,
  context?: {
    cause?: Error;
    metadata?: Record<string, unknown>;
  }
): NetworkError;

// Result pattern utility functions
export declare function success<T>(data: T, warnings?: readonly string[]): Success<T>;
export declare function failure<E extends CLIError>(error: E, recoverable?: boolean): Failure<E>;
export declare function isSuccess<T, E extends CLIError>(result: Result<T, E>): result is Success<T>;
export declare function isFailure<T, E extends CLIError>(result: Result<T, E>): result is Failure<E>;

// Result pattern async utilities
export declare function asyncResult<T, E extends CLIError>(
  operation: () => Promise<T>,
  errorHandler: (error: unknown) => E
): Promise<Result<T, E>>;

export declare function syncResult<T, E extends CLIError>(
  operation: () => T,
  errorHandler: (error: unknown) => E
): Result<T, E>;