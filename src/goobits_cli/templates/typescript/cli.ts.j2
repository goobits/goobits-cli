#!/usr/bin/env node
/**
 * ‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
 * ‚ïë                        AUTO-GENERATED FILE                               ‚ïë
 * ‚ïë                                                                           ‚ïë
 * ‚ïë  Generated by: goobits-cli v{{ version or '3.0.0' }}                     ‚ïë
 * ‚ïë  Generated from: {{ file_name }}                                         ‚ïë
 * ‚ïë  Generated on: {% raw %}{{ new Date().toISOString() }}{% endraw %}       ‚ïë
 * ‚ïë                                                                           ‚ïë
 * ‚ïë  ‚ö†Ô∏è  DO NOT EDIT THIS FILE MANUALLY                                      ‚ïë
 * ‚ïë  Changes will be overwritten on next generation                          ‚ïë
 * ‚ïë                                                                           ‚ïë
 * ‚ïë  To modify this CLI, edit the source configuration file:                 ‚ïë
 * ‚ïë  {{ file_name }}                                                         ‚ïë
 * ‚ïë                                                                           ‚ïë
 * ‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù
 * 
 * {{ display_name }} CLI - TypeScript Implementation
 */

import { Command, Argument } from 'commander';
import * as path from 'path';
import * as fs from 'fs';
import { execSync } from 'child_process';

// Enhanced Error Classes
class CLIError extends Error {
    public exitCode: number;
    public suggestion: string | null;

    constructor(message: string, exitCode: number = 1, suggestion: string | null = null) {
        super(message);
        this.name = 'CLIError';
        this.exitCode = exitCode;
        this.suggestion = suggestion;
    }
}

class ConfigError extends CLIError {
    constructor(message: string, suggestion: string | null = null) {
        super(message, 2, suggestion);
        this.name = 'ConfigError';
    }
}

class HookError extends CLIError {
    public hookName: string | null;

    constructor(message: string, hookName: string | null = null) {
        const suggestion = hookName ? `Check the '${hookName}' function in your hooks file` : null;
        super(message, 3, suggestion);
        this.name = 'HookError';
        this.hookName = hookName;
    }
}

class DependencyError extends CLIError {
    public dependency: string;
    public installCommand: string | null;

    constructor(message: string, dependency: string, installCommand: string | null = null) {
        const suggestion = installCommand ? `Install with: ${installCommand}` : `Install the '${dependency}' package`;
        super(message, 4, suggestion);
        this.name = 'DependencyError';
        this.dependency = dependency;
        this.installCommand = installCommand;
    }
}

// Interface definitions
interface GlobalOptions {
    {% if cli.options %}
    {% for option in cli.options %}
    {{ option.name|replace('-', '') }}: {% if option.type == 'flag' %}boolean{% elif option.type == 'int' %}number{% elif option.type == 'float' %}number{% else %}string{% endif %}{% if not option.required %} | undefined{% endif %};
    {% endfor %}
    {% endif %}
}

interface CommandArgs {
    [key: string]: any;
}

interface HookFunction {
    (args: CommandArgs): Promise<any> | any;
}

interface ManagedCommand {
    execute(args: CommandArgs): Promise<any> | any;
}

interface AppHooks {
    [key: string]: HookFunction | ManagedCommand;
}

// Global error handler
function handleCLIError(error: Error, verbose: boolean = false): number {
    if (error instanceof CLIError) {
        console.error(`‚ùå Error: ${error.message}`);
        if (error.suggestion) {
            console.error(`üí° Suggestion: ${error.suggestion}`);
        }
        if (verbose) {
            console.error('\nüîç Verbose traceback:');
            console.error(error.stack);
        }
        return error.exitCode;
    } else {
        // Unexpected errors
        console.error(`‚ùå Unexpected error: ${error.message}`);
        console.error('üí° This may be a bug. Please report it with the following details:');
        if (verbose) {
            console.error(error.stack);
        } else {
            console.error(`   Error type: ${error.constructor.name}`);
            console.error(`   Error message: ${error.message}`);
            console.error('   Run with --verbose for full traceback');
        }
        return 1;
    }
}

// Helper module loading with error handling
let configManager: any, progressHelper: any, promptsHelper: any, completionHelper: any;
let HAS_CONFIG_MANAGER = false;
let HAS_PROGRESS_HELPER = false;
let HAS_PROMPTS_HELPER = false;
let HAS_COMPLETION_HELPER = false;

try {
    configManager = require('./lib/config');
    HAS_CONFIG_MANAGER = true;
} catch (e) {
    if (process.env.DEBUG) console.debug('Config manager not available:', (e as Error).message);
}

try {
    progressHelper = require('./lib/progress');
    HAS_PROGRESS_HELPER = true;
} catch (e) {
    if (process.env.DEBUG) console.debug('Progress helper not available:', (e as Error).message);
}

try {
    promptsHelper = require('./lib/prompts');
    HAS_PROMPTS_HELPER = true;
} catch (e) {
    if (process.env.DEBUG) console.debug('Prompts helper not available:', (e as Error).message);
}

try {
    completionHelper = require('./lib/completion');
    HAS_COMPLETION_HELPER = true;
} catch (e) {
    if (process.env.DEBUG) console.debug('Completion helper not available:', (e as Error).message);
}

// Initialize global helpers
let config: any = null;
let progress: any = null;
let prompts: any = null;
let completion: any = null;

if (HAS_CONFIG_MANAGER) {
    try {
        config = configManager.getConfig();
    } catch (e) {
        console.warn(`Failed to initialize config manager: ${(e as Error).message}`);
        HAS_CONFIG_MANAGER = false;
    }
}

if (HAS_PROGRESS_HELPER) {
    try {
        progress = progressHelper.getProgressHelper();
    } catch (e) {
        console.warn(`Failed to initialize progress helper: ${(e as Error).message}`);
        HAS_PROGRESS_HELPER = false;
    }
}

if (HAS_PROMPTS_HELPER) {
    try {
        prompts = promptsHelper.getPromptsHelper();
    } catch (e) {
        console.warn(`Failed to initialize prompts helper: ${(e as Error).message}`);
        HAS_PROMPTS_HELPER = false;
    }
}

if (HAS_COMPLETION_HELPER) {
    try {
        completion = completionHelper.getCompletionHelper();
    } catch (e) {
        console.warn(`Failed to initialize completion helper: ${(e as Error).message}`);
        HAS_COMPLETION_HELPER = false;
    }
}

// Load hooks module
let appHooks: AppHooks | null = null;
{% if hooks_path %}
// Using configured hooks path: {{ hooks_path }}
try {
    const hooksPath = path.resolve(__dirname, '{{ hooks_path }}');
    if (fs.existsSync(hooksPath)) {
        appHooks = require(hooksPath);
    }
} catch (e) {
    // No hooks module found
}
{% else %}
// No hooks path configured, try default locations
try {
    // Try relative to script location
    const possiblePaths = [
        path.join(__dirname, '../hooks.ts'),
        path.join(__dirname, '../hooks.js'),
        path.join(__dirname, '../src/hooks.ts'),
        path.join(__dirname, '../src/hooks.js'),
        path.join(process.cwd(), 'hooks.ts'),
        path.join(process.cwd(), 'hooks.js'),
        path.join(process.cwd(), 'src/hooks.ts'),
        path.join(process.cwd(), 'src/hooks.js')
    ];
    
    for (const hookPath of possiblePaths) {
        if (fs.existsSync(hookPath)) {
            appHooks = require(hookPath);
            break;
        }
    }
} catch (e) {
    // No hooks module found
}
{% endif %}

// Get version function
function getVersion(): string {
    try {
        // Try package.json first
        const packagePath = path.join(__dirname, '../package.json');
        if (fs.existsSync(packagePath)) {
            const pkg = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
            return pkg.version;
        }
    } catch (e) {
        // Ignore
    }
    
    // Fallback to configured version
    return '{{ version | default("1.0.0") }}';
}

// Built-in upgrade command
{% if cli %}
async function builtinUpgradeCommand(checkOnly: boolean = false, pre: boolean = false, version: string | null = null, dryRun: boolean = false): Promise<void> {
    if (checkOnly) {
        console.log(`Checking for updates to {{ display_name }}...`);
        console.log('Update check not yet implemented. Run without --check to upgrade.');
        return;
    }

    if (dryRun) {
        console.log('Dry run - would execute: npm update -g {{ package_name }}');
        return;
    }

    // Find the setup.sh script
    let setupScript: string | null = null;
    const searchPaths = [
        path.join(__dirname, 'setup.sh'),
        path.join(__dirname, '../setup.sh'),
        path.join(process.env.HOME || process.env.USERPROFILE || '', '.local', 'share', '{{ installation.npm_name | default(package_name) }}', 'setup.sh')
    ];
    
    for (const scriptPath of searchPaths) {
        if (fs.existsSync(scriptPath)) {
            setupScript = scriptPath;
            break;
        }
    }
    
    if (!setupScript) {
        // Fallback to basic upgrade
        console.log(`Enhanced setup script not found. Using basic upgrade for {{ display_name }}...`);
        
        const packageName = '{{ package_name }}';
        const npmName = '{% if installation and installation.npm_name %}{{ installation.npm_name }}{% else %}{{ package_name }}{% endif %}';
        
        try {
            const cmd = process.platform === 'win32' ? 'npm.cmd' : 'npm';
            execSync(`${cmd} update -g ${npmName}`, { stdio: 'inherit' });
            console.log(`‚úÖ {{ display_name }} upgraded successfully!`);
            console.log(`Run '{{ command_name }} --version' to verify the new version.`);
        } catch (e) {
            console.error(`‚ùå Upgrade failed: ${(e as Error).message}`);
            process.exit(1);
        }
        return;
    }

    // Use the enhanced setup.sh script
    try {
        execSync(`${setupScript} upgrade`, { stdio: 'inherit' });
    } catch (e: any) {
        process.exit(e.status || 1);
    }
}
{% endif %}

// Plugin loading
function loadPlugins(program: Command): void {
    const pluginDirs = [
        path.join(process.env.HOME || process.env.USERPROFILE || '', '.config', 'goobits', '{{ cli.name }}', 'plugins'),
        path.join(__dirname, 'plugins')
    ];
    
    for (const pluginDir of pluginDirs) {
        if (!fs.existsSync(pluginDir)) continue;
        
        const files = fs.readdirSync(pluginDir);
        for (const file of files) {
            if (!file.endsWith('.js') && !file.endsWith('.ts')) continue;
            if (file.startsWith('_')) continue;
            if (['loader.js', 'loader.ts', 'index.js', 'index.ts'].includes(file)) continue;
            
            const pluginName = path.basename(file, path.extname(file));
            
            try {
                const pluginPath = path.join(pluginDir, file);
                const plugin = require(pluginPath);
                
                if (typeof plugin.registerPlugin === 'function') {
                    plugin.registerPlugin(program);
                    console.error(`Loaded plugin: ${pluginName}`);
                }
            } catch (e) {
                console.error(`Failed to load plugin ${pluginName}: ${(e as Error).message}`);
            }
        }
    }
}

// Create the main program
const program = new Command();

// Configure program
program
    .name('{{ cli.name }}')
    .version(getVersion())
    .description(`{% if cli.icon %}{{ cli.icon }} {% endif %}{{ cli.name }}{% if cli.display_version %} v${getVersion()}{% endif %} - {{ cli.tagline }}`)
    .helpOption('-h, --help', 'Display help for command')
    .configureHelp({
        sortSubcommands: true,
        sortOptions: true
    });

// Add custom help formatting
program.addHelpText('after', `
{% if cli.description %}
{{ cli.description }}
{% endif %}

{% if cli.header_sections %}
{% for section in cli.header_sections %}
{{ section.title }}:
{%- set aligned_items = section.items | align_header_items %}
{% for item in aligned_items %}
{% if item.style == 'example' %}
  {{ item.item_aligned }} # {{ item.desc }}
{% elif item.style == 'command' %}
  {{ item.item_aligned }}  {{ item.desc }}
{% elif item.style == 'setup' %}
  {{ item.item }}: {{ item.desc }}
{%- endif %}
{%- endfor %}

{% endfor %}
{% endif %}
{% if cli.footer_note %}
{{ cli.footer_note }}
{% endif %}`);

// Global options
const globalOptions: Partial<GlobalOptions> = {};
{% if cli.options %}
{% for option in cli.options %}
program.option(
    '{%- if option.short %}-{{ option.short }}, {% endif %}--{{ option.name }}{% if option.type != 'flag' %} <value>{% endif %}',
    '{{ option.desc }}'
    {%- if option.default is not none %},
    {% if option.default is sameas true %}true{% elif option.default is sameas false %}false{% elif option.default is number %}{{ option.default }}{% else %}'{{ option.default }}'{% endif %}
    {%- endif %}
);
{% endfor %}
{% endif %}

// Built-in upgrade command
{% if cli and (cli.enable_upgrade_command is not defined or cli.enable_upgrade_command) %}
program
    .command('upgrade')
    .description('Upgrade {{ display_name }} to the latest version')
    .option('--check', 'Check for updates without installing')
    .option('--version <version>', 'Install specific version')
    .option('--pre', 'Include pre-release versions')
    .option('--dry-run', 'Show what would be done without doing it')
    .action(async (options: { check?: boolean; version?: string; pre?: boolean; dryRun?: boolean }) => {
        await builtinUpgradeCommand(options.check, options.pre, options.version, options.dryRun);
    });
{% endif %}

// Commands from configuration
{% for cmd_name, cmd_data in cli.commands.items() %}
{% if not cmd_data.subcommands %}
// Command: {{ cmd_name }}
interface {{ cmd_name[0]|upper }}{{ cmd_name[1:] }}Options {
    {% for opt in (cmd_data.options or []) %}
    {{ opt.name|replace('-', '') }}: {% if opt.type == 'flag' %}boolean{% elif opt.type == 'int' %}number{% elif opt.type == 'float' %}number{% else %}string{% endif %}{% if not opt.required %} | undefined{% endif %};
    {% endfor %}
    verbose?: boolean;
}

const {{ cmd_name }}Cmd = program
    .command('{{ cmd_name }}')
    .description('{% if cmd_data.icon %}{{ cmd_data.icon }} {% endif %}{{ cmd_data.desc }}')
    {% for arg in (cmd_data.args or []) %}
    {% if arg.choices %}
    .addArgument(new Argument('{% if arg.required is defined and not arg.required %}[{{ arg.name }}]{% else %}<{{ arg.name }}>{% endif %}', '{{ arg.desc | default("") }}').choices({{ arg.choices | tojson }}))
    {% else %}
    .argument('{% if arg.required is defined and not arg.required %}[{{ arg.name }}]{% else %}<{{ arg.name }}>{% endif %}', '{{ arg.desc | default("") }}')
    {% endif %}
    {% endfor %}
    {% for opt in (cmd_data.options or []) %}
    .option('{%- if opt.short %}-{{ opt.short }}, {% endif %}--{{ opt.name }}{% if opt.type != 'flag' %} <value>{% endif %}', '{{ opt.desc }}'
    {%- if opt.default is not none %}, {% if opt.default is sameas true %}true{% elif opt.default is sameas false %}false{% elif opt.default is number %}{{ opt.default }}{% else %}'{{ opt.default }}'{% endif %}{% endif %})
    {% endfor %}
    .action(async ({% if cmd_data.args %}{{ cmd_data.args|map(attribute='name')|join(': string, ') }}{% if cmd_data.args %}: string, {% endif %}{% endif %}options: {{ cmd_name[0]|upper }}{{ cmd_name[1:] }}Options, command: Command) => {
        try {
            {% if cmd_data.lifecycle == 'managed' %}
            // Managed command - expect an instance
            const commandInstanceName = '{{ cmd_name }}Command';
            if (appHooks && appHooks[commandInstanceName]) {
                const commandInstance = appHooks[commandInstanceName] as ManagedCommand;
                const kwargs: CommandArgs = {
                    commandName: '{{ cmd_name }}',
                    {% if cmd_data.args %}
                    {% for arg in cmd_data.args %}
                    {{ arg.name|lower|replace('-', '_') }}: {{ arg.name }},
                    {% endfor %}
                    {% endif %}
                    ...options,
                    // Add global options
                    {% if cli.options %}
                    {% for option in cli.options %}
                    {{ option.name|replace('-', '_') }}: (command.parent?.opts() as GlobalOptions)?.{{ option.name|replace('-', '') }},
                    {% endfor %}
                    {% endif %}
                };
                
                if (typeof commandInstance.execute === 'function') {
                    await commandInstance.execute(kwargs);
                } else {
                    throw new Error(`Managed command '{{ cmd_name }}' must have an execute() method`);
                }
            } else {
                throw new Error(`Managed command '{{ cmd_name }}' requires '{{ cmd_name }}Command' export in hooks file`);
            }
            {% else %}
            // Standard command - use hook pattern
            const hookName = 'on{{ cmd_name[0]|upper }}{{ cmd_name[1:] }}';
            if (appHooks && typeof appHooks[hookName] === 'function') {
                const kwargs: CommandArgs = {
                    commandName: '{{ cmd_name }}',
                    {% if cmd_data.args %}
                    {% for arg in cmd_data.args %}
                    {{ arg.name|lower|replace('-', '_') }}: {{ arg.name }},
                    {% endfor %}
                    {% endif %}
                    ...options,
                    // Add global options
                    {% if cli.options %}
                    {% for option in cli.options %}
                    {{ option.name|replace('-', '_') }}: (command.parent?.opts() as GlobalOptions)?.{{ option.name|replace('-', '') }},
                    {% endfor %}
                    {% endif %}
                };
                
                await (appHooks[hookName] as HookFunction)(kwargs);
            } else {
                // Default placeholder behavior
                console.log(`Executing {{ cmd_name }} command...`);
                {% if cmd_data.args %}
                {% for arg in cmd_data.args %}
                console.log(`  {{ arg.name }}: ${{ '${' }}{{ arg.name }}}`);  
                {% endfor %}
                {% endif %}
                {% if cmd_data.options %}
                {% for opt in cmd_data.options %}
                console.log(`  {{ opt.name }}: ${options.{{ opt.name|replace('-', '') }}}`);
                {% endfor %}
                {% endif %}
            }
            {% endif %}
        } catch (error) {
            const exitCode = handleCLIError(error as Error, options.verbose || false);
            process.exit(exitCode);
        }
    });
{% else %}
// Command group: {{ cmd_name }}
const {{ cmd_name }}Cmd = program
    .command('{{ cmd_name }}')
    .description('{% if cmd_data.icon %}{{ cmd_data.icon }} {% endif %}{{ cmd_data.desc }}');

{% for subcmd_name, subcmd_data in cmd_data.subcommands.items() %}
interface {{ cmd_name[0]|upper }}{{ cmd_name[1:] }}{{ subcmd_name[0]|upper }}{{ subcmd_name[1:] }}Options {
    {% for opt in (subcmd_data.options or []) %}
    {{ opt.name|replace('-', '') }}: {% if opt.type == 'flag' %}boolean{% elif opt.type == 'int' %}number{% elif opt.type == 'float' %}number{% else %}string{% endif %}{% if not opt.required %} | undefined{% endif %};
    {% endfor %}
    verbose?: boolean;
}

{{ cmd_name }}Cmd
    .command('{{ subcmd_name }}')
    .description('{% if subcmd_data.icon %}{{ subcmd_data.icon }} {% endif %}{{ subcmd_data.desc }}')
    {% for arg in (subcmd_data.args or []) %}
    {% if arg.choices %}
    .addArgument(new Argument('{% if arg.required is defined and not arg.required %}[{{ arg.name }}]{% else %}<{{ arg.name }}>{% endif %}', '{{ arg.desc | default("") }}').choices({{ arg.choices | tojson }}))
    {% else %}
    .argument('{% if arg.required is defined and not arg.required %}[{{ arg.name }}]{% else %}<{{ arg.name }}>{% endif %}', '{{ arg.desc | default("") }}')
    {% endif %}
    {% endfor %}
    {% for opt in (subcmd_data.options or []) %}
    .option('{%- if opt.short %}-{{ opt.short }}, {% endif %}--{{ opt.name }}{% if opt.type != 'flag' %} <value>{% endif %}', '{{ opt.desc }}'
    {%- if opt.default is not none %}, {% if opt.default is sameas true %}true{% elif opt.default is sameas false %}false{% elif opt.default is number %}{{ opt.default }}{% else %}'{{ opt.default }}'{% endif %}{% endif %})
    {% endfor %}
    .action(async ({% if subcmd_data.args %}{{ subcmd_data.args|map(attribute='name')|join(': string, ') }}{% if subcmd_data.args %}: string, {% endif %}{% endif %}options: {{ cmd_name[0]|upper }}{{ cmd_name[1:] }}{{ subcmd_name[0]|upper }}{{ subcmd_name[1:] }}Options, command: Command) => {
        try {
            const hookName = 'on{{ cmd_name[0]|upper }}{{ cmd_name[1:] }}{{ subcmd_name[0]|upper }}{{ subcmd_name[1:] }}';
            if (appHooks && typeof appHooks[hookName] === 'function') {
                const kwargs: CommandArgs = {
                    commandName: '{{ subcmd_name }}',
                    {% if subcmd_data.args %}
                    {% for arg in subcmd_data.args %}
                    {{ arg.name|lower|replace('-', '_') }}: {{ arg.name }},
                    {% endfor %}
                    {% endif %}
                    ...options,
                    // Add global options
                    {% if cli.options %}
                    {% for option in cli.options %}
                    {{ option.name|replace('-', '_') }}: (command.parent?.parent?.opts() as GlobalOptions)?.{{ option.name|replace('-', '') }},
                    {% endfor %}
                    {% endif %}
                };
                
                await (appHooks[hookName] as HookFunction)(kwargs);
            } else {
                // Default placeholder behavior
                console.log(`Executing {{ subcmd_name }} command...`);
                {% if subcmd_data.args %}
                {% for arg in subcmd_data.args %}
                console.log(`  {{ arg.name }}: ${{ '${' }}{{ arg.name }}}`);  
                {% endfor %}
                {% endif %}
                {% if subcmd_data.options %}
                {% for opt in subcmd_data.options %}
                console.log(`  {{ opt.name }}: ${options.{{ opt.name|replace('-', '') }}}`);
                {% endfor %}
                {% endif %}
            }
        } catch (error) {
            const exitCode = handleCLIError(error as Error, options.verbose || false);
            process.exit(exitCode);
        }
    });
{% endfor %}
{% endif %}

{% endfor %}

// Completion commands
const completionCmd = program
    .command('completion')
    .description('üîß Shell completion management');

completionCmd
    .command('generate <shell>')
    .description('Generate shell completion script')
    .option('-o, --output <file>', 'Output file path')
    .action((shell: string, options: { output?: string }) => {
        if (!HAS_COMPLETION_HELPER) {
            console.error('‚ùå Completion helper not available. Missing completion module.');
            return;
        }
        
        try {
            const script = completion.generateCompletionScript(shell);
            
            if (options.output) {
                fs.writeFileSync(options.output, script);
                console.log(`‚úÖ ${shell} completion script saved to: ${options.output}`);
            } else {
                console.log(script);
            }
        } catch (e) {
            console.error(`‚ùå Error generating ${shell} completion: ${(e as Error).message}`);
        }
    });

completionCmd
    .command('install <shell>')
    .description('Install shell completion script')
    .option('--user', 'Install for current user (default)', true)
    .option('--system', 'Install system-wide (requires sudo)')
    .action(async (shell: string, options: { user?: boolean; system?: boolean }) => {
        if (!HAS_COMPLETION_HELPER) {
            console.error('‚ùå Completion helper not available. Missing completion module.');
            return;
        }
        
        try {
            const userInstall = !options.system;
            const success = await completion.installCompletion(shell, userInstall);
            
            if (success) {
                console.log(`‚úÖ ${shell} completion installed successfully!`);
                
                const instructions = completion.getInstallInstructions(shell);
                if (instructions && instructions.reloadCmd) {
                    console.log(`üí° Reload your shell: ${instructions.reloadCmd}`);
                }
            } else {
                console.error(`‚ùå Failed to install ${shell} completion`);
            }
        } catch (e) {
            console.error(`‚ùå Error installing ${shell} completion: ${(e as Error).message}`);
        }
    });

completionCmd
    .command('instructions <shell>')
    .description('Show installation instructions for shell completion')
    .action((shell: string) => {
        if (!HAS_COMPLETION_HELPER) {
            console.error('‚ùå Completion helper not available. Missing completion module.');
            return;
        }
        
        const instructions = completion.getInstallInstructions(shell);
        if (!instructions) {
            console.error(`‚ùå No instructions available for ${shell}`);
            return;
        }
        
        console.log(`üìã ${shell} completion installation instructions:\n`);
        
        console.log('üè† User installation (recommended):');
        console.log(`   mkdir -p ${path.dirname(instructions.userScriptPath)}`);
        console.log(`   {{ cli.name }} completion generate ${shell} > completion.${shell}`);
        console.log(`   cp completion.${shell} ${instructions.userScriptPath}\n`);
        
        console.log('üåê System-wide installation:');
        console.log(`   {{ cli.name }} completion generate ${shell} > completion.${shell}`);
        console.log(`   ${instructions.installCmd}\n`);
        
        console.log('üîÑ Reload shell:');
        console.log(`   ${instructions.reloadCmd}`);
    });

// Hidden internal completion command
program
    .command('_completion <shell> <currentLine> [cursorPos]', { hidden: true })
    .option('--debug', 'Debug completion engine')
    .action((shell: string, currentLine: string, cursorPos?: string, options?: { debug?: boolean }) => {
        try {
            const enginePath = path.join(__dirname, 'completion_engine.js');
            
            if (fs.existsSync(enginePath)) {
                const CompletionEngine = require(enginePath).CompletionEngine;
                const engine = new CompletionEngine();
                const completions = engine.getCompletions(shell, currentLine, cursorPos);
                
                completions.forEach((completion: string) => console.log(completion));
            } else if (options?.debug) {
                console.error('completion_engine.js not found');
            }
        } catch (e) {
            if (options?.debug) {
                console.error(`Completion error: ${(e as Error).message}`);
            }
        }
    });

// Config commands
const configCmd = program
    .command('config')
    .description('‚öôÔ∏è Configuration management');

configCmd
    .command('get [key]')
    .description('Get configuration value')
    .action((key?: string) => {
        if (!HAS_CONFIG_MANAGER) {
            console.error('‚ùå Configuration manager not available.');
            return;
        }
        
        try {
            if (key) {
                const value = config.getConfigValue(key);
                if (value !== null && value !== undefined) {
                    console.log(`${key}: ${value}`);
                } else {
                    console.error(`‚ùå Configuration key '${key}' not found`);
                }
            } else {
                // Show all configuration
                const configData = config.loadConfig();
                console.log(JSON.stringify(configData, null, 2));
            }
        } catch (e) {
            console.error(`‚ùå Error getting configuration: ${(e as Error).message}`);
        }
    });

configCmd
    .command('set <key> <value>')
    .description('Set configuration value')
    .action((key: string, value: string) => {
        if (!HAS_CONFIG_MANAGER) {
            console.error('‚ùå Configuration manager not available.');
            return;
        }
        
        try {
            // Try to parse value as JSON for complex types
            let parsedValue: any;
            try {
                parsedValue = JSON.parse(value);
            } catch (e) {
                parsedValue = value;
            }
            
            const success = config.setConfigValue(key, parsedValue);
            if (success) {
                console.log(`‚úÖ Set ${key} = ${parsedValue}`);
            } else {
                console.error('‚ùå Failed to set configuration value');
            }
        } catch (e) {
            console.error(`‚ùå Error setting configuration: ${(e as Error).message}`);
        }
    });

configCmd
    .command('reset')
    .description('Reset configuration to defaults')
    .action(async () => {
        if (!HAS_CONFIG_MANAGER) {
            console.error('‚ùå Configuration manager not available.');
            return;
        }
        
        try {
            if (HAS_PROMPTS_HELPER) {
                const confirmed = await prompts.confirm('Are you sure you want to reset all configuration to defaults?');
                if (confirmed) {
                    config.reset();
                    console.log('‚úÖ Configuration reset to defaults');
                } else {
                    console.log('‚ùå Reset cancelled');
                }
            } else {
                config.reset();
                console.log('‚úÖ Configuration reset to defaults');
            }
        } catch (e) {
            console.error(`‚ùå Error resetting configuration: ${(e as Error).message}`);
        }
    });

configCmd
    .command('path')
    .description('Show configuration file path')
    .action(() => {
        if (!HAS_CONFIG_MANAGER) {
            console.error('‚ùå Configuration manager not available.');
            return;
        }
        
        try {
            const configPath = config.getConfigPath();
            console.log(`üìÅ Configuration file: ${configPath}`);
            
            // Check for RC files
            const rcFile = config.findRcFile();
            if (rcFile) {
                console.log(`üìÑ Active RC file: ${rcFile}`);
            }
        } catch (e) {
            console.error(`‚ùå Error getting configuration path: ${(e as Error).message}`);
        }
    });

{# Auto-generate daemon management commands for managed commands #}
{% set ns = namespace(has_managed=false) %}
{% for cmd_name, cmd_data in cli.commands.items() %}
{% if cmd_data.lifecycle == "managed" %}
{% set ns.has_managed = true %}
{% endif %}
{% endfor %}
{% if ns.has_managed %}
// Daemon management commands
program
    .command('daemonstop <commandName>')
    .description('‚èπÔ∏è Stop a running daemon process')
    .option('--timeout <seconds>', 'Timeout in seconds for graceful shutdown', '10')
    .option('--json', 'Output in JSON format')
    .action(async (commandName: string, options: { timeout?: string; json?: boolean }) => {
        try {
            const DaemonHelper = require('./lib/daemon').DaemonHelper;
            const daemonHelper = new DaemonHelper(commandName);
            
            if (!daemonHelper.isRunning()) {
                const msg = `No daemon running for command '${commandName}'`;
                if (options.json) {
                    console.log(JSON.stringify({ status: 'not_running', message: msg }));
                } else {
                    console.log(`‚ö†Ô∏è  ${msg}`);
                }
                return;
            }
            
            const pid = daemonHelper.getPid();
            const timeout = parseInt(options.timeout || '10');
            
            if (await daemonHelper.stop(timeout)) {
                if (options.json) {
                    console.log(JSON.stringify({
                        status: 'stopped',
                        command: commandName,
                        pid: pid,
                        message: `Successfully stopped daemon for '${commandName}'`
                    }));
                } else {
                    console.log(`‚úÖ Successfully stopped daemon '${commandName}' (PID: ${pid})`);
                }
            } else {
                const errorMsg = `Failed to stop daemon '${commandName}' (PID: ${pid})`;
                if (options.json) {
                    console.log(JSON.stringify({ status: 'error', message: errorMsg }));
                } else {
                    console.error(`‚ùå ${errorMsg}`);
                }
                process.exit(1);
            }
        } catch (e) {
            const exitCode = handleCLIError(e as Error, options.verbose || program.opts().verbose);
            process.exit(exitCode);
        }
    });

program
    .command('daemonstatus <commandName>')
    .description('üìä Check status of a daemon process')
    .option('--json', 'Output in JSON format')
    .action(async (commandName: string, options: { json?: boolean }) => {
        try {
            const DaemonHelper = require('./lib/daemon').DaemonHelper;
            const daemonHelper = new DaemonHelper(commandName);
            
            const stats = daemonHelper.getDaemonStats();
            
            if (options.json) {
                console.log(JSON.stringify(stats, null, 2));
            } else {
                const isRunning = stats.running;
                const statusEmoji = isRunning ? 'üü¢' : 'üî¥';
                const statusText = isRunning ? 'Running' : 'Stopped';
                
                console.log(`üìä Daemon Status for '${commandName}': ${statusEmoji} ${statusText}`);
                
                if (isRunning) {
                    console.log(`   PID: ${stats.pid}`);
                    console.log(`   PID File: ${stats.pidFile}`);
                } else {
                    console.log(`   PID File: ${stats.pidFile} (not found or stale)`);
                }
            }
        } catch (e) {
            const exitCode = handleCLIError(e as Error, options.verbose || program.opts().verbose);
            process.exit(exitCode);
        }
    });

const daemonCmd = program
    .command('daemon')
    .description('üîß Daemon system integration commands');

daemonCmd
    .command('install <commandName>')
    .description('üîß Generate systemd service file for daemon management')
    .option('--user', 'Install as user service (default)', true)
    .option('--system', 'Install as system service (requires sudo)')
    .action(async (commandName: string, options: { user?: boolean; system?: boolean }) => {
        try {
            // Implementation would be similar to Python version
            console.log('Daemon installation not yet implemented for TypeScript');
        } catch (e) {
            const exitCode = handleCLIError(e as Error, options.verbose || program.parent?.opts().verbose);
            process.exit(exitCode);
        }
    });
{% endif %}

// CLI entry point
function cliEntry(): void {
    try {
        // Load plugins before parsing
        loadPlugins(program);
        
        // Parse command line
        program.parse(process.argv);
        
        // Show help if no args
        if (!process.argv.slice(2).length) {
            program.outputHelp();
        }
    } catch (e) {
        if ((e as any).code === 'commander.help') {
            // Normal help display
            process.exit(0);
        }
        
        // Get verbose flag from program options
        const verbose = program.opts().verbose || false;
        const exitCode = handleCLIError(e as Error, verbose);
        process.exit(exitCode);
    }
}

// Handle uncaught errors
process.on('uncaughtException', (error: Error) => {
    // Get verbose flag from program options if available, fallback to process.argv check
    const verbose = program.opts().verbose || process.argv.includes('--verbose');
    const exitCode = handleCLIError(error, verbose);
    process.exit(exitCode);
});

process.on('unhandledRejection', (reason: any, promise: Promise<any>) => {
    const error = reason instanceof Error ? reason : new Error(String(reason));
    // Get verbose flag from program options if available, fallback to process.argv check
    const verbose = program.opts().verbose || process.argv.includes('--verbose');
    const exitCode = handleCLIError(error, verbose);
    process.exit(exitCode);
});

// Handle Ctrl+C
process.on('SIGINT', () => {
    console.error('\n‚èπÔ∏è  Operation cancelled by user');
    process.exit(130); // Standard exit code for Ctrl+C
});

// Export for use as module
export { program, cliEntry };

// Run if called directly
if (require.main === module) {
    cliEntry();
}