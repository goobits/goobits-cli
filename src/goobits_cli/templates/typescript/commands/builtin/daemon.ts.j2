// Built-in daemon management commands for {{ display_name }}
const chalk = require('chalk');
const fs = require('fs');
const path = require('path');
const { spawn } = require('child_process');

class DaemonHelper {
  constructor(commandName) {
    this.commandName = commandName;
    this.pidFile = this.getPidFilePath();
  }

  getPidFilePath() {
    const runtimeDir = process.env.XDG_RUNTIME_DIR || path.join(os.tmpdir(), `${process.getuid()}`);
    return path.join(runtimeDir, `{{ cli.name | lower | replace(' ', '-') }}-${this.commandName}.pid`);
  }

  getPid() {
    try {
      if (fs.existsSync(this.pidFile)) {
        const pid = parseInt(fs.readFileSync(this.pidFile, 'utf8').trim());
        // Check if process is still running
        try {
          process.kill(pid, 0);
          return pid;
        } catch (e) {
          // Process not running, clean up stale PID file
          fs.unlinkSync(this.pidFile);
          return null;
        }
      }
    } catch (error) {
      return null;
    }
    return null;
  }

  isRunning() {
    return this.getPid() !== null;
  }

  stop(timeout = 10) {
    const pid = this.getPid();
    if (!pid) return true;

    try {
      // Send SIGTERM for graceful shutdown
      process.kill(pid, 'SIGTERM');
      
      // Wait for process to terminate
      const startTime = Date.now();
      while (Date.now() - startTime < timeout * 1000) {
        try {
          process.kill(pid, 0);
          // Process still running, wait a bit
          require('child_process').execSync('sleep 0.1');
        } catch (e) {
          // Process terminated
          if (fs.existsSync(this.pidFile)) {
            fs.unlinkSync(this.pidFile);
          }
          return true;
        }
      }
      
      // Force kill if still running
      process.kill(pid, 'SIGKILL');
      if (fs.existsSync(this.pidFile)) {
        fs.unlinkSync(this.pidFile);
      }
      return true;
    } catch (error) {
      return false;
    }
  }

  getDaemonStats() {
    const pid = this.getPid();
    return {
      running: pid !== null,
      pid: pid,
      pid_file: this.pidFile,
      command: this.commandName
    };
  }
}

module.exports = function(program) {
  {% set ns = namespace(has_managed=false) %}
  {% for cmd_name, cmd_data in cli.commands.items() %}
  {% if cmd_data.lifecycle == "managed" %}
  {% set ns.has_managed = true %}
  {% endif %}
  {% endfor %}
  
  {% if ns.has_managed %}
  // Add daemon management commands
  program
    .command('daemonstop <command>')
    .description('‚èπÔ∏è Stop a running daemon process')
    .option('--timeout <seconds>', 'Timeout in seconds for graceful shutdown', parseInt, 10)
    .option('--json', 'Output in JSON format')
    .action(async function(commandName, options) {
      const daemonHelper = new DaemonHelper(commandName);
      
      if (!daemonHelper.isRunning()) {
        const msg = `No daemon running for command '${commandName}'`;
        if (options.json) {
          console.log(JSON.stringify({ status: 'not_running', message: msg }));
        } else {
          console.log(chalk.yellow(`‚ö†Ô∏è  ${msg}`));
        }
        return;
      }
      
      const pid = daemonHelper.getPid();
      
      if (daemonHelper.stop(options.timeout)) {
        if (options.json) {
          console.log(JSON.stringify({
            status: 'stopped',
            command: commandName,
            pid: pid,
            message: `Successfully stopped daemon for '${commandName}'`
          }));
        } else {
          console.log(chalk.green(`‚úÖ Successfully stopped daemon '${commandName}' (PID: ${pid})`));
        }
      } else {
        const errorMsg = `Failed to stop daemon '${commandName}' (PID: ${pid})`;
        if (options.json) {
          console.log(JSON.stringify({ status: 'error', message: errorMsg }));
        } else {
          console.error(chalk.red(`‚ùå ${errorMsg}`));
        }
        process.exit(1);
      }
    });

  program
    .command('daemonstatus <command>')
    .description('üìä Check status of a daemon process')
    .option('--json', 'Output in JSON format')
    .action(async function(commandName, options) {
      const daemonHelper = new DaemonHelper(commandName);
      const stats = daemonHelper.getDaemonStats();
      
      if (options.json) {
        console.log(JSON.stringify(stats, null, 2));
      } else {
        const isRunning = stats.running;
        const statusEmoji = isRunning ? 'üü¢' : 'üî¥';
        const statusText = isRunning ? 'Running' : 'Stopped';
        
        console.log(chalk.bold(`üìä Daemon Status for '${commandName}': ${statusEmoji} ${statusText}`));
        
        if (isRunning) {
          console.log(`   PID: ${stats.pid}`);
          console.log(`   PID File: ${stats.pid_file}`);
        } else {
          console.log(`   PID File: ${stats.pid_file} (not found or stale)`);
        }
      }
    });

  // Daemon group command
  const daemonGroup = program
    .command('daemon')
    .description('üîß Daemon system integration commands');

  daemonGroup
    .command('install <command>')
    .description('üîß Generate systemd service file for daemon management')
    .option('--user', 'Install as user service (default)', true)
    .option('--system', 'Install as system service (requires sudo)')
    .action(async function(commandName, options) {
      const cliName = '{{ cli.name | lower | replace(' ', '-') }}';
      const displayName = '{{ display_name }}';
      const cliExecutable = process.argv[1];
      
      // Determine installation type
      const isSystem = options.system;
      const serviceDir = isSystem 
        ? '/etc/systemd/system'
        : path.join(process.env.HOME, '.config', 'systemd', 'user');
      
      // Ensure service directory exists
      if (!fs.existsSync(serviceDir)) {
        try {
          fs.mkdirSync(serviceDir, { recursive: true });
        } catch (error) {
          console.error(chalk.red(`‚ùå Permission denied creating directory: ${serviceDir}`));
          if (!isSystem) {
            console.log(`   Try: mkdir -p ${serviceDir}`);
          }
          process.exit(1);
        }
      }
      
      // Generate service file
      const serviceName = `${cliName}-${commandName}.service`;
      const serviceFilePath = path.join(serviceDir, serviceName);
      
      // Determine paths
      const pidFilePath = isSystem
        ? `/run/${cliName}-${commandName}.pid`
        : `\${XDG_RUNTIME_DIR}/${cliName}-${commandName}.pid`;
      const workingDir = isSystem
        ? `/var/lib/${cliName}`
        : process.env.HOME;
      
      const serviceContent = `# Auto-generated by goobits for the '${commandName}' command
# Service file for ${displayName} daemon management
[Unit]
Description=goobits-managed daemon for the '${commandName}' command
After=network.target
Wants=network.target

[Service]
Type=forking
ExecStart=${cliExecutable} ${commandName} --daemon
PIDFile=${pidFilePath}
Restart=on-failure
RestartSec=5
WorkingDirectory=${workingDir}
${!isSystem ? `
# User service settings
User=%i
Group=%i` : ''}

[Install]
WantedBy=${isSystem ? 'multi-user.target' : 'default.target'}
`;
      
      // Write service file
      try {
        fs.writeFileSync(serviceFilePath, serviceContent);
        console.log(chalk.green(`‚úÖ Generated systemd service file: ${serviceFilePath}`));
      } catch (error) {
        console.error(chalk.red(`‚ùå Permission denied writing to: ${serviceFilePath}`));
        process.exit(1);
      }
      
      // Print usage instructions
      console.log('');
      console.log(chalk.bold(`üîß Systemd service '${serviceName}' created successfully!`));
      console.log('');
      console.log(chalk.yellow('üìã To enable and start the service:'));
      
      const prefix = isSystem ? 'sudo ' : '';
      const systemctl = isSystem ? 'systemctl' : 'systemctl --user';
      
      console.log(`   ${prefix}${systemctl} daemon-reload`);
      console.log(`   ${prefix}${systemctl} enable ${serviceName}`);
      console.log(`   ${prefix}${systemctl} start ${serviceName}`);
      console.log('');
      console.log(chalk.yellow('üìä To check status:'));
      console.log(`   ${prefix}${systemctl} status ${serviceName}`);
      console.log('');
      console.log(chalk.yellow('üõë To stop and disable:'));
      console.log(`   ${prefix}${systemctl} stop ${serviceName}`);
      console.log(`   ${prefix}${systemctl} disable ${serviceName}`);
      console.log('');
      console.log(chalk.gray(`üìù Service file location: ${serviceFilePath}`));
    });
  {% endif %}

  return program;
};