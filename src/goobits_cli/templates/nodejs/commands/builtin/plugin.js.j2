/**
 * Built-in plugin management command for {{ display_name }}
 */

import { Command } from 'commander';
import chalk from 'chalk';
import { PluginManager } from '../../lib/plugin-manager.js';
import { writeFile, mkdir } from 'fs/promises';
import { join, resolve } from 'path';
import { existsSync } from 'fs';

export default function registerPluginCommand(program) {
  const pluginCmd = program
    .command('plugin')
    .description('ðŸ”Œ Manage plugins for {{ display_name }}')
    .alias('plugins');

  // List plugins subcommand
  pluginCmd
    .command('list')
    .alias('ls')
    .description('List all available and loaded plugins')
    .option('--json', 'Output as JSON')
    .action(async (options) => {
      const pluginManager = new PluginManager(program);
      const plugins = await pluginManager.listPlugins();

      if (options.json) {
        console.log(JSON.stringify(plugins, null, 2));
        return;
      }

      console.log(chalk.bold.blue('\nðŸ“¦ Plugin Status\n'));

      if (plugins.loaded.length > 0) {
        console.log(chalk.green('âœ… Loaded Plugins:'));
        plugins.loaded.forEach(plugin => {
          console.log(`  ${chalk.cyan(plugin.name)} ${chalk.gray(`(${plugin.type})`)}`);
          if (plugin.package?.description) {
            console.log(`    ${chalk.gray(plugin.package.description)}`);
          }
        });
        console.log();
      }

      if (plugins.discovered.length > plugins.loaded.length) {
        const unloaded = plugins.discovered.filter(d => 
          !plugins.loaded.some(l => l.name === d.name)
        );
        
        if (unloaded.length > 0) {
          console.log(chalk.yellow('ðŸ“‹ Available Plugins:'));
          unloaded.forEach(plugin => {
            console.log(`  ${chalk.cyan(plugin.name)} ${chalk.gray(`(${plugin.type})`)}`);
            if (plugin.package?.description) {
              console.log(`    ${chalk.gray(plugin.package.description)}`);
            }
          });
          console.log();
        }
      }

      if (plugins.discovered.length === 0) {
        console.log(chalk.gray('No plugins discovered. Use "plugin create" to create your first plugin.'));
      }
    });

  // Install plugin subcommand
  pluginCmd
    .command('install <plugin-name>')
    .description('Install a plugin from npm')
    .option('-g, --global', 'Install globally')
    .option('--version <version>', 'Install specific version', 'latest')
    .action(async (pluginName, options) => {
      const pluginManager = new PluginManager(program);
      await pluginManager.installPlugin(pluginName, options);
    });

  // Uninstall plugin subcommand
  pluginCmd
    .command('uninstall <plugin-name>')
    .alias('remove')
    .description('Uninstall a plugin')
    .option('-g, --global', 'Uninstall globally')
    .action(async (pluginName, options) => {
      const pluginManager = new PluginManager(program);
      await pluginManager.uninstallPlugin(pluginName, options);
    });

  // Create plugin subcommand
  pluginCmd
    .command('create <plugin-name>')
    .description('Create a new plugin template')
    .option('--type <type>', 'Plugin type (function|class|npm)', 'function')
    .option('--dir <directory>', 'Output directory', './plugins')
    .action(async (pluginName, options) => {
      try {
        await createPluginTemplate(pluginName, options);
        console.log(chalk.green(`âœ… Plugin template "${pluginName}" created successfully!`));
      } catch (error) {
        console.error(chalk.red(`Failed to create plugin template: ${error.message}`));
        process.exit(1);
      }
    });

  // Info plugin subcommand
  pluginCmd
    .command('info <plugin-name>')
    .description('Show detailed information about a plugin')
    .action(async (pluginName) => {
      const pluginManager = new PluginManager(program);
      const pluginInfo = pluginManager.getPluginInfo(pluginName);

      if (!pluginInfo) {
        console.log(chalk.red(`Plugin "${pluginName}" is not loaded.`));
        
        // Check if it's discovered but not loaded
        const plugins = await pluginManager.listPlugins();
        const discovered = plugins.discovered.find(p => p.name === pluginName);
        
        if (discovered) {
          console.log(chalk.yellow('Plugin is available but not loaded:'));
          console.log(`  Path: ${discovered.path}`);
          console.log(`  Type: ${discovered.type}`);
          if (discovered.package) {
            console.log(`  Version: ${discovered.package.version}`);
            console.log(`  Description: ${discovered.package.description}`);
          }
        }
        return;
      }

      console.log(chalk.bold.blue(`\nðŸ”Œ Plugin: ${pluginName}\n`));
      console.log(`${chalk.cyan('Status:')} ${chalk.green('Loaded')}`);
      console.log(`${chalk.cyan('Path:')} ${pluginInfo.path}`);
      console.log(`${chalk.cyan('Type:')} ${pluginInfo.type}`);
      
      if (pluginInfo.package) {
        console.log(`${chalk.cyan('Version:')} ${pluginInfo.package.version}`);
        console.log(`${chalk.cyan('Description:')} ${pluginInfo.package.description}`);
        if (pluginInfo.package.author) {
          console.log(`${chalk.cyan('Author:')} ${pluginInfo.package.author}`);
        }
        if (pluginInfo.package.keywords) {
          console.log(`${chalk.cyan('Keywords:')} ${pluginInfo.package.keywords.join(', ')}`);
        }
      }
    });

  return pluginCmd;
}

/**
 * Create a plugin template
 */
async function createPluginTemplate(pluginName, options) {
  const { type, dir } = options;
  const outputDir = resolve(dir);
  const pluginDir = join(outputDir, pluginName);

  // Create plugin directory
  await mkdir(pluginDir, { recursive: true });

  // Generate plugin based on type
  switch (type) {
    case 'function':
      await createFunctionPlugin(pluginDir, pluginName);
      break;
    case 'class':
      await createClassPlugin(pluginDir, pluginName);
      break;
    case 'npm':
      await createNpmPlugin(pluginDir, pluginName);
      break;
    default:
      throw new Error(`Unknown plugin type: ${type}`);
  }
}

/**
 * Create a function-style plugin template
 */
async function createFunctionPlugin(pluginDir, pluginName) {
  const pluginCode = `/**
 * ${pluginName} plugin for {{ display_name }}
 * Function-style plugin
 */

import chalk from 'chalk';

export default function ${toCamelCase(pluginName)}Plugin(program) {
  // Add a new command to the CLI
  program
    .command('${pluginName}')
    .description('Command added by ${pluginName} plugin')
    .option('--example <value>', 'Example option')
    .action((options) => {
      console.log(chalk.blue('ðŸ”Œ Plugin command executed!'));
      console.log('Plugin name:', '${pluginName}');
      console.log('Options:', options);
      
      // Your plugin logic here
      console.log(chalk.green('Plugin functionality goes here!'));
    });

  // You can also add global options or modify existing commands
  console.debug(chalk.gray('${pluginName} plugin loaded'));
}

function toCamelCase(str) {
  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}`;

  await writeFile(join(pluginDir, 'index.js'), pluginCode, 'utf8');
  
  // Create a simple README
  const readme = `# ${pluginName}

A plugin for {{ display_name }}.

## Installation

\`\`\`bash
# Copy this plugin to your plugins directory
cp -r ${pluginName} ~/.config/goobits/{{ cli.name }}/plugins/
\`\`\`

## Usage

\`\`\`bash
{{ command_name }} ${pluginName} --help
\`\`\`

## Development

This is a function-style plugin. The main export should be a function that receives the Commander.js program instance and can register new commands or modify existing ones.
`;

  await writeFile(join(pluginDir, 'README.md'), readme, 'utf8');
}

/**
 * Create a class-style plugin template  
 */
async function createClassPlugin(pluginDir, pluginName) {
  const pluginCode = `/**
 * ${pluginName} plugin for {{ display_name }}
 * Class-style plugin
 */

import chalk from 'chalk';

export class ${toPascalCase(pluginName)}Plugin {
  constructor(program) {
    this.program = program;
    this.name = '${pluginName}';
    this.version = '1.0.0';
  }

  register(program) {
    // Add commands
    program
      .command('${pluginName}')
      .description('Command added by ${pluginName} plugin')
      .option('--example <value>', 'Example option')
      .action(this.execute.bind(this));

    console.debug(chalk.gray(\`\${this.name} plugin loaded\`));
  }

  async execute(options) {
    console.log(chalk.blue('ðŸ”Œ Class plugin command executed!'));
    console.log('Plugin name:', this.name);
    console.log('Plugin version:', this.version);
    console.log('Options:', options);
    
    // Your plugin logic here
    console.log(chalk.green('Plugin functionality goes here!'));
  }

  // Optional: cleanup method
  destroy() {
    console.debug(chalk.gray(\`\${this.name} plugin destroyed\`));
  }
}

// Export for function-style loading
export default function(program) {
  const plugin = new ${toPascalCase(pluginName)}Plugin(program);
  plugin.register(program);
  return plugin;
}

function toPascalCase(str) {
  return str.replace(/(^|-)([a-z])/g, (g) => g.replace('-', '').toUpperCase());
}`;

  await writeFile(join(pluginDir, 'index.js'), pluginCode, 'utf8');
  
  // Create README
  const readme = `# ${pluginName}

A class-based plugin for {{ display_name }}.

## Installation

\`\`\`bash
# Copy this plugin to your plugins directory
cp -r ${pluginName} ~/.config/goobits/{{ cli.name }}/plugins/
\`\`\`

## Usage

\`\`\`bash
{{ command_name }} ${pluginName} --help
\`\`\`

## Development

This is a class-style plugin. It exports both a class and a default function for compatibility with different loading mechanisms.
`;

  await writeFile(join(pluginDir, 'README.md'), readme, 'utf8');
}

/**
 * Create an npm-style plugin template
 */
async function createNpmPlugin(pluginDir, pluginName) {
  // Create package.json
  const packageJson = {
    name: `{{ cli.name }}-plugin-${pluginName}`,
    version: '1.0.0',
    description: `${pluginName} plugin for {{ display_name }}`,
    main: 'index.js',
    type: 'module',
    keywords: ['{{ cli.name }}-plugin', 'goobits-plugin', 'cli-plugin'],
    author: '',
    license: 'MIT',
    peerDependencies: {
      'commander': '^11.0.0',
      'chalk': '^5.0.0'
    },
    engines: {
      node: '>=14.0.0'
    }
  };

  await writeFile(
    join(pluginDir, 'package.json'), 
    JSON.stringify(packageJson, null, 2), 
    'utf8'
  );

  // Create main plugin file
  const pluginCode = `/**
 * ${pluginName} plugin for {{ display_name }}
 * NPM-style plugin with package.json
 */

import chalk from 'chalk';

export default function ${toCamelCase(pluginName)}Plugin(program) {
  program
    .command('${pluginName}')
    .description('Command added by ${pluginName} plugin')
    .option('--example <value>', 'Example option')
    .action(async (options) => {
      console.log(chalk.blue('ðŸ”Œ NPM plugin command executed!'));
      console.log('Plugin name:', '${pluginName}');
      console.log('Options:', options);
      
      // Your plugin logic here
      console.log(chalk.green('Plugin functionality goes here!'));
    });

  console.debug(chalk.gray('${pluginName} plugin loaded'));
}

// Also export as named export for flexibility
export const register = ${toCamelCase(pluginName)}Plugin;

function toCamelCase(str) {
  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}`;

  await writeFile(join(pluginDir, 'index.js'), pluginCode, 'utf8');

  // Create comprehensive README
  const readme = `# {{ cli.name }}-plugin-${pluginName}

A plugin for {{ display_name }}.

## Installation

### From npm (when published)

\`\`\`bash
npm install -g {{ cli.name }}-plugin-${pluginName}
\`\`\`

### Local development

\`\`\`bash
# Link locally for development
npm link

# Or copy to plugins directory
cp -r . ~/.config/goobits/{{ cli.name }}/plugins/${pluginName}/
\`\`\`

## Usage

\`\`\`bash
{{ command_name }} ${pluginName} --help
\`\`\`

## Development

This is an npm-style plugin with a full package.json. It can be published to npm and installed globally or locally.

### Publishing

1. Update version in package.json
2. Run \`npm publish\`
3. Install with \`npm install -g {{ cli.name }}-plugin-${pluginName}\`

### API

The plugin exports a default function that receives the Commander.js program instance and can register new commands.

## License

MIT
`;

  await writeFile(join(pluginDir, 'README.md'), readme, 'utf8');
}

function toCamelCase(str) {
  return str.replace(/-([a-z])/g, (g) => g[1].toUpperCase());
}

function toPascalCase(str) {
  return str.replace(/(^|-)([a-z])/g, (g) => g.replace('-', '').toUpperCase());
}