/**
 * Built-in shell completion command for {{ display_name }}
 */

import { Command } from 'commander';
import chalk from 'chalk';
import { writeFile, mkdir } from 'fs/promises';
import { join, resolve } from 'path';
import { existsSync } from 'fs';
import { execSync } from 'child_process';

export default function registerCompletionCommand(program) {
  const completionCmd = program
    .command('completion')
    .description('üîß Generate shell completion scripts')
    .alias('completions');

  // Generate completion subcommand
  completionCmd
    .command('generate <shell>')
    .description('Generate completion script for specified shell')
    .option('--output <file>', 'Write to file instead of stdout')
    .option('--install', 'Automatically install the completion script')
    .action(async (shell, options) => {
      try {
        const validShells = ['bash', 'zsh', 'fish'];
        if (!validShells.includes(shell)) {
          console.error(chalk.red(`Invalid shell: ${shell}. Valid shells: ${validShells.join(', ')}`));
          process.exit(1);
        }

        const completionScript = await generateCompletionScript(shell);
        
        if (options.output) {
          await writeFile(options.output, completionScript, 'utf8');
          console.log(chalk.green(`‚úÖ Completion script written to ${options.output}`));
        } else {
          console.log(completionScript);
        }

        if (options.install) {
          await installCompletion(shell, completionScript);
        }
      } catch (error) {
        console.error(chalk.red(`Failed to generate ${shell} completion:`, error.message));
        process.exit(1);
      }
    });

  // Install completion subcommand
  completionCmd
    .command('install <shell>')
    .description('Install completion script for specified shell')
    .option('--force', 'Overwrite existing completion script')
    .action(async (shell, options) => {
      try {
        const validShells = ['bash', 'zsh', 'fish'];
        if (!validShells.includes(shell)) {
          console.error(chalk.red(`Invalid shell: ${shell}. Valid shells: ${validShells.join(', ')}`));
          process.exit(1);
        }

        const completionScript = await generateCompletionScript(shell);
        await installCompletion(shell, completionScript, options.force);
        
        console.log(chalk.green(`‚úÖ Completion installed for ${shell}`));
        console.log(chalk.yellow('You may need to restart your shell or source your profile.'));
        
        // Provide shell-specific instructions
        showInstallInstructions(shell);
      } catch (error) {
        console.error(chalk.red(`Failed to install ${shell} completion:`, error.message));
        process.exit(1);
      }
    });

  // Uninstall completion subcommand
  completionCmd
    .command('uninstall <shell>')
    .description('Uninstall completion script for specified shell')
    .action(async (shell) => {
      try {
        const validShells = ['bash', 'zsh', 'fish'];
        if (!validShells.includes(shell)) {
          console.error(chalk.red(`Invalid shell: ${shell}. Valid shells: ${validShells.join(', ')}`));
          process.exit(1);
        }

        await uninstallCompletion(shell);
        console.log(chalk.green(`‚úÖ Completion uninstalled for ${shell}`));
      } catch (error) {
        console.error(chalk.red(`Failed to uninstall ${shell} completion:`, error.message));
        process.exit(1);
      }
    });

  // Status subcommand
  completionCmd
    .command('status')
    .description('Show completion installation status')
    .action(async () => {
      console.log(chalk.bold.blue('\nüîß Shell Completion Status\n'));
      
      const shells = ['bash', 'zsh', 'fish'];
      for (const shell of shells) {
        const installed = await isCompletionInstalled(shell);
        const status = installed ? chalk.green('‚úÖ Installed') : chalk.gray('‚ùå Not installed');
        console.log(`${shell.padEnd(6)} ${status}`);
        
        if (installed) {
          const location = getCompletionPath(shell);
          console.log(`         ${chalk.gray(location)}`);
        }
      }
      
      console.log();
      console.log(chalk.gray('Run "completion install <shell>" to install for a specific shell.'));
    });

  return completionCmd;
}

/**
 * Generate completion script for a shell
 */
async function generateCompletionScript(shell) {
  const { fileURLToPath } = await import('url');
  const { dirname, join } = await import('path');
  
  const __filename = fileURLToPath(import.meta.url);
  const __dirname = dirname(__filename);
  
  try {
    // Try to load template file
    const completionsDir = join(__dirname, '..', '..', 'completions');
    const templateFile = join(completionsDir, `${shell}-completion`);
    
    if (existsSync(templateFile)) {
      const { readFile } = await import('fs/promises');
      return await readFile(templateFile, 'utf8');
    }
  } catch (error) {
    console.debug('Template file not available, generating dynamic completion');
  }
  
  // Fallback to dynamic generation
  return generateDynamicCompletion(shell);
}

/**
 * Generate dynamic completion script
 */
function generateDynamicCompletion(shell) {
  // This would use the same logic as in index.js
  // For now, return a basic template
  switch (shell) {
    case 'bash':
      return `# Bash completion for {{ command_name }}
_{{ command_name | replace('-', '_') }}_completions() {
    local cur prev words cword
    _init_completion || return
    
    COMPREPLY=($(compgen -W "help --help --version" -- "$cur"))
}

complete -F _{{ command_name | replace('-', '_') }}_completions {{ command_name }}`;

    case 'zsh':
      return `#compdef {{ command_name }}
_{{ command_name | replace('-', '_') }}() {
    _arguments \\
        '(-h --help)'{-h,--help}'[Show help]' \\
        '(-V --version)'{-V,--version}'[Show version]'
}

_{{ command_name | replace('-', '_') }} "$@"`;

    case 'fish':
      return `# Fish completion for {{ command_name }}
complete -c {{ command_name }} -l help -s h -d 'Show help'
complete -c {{ command_name }} -l version -s V -d 'Show version'`;

    default:
      throw new Error(`Unsupported shell: ${shell}`);
  }
}

/**
 * Install completion script for a shell
 */
async function installCompletion(shell, script, force = false) {
  const completionPath = getCompletionPath(shell);
  const completionDir = resolve(completionPath, '..');
  
  // Create completion directory if it doesn't exist
  await mkdir(completionDir, { recursive: true });
  
  // Check if completion already exists
  if (existsSync(completionPath) && !force) {
    throw new Error(`Completion already installed at ${completionPath}. Use --force to overwrite.`);
  }
  
  // Write completion script
  await writeFile(completionPath, script, { mode: 0o755 });
}

/**
 * Uninstall completion script
 */
async function uninstallCompletion(shell) {
  const completionPath = getCompletionPath(shell);
  
  if (existsSync(completionPath)) {
    const { unlink } = await import('fs/promises');
    await unlink(completionPath);
  } else {
    throw new Error(`Completion not installed for ${shell}`);
  }
}

/**
 * Check if completion is installed for a shell
 */
async function isCompletionInstalled(shell) {
  const completionPath = getCompletionPath(shell);
  return existsSync(completionPath);
}

/**
 * Get the standard completion path for a shell
 */
function getCompletionPath(shell) {
  const home = process.env.HOME || '';
  
  switch (shell) {
    case 'bash':
      // Try different bash completion directories
      const bashCompletionDirs = [
        join(home, '.local/share/bash-completion/completions'),
        join(home, '.bash_completion.d'),
        '/usr/local/share/bash-completion/completions',
        '/etc/bash_completion.d'
      ];
      
      // Use the first writable directory
      for (const dir of bashCompletionDirs) {
        try {
          if (existsSync(dir)) {
            return join(dir, '{{ command_name }}');
          }
        } catch (error) {
          continue;
        }
      }
      
      // Fallback to ~/.local/share/bash-completion/completions
      return join(home, '.local/share/bash-completion/completions', '{{ command_name }}');
      
    case 'zsh':
      // Use ~/.local/share/zsh/site-functions for user installations
      return join(home, '.local/share/zsh/site-functions', '_{{ command_name }}');
      
    case 'fish':
      // Use ~/.config/fish/completions
      return join(home, '.config/fish/completions', '{{ command_name }}.fish');
      
    default:
      throw new Error(`Unsupported shell: ${shell}`);
  }
}

/**
 * Show shell-specific installation instructions
 */
function showInstallInstructions(shell) {
  console.log(chalk.bold('\nNext steps:'));
  
  switch (shell) {
    case 'bash':
      console.log(chalk.gray('‚Ä¢ Restart your terminal or run: source ~/.bashrc'));
      console.log(chalk.gray('‚Ä¢ If using macOS, you may need to install bash-completion:'));
      console.log(chalk.gray('  brew install bash-completion'));
      break;
      
    case 'zsh':
      console.log(chalk.gray('‚Ä¢ Add to your ~/.zshrc:'));
      console.log(chalk.gray('  fpath=(~/.local/share/zsh/site-functions $fpath)'));
      console.log(chalk.gray('  autoload -U compinit && compinit'));
      console.log(chalk.gray('‚Ä¢ Then restart your terminal or run: source ~/.zshrc'));
      break;
      
    case 'fish':
      console.log(chalk.gray('‚Ä¢ Completions should be available immediately'));
      console.log(chalk.gray('‚Ä¢ If not, restart fish or run: fish_reload'));
      break;
  }
}