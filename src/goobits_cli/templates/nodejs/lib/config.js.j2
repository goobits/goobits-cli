/**
 * Configuration management for {{ display_name }}
 * Generated by goobits-cli
 */

import fs from 'fs';
import path from 'path';
import os from 'os';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

// Import error handling utilities
import {
  ConfigError,
  ConfigNotFoundError,
  InvalidConfigError,
  FileSystemError,
  PermissionDeniedError,
  ValidationError,
  handleError,
  asyncErrorHandler
} from './errors.js';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

/**
 * Configuration manager class
 */
class ConfigManager {
    constructor() {
        this.packageName = '{{ package_name }}';
        this.configDirName = '{{ package_name }}';
        this.configFileName = 'config.json';
        this._config = null;
        this._configPath = null;
    }

    /**
     * Get the configuration directory path based on platform
     */
    getConfigDir() {
        const homeDir = os.homedir();
        
        if (process.platform === 'win32') {
            // Windows: Use APPDATA or fallback to home
            return path.join(process.env.APPDATA || homeDir, this.configDirName);
        } else if (process.platform === 'darwin') {
            // macOS: Use ~/Library/Application Support
            return path.join(homeDir, 'Library', 'Application Support', this.configDirName);
        } else {
            // Linux and others: Use XDG_CONFIG_HOME or ~/.config
            const xdgConfig = process.env.XDG_CONFIG_HOME || path.join(homeDir, '.config');
            return path.join(xdgConfig, this.configDirName);
        }
    }

    /**
     * Get the full path to the configuration file
     */
    getConfigPath() {
        if (!this._configPath) {
            this._configPath = path.join(this.getConfigDir(), this.configFileName);
        }
        return this._configPath;
    }

    /**
     * Ensure the configuration directory exists
     */
    ensureConfigDir() {
        try {
            const configDir = this.getConfigDir();
            if (!fs.existsSync(configDir)) {
                fs.mkdirSync(configDir, { recursive: true });
            }
        } catch (error) {
            if (error.code === 'EACCES' || error.code === 'EPERM') {
                throw new PermissionDeniedError(this.getConfigDir(), 'create directory');
            }
            throw new FileSystemError(
                `Failed to create config directory: ${error.message}`,
                this.getConfigDir(),
                'mkdir',
                `Cannot create configuration directory. Check permissions for: ${this.getConfigDir()}`
            );
        }
    }

    /**
     * Load configuration from file
     */
    load() {
        const configPath = this.getConfigPath();
        
        try {
            if (fs.existsSync(configPath)) {
                const data = fs.readFileSync(configPath, 'utf8');
                try {
                    this._config = JSON.parse(data);
                    
                    // Validate configuration structure
                    this._validateConfig(this._config);
                } catch (parseError) {
                    if (parseError instanceof SyntaxError) {
                        throw new InvalidConfigError(
                            `Invalid JSON in configuration file: ${parseError.message}`,
                            configPath
                        );
                    }
                    throw parseError;
                }
            } else {
                // Create default config if file doesn't exist
                this._config = this.getDefaults();
                try {
                    this.save();
                } catch (saveError) {
                    // Log but don't fail if we can't save defaults
                    if (process.env.DEBUG) {
                        console.debug('Could not save default config:', saveError.message);
                    }
                }
            }
        } catch (error) {
            if (error instanceof ConfigError) {
                throw error;
            }
            
            if (error.code === 'EACCES' || error.code === 'EPERM') {
                throw new PermissionDeniedError(configPath, 'read');
            }
            
            // Fallback to defaults on any other error
            console.warn(`Warning: Could not load config (${error.message}), using defaults`);
            this._config = this.getDefaults();
        }
        
        return this._config;
    }

    /**
     * Validate configuration structure
     */
    _validateConfig(config) {
        if (!config || typeof config !== 'object') {
            throw new InvalidConfigError('Configuration must be an object');
        }
        
        // Add specific validation rules here based on your config schema
        const requiredFields = ['version'];
        const missingFields = requiredFields.filter(field => !(field in config));
        
        if (missingFields.length > 0) {
            throw new InvalidConfigError(
                `Missing required configuration fields: ${missingFields.join(', ')}`
            );
        }
        
        return true;
    }

    /**
     * Save configuration to file
     */
    save() {
        try {
            this.ensureConfigDir();
            const configPath = this.getConfigPath();
            
            // Validate before saving
            this._validateConfig(this._config);
            
            // Create backup if file exists
            if (fs.existsSync(configPath)) {
                const backupPath = `${configPath}.backup`;
                try {
                    fs.copyFileSync(configPath, backupPath);
                } catch (backupError) {
                    // Log but don't fail on backup error
                    if (process.env.DEBUG) {
                        console.debug('Could not create config backup:', backupError.message);
                    }
                }
            }
            
            const configData = JSON.stringify(this._config, null, 2);
            fs.writeFileSync(configPath, configData, 'utf8');
            return true;
        } catch (error) {
            if (error instanceof ConfigError) {
                throw error;
            }
            
            if (error.code === 'EACCES' || error.code === 'EPERM') {
                throw new PermissionDeniedError(this.getConfigPath(), 'write');
            }
            
            throw new FileSystemError(
                `Failed to save configuration: ${error.message}`,
                this.getConfigPath(),
                'write',
                `Cannot save configuration file. Check permissions for: ${this.getConfigPath()}`
            );
        }
    }

    /**
     * Get configuration value by key (supports nested keys with dot notation)
     */
    get(key, defaultValue = undefined) {
        if (!this._config) {
            this.load();
        }
        
        if (!key) {
            return this._config;
        }
        
        // Support nested keys (e.g., 'api.endpoint')
        const keys = key.split('.');
        let value = this._config;
        
        for (const k of keys) {
            if (value && typeof value === 'object' && k in value) {
                value = value[k];
            } else {
                return defaultValue;
            }
        }
        
        return value;
    }

    /**
     * Set configuration value by key (supports nested keys with dot notation)
     */
    set(key, value) {
        if (!key || typeof key !== 'string') {
            throw new ValidationError('Configuration key must be a non-empty string', 'key', key);
        }
        
        if (!this._config) {
            this.load();
        }
        
        try {
            const keys = key.split('.');
            let current = this._config;
            
            // Navigate to the nested location
            for (let i = 0; i < keys.length - 1; i++) {
                const k = keys[i];
                if (!(k in current) || typeof current[k] !== 'object') {
                    current[k] = {};
                }
                current = current[k];
            }
            
            // Set the value
            const finalKey = keys[keys.length - 1];
            current[finalKey] = value;
            
            // Validate the updated config
            this._validateConfig(this._config);
            
            // Auto-save
            return this.save();
        } catch (error) {
            if (error instanceof ConfigError || error instanceof ValidationError) {
                throw error;
            }
            
            throw new ConfigError(
                `Failed to set configuration value '${key}': ${error.message}`,
                `Cannot set configuration value for '${key}'.`
            );
        }
    }

    /**
     * Delete configuration value by key
     */
    delete(key) {
        if (!key || typeof key !== 'string') {
            throw new ValidationError('Configuration key must be a non-empty string', 'key', key);
        }
        
        if (!this._config) {
            this.load();
        }
        
        try {
            const keys = key.split('.');
            let current = this._config;
            
            // Navigate to the parent of the key to delete
            for (let i = 0; i < keys.length - 1; i++) {
                const k = keys[i];
                if (!(k in current) || typeof current[k] !== 'object') {
                    return false; // Key doesn't exist
                }
                current = current[k];
            }
            
            const finalKey = keys[keys.length - 1];
            if (!(finalKey in current)) {
                return false; // Key doesn't exist
            }
            
            // Delete the key
            delete current[finalKey];
            
            // Validate the updated config
            this._validateConfig(this._config);
            
            // Auto-save
            return this.save();
        } catch (error) {
            if (error instanceof ConfigError || error instanceof ValidationError) {
                throw error;
            }
            
            throw new ConfigError(
                `Failed to delete configuration value '${key}': ${error.message}`,
                `Cannot delete configuration value for '${key}'.`
            );
        }
    }

    /**
     * Reset configuration to defaults
     */
    reset() {
        this._config = this.getDefaults();
        return this.save();
    }

    /**
     * Get default configuration
     */
    getDefaults() {
        return {
            version: '{{ version }}',
            {% if cli and cli.config_defaults %}
            ...{{ cli.config_defaults | json_stringify }}
            {% else %}
            // Add your default configuration here
            {% endif %}
        };
    }

    /**
     * Merge configuration with environment variables
     * Environment variables should be prefixed with {{ package_name | upper | replace('-', '_') }}_
     */
    mergeWithEnv() {
        try {
            const prefix = '{{ package_name | upper | replace("-", "_") }}_';
            const env = process.env;
            const envConfig = {};
            
            for (const key in env) {
                if (key.startsWith(prefix)) {
                    const configKey = key
                        .substring(prefix.length)
                        .toLowerCase()
                        .replace(/_/g, '.');
                    
                    if (!configKey) {
                        console.warn(`Invalid environment variable name: ${key}`);
                        continue;
                    }
                    
                    // Try to parse as JSON, fallback to string
                    let value = env[key];
                    try {
                        // Only try to parse if it looks like JSON
                        if (value.startsWith('{') || value.startsWith('[') || 
                            value === 'true' || value === 'false' || 
                            value === 'null' || !isNaN(value)) {
                            value = JSON.parse(value);
                        }
                    } catch (e) {
                        // Keep as string if JSON parsing fails
                    }
                    
                    envConfig[configKey] = value;
                }
            }
            
            // Apply environment overrides
            for (const [key, value] of Object.entries(envConfig)) {
                try {
                    this.set(key, value);
                } catch (error) {
                    console.warn(`Could not set environment config '${key}':`, error.message);
                }
            }
        } catch (error) {
            throw new ConfigError(
                `Failed to merge environment variables: ${error.message}`,
                'Could not apply environment variable overrides to configuration.'
            );
        }
    }
}

/**
 * Load configuration from RC files (.{{ package_name }}rc, .{{ package_name }}rc.json, .{{ package_name }}rc.yaml)
 */
class RCConfigLoader extends ConfigManager {
    constructor() {
        super();
        this.rcFileNames = [
            '.{{ package_name }}rc',
            '.{{ package_name }}rc.json',
            '.{{ package_name }}rc.yaml',
            '.{{ package_name }}rc.yml',
            '{{ package_name }}.config.js'
        ];
    }

    /**
     * Find RC file in current directory or parent directories
     */
    findRCFile(startDir = process.cwd()) {
        let currentDir = startDir;
        
        while (currentDir !== path.dirname(currentDir)) {
            for (const fileName of this.rcFileNames) {
                const filePath = path.join(currentDir, fileName);
                if (fs.existsSync(filePath)) {
                    return filePath;
                }
            }
            currentDir = path.dirname(currentDir);
        }
        
        return null;
    }

    /**
     * Load configuration from RC file
     */
    async loadRCFile() {
        const rcPath = this.findRCFile();
        if (!rcPath) {
            return null;
        }

        const ext = path.extname(rcPath);
        const content = fs.readFileSync(rcPath, 'utf8');

        try {
            if (ext === '.yaml' || ext === '.yml') {
                // Try to load yaml-js if available
                try {
                    const yaml = await import('js-yaml');
                    return yaml.default.load(content);
                } catch (e) {
                    console.warn('js-yaml not installed. Install it to use YAML config files.');
                    return null;
                }
            } else if (ext === '.js') {
                // Dynamic import for JS config
                const configModule = await import(rcPath);
                return configModule.default || configModule;
            } else {
                // Try JSON parse
                return JSON.parse(content);
            }
        } catch (error) {
            console.error(`Error loading RC file ${rcPath}: ${error.message}`);
            return null;
        }
    }

    /**
     * Enhanced load method that checks RC files first
     */
    async load() {
        // First try RC file
        const rcConfig = await this.loadRCFile();
        if (rcConfig) {
            this._config = { ...this.getDefaults(), ...rcConfig };
            return this._config;
        }

        // Fall back to regular config file
        return super.load();
    }
}

// Export singleton instance
const configManager = new RCConfigLoader();
export default configManager;

// Also export the class for advanced usage
export { ConfigManager, RCConfigLoader };