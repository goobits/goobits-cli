/**
 * Auto-generated test for {{ cmd_name }} command
 * Testing {{ display_name }}
 */

import { test, describe, it, before, after } from 'node:test';
import assert from 'node:assert';
import { spawn } from 'node:child_process';
import { promisify } from 'node:util';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const execCommand = promisify((cmd, args, callback) => {
  const child = spawn(cmd, args, { encoding: 'utf8' });
  let stdout = '';
  let stderr = '';
  
  child.stdout.on('data', (data) => {
    stdout += data;
  });
  
  child.stderr.on('data', (data) => {
    stderr += data;
  });
  
  child.on('close', (code) => {
    callback(null, { stdout, stderr, code });
  });
  
  child.on('error', callback);
});

describe('{{ cmd_name }} command', () => {
  const cliPath = join(__dirname, '..', '..', 'bin', 'cli.js');
  
  before(() => {
    // Setup before tests
    console.log('Testing {{ cmd_name }} command...');
  });
  
  after(() => {
    // Cleanup after tests
  });
  
  it('should run without errors', async () => {
    const { stdout, stderr, code } = await execCommand('node', [cliPath, '{{ cmd_name }}', '--help']);
    
    assert.strictEqual(code, 0, `Command exited with code ${code}`);
    assert.ok(stdout.includes('{{ cmd_data.desc }}'), 'Command description not found in help output');
  });
  
  {% if cmd_data.args %}
  it('should handle required arguments', async () => {
    {% for arg in cmd_data.args %}
    {% if arg.required %}
    // Test missing required argument: {{ arg.name }}
    const { stderr: missingArgErr, code: missingArgCode } = await execCommand('node', [cliPath, '{{ cmd_name }}']);
    assert.notStrictEqual(missingArgCode, 0, 'Command should fail when required argument is missing');
    {% endif %}
    {% endfor %}
  });
  {% endif %}
  
  {% if cmd_data.options %}
  it('should handle command options', async () => {
    const testArgs = [cliPath, '{{ cmd_name }}'];
    
    {% for arg in cmd_data.args %}
    {% if arg.required %}
    testArgs.push('test-{{ arg.name }}');
    {% endif %}
    {% endfor %}
    
    {% for opt in cmd_data.options %}
    {% if opt.type == 'flag' %}
    // Test flag option: --{{ opt.name }}
    const { code: flagCode } = await execCommand('node', [...testArgs, '--{{ opt.name }}']);
    assert.strictEqual(flagCode, 0, 'Command should handle flag option --{{ opt.name }}');
    {% else %}
    // Test option with value: --{{ opt.name }}
    const { code: optCode } = await execCommand('node', [...testArgs, '--{{ opt.name }}', 'test-value']);
    assert.strictEqual(optCode, 0, 'Command should handle option --{{ opt.name }} with value');
    {% endif %}
    {% endfor %}
  });
  {% endif %}
  
  {% if cmd_data.subcommands %}
  describe('subcommands', () => {
    {% for subcmd_name, subcmd_data in cmd_data.subcommands.items() %}
    it('should run {{ subcmd_name }} subcommand', async () => {
      const { stdout, code } = await execCommand('node', [cliPath, '{{ cmd_name }}', '{{ subcmd_name }}', '--help']);
      
      assert.strictEqual(code, 0, `Subcommand {{ subcmd_name }} exited with code ${code}`);
      assert.ok(stdout.includes('{{ subcmd_data.desc }}'), 'Subcommand description not found in help output');
    });
    {% endfor %}
  });
  {% endif %}
  
  it('should integrate with hooks when available', async () => {
    // This test would require mocking the hooks module
    // For now, just verify the command structure
    const { stdout } = await execCommand('node', [cliPath, '{{ cmd_name }}', '--help']);
    assert.ok(stdout.length > 0, 'Help output should not be empty');
  });
});