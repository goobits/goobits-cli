/**
 * Auto-generated test for {{ cmd_name }} command
 * Testing {{ display_name }}
 */

// Support both Jest and Node.js test runner
let describe, test, it, beforeAll, afterAll, beforeEach, afterEach, expect;

try {
  // Try Jest first
  const jestGlobals = await import('@jest/globals');
  ({ describe, test, it, beforeAll, afterAll, beforeEach, afterEach, expect } = jestGlobals);
} catch {
  // Fallback to Node.js test runner
  const nodeTest = await import('node:test');
  const assert = await import('node:assert');
  
  ({ describe, test, it } = nodeTest);
  beforeAll = nodeTest.before;
  afterAll = nodeTest.after;
  beforeEach = nodeTest.beforeEach;
  afterEach = nodeTest.afterEach;
  
  // Create expect-like interface for Node.js assert
  expect = (actual) => ({
    toBe: (expected) => assert.strictEqual(actual, expected),
    toEqual: (expected) => assert.deepStrictEqual(actual, expected),
    toContain: (expected) => assert.ok(actual.includes(expected)),
    toBeTruthy: () => assert.ok(actual),
    toBeFalsy: () => assert.ok(!actual),
    toBeGreaterThan: (expected) => assert.ok(actual > expected),
    toBeLessThan: (expected) => assert.ok(actual < expected)
  });
}

import { spawn } from 'child_process';
import { promisify } from 'util';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

const execCommand = promisify((cmd, args, callback) => {
  const child = spawn(cmd, args, { encoding: 'utf8' });
  let stdout = '';
  let stderr = '';
  
  child.stdout.on('data', (data) => {
    stdout += data;
  });
  
  child.stderr.on('data', (data) => {
    stderr += data;
  });
  
  child.on('close', (code) => {
    callback(null, { stdout, stderr, code });
  });
  
  child.on('error', callback);
});

describe('{{ cmd_name }} command', () => {
  const cliPath = join(__dirname, '..', '..', 'bin', 'cli.js');
  
  beforeAll(() => {
    // Setup before tests
    console.log('Testing {{ cmd_name }} command...');
  });
  
  afterAll(() => {
    // Cleanup after tests
  });
  
  it('should run without errors', async () => {
    const { stdout, stderr, code } = await execCommand('node', [cliPath, '{{ cmd_name }}', '--help']);
    
    expect(code).toBe(0);
    expect(stdout).toContain('{{ cmd_data.desc }}');
  });
  
  {% if cmd_data.args %}
  it('should handle required arguments', async () => {
    {% for arg in cmd_data.args %}
    {% if arg.required %}
    // Test missing required argument: {{ arg.name }}
    const { stderr: missingArgErr, code: missingArgCode } = await execCommand('node', [cliPath, '{{ cmd_name }}']);
    expect(missingArgCode).not.toBe(0);
    {% endif %}
    {% endfor %}
  });
  {% endif %}
  
  {% if cmd_data.options %}
  it('should handle command options', async () => {
    const testArgs = [cliPath, '{{ cmd_name }}'];
    
    {% for arg in cmd_data.args %}
    {% if arg.required %}
    testArgs.push('test-{{ arg.name }}');
    {% endif %}
    {% endfor %}
    
    {% for opt in cmd_data.options %}
    {% if opt.type == 'flag' %}
    // Test flag option: --{{ opt.name }}
    const { code: flagCode } = await execCommand('node', [...testArgs, '--{{ opt.name }}']);
    expect(flagCode).toBe(0);
    {% else %}
    // Test option with value: --{{ opt.name }}
    const { code: optCode } = await execCommand('node', [...testArgs, '--{{ opt.name }}', 'test-value']);
    expect(optCode).toBe(0);
    {% endif %}
    {% endfor %}
  });
  {% endif %}
  
  {% if cmd_data.subcommands %}
  describe('subcommands', () => {
    {% for subcmd_name, subcmd_data in cmd_data.subcommands.items() %}
    it('should run {{ subcmd_name }} subcommand', async () => {
      const { stdout, code } = await execCommand('node', [cliPath, '{{ cmd_name }}', '{{ subcmd_name }}', '--help']);
      
      expect(code).toBe(0);
      expect(stdout).toContain('{{ subcmd_data.desc }}');
    });
    {% endfor %}
  });
  {% endif %}
  
  it('should integrate with hooks when available', async () => {
    // This test would require mocking the hooks module
    // For now, just verify the command structure
    const { stdout } = await execCommand('node', [cliPath, '{{ cmd_name }}', '--help']);
    expect(stdout.length).toBeGreaterThan(0);
  });
});