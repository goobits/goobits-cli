/**
 * ╔════════════════════════════════════════════════════════════════════════════╗
 * ║                        AUTO-GENERATED FILE                               ║
 * ║  Generated by: goobits-cli v{{ version or '3.0.0' }}                     ║
 * ║  ⚠️  DO NOT EDIT - Changes will be overwritten                           ║
 * ╚════════════════════════════════════════════════════════════════════════════╝
 * 
 * Main CLI implementation for {{ display_name }}
 * Generated from: {{ file_name }}
 */

import { Command } from 'commander';
import chalk from 'chalk';
import { readdir } from 'fs/promises';
import { fileURLToPath } from 'url';
import { dirname, join } from 'path';
import { existsSync } from 'fs';

// Import error handling utilities
import { 
  setupGlobalErrorHandlers, 
  handleError, 
  asyncErrorHandler,
  ConfigError,
  PluginLoadError,
  CommandNotFoundError,
  CLIError
} from './lib/errors.js';

// Structured logging setup (initialized lazily)
let logger = null;

async function initializeLogger() {
    if (logger) return logger;
    
    try {
        const loggerModule = await import('./lib/logger.js');
        logger = loggerModule.getLogger('index');
    } catch (e) {
        // Fallback to console if logger not available
        logger = {
            debug: (msg, meta) => console.debug(`DEBUG: ${msg}`, meta ? JSON.stringify(meta) : ''),
            info: (msg, meta) => console.log(`INFO: ${msg}`, meta ? JSON.stringify(meta) : ''),
            warn: (msg, meta) => console.warn(`WARN: ${msg}`, meta ? JSON.stringify(meta) : ''),
            error: (msg, meta) => console.error(`ERROR: ${msg}`, meta ? JSON.stringify(meta) : ''),
            setContext: () => {},
            clearContext: () => {},
            updateContext: () => {},
            getContext: () => ({}),
            removeContextKeys: () => {}
        };
    }
    
    return logger;
}

// Get logger (with lazy initialization)
async function getLogger() {
    if (!logger) {
        logger = await initializeLogger();
    }
    return logger;
}
{% set npm_packages = [] %}
{% if installation and installation.extras and installation.extras.npm %}
{% for pkg in installation.extras.npm %}
{% set _ = npm_packages.append(pkg.split('@')[0]) %}
{% endfor %}
{% endif %}
{% if 'inquirer' in npm_packages %}
import inquirer from 'inquirer';
{% endif %}
{% if 'ora' in npm_packages %}
import ora from 'ora';
{% endif %}

const __filename = fileURLToPath(import.meta.url);
const __dirname = dirname(__filename);

// Setup global error handlers
const globalErrorHandler = setupGlobalErrorHandlers({
  showStack: process.env.NODE_ENV === 'development' || process.env.DEBUG,
  colorize: true,
  exitOnError: true
});

// Load configuration if config module exists
let config = null;
try {
  const configModule = await import('./lib/config.js');
  config = configModule.default;
  await config.load();
} catch (error) {
  // Config module not available or error loading
  const log = await getLogger();
  log.debug('Config module not loaded', { error: error.message });
  // Don't exit on config load failure during initialization
}

// Create the main program
const program = new Command();

// Version helper function
const getVersion = asyncErrorHandler(async function getVersion() {
  try {
    const packagePath = join(__dirname, 'package.json');
    const { default: pkg } = await import(packagePath, { assert: { type: 'json' } });
    return pkg.version;
  } catch (error) {
    const log = await getLogger();
    log.debug('Could not load version from package.json', { error: error.message });
    return '{{ version | default("1.0.0") }}';
  }
});

// Hooks system - try to import app_hooks module
let appHooks = null;
{% if hooks_path %}
// Using configured hooks path: {{ hooks_path }}
try {
  const hooksPath = join(__dirname, '{{ hooks_path }}');
  if (existsSync(hooksPath)) {
    appHooks = await import(hooksPath);
  }
} catch (error) {
  // No hooks module found, use default behavior
  const log = await getLogger();
  log.debug('Hooks module not found', { error: error.message, hookPath: '{{ hooks_path }}' });
}
{% else %}
// No hooks path configured, try default locations
try {
  const hooksPath = join(__dirname, 'app_hooks.js');
  if (existsSync(hooksPath)) {
    appHooks = await import(hooksPath);
  }
} catch (error) {
  // No hooks module found, use default behavior
  const log = await getLogger();
  log.debug('Hooks module not found', { error: error.message, hookPath: 'app_hooks.js' });
}
{% endif %}

// Load commands dynamically from commands directory
const loadCommands = asyncErrorHandler(async function loadCommands(program) {
  const commandsDir = join(__dirname, 'commands');
  
  try {
    if (!existsSync(commandsDir)) {
      const log = await getLogger();
      log.debug('Commands directory not found', { commandsDir });
      return;
    }
    
    const files = await readdir(commandsDir);
    let loadedCount = 0;
    
    for (const file of files) {
      if (file.endsWith('.js') && !file.startsWith('_')) {
        try {
          const commandPath = join(commandsDir, file);
          const { default: commandModule } = await import(commandPath);
          
          if (typeof commandModule === 'function') {
            commandModule(program);
            loadedCount++;
          } else if (commandModule.register) {
            commandModule.register(program);
            loadedCount++;
          } else {
            console.warn(chalk.yellow(`Warning: Command file ${file} does not export a function or register method`));
          }
        } catch (error) {
          const commandError = new CLIError(`Failed to load command ${file}: ${error.message}`, 'COMMAND_LOAD_ERROR');
          console.error(chalk.red(commandError.getUserMessage()));
          const log = await getLogger();
          log.debug('Command load error stack trace', { file, stack: error.stack });
        }
      }
    }
    
    if (loadedCount > 0) {
      const log = await getLogger();
      log.debug('Commands loaded from directory', { loadedCount, commandsDir });
    }
  } catch (error) {
    throw new CLIError(`Could not load commands directory: ${error.message}`, 'COMMANDS_DIR_ERROR');
  }
});

// Enhanced plugin loading with PluginManager
const loadPlugins = asyncErrorHandler(async function loadPlugins(program) {
  try {
    // Try to use enhanced plugin manager
    const { PluginManager } = await import('./lib/plugin-manager.js');
    const pluginManager = new PluginManager(program);
    
    const loadedCount = await pluginManager.loadAllPlugins();
    if (loadedCount > 0) {
      const log = await getLogger();
      log.debug('Plugins loaded via enhanced manager', { loadedCount });
    }
    
    // Store plugin manager on program for later use
    program.pluginManager = pluginManager;
    
  } catch (error) {
    const log = await getLogger();
    log.debug('Enhanced plugin manager not available, falling back to basic loading', { error: error.message });
    
    // Fallback to basic plugin loading
    const pluginDirs = [
      // User-specific plugin directory
      join(process.env.HOME || '', '.config', 'goobits', '{{ cli.name }}', 'plugins'),
      // Local plugin directory
      join(__dirname, 'plugins'),
    ];
    
    let totalLoaded = 0;
    
    for (const pluginDir of pluginDirs) {
      try {
        if (!existsSync(pluginDir)) {
          continue;
        }
        
        const files = await readdir(pluginDir);
        
        for (const file of files) {
          if (file.endsWith('.js') && !file.startsWith('_')) {
            try {
              const pluginPath = join(pluginDir, file);
              const { default: pluginModule } = await import(pluginPath);
              
              if (typeof pluginModule === 'function') {
                pluginModule(program);
                totalLoaded++;
                const log = await getLogger();
                log.debug('Plugin loaded successfully', { plugin: file, type: 'function' });
              } else if (pluginModule.register) {
                pluginModule.register(program);
                totalLoaded++;
                const log = await getLogger();
                log.debug('Plugin loaded successfully', { plugin: file, type: 'register' });
              } else {
                console.warn(chalk.yellow(`Warning: Plugin ${file} does not export a function or register method`));
              }
            } catch (pluginError) {
              const error = new PluginLoadError(file, pluginError);
              console.error(chalk.red(error.getUserMessage()));
              const log = await getLogger();
              log.debug('Plugin load error stack trace', { plugin: file, stack: pluginError.stack });
            }
          }
        }
      } catch (dirError) {
        // Plugin directory doesn't exist or can't be read
        const log = await getLogger();
        log.debug('Could not access plugin directory', { pluginDir, error: dirError.message });
      }
    }
    
    if (totalLoaded > 0) {
      const log = await getLogger();
      log.debug('Plugins loaded via fallback loading', { totalLoaded });
    }
  }
});

{% if cli and (cli.enable_upgrade_command is not defined or cli.enable_upgrade_command) %}
// Built-in upgrade command
async function builtinUpgradeCommand(options) {
  const { execSync } = await import('child_process');
  const packageName = '{{ package_name }}';
  const displayName = '{{ display_name }}';
  
  console.log(chalk.blue(`Current version: ${await getVersion()}`));
  
  if (options.check) {
    console.log(chalk.yellow(`Checking for updates to ${displayName}...`));
    console.log('Update check not yet implemented. Run without --check to upgrade.');
    return;
  }
  
  if (options.dryRun) {
    console.log(chalk.gray(`Dry run - would execute: npm install -g ${packageName}`));
    return;
  }
  
  console.log(chalk.blue(`Upgrading ${displayName}...`));
  
  try {
    let cmd = `npm install -g ${packageName}`;
    if (options.version) {
      cmd = `npm install -g ${packageName}@${options.version}`;
    } else if (options.pre) {
      cmd = `npm install -g ${packageName}@next`;
    }
    
    execSync(cmd, { stdio: 'inherit' });
    console.log(chalk.green(`✅ ${displayName} upgraded successfully!`));
    console.log(chalk.gray(`Run '{{ command_name }} --version' to verify the new version.`));
  } catch (error) {
    const upgradeError = new CLIError(
      `Upgrade failed: ${error.message}`,
      'UPGRADE_ERROR',
      `Failed to upgrade ${displayName}. Please check your network connection and permissions.`,
      1
    );
    handleError(upgradeError);
  }
}
{% endif %}

// Shell completion generation function
async function generateCompletion(shell) {
  try {
    const completionsDir = join(__dirname, 'completions');
    let templateFile;
    
    switch (shell) {
      case 'bash':
        templateFile = join(completionsDir, 'bash-completion');
        break;
      case 'zsh':
        templateFile = join(completionsDir, 'zsh-completion');
        break;
      case 'fish':
        templateFile = join(completionsDir, 'fish-completion');
        break;
      default:
        console.error(chalk.red(`Unknown shell: ${shell}`));
        return;
    }
    
    if (existsSync(templateFile)) {
      const { readFile } = await import('fs/promises');
      const completionScript = await readFile(templateFile, 'utf8');
      console.log(completionScript);
    } else {
      // Generate dynamic completion based on current commands
      generateDynamicCompletion(shell);
    }
  } catch (error) {
    console.error(chalk.red(`Failed to generate ${shell} completion:`, error.message));
    generateDynamicCompletion(shell);
  }
}

// Generate dynamic completion when template files are not available
function generateDynamicCompletion(shell) {
  const commands = program.commands.map(cmd => cmd.name()).join(' ');
  
  switch (shell) {
    case 'bash':
      console.log(`# Basic bash completion for {{ command_name }}
_{{ command_name | replace('-', '_') }}_completions() {
    local cur prev words cword
    _init_completion || return
    
    case "\${prev}" in
        {{ command_name }})
            COMPREPLY=($(compgen -W "${commands}" -- "$cur"))
            return 0
            ;;
        --help|-h|--version|-V)
            return 0
            ;;
        *)
            COMPREPLY=($(compgen -W "--help -h --version -V" -- "$cur"))
            return 0
            ;;
    esac
}

complete -F _{{ command_name | replace('-', '_') }}_completions {{ command_name }}`);
      break;
      
    case 'zsh':
      console.log(`#compdef {{ command_name }}
# Basic zsh completion for {{ command_name }}
_{{ command_name | replace('-', '_') }}() {
    local commands=(
        ${commands.split(' ').map(cmd => `'${cmd}:${cmd} command'`).join('\n        ')}
    )
    
    _arguments \\
        '(-h --help)'{-h,--help}'[Show help information]' \\
        '(-V --version)'{-V,--version}'[Show version information]' \\
        '1: :_describe "commands" commands' \\
        '*::arg:->args'
}

_{{ command_name | replace('-', '_') }} "$@"`);
      break;
      
    case 'fish':
      console.log(`# Basic fish completion for {{ command_name }}
complete -c {{ command_name }} -f
complete -c {{ command_name }} -l help -s h -d 'Show help information'
complete -c {{ command_name }} -l version -s V -d 'Show version information'

${commands.split(' ').map(cmd => 
  `complete -c {{ command_name }} -n '__fish_use_subcommand' -a ${cmd} -d '${cmd} command'`
).join('\n')}`);
      break;
  }
}

// Main CLI setup
export const cli = asyncErrorHandler(async function cli() {
  const version = await getVersion();
  
  program
    .name('{{ cli.name }}')
    .description(`{{ cli.tagline }}{% if cli.description %}\n\n{{ cli.description }}{% endif %}`)
    .version(version)
    .helpOption('-h, --help', 'Display help for command')
    .addHelpCommand('help [command]', 'Display help for command');

  // Configure help formatting
  program.configureHelp({
    sortSubcommands: true,
    subcommandTerm: (cmd) => cmd.name() + ' ' + cmd.usage(),
  });

  // Global options
  {% if cli.options %}
  {% for option in cli.options %}
  program
    .option(
      '{% if option.short %}-{{ option.short }}, {% endif %}--{{ option.name }}{% if option.type != "flag" %}{% if option.default is not none %} [{{ option.type }}]{% else %} <{{ option.type }}>{% endif %}{% endif %}',
      '{{ option.desc }}'
      {%- if option.default is not none %},
      {% if option.default is sameas true %}true{% elif option.default is sameas false %}false{% elif option.default is number %}{{ option.default }}{% else %}'{{ option.default }}'{% endif %}
      {%- endif %}
    );
  {% endfor %}
  {% endif %}

  // Interactive mode option
  program
    .option('--interactive', 'Launch interactive mode for running commands interactively')
    .on('option:interactive', async () => {
      try {
        // Try to import enhanced interactive mode
        const { startEnhancedInteractive } = await import('./enhanced_interactive_mode.js');
        startEnhancedInteractive();
      } catch (error) {
        try {
          // Fallback to basic interactive mode
          const { runInteractive } = await import('./interactive_mode.js');
          runInteractive();
        } catch (fallbackError) {
          console.error(chalk.red('❌ Interactive mode not available. Missing interactive mode modules.'));
          process.exit(1);
        }
      }
      process.exit(0);
    });

  {% if cli.enable_help_json %}
  // Add --help-json option
  program
    .option('--help-json', 'Output CLI structure as JSON', false)
    .on('option:help-json', () => {
      const cliConfig = {{ cli | json_stringify | safe }};
      console.log(JSON.stringify(cliConfig, null, 2));
      process.exit(0);
    });
  {% endif %}

  // Shell completion support
  program
    .option('--completion-bash', 'Generate bash completion script', false)
    .option('--completion-zsh', 'Generate zsh completion script', false)  
    .option('--completion-fish', 'Generate fish completion script', false)
    .on('option:completion-bash', async () => {
      await generateCompletion('bash');
      process.exit(0);
    })
    .on('option:completion-zsh', async () => {
      await generateCompletion('zsh');
      process.exit(0);
    })
    .on('option:completion-fish', async () => {
      await generateCompletion('fish');
      process.exit(0);
    });

  // Internal completion command (hidden from help)
  const builtin_completionCmd = program
    .command('_completion <shell> <current_line> [cursor_pos]', { hidden: true })
    .option('--debug', 'Debug completion engine')
    .action(async (shell, currentLine, cursorPos, options) => {
      try {
        // Import completion engine
        const enginePath = join(__dirname, 'completion_engine.js');
        
        if (existsSync(enginePath)) {
          const { CompletionEngine } = await import(enginePath);
          const engine = new CompletionEngine();
          const completions = engine.getCompletions(shell, currentLine, cursorPos ? parseInt(cursorPos) : null);
          
          // Output completions
          for (const completion of completions) {
            console.log(completion);
          }
        } else if (options.debug) {
          const log = await getLogger();
          log.warn('completion_engine.js not found');
        }
      } catch (error) {
        if (options.debug) {
          const log = await getLogger();
          log.error('Completion error', { error: error.message });
        }
        // Silently fail in production to avoid breaking shell completion
      }
    });

  {% if cli.enable_recursive_help %}
  // Add --help-all option
  program
    .option('--help-all', 'Show help for all commands', false)
    .on('option:help-all', () => {
      console.log(program.helpInformation());
      console.log('\n' + chalk.bold('All Commands:') + '\n');
      
      program.commands.forEach(cmd => {
        console.log(chalk.yellow('='.repeat(50)));
        console.log(chalk.bold(`Command: ${cmd.name()}`));
        console.log(cmd.helpInformation());
      });
      
      process.exit(0);
    });
  {% endif %}

  // Built-in commands
  {% if cli and (cli.enable_upgrade_command is not defined or cli.enable_upgrade_command) %}
  program
    .command('upgrade')
    .description('Upgrade {{ display_name }} to the latest version')
    .option('--check', 'Check for updates without installing')
    .option('--version <version>', 'Install specific version')
    .option('--pre', 'Include pre-release versions')
    .option('--dry-run', 'Show what would be done without doing it')
    .action(builtinUpgradeCommand);
  {% endif %}

  // Enhanced plugin management command
  try {
    const { default: registerPluginCommand } = await import('./commands/builtin/plugin.js');
    registerPluginCommand(program);
  } catch (error) {
    const log = await getLogger();
    log.debug('Plugin command not available', { error: error.message });
  }

  // Shell completion command
  try {
    const { default: registerCompletionCommand } = await import('./commands/builtin/completion.js');
    registerCompletionCommand(program);
  } catch (error) {
    const log = await getLogger();
    log.debug('Completion command not available', { error: error.message });
  }

  // Format demo command (optional - for demonstration)
  try {
    const { default: registerFormatDemoCommand } = await import('./commands/builtin/format-demo.js');
    registerFormatDemoCommand(program);
  } catch (error) {
    const log = await getLogger();
    log.debug('Format demo command not available', { error: error.message });
  }

  // Define commands from configuration
  {% for cmd_name, cmd_data in cli.commands.items() %}
  {% if not cmd_data.subcommands %}
  {
    const cmd = program
      .command('{{ cmd_name }}'{% if cmd_data.is_default %}, { isDefault: true }{% endif %})
      .description('{% if cmd_data.icon %}{{ cmd_data.icon }} {% endif %}{{ cmd_data.desc }}')
      {% if cmd_data.alias %}
      .alias('{{ cmd_data.alias }}')
      {% endif %};

    {% if cmd_data.args %}
    {% for arg in cmd_data.args %}
    cmd.argument(
      '{% if arg.required %}<{{ arg.name }}>{% else %}[{{ arg.name }}]{% endif %}',
      '{{ arg.desc }}'
      {%- if arg.choices %},
      (value) => {
        const choices = {{ arg.choices | json_stringify }};
        if (!choices.includes(value)) {
          throw new Error(`Invalid {{ arg.name }} '${value}'. Choose from: ${choices.join(', ')}`);
        }
        return value;
      }
      {%- endif %}
    );
    {% endfor %}
    {% endif %}

    {% if cmd_data.options %}
    {% for opt in cmd_data.options %}
    cmd.option(
      '{% if opt.short %}-{{ opt.short }}, {% endif %}--{{ opt.name }}{% if opt.type != "flag" %}{% if opt.default is not none %} [{{ opt.type }}]{% else %} <{{ opt.type }}>{% endif %}{% endif %}',
      '{{ opt.desc }}'
      {%- if opt.default is not none %},
      {% if opt.default is sameas true %}true{% elif opt.default is sameas false %}false{% elif opt.default is number %}{{ opt.default }}{% else %}'{{ opt.default }}'{% endif %}
      {%- endif %}
    );
    {% endfor %}
    {% endif %}

    cmd.action(async ({% if cmd_data.args %}{{ cmd_data.args | map(attribute='name') | join(', ') }}, {% endif %}options, command) => {
      {% if cmd_data.lifecycle == "managed" %}
      // Managed command - expect an instance of ManagedCommand
      const commandInstanceName = '{{ cmd_name }}Command';
      if (appHooks && appHooks[commandInstanceName]) {
        const commandInstance = appHooks[commandInstanceName];
        
        // Prepare arguments
        const args = {
          commandName: '{{ cmd_name }}',
          {% if cmd_data.args %}
          {% for arg in cmd_data.args %}
          {{ arg.name }}: {{ arg.name }},
          {% endfor %}
          {% endif %}
          ...options,
          // Add global options
          {% for option in cli.options %}
          {{ option.name | replace('-', '_') }}: command.parent.opts().{{ option.name | replace('-', '_') }},
          {% endfor %}
          // Add config if available
          config: config,
          // Add logger for structured logging
          logger: await getLogger()
        };
        
        try {
          const result = await commandInstance.execute(args);
          return result;
        } catch (error) {
          const commandError = error instanceof CLIError ? error : new CLIError(
            `Command '{{ cmd_name }}' execution failed: ${error.message}`,
            'COMMAND_EXECUTION_ERROR',
            `Failed to execute command '{{ cmd_name }}'. ${error.message}`,
            1
          );
          handleError(commandError);
        }
      } else {
        const missingCommandError = new CLIError(
          `Managed command '{{ cmd_name }}' requires '${commandInstanceName}' export in app_hooks.js`,
          'COMMAND_HOOK_MISSING',
          `Command '{{ cmd_name }}' is not properly configured. Missing '${commandInstanceName}' in app_hooks.js`,
          1
        );
        handleError(missingCommandError);
      }
      {% else %}
      // Standard command - use hook pattern
      const hookName = 'on{{ cmd_name | title | replace('-', '') }}';
      if (appHooks && appHooks[hookName]) {
        const hookFunc = appHooks[hookName];
        
        // Prepare arguments
        const args = {
          commandName: '{{ cmd_name }}',
          {% if cmd_data.args %}
          {% for arg in cmd_data.args %}
          {{ arg.name }}: {{ arg.name }},
          {% endfor %}
          {% endif %}
          ...options,
          // Add global options
          {% for option in cli.options %}
          {{ option.name | replace('-', '_') }}: command.parent.opts().{{ option.name | replace('-', '_') }},
          {% endfor %}
          // Add config if available
          config: config,
          // Add logger for structured logging
          logger: await getLogger()
        };
        
        try {
          const result = await hookFunc(args);
          return result;
        } catch (error) {
          const hookError = error instanceof CLIError ? error : new CLIError(
            `Hook function '${hookName}' failed: ${error.message}`,
            'HOOK_EXECUTION_ERROR',
            `Failed to execute command '{{ cmd_name }}'. ${error.message}`,
            1
          );
          handleError(hookError);
        }
      } else {
        // Default placeholder behavior
        {% if 'inquirer' in npm_packages and cmd_data.interactive %}
        // Interactive mode with inquirer
        const questions = [];
        {% if cmd_data.args %}
        {% for arg in cmd_data.args %}
        {% if not arg.required %}
        if (!{{ arg.name }}) {
          questions.push({
            type: 'input',
            name: '{{ arg.name }}',
            message: '{{ arg.desc }}:'
          });
        }
        {% endif %}
        {% endfor %}
        {% endif %}
        
        if (questions.length > 0) {
          const answers = await inquirer.prompt(questions);
          Object.assign(options, answers);
        }
        {% endif %}
        
        {% if 'ora' in npm_packages %}
        const spinner = ora(`Executing {{ cmd_name }} command...`).start();
        {% else %}
        console.log(chalk.blue(`Executing {{ cmd_name }} command...`));
        {% endif %}
        
        {% if cmd_data.args %}
        {% for arg in cmd_data.args %}
        console.log(`  {{ arg.name }}: ${ {{- arg.name -}} }`);
        {% endfor %}
        {% endif %}
        console.log('Options:', options);
        
        {% if 'ora' in npm_packages %}
        // Simulate work
        await new Promise(resolve => setTimeout(resolve, 1000));
        spinner.succeed('Command completed successfully!');
        {% endif %}
      }
      {% endif %}
    });
  }
  {% else %}
  {
    // Command with subcommands
    const parentCmd = program
      .command('{{ cmd_name }}')
      .description('{% if cmd_data.icon %}{{ cmd_data.icon }} {% endif %}{{ cmd_data.desc }}');

    {% for subcmd_name, subcmd_data in cmd_data.subcommands.items() %}
    {
      const subCmd = parentCmd
        .command('{{ subcmd_name }}')
        .description('{% if subcmd_data.icon %}{{ subcmd_data.icon }} {% endif %}{{ subcmd_data.desc }}');

      {% if subcmd_data.args %}
      {% for arg in subcmd_data.args %}
      subCmd.argument(
        '{% if arg.required %}<{{ arg.name }}>{% else %}[{{ arg.name }}]{% endif %}',
        '{{ arg.desc }}'
        {%- if arg.choices %},
        (value) => {
          const choices = {{ arg.choices | json_stringify }};
          if (!choices.includes(value)) {
            throw new Error(`Invalid {{ arg.name }} '${value}'. Choose from: ${choices.join(', ')}`);
          }
          return value;
        }
        {%- endif %}
      );
      {% endfor %}
      {% endif %}

      {% if subcmd_data.options %}
      {% for opt in subcmd_data.options %}
      subCmd.option(
        '{% if opt.short %}-{{ opt.short }}, {% endif %}--{{ opt.name }}{% if opt.type != "flag" %} <{{ opt.type }}>{% endif %}',
        '{{ opt.desc }}'
        {%- if opt.default is not none %},
        {% if opt.default is sameas true %}true{% elif opt.default is sameas false %}false{% elif opt.default is number %}{{ opt.default }}{% else %}'{{ opt.default }}'{% endif %}
        {%- endif %}
      );
      {% endfor %}
      {% endif %}

      subCmd.action(async ({% if subcmd_data.args %}{{ subcmd_data.args | map(attribute='name') | join(', ') }}, {% endif %}options, command) => {
        const hookName = 'on{{ cmd_name | title | replace('-', '') }}{{ subcmd_name | title | replace('-', '') }}';
        if (appHooks && appHooks[hookName]) {
          const hookFunc = appHooks[hookName];
          
          // Prepare arguments
          const args = {
            commandName: '{{ subcmd_name }}',
            {% if subcmd_data.args %}
            {% for arg in subcmd_data.args %}
            {{ arg.name }}: {{ arg.name }},
            {% endfor %}
            {% endif %}
            ...options,
            // Add global options
            {% for option in cli.options %}
            {{ option.name | replace('-', '_') }}: command.parent.parent.opts().{{ option.name | replace('-', '_') }},
            {% endfor %}
            // Add config if available
            config: config,
            // Add logger for structured logging
            logger: await getLogger()
          };
          
          try {
            const result = await hookFunc(args);
            return result;
          } catch (error) {
            const subcommandError = error instanceof CLIError ? error : new CLIError(
              `Subcommand hook '${hookName}' failed: ${error.message}`,
              'SUBCOMMAND_EXECUTION_ERROR',
              `Failed to execute subcommand '{{ subcmd_name }}'. ${error.message}`,
              1
            );
            handleError(subcommandError);
          }
        } else {
          // Default placeholder behavior
          {% if 'ora' in npm_packages %}
          const spinner = ora(`Executing {{ subcmd_name }} subcommand...`).start();
          {% else %}
          console.log(chalk.blue(`Executing {{ subcmd_name }} subcommand...`));
          {% endif %}
          
          {% if subcmd_data.args %}
          {% for arg in subcmd_data.args %}
          console.log(`  {{ arg.name }}: ${ {{- arg.name -}} }`);
          {% endfor %}
          {% endif %}
          console.log('Options:', options);
          
          {% if 'ora' in npm_packages %}
          // Simulate work
          await new Promise(resolve => setTimeout(resolve, 1000));
          spinner.succeed('Subcommand completed successfully!');
          {% endif %}
        }
      });
    }
    {% endfor %}
  }
  {% endif %}
  {% endfor %}

  // Load dynamic commands from commands directory
  await loadCommands(program);
  
  // Load plugins
  await loadPlugins(program);

  {% if cli.command_groups %}
  // Command groups for help display
  program.addHelpText('after', '\n' + chalk.bold('Command Groups:'));
  {% for group in cli.command_groups %}
  program.addHelpText('after', `\n${chalk.yellow('{{ group.name }}:')}`);
  {% for cmd_name in group.commands %}
  {% if cmd_name in cli.commands %}
  const {{ cmd_name }}Cmd = program.commands.find(c => c.name() === '{{ cmd_name }}');
  if ({{ cmd_name }}Cmd) {
    program.addHelpText('after', `  ${ {{- cmd_name -}} Cmd.name().padEnd(15)} ${ {{- cmd_name -}} Cmd.description()}`);
  }
  {% endif %}
  {% endfor %}
  {% endfor %}
  {% endif %}

  {% if cli.header_sections %}
  // Add header sections to help
  let headerText = '';
  {% for section in cli.header_sections %}
  headerText += '\n' + chalk.bold.yellow('{{ section.title }}') + '\n';
  {% for item in section.items %}
  {% if item.style == 'example' %}
  headerText += chalk.green('  {{ item.item }}') + chalk.gray(' # {{ item.desc }}') + '\n';
  {% elif item.style == 'command' %}
  headerText += chalk.green('  {{ item.item }}') + '  {{ item.desc }}\n';
  {% elif item.style == 'setup' %}
  headerText += chalk.gray('  {{ item.item }}: ') + chalk.green('{{ item.desc }}') + '\n';
  {% endif %}
  {% endfor %}
  {% endfor %}
  program.addHelpText('before', headerText);
  {% endif %}

  {% if cli.footer_note %}
  // Add footer note
  program.addHelpText('after', '\n' + chalk.gray('{{ cli.footer_note }}'));
  {% endif %}

  // Parse arguments with error handling
  try {
    program.parse(process.argv);
    
    // Show help if no arguments provided and no default command
    {% set has_default = namespace(value=false) %}
    {% for cmd_name, cmd_data in cli.commands.items() %}
    {% if cmd_data.is_default %}
    {% set has_default.value = true %}
    {% endif %}
    {% endfor %}
    {% if not has_default.value %}
    if (!process.argv.slice(2).length) {
      program.outputHelp();
    }
    {% endif %}
  } catch (error) {
    // Handle commander.js parsing errors
    if (error.code === 'commander.unknownCommand') {
      const availableCommands = program.commands.map(cmd => cmd.name());
      const unknownCommand = error.message.match(/Unknown command '([^']+)'/)?.[1];
      throw new CommandNotFoundError(unknownCommand, availableCommands);
    }
    
    if (error.code === 'commander.invalidArgument') {
      throw new CLIError(
        error.message,
        'INVALID_ARGUMENT',
        error.message,
        2
      );
    }
    
    // Re-throw other commander errors as CLI errors
    throw new CLIError(
      error.message,
      'PARSE_ERROR',
      `Command line parsing error: ${error.message}`,
      2
    );
  }
});

// Export for use as a module
export default cli;

// Run CLI if this is the main module
if (import.meta.url === `file://${process.argv[1]}`) {
  cli().catch(error => {
    // Error handling is already set up in cli() function with asyncErrorHandler
    // This is a fallback for any errors that slip through
    const log = await getLogger();
    log.error('Unhandled CLI Error', { error: error.message, stack: error.stack });
    process.exit(error.exitCode || 1);
  });
}