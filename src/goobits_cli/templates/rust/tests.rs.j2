/**
 * Integration tests for {{ display_name }}
 * Auto-generated from {{ file_name }}
 */

#[cfg(test)]
mod integration_tests {
    use assert_cmd::Command;
    use predicates::prelude::*;
    use std::process::Command as StdCommand;
    use tempfile::TempDir;

    /// Test that the CLI binary can be executed
    #[test]
    fn test_cli_runs() {
        let mut cmd = Command::cargo_bin("{{ command_name }}").unwrap();
        cmd.assert().success();
    }

    /// Test help command
    #[test]
    fn test_help_command() {
        let mut cmd = Command::cargo_bin("{{ command_name }}").unwrap();
        cmd.arg("--help");
        cmd.assert()
            .success()
            .stdout(predicate::str::contains("{{ cli.tagline if cli.tagline else description }}"));
    }

    /// Test version command
    #[test]
    fn test_version_command() {
        let mut cmd = Command::cargo_bin("{{ command_name }}").unwrap();
        cmd.arg("--version");
        cmd.assert()
            .success()
            .stdout(predicate::str::contains("{{ version | default('1.0.0') }}"));
    }

    {% for cmd_name, cmd_data in cli.commands.items() %}
    {% if not cmd_data.subcommands %}
    /// Test {{ cmd_name }} command
    #[test]
    fn test_{{ cmd_name | replace('-', '_') }}_command() {
        let mut cmd = Command::cargo_bin("{{ command_name }}").unwrap();
        cmd.arg("{{ cmd_name }}");
        
        {% if cmd_data.args %}
        // Add required arguments for testing
        {% for arg in cmd_data.args %}
        {% if arg.required %}
        cmd.arg("test_{{ arg.name }}");
        {% endif %}
        {% endfor %}
        {% endif %}
        
        cmd.assert()
            .success()
            .stdout(predicate::str::contains("Executing {{ cmd_name }} command"));
    }

    /// Test {{ cmd_name }} command help
    #[test]
    fn test_{{ cmd_name | replace('-', '_') }}_help() {
        let mut cmd = Command::cargo_bin("{{ command_name }}").unwrap();
        cmd.args(&["{{ cmd_name }}", "--help"]);
        cmd.assert()
            .success()
            .stdout(predicate::str::contains("{{ cmd_data.desc }}"));
    }
    {% endif %}
    {% endfor %}

    /// Test invalid command
    #[test]
    fn test_invalid_command() {
        let mut cmd = Command::cargo_bin("{{ command_name }}").unwrap();
        cmd.arg("invalid-command-that-does-not-exist");
        cmd.assert()
            .failure();
    }

    /// Test configuration directory creation
    #[test]
    fn test_config_directory() {
        // This test would need to mock the home directory
        // For now, just test that the config module can be loaded
        use {{ package_name | replace('-', '_') }}::config::AppConfig;
        
        let config = AppConfig::default();
        assert_eq!(config.settings.version, "{{ version | default('1.0.0') }}");
        assert!(config.features.colored_output);
    }

    /// Test command argument validation
    #[test]
    fn test_command_validation() {
        use {{ package_name | replace('-', '_') }}::commands::{CommandArgs, create_command_registry};
        use {{ package_name | replace('-', '_') }}::config::AppConfig;
        use std::collections::HashMap;

        let registry = create_command_registry();
        let config = AppConfig::default();
        
        {% for cmd_name, cmd_data in cli.commands.items() %}
        {% if not cmd_data.subcommands and cmd_data.args %}
        // Test {{ cmd_name }} command validation
        {
            let mut args = CommandArgs {
                command: "{{ cmd_name }}".to_string(),
                subcommand: None,
                args: vec![],
                options: HashMap::new(),
                config: config.clone(),
            };
            
            {% for arg in cmd_data.args %}
            {% if arg.required %}
            // Should fail without required argument
            assert!(registry.execute("{{ cmd_name }}", &args).is_err());
            
            // Add required argument
            args.args.push("test_value".to_string());
            {% endif %}
            {% endfor %}
            
            // Should succeed with all required arguments
            assert!(registry.execute("{{ cmd_name }}", &args).is_ok());
        }
        {% endif %}
        {% endfor %}
    }

    /// Benchmark basic operations (requires nightly Rust)
    #[cfg(feature = "bench")]
    mod benchmarks {
        use super::*;
        use test::Bencher;

        #[bench]
        fn bench_cli_startup(b: &mut Bencher) {
            b.iter(|| {
                let mut cmd = Command::cargo_bin("{{ command_name }}").unwrap();
                cmd.arg("--help");
                cmd.assert().success();
            });
        }

        {% for cmd_name, cmd_data in cli.commands.items() %}
        {% if not cmd_data.subcommands %}
        #[bench]
        fn bench_{{ cmd_name | replace('-', '_') }}_command(b: &mut Bencher) {
            b.iter(|| {
                let mut cmd = Command::cargo_bin("{{ command_name }}").unwrap();
                cmd.arg("{{ cmd_name }}");
                {% if cmd_data.args %}
                {% for arg in cmd_data.args %}
                {% if arg.required %}
                cmd.arg("test_value");
                {% endif %}
                {% endfor %}
                {% endif %}
                cmd.assert().success();
            });
        }
        {% endif %}
        {% endfor %}
    }

    /// Property-based testing (requires proptest)
    #[cfg(feature = "proptest")]
    mod property_tests {
        use super::*;
        use proptest::prelude::*;

        proptest! {
            #[test]
            fn test_command_names_are_valid(name in r"[a-z][a-z0-9\-]*") {
                // Test that command names follow expected patterns
                let mut cmd = Command::cargo_bin("{{ command_name }}").unwrap();
                cmd.arg(&name);
                // We expect this to fail for random names, but shouldn't crash
                let result = cmd.assert();
            }
        }
    }
}