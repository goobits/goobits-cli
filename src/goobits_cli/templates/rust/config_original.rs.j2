/**
 * Configuration module for {{ display_name }}
 * Auto-generated from {{ file_name }}
 */

use anyhow::{Context, Result};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

/// Application configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    /// General settings
    pub settings: Settings,
    /// Feature flags
    pub features: Features,
    /// User preferences
    pub preferences: Preferences,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Settings {
    /// Application version
    pub version: String,
    /// Enable automatic updates
    pub auto_update: bool,
    /// Log level (debug, info, warn, error)
    pub log_level: String,
    /// Configuration file format (yaml, json, toml)
    pub config_format: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Features {
    /// Enable colored output
    pub colored_output: bool,
    /// Show progress bars
    pub progress_bars: bool,
    /// Enable interactive prompts
    pub interactive_mode: bool,
    /// Use Unicode symbols
    pub unicode_symbols: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Preferences {
    /// Default editor for file editing
    pub editor: Option<String>,
    /// Default output format
    pub output_format: String,
    /// Custom aliases for commands
    pub aliases: HashMap<String, String>,
    /// User-specific settings
    pub custom: HashMap<String, String>,
}

impl Default for AppConfig {
    fn default() -> Self {
        let mut aliases = HashMap::new();
        let mut custom = HashMap::new();
        
        // Add some default aliases if defined in goobits.yaml
        {% for cmd_name, cmd_data in cli.commands.items() %}
        {% if cmd_data.alias %}
        aliases.insert("{{ cmd_data.alias }}".to_string(), "{{ cmd_name }}".to_string());
        {% endif %}
        {% endfor %}
        
        Self {
            settings: Settings {
                version: "{{ version | default('1.0.0') }}".to_string(),
                auto_update: false,
                log_level: "info".to_string(),
                config_format: "yaml".to_string(),
            },
            features: Features {
                colored_output: true,
                progress_bars: true,
                interactive_mode: true,
                unicode_symbols: true,
            },
            preferences: Preferences {
                editor: None,
                output_format: "human".to_string(),
                aliases,
                custom,
            },
        }
    }
}

impl AppConfig {
    /// Load configuration from multiple possible locations and formats
    pub fn load() -> Result<Self> {
        // Search for configuration files in order of preference
        let search_paths = Self::get_config_search_paths()?;
        
        for (path, format) in search_paths {
            if path.exists() {
                let content = std::fs::read_to_string(&path)
                    .with_context(|| format!("Failed to read config file: {}", path.display()))?;
                
                let config = match format.as_str() {
                    "yaml" | "yml" => serde_yaml::from_str::<AppConfig>(&content)
                        .with_context(|| "Failed to parse YAML config file")?,
                    "json" => serde_json::from_str::<AppConfig>(&content)
                        .with_context(|| "Failed to parse JSON config file")?,
                    "toml" => toml::from_str::<AppConfig>(&content)
                        .with_context(|| "Failed to parse TOML config file")?,
                    _ => {
                        anyhow::bail!("Unsupported config format: {}", format);
                    }
                };
                
                return Ok(config);
            }
        }
        
        // No config file found, create default
        let config = Self::default();
        config.save()?;
        Ok(config)
    }
    
    /// Get search paths for configuration files in order of preference
    fn get_config_search_paths() -> Result<Vec<(PathBuf, String)>> {
        let mut paths = Vec::new();
        
        // 1. Current directory (highest priority)
        let current_dir = std::env::current_dir()?;
        paths.push((current_dir.join(".{{ package_name }}.yaml"), "yaml".to_string()));
        paths.push((current_dir.join(".{{ package_name }}.yml"), "yaml".to_string()));
        paths.push((current_dir.join(".{{ package_name }}.json"), "json".to_string()));
        paths.push((current_dir.join(".{{ package_name }}.toml"), "toml".to_string()));
        paths.push((current_dir.join("{{ package_name }}.yaml"), "yaml".to_string()));
        paths.push((current_dir.join("{{ package_name }}.yml"), "yaml".to_string()));
        paths.push((current_dir.join("{{ package_name }}.json"), "json".to_string()));
        paths.push((current_dir.join("{{ package_name }}.toml"), "toml".to_string()));
        
        // 2. User config directory
        let config_dir = Self::config_dir()?;
        paths.push((config_dir.join("config.yaml"), "yaml".to_string()));
        paths.push((config_dir.join("config.yml"), "yaml".to_string()));
        paths.push((config_dir.join("config.json"), "json".to_string()));
        paths.push((config_dir.join("config.toml"), "toml".to_string()));
        
        // 3. XDG config directory (Linux/Unix)
        if let Ok(xdg_config) = std::env::var("XDG_CONFIG_HOME") {
            let xdg_dir = PathBuf::from(xdg_config).join("{{ package_name }}");
            paths.push((xdg_dir.join("config.yaml"), "yaml".to_string()));
            paths.push((xdg_dir.join("config.yml"), "yaml".to_string()));
            paths.push((xdg_dir.join("config.json"), "json".to_string()));
            paths.push((xdg_dir.join("config.toml"), "toml".to_string()));
        }
        
        // 4. Home directory RC files
        if let Some(home_dir) = dirs::home_dir() {
            paths.push((home_dir.join(".{{ package_name }}rc"), "yaml".to_string()));
            paths.push((home_dir.join(".{{ package_name }}rc.yaml"), "yaml".to_string()));
            paths.push((home_dir.join(".{{ package_name }}rc.yml"), "yaml".to_string()));
            paths.push((home_dir.join(".{{ package_name }}rc.json"), "json".to_string()));
            paths.push((home_dir.join(".{{ package_name }}rc.toml"), "toml".to_string()));
        }
        
        // 5. System-wide config (Unix-like systems)
        #[cfg(unix)]
        {
            paths.push((PathBuf::from("/etc/{{ package_name }}/config.yaml"), "yaml".to_string()));
            paths.push((PathBuf::from("/etc/{{ package_name }}/config.yml"), "yaml".to_string()));
            paths.push((PathBuf::from("/etc/{{ package_name }}/config.json"), "json".to_string()));
            paths.push((PathBuf::from("/etc/{{ package_name }}/config.toml"), "toml".to_string()));
        }
        
        Ok(paths)
    }
    
    /// Save configuration to file
    pub fn save(&self) -> Result<()> {
        let config_path = Self::config_file_path()?;
        
        // Ensure config directory exists
        if let Some(parent) = config_path.parent() {
            std::fs::create_dir_all(parent)
                .with_context(|| format!("Failed to create config directory: {}", parent.display()))?;
        }
        
        let content = serde_yaml::to_string(self)
            .with_context(|| "Failed to serialize config")?;
        
        std::fs::write(&config_path, content)
            .with_context(|| format!("Failed to write config file: {}", config_path.display()))?;
        
        Ok(())
    }
    
    /// Get the path to the configuration file
    pub fn config_file_path() -> Result<PathBuf> {
        let config_dir = Self::config_dir()?;
        Ok(config_dir.join("config.yaml"))
    }
    
    /// Get the configuration directory path
    pub fn config_dir() -> Result<PathBuf> {
        let home_dir = dirs::home_dir()
            .ok_or_else(|| anyhow::anyhow!("Could not determine home directory"))?;
        
        Ok(home_dir.join(".config").join("{{ package_name }}"))
    }
    
    /// List all available configuration files (for debugging/info)
    pub fn list_config_files() -> Result<Vec<(PathBuf, String, bool)>> {
        let search_paths = Self::get_config_search_paths()?;
        let mut found_files = Vec::new();
        
        for (path, format) in search_paths {
            let exists = path.exists();
            found_files.push((path, format, exists));
        }
        
        Ok(found_files)
    }
    
    /// Get the configuration file that would be loaded (highest priority existing file)
    pub fn get_active_config_file() -> Result<Option<(PathBuf, String)>> {
        let search_paths = Self::get_config_search_paths()?;
        
        for (path, format) in search_paths {
            if path.exists() {
                return Ok(Some((path, format)));
            }
        }
        
        Ok(None)
    }
    
    /// Save configuration to file in the specified format
    pub fn save_as(&self, format: &str) -> Result<()> {
        let config_dir = Self::config_dir()?;
        std::fs::create_dir_all(&config_dir)
            .with_context(|| format!("Failed to create config directory: {}", config_dir.display()))?;
        
        let (filename, content) = match format {
            "yaml" | "yml" => ("config.yaml", serde_yaml::to_string(self)?),
            "json" => ("config.json", serde_json::to_string_pretty(self)?),
            "toml" => ("config.toml", toml::to_string_pretty(self)?),
            _ => anyhow::bail!("Unsupported config format: {}", format),
        };
        
        let config_path = config_dir.join(filename);
        std::fs::write(&config_path, content)
            .with_context(|| format!("Failed to write config file: {}", config_path.display()))?;
        
        Ok(())
    }
    
    /// Get a custom setting by key
    pub fn get_custom(&self, key: &str) -> Option<&String> {
        self.preferences.custom.get(key)
    }
    
    /// Set a custom setting
    pub fn set_custom(&mut self, key: String, value: String) {
        self.preferences.custom.insert(key, value);
    }
    
    /// Get an alias for a command
    pub fn get_alias(&self, alias: &str) -> Option<&String> {
        self.preferences.aliases.get(alias)
    }
    
    /// Add a command alias
    pub fn add_alias(&mut self, alias: String, command: String) {
        self.preferences.aliases.insert(alias, command);
    }
    
    /// Remove a command alias
    pub fn remove_alias(&mut self, alias: &str) -> Option<String> {
        self.preferences.aliases.remove(alias)
    }
    
    /// Check if a feature is enabled
    pub fn is_feature_enabled(&self, feature: &str) -> bool {
        match feature {
            "colored_output" => self.features.colored_output,
            "progress_bars" => self.features.progress_bars,
            "interactive_mode" => self.features.interactive_mode,
            "unicode_symbols" => self.features.unicode_symbols,
            _ => false,
        }
    }
    
    /// Enable or disable a feature
    pub fn set_feature(&mut self, feature: &str, enabled: bool) -> Result<()> {
        match feature {
            "colored_output" => self.features.colored_output = enabled,
            "progress_bars" => self.features.progress_bars = enabled,
            "interactive_mode" => self.features.interactive_mode = enabled,
            "unicode_symbols" => self.features.unicode_symbols = enabled,
            _ => anyhow::bail!("Unknown feature: {}", feature),
        }
        Ok(())
    }
    
    /// Validate the configuration
    pub fn validate(&self) -> Result<()> {
        // Validate log level
        match self.settings.log_level.as_str() {
            "debug" | "info" | "warn" | "error" => {}
            _ => anyhow::bail!("Invalid log level: {}", self.settings.log_level),
        }
        
        // Validate output format
        match self.preferences.output_format.as_str() {
            "human" | "json" | "yaml" | "table" => {}
            _ => anyhow::bail!("Invalid output format: {}", self.preferences.output_format),
        }
        
        // Validate config format
        match self.settings.config_format.as_str() {
            "yaml" | "json" | "toml" => {}
            _ => anyhow::bail!("Invalid config format: {}", self.settings.config_format),
        }
        
        Ok(())
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    
    #[test]
    fn test_default_config() {
        let config = AppConfig::default();
        assert_eq!(config.settings.version, "{{ version | default('1.0.0') }}");
        assert!(config.features.colored_output);
        assert_eq!(config.preferences.output_format, "human");
    }
    
    #[test]
    fn test_config_validation() {
        let mut config = AppConfig::default();
        assert!(config.validate().is_ok());
        
        config.settings.log_level = "invalid".to_string();
        assert!(config.validate().is_err());
    }
    
    #[test]
    fn test_feature_management() {
        let mut config = AppConfig::default();
        
        assert!(config.is_feature_enabled("colored_output"));
        config.set_feature("colored_output", false).unwrap();
        assert!(!config.is_feature_enabled("colored_output"));
    }
    
    #[test]
    fn test_alias_management() {
        let mut config = AppConfig::default();
        
        config.add_alias("h".to_string(), "help".to_string());
        assert_eq!(config.get_alias("h"), Some(&"help".to_string()));
        
        let removed = config.remove_alias("h");
        assert_eq!(removed, Some("help".to_string()));
        assert_eq!(config.get_alias("h"), None);
    }
}