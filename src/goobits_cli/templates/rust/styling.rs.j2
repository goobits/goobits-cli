/**
 * Styling and output formatting for {{ display_name }}
 * Auto-generated from {{ file_name }}
 */

use anyhow::Result;
use console::{Color, Style, Term, Emoji};
use indicatif::{ProgressBar, ProgressStyle};
use tabled::{Table, Tabled, settings::{Alignment, Style as TableStyle}};
use std::io::{self, Write};
use std::time::Duration;
use std::collections::HashMap;

/// Emoji definitions for consistent styling
pub mod emoji {
    use console::Emoji;
    
    pub static SUCCESS: Emoji<'_, '_> = Emoji("‚úÖ ", "");
    pub static ERROR: Emoji<'_, '_> = Emoji("‚ùå ", "");
    pub static WARNING: Emoji<'_, '_> = Emoji("‚ö†Ô∏è  ", "");
    pub static INFO: Emoji<'_, '_> = Emoji("üîπ ", "");
    pub static PROGRESS: Emoji<'_, '_> = Emoji("üîÑ ", "");
    pub static ROCKET: Emoji<'_, '_> = Emoji("üöÄ ", "");
    pub static WRENCH: Emoji<'_, '_> = Emoji("üîß ", "");
    pub static LIGHTBULB: Emoji<'_, '_> = Emoji("üí° ", "");
    pub static QUESTION: Emoji<'_, '_> = Emoji("‚ùì ", "");
    pub static CHECK: Emoji<'_, '_> = Emoji("‚úì ", "");
    pub static CROSS: Emoji<'_, '_> = Emoji("‚úó ", "");
    pub static ARROW: Emoji<'_, '_> = Emoji("‚Üí ", "");
    pub static SPARKLES: Emoji<'_, '_> = Emoji("‚ú® ", "");
}

/// Color theme for the CLI
#[derive(Debug, Clone)]
pub struct ColorTheme {
    pub primary: Color,
    pub secondary: Color,
    pub success: Color,
    pub error: Color,
    pub warning: Color,
    pub info: Color,
    pub muted: Color,
}

impl Default for ColorTheme {
    fn default() -> Self {
        Self {
            primary: Color::Blue,
            secondary: Color::Cyan,
            success: Color::Green,
            error: Color::Red,
            warning: Color::Yellow,
            info: Color::Blue,
            muted: Color::Black,
        }
    }
}

impl ColorTheme {
    /// Create a dark theme
    pub fn dark() -> Self {
        Self {
            primary: Color::Cyan,
            secondary: Color::Magenta,
            success: Color::Green,
            error: Color::Red,
            warning: Color::Yellow,
            info: Color::Blue,
            muted: Color::Black,
        }
    }
    
    /// Create a light theme
    pub fn light() -> Self {
        Self {
            primary: Color::Blue,
            secondary: Color::Magenta,
            success: Color::Green,
            error: Color::Red,
            warning: Color::Color256(208), // Orange
            info: Color::Blue,
            muted: Color::Color256(244), // Gray
        }
    }
}

/// Output formatter with styling capabilities
pub struct StyledOutput {
    term: Term,
    theme: ColorTheme,
    colors_enabled: bool,
    unicode_enabled: bool,
}

impl StyledOutput {
    /// Create a new styled output instance
    pub fn new() -> Self {
        let term = Term::stdout();
        let colors_enabled = term.features().colors_supported();
        let unicode_enabled = true; // Can be configured
        
        Self {
            term,
            theme: ColorTheme::default(),
            colors_enabled,
            unicode_enabled,
        }
    }
    
    /// Create with custom theme
    pub fn with_theme(theme: ColorTheme) -> Self {
        let mut output = Self::new();
        output.theme = theme;
        output
    }
    
    /// Enable or disable colors
    pub fn set_colors_enabled(&mut self, enabled: bool) {
        self.colors_enabled = enabled;
    }
    
    /// Enable or disable unicode symbols
    pub fn set_unicode_enabled(&mut self, enabled: bool) {
        self.unicode_enabled = enabled;
    }
    
    /// Print a success message
    pub fn success(&self, message: &str) -> Result<()> {
        let style = if self.colors_enabled {
            Style::new().fg(self.theme.success).bold()
        } else {
            Style::new()
        };
        
        let prefix = if self.unicode_enabled {
            emoji::SUCCESS.to_string()
        } else {
            "SUCCESS: ".to_string()
        };
        
        self.term.write_line(&format!("{}{}", prefix, style.apply_to(message)))?;
        Ok(())
    }
    
    /// Print an error message
    pub fn error(&self, message: &str) -> Result<()> {
        let style = if self.colors_enabled {
            Style::new().fg(self.theme.error).bold()
        } else {
            Style::new()
        };
        
        let prefix = if self.unicode_enabled {
            emoji::ERROR.to_string()
        } else {
            "ERROR: ".to_string()
        };
        
        self.term.write_line(&format!("{}{}", prefix, style.apply_to(message)))?;
        Ok(())
    }
    
    /// Print a warning message
    pub fn warning(&self, message: &str) -> Result<()> {
        let style = if self.colors_enabled {
            Style::new().fg(self.theme.warning).bold()
        } else {
            Style::new()
        };
        
        let prefix = if self.unicode_enabled {
            emoji::WARNING.to_string()
        } else {
            "WARNING: ".to_string()
        };
        
        self.term.write_line(&format!("{}{}", prefix, style.apply_to(message)))?;
        Ok(())
    }
    
    /// Print an info message
    pub fn info(&self, message: &str) -> Result<()> {
        let style = if self.colors_enabled {
            Style::new().fg(self.theme.info)
        } else {
            Style::new()
        };
        
        let prefix = if self.unicode_enabled {
            emoji::INFO.to_string()
        } else {
            "INFO: ".to_string()
        };
        
        self.term.write_line(&format!("{}{}", prefix, style.apply_to(message)))?;
        Ok(())
    }
    
    /// Print a debug message (only if debug assertions are enabled)
    pub fn debug(&self, message: &str) -> Result<()> {
        #[cfg(debug_assertions)]
        {
            let style = if self.colors_enabled {
                Style::new().fg(self.theme.muted)
            } else {
                Style::new()
            };
            
            let prefix = if self.unicode_enabled {
                emoji::WRENCH.to_string()
            } else {
                "DEBUG: ".to_string()
            };
            
            self.term.write_line(&format!("{}{}", prefix, style.apply_to(message)))?;
        }
        Ok(())
    }
    
    /// Print a progress message without newline
    pub fn progress(&self, message: &str) -> Result<()> {
        let style = if self.colors_enabled {
            Style::new().fg(self.theme.secondary)
        } else {
            Style::new()
        };
        
        let prefix = if self.unicode_enabled {
            emoji::PROGRESS.to_string()
        } else {
            "PROGRESS: ".to_string()
        };
        
        write!(io::stdout(), "{}{}...", prefix, style.apply_to(message))?;
        io::stdout().flush()?;
        Ok(())
    }
    
    /// Complete a progress message
    pub fn progress_done(&self) -> Result<()> {
        let style = if self.colors_enabled {
            Style::new().fg(self.theme.success)
        } else {
            Style::new()
        };
        
        let suffix = if self.unicode_enabled {
            emoji::CHECK.to_string()
        } else {
            " OK".to_string()
        };
        
        println!(" {}", style.apply_to(suffix));
        Ok(())
    }
    
    /// Fail a progress message
    pub fn progress_failed(&self) -> Result<()> {
        let style = if self.colors_enabled {
            Style::new().fg(self.theme.error)
        } else {
            Style::new()
        };
        
        let suffix = if self.unicode_enabled {
            emoji::CROSS.to_string()
        } else {
            " FAILED".to_string()
        };
        
        println!(" {}", style.apply_to(suffix));
        Ok(())
    }
    
    /// Print a header
    pub fn header(&self, title: &str) -> Result<()> {
        let style = if self.colors_enabled {
            Style::new().fg(self.theme.primary).bold().underlined()
        } else {
            Style::new().bold()
        };
        
        self.term.write_line("")?;
        self.term.write_line(&style.apply_to(title).to_string())?;
        self.term.write_line("")?;
        Ok(())
    }
    
    /// Print a subheader
    pub fn subheader(&self, title: &str) -> Result<()> {
        let style = if self.colors_enabled {
            Style::new().fg(self.theme.secondary).bold()
        } else {
            Style::new().bold()
        };
        
        self.term.write_line(&style.apply_to(title).to_string())?;
        Ok(())
    }
    
    /// Print a list item
    pub fn list_item(&self, item: &str) -> Result<()> {
        let prefix = if self.unicode_enabled {
            emoji::ARROW.to_string()
        } else {
            "- ".to_string()
        };
        
        self.term.write_line(&format!("{}{}", prefix, item))?;
        Ok(())
    }
    
    /// Print a key-value pair
    pub fn key_value(&self, key: &str, value: &str) -> Result<()> {
        let key_style = if self.colors_enabled {
            Style::new().fg(self.theme.primary).bold()
        } else {
            Style::new().bold()
        };
        
        let value_style = if self.colors_enabled {
            Style::new().fg(self.theme.muted)
        } else {
            Style::new()
        };
        
        self.term.write_line(&format!("{}: {}", 
            key_style.apply_to(key),
            value_style.apply_to(value)
        ))?;
        Ok(())
    }
    
    /// Print JSON formatted output
    pub fn json(&self, data: &serde_json::Value) -> Result<()> {
        let json_str = serde_json::to_string_pretty(data)?;
        if self.colors_enabled {
            // Simple JSON syntax highlighting
            let highlighted = json_str
                .replace("\"", &Style::new().fg(Color::Green).apply_to("\"").to_string())
                .replace(":", &Style::new().fg(self.theme.primary).apply_to(":").to_string())
                .replace("{", &Style::new().fg(self.theme.secondary).apply_to("{").to_string())
                .replace("}", &Style::new().fg(self.theme.secondary).apply_to("}").to_string());
            self.term.write_line(&highlighted)?;
        } else {
            self.term.write_line(&json_str)?;
        }
        Ok(())
    }
    
    /// Clear the terminal
    pub fn clear(&self) -> Result<()> {
        self.term.clear_screen()?;
        Ok(())
    }
}

/// Progress bar utilities
pub struct ProgressManager {
    bars: HashMap<String, ProgressBar>,
}

impl ProgressManager {
    pub fn new() -> Self {
        Self {
            bars: HashMap::new(),
        }
    }
    
    /// Create a new progress bar
    pub fn create(&mut self, name: &str, length: u64, message: &str) -> &ProgressBar {
        let pb = ProgressBar::new(length);
        pb.set_style(
            ProgressStyle::default_bar()
                .template("{spinner:.green} [{elapsed_precise}] [{wide_bar:.cyan/blue}] {bytes}/{total_bytes} ({bytes_per_sec}, {eta})")
                .unwrap()
                .progress_chars("#>-")
        );
        pb.set_message(message.to_string());
        
        self.bars.insert(name.to_string(), pb);
        self.bars.get(name).unwrap()
    }
    
    /// Get an existing progress bar
    pub fn get(&self, name: &str) -> Option<&ProgressBar> {
        self.bars.get(name)
    }
    
    /// Update progress bar
    pub fn update(&self, name: &str, position: u64) {
        if let Some(pb) = self.bars.get(name) {
            pb.set_position(position);
        }
    }
    
    /// Finish a progress bar
    pub fn finish(&self, name: &str, message: &str) {
        if let Some(pb) = self.bars.get(name) {
            pb.finish_with_message(message.to_string());
        }
    }
    
    /// Create a spinner
    pub fn spinner(&mut self, name: &str, message: &str) -> &ProgressBar {
        let pb = ProgressBar::new_spinner();
        pb.set_style(
            ProgressStyle::default_spinner()
                .template("{spinner:.green} {msg}")
                .unwrap()
        );
        pb.set_message(message.to_string());
        pb.enable_steady_tick(Duration::from_millis(100));
        
        self.bars.insert(name.to_string(), pb);
        self.bars.get(name).unwrap()
    }
}

/// Table formatting utilities
pub struct TableFormatter;

impl TableFormatter {
    /// Create a simple table from key-value pairs
    pub fn key_value_table(data: &[(String, String)]) -> String {
        let table_data: Vec<KeyValueRow> = data
            .iter()
            .map(|(k, v)| KeyValueRow {
                key: k.clone(),
                value: v.clone(),
            })
            .collect();
        
        let mut table = Table::new(table_data);
        table
            .with(TableStyle::rounded())
            .with(Alignment::left());
        
        table.to_string()
    }
    
    /// Create a table with custom headers and rows
    pub fn custom_table(headers: &[&str], rows: &[Vec<String>]) -> String {
        if rows.is_empty() {
            return "No data to display".to_string();
        }
        
        let table_data: Vec<CustomRow> = rows
            .iter()
            .map(|row| CustomRow {
                columns: row.clone(),
            })
            .collect();
        
        let mut table = Table::new(table_data);
        table
            .with(TableStyle::rounded())
            .with(Alignment::left());
        
        table.to_string()
    }
}

#[derive(Tabled)]
struct KeyValueRow {
    #[tabled(rename = "Key")]
    key: String,
    #[tabled(rename = "Value")]
    value: String,
}

#[derive(Tabled)]
struct CustomRow {
    #[tabled(display_with = "display_columns")]
    columns: Vec<String>,
}

fn display_columns(columns: &Vec<String>) -> String {
    columns.join(" | ")
}

/// Input prompting utilities
pub struct InputPrompt {
    output: StyledOutput,
}

impl InputPrompt {
    pub fn new() -> Self {
        Self {
            output: StyledOutput::new(),
        }
    }
    
    /// Prompt for text input
    pub fn text(&self, message: &str) -> Result<String> {
        let prefix = if self.output.unicode_enabled {
            emoji::QUESTION.to_string()
        } else {
            "? ".to_string()
        };
        
        print!("{}{}: ", prefix, message);
        io::stdout().flush()?;
        
        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        Ok(input.trim().to_string())
    }
    
    /// Prompt with default value
    pub fn text_with_default(&self, message: &str, default: &str) -> Result<String> {
        let prefix = if self.output.unicode_enabled {
            emoji::QUESTION.to_string()
        } else {
            "? ".to_string()
        };
        
        print!("{}{} [{}]: ", prefix, message, default);
        io::stdout().flush()?;
        
        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        let input = input.trim();
        
        if input.is_empty() {
            Ok(default.to_string())
        } else {
            Ok(input.to_string())
        }
    }
    
    /// Prompt for confirmation
    pub fn confirm(&self, message: &str) -> Result<bool> {
        loop {
            let input = self.text(&format!("{} (y/n)", message))?;
            match input.to_lowercase().as_str() {
                "y" | "yes" => return Ok(true),
                "n" | "no" => return Ok(false),
                _ => {
                    self.output.warning("Please enter 'y' or 'n'")?;
                    continue;
                }
            }
        }
    }
    
    /// Select from a list of options
    pub fn select(&self, message: &str, options: &[&str]) -> Result<usize> {
        self.output.info(message)?;
        for (i, option) in options.iter().enumerate() {
            println!("  {}. {}", i + 1, option);
        }
        
        loop {
            let input = self.text("Enter selection number")?;
            if let Ok(selection) = input.parse::<usize>() {
                if selection > 0 && selection <= options.len() {
                    return Ok(selection - 1);
                }
            }
            self.output.warning(&format!("Please enter a number between 1 and {}", options.len()))?;
        }
    }
}

/// Global styling instances
static mut GLOBAL_OUTPUT: Option<StyledOutput> = None;
static mut GLOBAL_PROGRESS: Option<ProgressManager> = None;

/// Initialize global styling
pub fn initialize_styling(colors_enabled: bool, unicode_enabled: bool) {
    unsafe {
        let mut output = StyledOutput::new();
        output.set_colors_enabled(colors_enabled);
        output.set_unicode_enabled(unicode_enabled);
        GLOBAL_OUTPUT = Some(output);
        GLOBAL_PROGRESS = Some(ProgressManager::new());
    }
}

/// Get global output instance
pub fn output() -> &'static StyledOutput {
    unsafe {
        GLOBAL_OUTPUT.as_ref().expect("Styling not initialized")
    }
}

/// Get global progress manager
pub fn progress() -> &'static mut ProgressManager {
    unsafe {
        GLOBAL_PROGRESS.as_mut().expect("Styling not initialized")
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_color_themes() {
        let default_theme = ColorTheme::default();
        let dark_theme = ColorTheme::dark();
        let light_theme = ColorTheme::light();
        
        // Themes should be different
        assert_ne!(format!("{:?}", default_theme), format!("{:?}", dark_theme));
        assert_ne!(format!("{:?}", default_theme), format!("{:?}", light_theme));
    }
    
    #[test]
    fn test_styled_output() {
        let output = StyledOutput::new();
        
        // These should not panic
        assert!(output.info("test").is_ok());
        assert!(output.success("test").is_ok());
        assert!(output.warning("test").is_ok());
        assert!(output.error("test").is_ok());
    }
    
    #[test]
    fn test_table_formatter() {
        let data = vec![
            ("Key1".to_string(), "Value1".to_string()),
            ("Key2".to_string(), "Value2".to_string()),
        ];
        
        let table = TableFormatter::key_value_table(&data);
        assert!(table.contains("Key1"));
        assert!(table.contains("Value1"));
    }
    
    #[test]
    fn test_progress_manager() {
        let mut pm = ProgressManager::new();
        pm.create("test", 100, "Testing");
        
        assert!(pm.get("test").is_some());
        pm.update("test", 50);
        pm.finish("test", "Done");
    }
}