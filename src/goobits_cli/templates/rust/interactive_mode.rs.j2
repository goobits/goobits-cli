//! Enhanced Interactive Mode for {{ display_name }}
//! Generated by Goobits CLI Framework
//!
//! This module provides a powerful interactive REPL (Read-Eval-Print Loop) interface
//! with advanced Rust-specific features including:
//! - Enhanced rustyline configuration with custom keybindings
//! - Rust-specific command parsing with proper error handling
//! - Support for Rust expression evaluation and compilation
//! - Integration with Rust's help system and documentation
//! - Tab completion for commands, options, and filesystem paths
//! - History management with persistence
//! - Cargo integration for project management

use anyhow::{Context, Result};
use rustyline::error::ReadlineError;
use rustyline::{config::Configurer, DefaultEditor, Editor};
use rustyline::config::{Config, EditMode, CompletionType, HistoryDuplicates};
use rustyline::history::FileHistory;
use std::collections::HashMap;
use std::env;
use std::fs;
use std::path::PathBuf;
use std::process::Command;
use std::io::{self, Write};
use clap::Parser;

// hooks module is imported via main.rs
use crate::commands::*;
use crate::config::AppConfig;
use crate::errors::AppError;

/// Interactive mode configuration
#[derive(Debug, Clone)]
pub struct InteractiveConfig {
    pub history_file: PathBuf,
    pub prompt: String,
    pub intro_message: String,
    pub max_history_size: usize,
    pub auto_save_history: bool,
    pub enable_vi_mode: bool,
    pub tab_completion_type: CompletionType,
}

impl Default for InteractiveConfig {
    fn default() -> Self {
        let mut history_file = dirs::data_dir()
            .unwrap_or_else(|| PathBuf::from("."))
            .join("{{ package_name }}");
        
        // Ensure directory exists
        if let Some(parent) = history_file.parent() {
            let _ = fs::create_dir_all(parent);
        }
        
        history_file.push("history.txt");

        Self {
            history_file,
            prompt: "{{ package_name }}> ".to_string(),
            intro_message: format!(
                "Welcome to {} interactive mode.\nType 'help' for commands, 'exit' to quit.\n",
                "{{ package_name }}"
            ),
            max_history_size: 1000,
            auto_save_history: true,
            enable_vi_mode: false,
            tab_completion_type: CompletionType::List,
        }
    }
}

/// Enhanced interactive shell with Rust-specific features
pub struct RustInteractiveShell {
    editor: DefaultEditor,
    config: InteractiveConfig,
    cli_commands: HashMap<String, CommandInfo>,
    app_config: AppConfig,
    current_directory: PathBuf,
    environment_vars: HashMap<String, String>,
}

/// Command information for tab completion and help
#[derive(Debug, Clone)]
struct CommandInfo {
    name: String,
    description: String,
    arguments: Vec<ArgumentInfo>,
    options: Vec<OptionInfo>,
    examples: Vec<String>,
}

#[derive(Debug, Clone)]
struct ArgumentInfo {
    name: String,
    description: String,
    required: bool,
    value_type: String,
}

#[derive(Debug, Clone)]
struct OptionInfo {
    name: String,
    short: Option<String>,
    description: String,
    value_type: Option<String>,
    default_value: Option<String>,
}

impl RustInteractiveShell {
    /// Create a new interactive shell with enhanced configuration
    pub fn new() -> Result<Self> {
        let config = InteractiveConfig::default();
        let mut editor = DefaultEditor::new()?;
        
        // Configure rustyline with advanced settings
        Self::configure_editor(&mut editor, &config)?;
        
        // Load history
        if config.history_file.exists() {
            let _ = editor.load_history(&config.history_file);
        }
        
        let cli_commands = Self::build_command_registry();
        let app_config = AppConfig::load()?;
        let current_directory = env::current_dir()?;
        let environment_vars = env::vars().collect();
        
        Ok(Self {
            editor,
            config,
            cli_commands,
            app_config,
            current_directory,
            environment_vars,
        })
    }
    
    /// Configure the rustyline editor with advanced features
    fn configure_editor(editor: &mut DefaultEditor, config: &InteractiveConfig) -> Result<()> {
        // Set edit mode (Emacs or Vi)
        if config.enable_vi_mode {
            editor.set_edit_mode(EditMode::Vi);
        } else {
            editor.set_edit_mode(EditMode::Emacs);
        }
        
        // Configure tab completion
        editor.set_completion_type(config.tab_completion_type);
        editor.set_max_history_size(config.max_history_size)?;
        editor.set_history_ignore_dups(HistoryDuplicates::IgnoreConsecutive);
        
        // Set up custom key bindings for enhanced functionality
        editor.bind_sequence(
            rustyline::KeyEvent::ctrl('r'),
            rustyline::Cmd::ReverseSearchHistory
        );
        
        editor.bind_sequence(
            rustyline::KeyEvent::ctrl('s'),
            rustyline::Cmd::ForwardSearchHistory
        );
        
        // Custom completion helper
        let helper = RustCompletionHelper::new();
        editor.set_helper(Some(helper));
        
        Ok(())
    }
    
    /// Build the command registry from CLI configuration
    fn build_command_registry() -> HashMap<String, CommandInfo> {
        let mut commands = HashMap::new();
        
        // Register CLI commands
        {%- for command_name, command in cli.commands.items() %}
        commands.insert("{{ command_name }}".to_string(), CommandInfo {
            name: "{{ command_name }}".to_string(),
            description: "{{ command.desc | replace('"', '\\"') }}".to_string(),
            arguments: vec![
                {%- if command.args %}
                {%- for arg in command.args %}
                ArgumentInfo {
                    name: "{{ arg.name }}".to_string(),
                    description: "{{ arg.desc | default('') | replace('"', '\\"') }}".to_string(),
                    required: {{ arg.required | default(false) | lower }},
                    value_type: "{{ arg.type | default('String') }}".to_string(),
                },
                {%- endfor %}
                {%- endif %}
            ],
            options: vec![
                {%- if command.options %}
                {%- for option in command.options %}
                OptionInfo {
                    name: "{{ option.name }}".to_string(),
                    short: {% if option.short %}Some("{{ option.short }}".to_string()){% else %}None{% endif %},
                    description: "{{ option.desc | default('') | replace('"', '\\"') }}".to_string(),
                    value_type: {% if option.type and option.type != 'flag' %}Some("{{ option.type }}".to_string()){% else %}None{% endif %},
                    default_value: {% if option.default %}Some("{{ option.default }}".to_string()){% else %}None{% endif %},
                },
                {%- endfor %}
                {%- endif %}
            ],
            examples: vec![
                {%- for example in command.examples or [] %}
                "{{ example | replace('"', '\\"') }}".to_string(),
                {%- endfor %}
            ],
        });
        {%- endfor %}
        
        // Register built-in interactive commands
        Self::register_builtin_commands(&mut commands);
        
        commands
    }
    
    /// Register built-in interactive commands
    fn register_builtin_commands(commands: &mut HashMap<String, CommandInfo>) {
        // Help command
        commands.insert("help".to_string(), CommandInfo {
            name: "help".to_string(),
            description: "Show available commands or detailed help for a specific command".to_string(),
            arguments: vec![
                ArgumentInfo {
                    name: "command".to_string(),
                    description: "Command to show help for".to_string(),
                    required: false,
                    value_type: "String".to_string(),
                }
            ],
            options: vec![],
            examples: vec!["help".to_string(), "help {{ cli.commands.keys() | first | default('command') }}".to_string()],
        });
        
        // History command
        commands.insert("history".to_string(), CommandInfo {
            name: "history".to_string(),
            description: "Show command history".to_string(),
            arguments: vec![],
            options: vec![
                OptionInfo {
                    name: "clear".to_string(),
                    short: Some("c".to_string()),
                    description: "Clear command history".to_string(),
                    value_type: None,
                    default_value: None,
                }
            ],
            examples: vec!["history".to_string(), "history --clear".to_string()],
        });
        
        // Exit command
        commands.insert("exit".to_string(), CommandInfo {
            name: "exit".to_string(),
            description: "Exit the interactive mode".to_string(),
            arguments: vec![],
            options: vec![],
            examples: vec!["exit".to_string()],
        });
        
        // Cargo integration commands
        commands.insert("cargo".to_string(), CommandInfo {
            name: "cargo".to_string(),
            description: "Run cargo commands directly".to_string(),
            arguments: vec![
                ArgumentInfo {
                    name: "subcommand".to_string(),
                    description: "Cargo subcommand to run".to_string(),
                    required: true,
                    value_type: "String".to_string(),
                }
            ],
            options: vec![],
            examples: vec![
                "cargo check".to_string(),
                "cargo build".to_string(),
                "cargo test".to_string(),
                "cargo doc".to_string(),
            ],
        });
        
        // Rust expression evaluation
        commands.insert("eval".to_string(), CommandInfo {
            name: "eval".to_string(),
            description: "Evaluate and compile a Rust expression".to_string(),
            arguments: vec![
                ArgumentInfo {
                    name: "expression".to_string(),
                    description: "Rust expression to evaluate".to_string(),
                    required: true,
                    value_type: "String".to_string(),
                }
            ],
            options: vec![
                OptionInfo {
                    name: "no-run".to_string(),
                    short: Some("n".to_string()),
                    description: "Only compile, don't execute".to_string(),
                    value_type: None,
                    default_value: None,
                }
            ],
            examples: vec![
                r#"eval 'println!("Hello, World!");'"#.to_string(),
                r#"eval 'let x = 42; println!("x = {}", x);'"#.to_string(),
            ],
        });
        
        // Environment commands
        commands.insert("env".to_string(), CommandInfo {
            name: "env".to_string(),
            description: "Show or modify environment variables".to_string(),
            arguments: vec![],
            options: vec![
                OptionInfo {
                    name: "set".to_string(),
                    short: Some("s".to_string()),
                    description: "Set an environment variable (KEY=VALUE)".to_string(),
                    value_type: Some("String".to_string()),
                    default_value: None,
                }
            ],
            examples: vec![
                "env".to_string(),
                "env --set RUST_LOG=debug".to_string(),
            ],
        });
    }
    
    /// Run the interactive loop
    pub fn run(&mut self) -> Result<()> {
        println!("{}", self.config.intro_message);
        
        // Show initial information
        self.show_project_info();
        
        loop {
            match self.editor.readline(&self.config.prompt) {
                Ok(line) => {
                    let trimmed = line.trim();
                    
                    if trimmed.is_empty() {
                        continue;
                    }
                    
                    // Add to history
                    let _ = self.editor.add_history_entry(&line);
                    
                    // Save history if auto-save is enabled
                    if self.config.auto_save_history {
                        let _ = self.editor.save_history(&self.config.history_file);
                    }
                    
                    // Execute command
                    if let Err(e) = self.execute_command(trimmed) {
                        match e.downcast_ref::<AppError>() {
                            Some(AppError::Exit) => break,
                            _ => eprintln!("Error: {}", e),
                        }
                    }
                }
                Err(ReadlineError::Interrupted) => {
                    println!("^C (Use 'exit' to quit)");
                    continue;
                }
                Err(ReadlineError::Eof) => {
                    println!("^D");
                    break;
                }
                Err(err) => {
                    eprintln!("Error: {:?}", err);
                    break;
                }
            }
        }
        
        // Final save of history
        if self.config.auto_save_history {
            let _ = self.editor.save_history(&self.config.history_file);
        }
        
        println!("Goodbye!");
        Ok(())
    }
    
    /// Show project information on startup
    fn show_project_info(&self) {
        if let Ok(metadata) = self.get_cargo_metadata() {
            println!("Project: {} v{}", metadata.name, metadata.version);
            if !metadata.description.is_empty() {
                println!("Description: {}", metadata.description);
            }
        }
        println!("Working directory: {}", self.current_directory.display());
        println!();
    }
    
    /// Execute a command line
    fn execute_command(&mut self, line: &str) -> Result<()> {
        let parts: Vec<&str> = line.split_whitespace().collect();
        if parts.is_empty() {
            return Ok(());
        }
        
        let command_name = parts[0];
        let args = &parts[1..];
        
        match command_name {
            "help" => self.handle_help_command(args),
            "history" => self.handle_history_command(args),
            "exit" | "quit" => Err(AppError::Exit.into()),
            "cargo" => self.handle_cargo_command(args),
            "eval" => self.handle_eval_command(args),
            "env" => self.handle_env_command(args),
            cmd => {
                if self.cli_commands.contains_key(cmd) {
                    self.handle_cli_command(cmd, args)
                } else {
                    println!("Unknown command: {}. Type 'help' for available commands.", cmd);
                    Ok(())
                }
            }
        }
    }
    
    /// Handle the help command
    fn handle_help_command(&self, args: &[&str]) -> Result<()> {
        if args.is_empty() {
            println!("Available commands:");
            
            let mut sorted_commands: Vec<_> = self.cli_commands.values().collect();
            sorted_commands.sort_by(|a, b| a.name.cmp(&b.name));
            
            for cmd in sorted_commands {
                println!("  {:15} {}", cmd.name, cmd.description);
            }
            println!();
            println!("Use 'help <command>' for detailed information about a specific command.");
        } else {
            let cmd_name = args[0];
            if let Some(cmd_info) = self.cli_commands.get(cmd_name) {
                self.show_detailed_help(cmd_info);
            } else {
                println!("Unknown command: {}. Type 'help' for available commands.", cmd_name);
            }
        }
        
        Ok(())
    }
    
    /// Show detailed help for a command
    fn show_detailed_help(&self, cmd_info: &CommandInfo) {
        println!("\n{}: {}", cmd_info.name, cmd_info.description);
        
        // Show usage
        print!("Usage: {}", cmd_info.name);
        for arg in &cmd_info.arguments {
            if arg.required {
                print!(" <{}>", arg.name);
            } else {
                print!(" [{}]", arg.name);
            }
        }
        
        for option in &cmd_info.options {
            if let Some(value_type) = &option.value_type {
                print!(" [--{} <{}>]", option.name, value_type);
            } else {
                print!(" [--{}]", option.name);
            }
        }
        println!();
        
        // Show arguments
        if !cmd_info.arguments.is_empty() {
            println!("\nArguments:");
            for arg in &cmd_info.arguments {
                let required_str = if arg.required { "required" } else { "optional" };
                println!("  {:15} {} ({})", arg.name, arg.description, required_str);
            }
        }
        
        // Show options
        if !cmd_info.options.is_empty() {
            println!("\nOptions:");
            for option in &cmd_info.options {
                let short_str = option.short.as_ref()
                    .map(|s| format!(", -{}", s))
                    .unwrap_or_default();
                println!("  --{}{:10} {}", option.name, short_str, option.description);
                
                if let Some(default) = &option.default_value {
                    println!("                      Default: {}", default);
                }
            }
        }
        
        // Show examples
        if !cmd_info.examples.is_empty() {
            println!("\nExamples:");
            for example in &cmd_info.examples {
                println!("  {}", example);
            }
        }
        
        println!();
    }
    
    /// Handle the history command
    fn handle_history_command(&mut self, args: &[&str]) -> Result<()> {
        if args.len() == 1 && args[0] == "--clear" {
            self.editor.history_mut().clear();
            println!("History cleared.");
        } else {
            let history = self.editor.history();
            if history.is_empty() {
                println!("No command history available.");
            } else {
                for (i, entry) in history.iter().enumerate() {
                    println!("{:4}  {}", i + 1, entry);
                }
            }
        }
        Ok(())
    }
    
    /// Handle cargo commands
    fn handle_cargo_command(&self, args: &[&str]) -> Result<()> {
        if args.is_empty() {
            println!("Usage: cargo <subcommand> [args...]");
            println!("Common subcommands: build, check, test, run, doc, clean");
            return Ok(());
        }
        
        println!("Running: cargo {}", args.join(" "));
        
        let mut cmd = Command::new("cargo");
        cmd.args(args);
        cmd.current_dir(&self.current_directory);
        
        match cmd.status() {
            Ok(status) => {
                if !status.success() {
                    println!("Cargo command failed with exit code: {}", 
                             status.code().unwrap_or(-1));
                }
            }
            Err(e) => {
                println!("Failed to run cargo command: {}", e);
            }
        }
        
        Ok(())
    }
    
    /// Handle Rust expression evaluation
    fn handle_eval_command(&self, args: &[&str]) -> Result<()> {
        if args.is_empty() {
            println!("Usage: eval <rust-expression>");
            println!("Example: eval 'println!(\\\"Hello, World!\\\");'");
            return Ok(());
        }
        
        let no_run = args.contains(&"--no-run") || args.contains(&"-n");
        let expression = args.iter()
            .filter(|&arg| !arg.starts_with('-'))
            .collect::<Vec<_>>()
            .join(" ");
        
        if expression.is_empty() {
            println!("No expression provided");
            return Ok(());
        }
        
        // Create a temporary Rust program
        {% raw %}
        let program = format!(
            r#"
fn main() -> Result<(), Box<dyn std::error::Error>> {{
    {}
    Ok(())
}}
"#,
            expression
        );
        {% endraw %}
        
        // Create a temporary directory and file
        let temp_dir = std::env::temp_dir().join(format!("rust_eval_{}", 
            std::process::id()));
        let _ = std::fs::create_dir_all(&temp_dir);
        
        let rust_file = temp_dir.join("main.rs");
        let binary_file = temp_dir.join("main");
        
        match std::fs::write(&rust_file, &program) {
            Ok(_) => {
                // Compile the program
                let mut compile_cmd = Command::new("rustc");
                compile_cmd.arg(&rust_file)
                    .arg("-o")
                    .arg(&binary_file)
                    .arg("--edition=2021");
                
                match compile_cmd.output() {
                    Ok(compile_output) => {
                        if compile_output.status.success() {
                            println!("✅ Compilation successful");
                            
                            if !no_run {
                                // Run the compiled program
                                match Command::new(&binary_file).output() {
                                    Ok(run_output) => {
                                        if !run_output.stdout.is_empty() {
                                            print!("Output:\n{}", String::from_utf8_lossy(&run_output.stdout));
                                        }
                                        if !run_output.stderr.is_empty() {
                                            print!("Error:\n{}", String::from_utf8_lossy(&run_output.stderr));
                                        }
                                        if run_output.status.success() {
                                            println!("✅ Execution successful");
                                        } else {
                                            println!("❌ Execution failed with exit code: {}", 
                                                   run_output.status.code().unwrap_or(-1));
                                        }
                                    }
                                    Err(e) => {
                                        println!("❌ Failed to run compiled program: {}", e);
                                    }
                                }
                            }
                        } else {
                            println!("❌ Compilation failed:");
                            println!("{}", String::from_utf8_lossy(&compile_output.stderr));
                        }
                    }
                    Err(e) => {
                        println!("❌ Failed to run rustc: {}", e);
                    }
                }
            }
            Err(e) => {
                println!("❌ Failed to write temporary file: {}", e);
            }
        }
        
        // Cleanup
        let _ = std::fs::remove_dir_all(&temp_dir);
        
        Ok(())
    }
    
    /// Handle environment variable commands
    fn handle_env_command(&mut self, args: &[&str]) -> Result<()> {
        if args.is_empty() {
            // Show all environment variables
            let mut env_vars: Vec<_> = self.environment_vars.iter().collect();
            env_vars.sort_by_key(|(k, _)| *k);
            
            for (key, value) in env_vars {
                println!("{}={}", key, value);
            }
        } else if args.len() >= 2 && (args[0] == "--set" || args[0] == "-s") {
            let set_arg = args[1];
            if let Some(eq_pos) = set_arg.find('=') {
                let key = &set_arg[..eq_pos];
                let value = &set_arg[eq_pos + 1..];
                
                std::env::set_var(key, value);
                self.environment_vars.insert(key.to_string(), value.to_string());
                
                println!("Set {}={}", key, value);
            } else {
                println!("Invalid format. Use: env --set KEY=VALUE");
            }
        } else {
            println!("Usage: env [--set KEY=VALUE]");
        }
        
        Ok(())
    }
    
    /// Handle CLI commands
    fn handle_cli_command(&self, command_name: &str, args: &[&str]) -> Result<()> {
        // Parse arguments and options properly
        let parsed_args = self.parse_cli_args(command_name, args)?;
        
        // Execute the hook function
        match command_name {
            {%- for command_name, command in cli.commands.items() %}
            "{{ command_name }}" => {
                let hook_args = crate::hooks::{{ command_name | replace('-', '_') }}::Args {
                    {%- if command.args %}
                    {%- for arg in command.args %}
                    {{ arg.name | replace('-', '_') }}: parsed_args.get("{{ arg.name }}").cloned(){% if not loop.last %},{% endif %}
                    {%- endfor %}
                    {%- endif %}
                    {%- if command.args and command.options %},{% endif %}
                    {%- if command.options %}
                    {%- for option in command.options %}
                    {{ option.name | replace('-', '_') }}: parsed_args.get("{{ option.name }}").cloned(){% if not loop.last %},{% endif %}
                    {%- endfor %}
                    {%- endif %}
                };
                
                crate::hooks::{{ command_name | replace('-', '_') }}::execute(hook_args)
                    .map_err(|e| CLIError::hook(command_name, format!("Hook execution failed: {}", e)))?;
            }
            {%- endfor %}
            _ => {
                println!("Command '{}' is not implemented in interactive mode", command_name);
            }
        }
        
        Ok(())
    }
    
    /// Parse CLI arguments and options
    fn parse_cli_args(&self, command_name: &str, args: &[&str]) -> Result<HashMap<String, String>> {
        let mut parsed = HashMap::new();
        let cmd_info = self.cli_commands.get(command_name)
            .context("Command not found")?;
        
        let mut arg_index = 0;
        let mut i = 0;
        
        while i < args.len() {
            let arg = args[i];
            
            if arg.starts_with("--") {
                // Long option
                let option_name = &arg[2..];
                if let Some(option_info) = cmd_info.options.iter()
                    .find(|opt| opt.name == option_name) {
                    
                    if option_info.value_type.is_some() {
                        // Option with value
                        if i + 1 < args.len() {
                            parsed.insert(option_name.to_string(), args[i + 1].to_string());
                            i += 2;
                        } else {
                            return Err(anyhow::anyhow!("Option --{} requires a value", option_name));
                        }
                    } else {
                        // Flag option
                        parsed.insert(option_name.to_string(), "true".to_string());
                        i += 1;
                    }
                } else {
                    return Err(anyhow::anyhow!("Unknown option: --{}", option_name));
                }
            } else if arg.starts_with("-") && arg.len() == 2 {
                // Short option
                let short_name = &arg[1..];
                if let Some(option_info) = cmd_info.options.iter()
                    .find(|opt| opt.short.as_ref() == Some(&short_name.to_string())) {
                    
                    if option_info.value_type.is_some() {
                        // Option with value
                        if i + 1 < args.len() {
                            parsed.insert(option_info.name.clone(), args[i + 1].to_string());
                            i += 2;
                        } else {
                            return Err(anyhow::anyhow!("Option -{} requires a value", short_name));
                        }
                    } else {
                        // Flag option
                        parsed.insert(option_info.name.clone(), "true".to_string());
                        i += 1;
                    }
                } else {
                    return Err(anyhow::anyhow!("Unknown short option: -{}", short_name));
                }
            } else {
                // Positional argument
                if arg_index < cmd_info.arguments.len() {
                    let arg_info = &cmd_info.arguments[arg_index];
                    parsed.insert(arg_info.name.clone(), arg.to_string());
                    arg_index += 1;
                } else {
                    return Err(anyhow::anyhow!("Too many arguments provided"));
                }
                i += 1;
            }
        }
        
        // Check for required arguments
        for (index, arg_info) in cmd_info.arguments.iter().enumerate() {
            if arg_info.required && index >= arg_index {
                return Err(anyhow::anyhow!("Missing required argument: {}", arg_info.name));
            }
        }
        
        Ok(parsed)
    }
    
    /// Get cargo metadata for the current project
    fn get_cargo_metadata(&self) -> Result<CargoMetadata> {
        let output = Command::new("cargo")
            .args(&["metadata", "--format-version", "1", "--no-deps"])
            .current_dir(&self.current_directory)
            .output()
            .context("Failed to run cargo metadata")?;
        
        if !output.status.success() {
            return Err(anyhow::anyhow!("cargo metadata failed"));
        }
        
        let metadata_str = String::from_utf8(output.stdout)
            .context("Invalid UTF-8 in cargo metadata output")?;
        
        let metadata: serde_json::Value = serde_json::from_str(&metadata_str)
            .context("Failed to parse cargo metadata JSON")?;
        
        let packages = metadata["packages"].as_array()
            .context("No packages in metadata")?;
        
        if let Some(package) = packages.first() {
            Ok(CargoMetadata {
                name: package["name"].as_str().unwrap_or("unknown").to_string(),
                version: package["version"].as_str().unwrap_or("0.0.0").to_string(),
                description: package["description"].as_str().unwrap_or("").to_string(),
            })
        } else {
            Err(anyhow::anyhow!("No package found in metadata"))
        }
    }
}

/// Cargo project metadata
#[derive(Debug)]
struct CargoMetadata {
    name: String,
    version: String,
    description: String,
}

/// Custom completion helper for enhanced tab completion
struct RustCompletionHelper;

impl RustCompletionHelper {
    fn new() -> Self {
        Self
    }
}

impl rustyline::completion::Completer for RustCompletionHelper {
    type Candidate = String;

    fn complete(
        &self,
        line: &str,
        pos: usize,
        _ctx: &rustyline::Context<'_>
    ) -> rustyline::Result<(usize, Vec<Self::Candidate>)> {
        let line = &line[..pos];
        let parts: Vec<&str> = line.split_whitespace().collect();
        
        if parts.is_empty() || (parts.len() == 1 && !line.ends_with(' ')) {
            // Complete command names
            let commands = vec![
                {%- for command_name, command in cli.commands.items() %}
                "{{ command_name }}",
                {%- endfor %}
                "help", "history", "exit", "cargo", "eval", "env"
            ];
            
            let prefix = parts.first().unwrap_or(&"");
            let matches: Vec<String> = commands
                .into_iter()
                .filter(|cmd| cmd.starts_with(prefix))
                .map(|s| s.to_string())
                .collect();
            
            Ok((line.len() - prefix.len(), matches))
        } else {
            // For now, return empty completions for arguments
            // This could be extended to provide context-aware completions
            Ok((pos, Vec::new()))
        }
    }
}

impl rustyline::highlight::Highlighter for RustCompletionHelper {
    fn highlight<'l>(&self, line: &'l str, _pos: usize) -> std::borrow::Cow<'l, str> {
        // Basic syntax highlighting could be added here
        std::borrow::Cow::Borrowed(line)
    }

    fn highlight_char(&self, _line: &str, _pos: usize) -> bool {
        false
    }
}

impl rustyline::hint::Hinter for RustCompletionHelper {
    type Hint = String;

    fn hint(&self, line: &str, pos: usize, _ctx: &rustyline::Context<'_>) -> Option<Self::Hint> {
        if pos < line.len() {
            return None;
        }
        
        // Provide hints for common commands
        match line.trim() {
            "h" => Some("elp".to_string()),
            "e" => Some("xit".to_string()),
            "c" => Some("argo".to_string()),
            "cargo b" => Some("uild".to_string()),
            "cargo t" => Some("est".to_string()),
            "cargo c" => Some("heck".to_string()),
            _ => None,
        }
    }
}

impl rustyline::Helper for RustCompletionHelper {}

/// Main entry point for the interactive mode
pub fn run_interactive() -> Result<()> {
    let mut shell = RustInteractiveShell::new()
        .context("Failed to initialize interactive shell")?;
    
    shell.run()
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_interactive_config_default() {
        let config = InteractiveConfig::default();
        assert_eq!(config.prompt, "{{ cli.name }}> ");
        assert_eq!(config.max_history_size, 1000);
        assert!(config.auto_save_history);
    }

    #[test]
    fn test_command_registry_has_builtins() {
        let commands = RustInteractiveShell::build_command_registry();
        assert!(commands.contains_key("help"));
        assert!(commands.contains_key("exit"));
        assert!(commands.contains_key("history"));
        assert!(commands.contains_key("cargo"));
    }
}