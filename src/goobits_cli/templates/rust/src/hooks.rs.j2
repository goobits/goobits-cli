//! Hook functions for {{ cli.name if cli else command_name }}
//! Auto-generated from {{ file_name | default('goobits.yaml') }}
//! 
//! Implement your business logic in these hook functions.
//! Each command will call its corresponding hook function.

use anyhow::Result;
use serde_json::json;
use std::collections::HashMap;

use crate::logger::{info, warn, error, debug, update_context, LogContext};

{% if cli and cli.commands -%}
{%- for cmd_name, cmd_data in cli.commands.items() %}
{%- if cmd_data.subcommands %}
{%- for sub_name, sub_data in cmd_data.subcommands.items() %}

/// Hook function for '{{ cmd_name }} {{ sub_name }}' command
pub fn on_{{ cmd_name | replace('-', '_') }}_{{ sub_name | replace('-', '_') }}(
    {%- if sub_data.args %}
    {%- for arg in sub_data.args %}
    {%- if arg.nargs and arg.nargs == "*" %}
    {{ arg.name }}: Vec<&str>,
    {%- else %}
    {{ arg.name }}: &str,
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    {%- if sub_data.options %}
    {%- for opt in sub_data.options %}
    {%- set var_name = "opt_" + opt.name if opt.name in ['verbose', 'config'] else opt.name %}
    {%- if opt.type == 'bool' or opt.type == 'flag' %}
    {{ var_name }}: bool,
    {%- elif opt.type == 'int' %}
    {{ var_name }}: Option<i32>,
    {%- else %}
    {{ var_name }}: Option<&str>,
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    verbose: bool,
    config: Option<&str>
) -> Result<()> {
    // Set up logging context for this command
    let mut context: LogContext = HashMap::new();
    context.insert("command".to_string(), json!("{{ cmd_name }}-{{ sub_name }}"));
    {%- if sub_data.args %}
    {%- for arg in sub_data.args %}
    {%- if arg.nargs and arg.nargs == "*" %}
    context.insert("{{ arg.name }}".to_string(), json!({{ arg.name }}));
    {%- else %}
    context.insert("{{ arg.name }}".to_string(), json!({{ arg.name }}));
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    {%- if sub_data.options %}
    {%- for opt in sub_data.options %}
    {%- set var_name = "opt_" + opt.name if opt.name in ['verbose', 'config'] else opt.name %}
    context.insert("{{ opt.name }}".to_string(), json!({{ var_name }}));
    {%- endfor %}
    {%- endif %}
    context.insert("verbose".to_string(), json!(verbose));
    if let Some(cfg) = config {
        context.insert("config".to_string(), json!(cfg));
    }
    update_context(context);

    info("hooks", "Executing {{ cmd_name }} {{ sub_name }} command", None);

    // TODO: Implement your business logic here
    // This is a placeholder implementation - replace with your actual logic
    {%- set command_key = cmd_name + "_" + sub_name %}
    {%- if command_key == "config_get" %}
    let value = match {{ sub_data.args[0].name if sub_data.args else 'key' }} {
        "theme" => std::env::var("{{ (command_name | upper) }}_THEME").unwrap_or_else(|_| "default".to_string()),
        "api_key" => std::env::var("{{ (command_name | upper) }}_API_KEY").unwrap_or_else(|_| "".to_string()),
        "timeout" => std::env::var("{{ (command_name | upper) }}_TIMEOUT").unwrap_or_else(|_| "30".to_string()),
        _ => {
            warn("hooks", &format!("Config key not found: {}", {{ sub_data.args[0].name if sub_data.args else 'key' }}), None);
            return Err(anyhow::anyhow!("Config key not found"));
        }
    };
    
    println!("{}: {}", {{ sub_data.args[0].name if sub_data.args else 'key' }}, value);
    {%- elif command_key == "config_set" %}
    println!("Setting {} to {}", {{ sub_data.args[0].name if sub_data.args else 'key' }}, {{ sub_data.args[1].name if sub_data.args and sub_data.args | length > 1 else 'value' }});
    // In a real implementation, you would save this to a config file or environment
    info("hooks", "Configuration updated", None);
    {%- elif command_key == "config_list" %}
    println!("theme: {}", std::env::var("{{ (command_name | upper) }}_THEME").unwrap_or_else(|_| "default".to_string()));
    println!("api_key: {}", std::env::var("{{ (command_name | upper) }}_API_KEY").unwrap_or_else(|_| "".to_string()));
    println!("timeout: {}", std::env::var("{{ (command_name | upper) }}_TIMEOUT").unwrap_or_else(|_| "30".to_string()));
    {%- elif command_key == "config_reset" %}
    {%- if sub_data.options %}
    {%- for opt in sub_data.options %}
    {%- if opt.name == "force" %}
    if !{{ "opt_" + opt.name if opt.name in ['verbose', 'config'] else opt.name }} {
        use std::io::{self, Write};
        print!("Are you sure you want to reset the configuration? (y/N): ");
        io::stdout().flush()?;
        
        let mut input = String::new();
        io::stdin().read_line(&mut input)?;
        
        if input.trim().to_lowercase() != "y" {
            println!("Reset cancelled");
            return Ok(());
        }
    }
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    
    println!("Configuration reset to defaults");
    info("hooks", "Configuration reset completed", None);
    {%- elif command_key == "file_create" %}
    use std::path::Path;
    use std::fs;
    
    let file_path = Path::new({{ sub_data.args[0].name if sub_data.args else 'path' }});
    
    if let Some(parent) = file_path.parent() {
        fs::create_dir_all(parent)?;
    }
    
    {%- if sub_data.args and sub_data.args | length > 1 %}
    {%- for arg in sub_data.args %}
    {%- if arg.name == "content" %}
    let content = {{ arg.name }};
    fs::write(file_path, content)?;
    {%- endif %}
    {%- endfor %}
    {%- else %}
    fs::write(file_path, "")?;
    {%- endif %}
    
    println!("Created file: {}", {{ sub_data.args[0].name if sub_data.args else 'path' }});
    info("hooks", &format!("File created: {}", {{ sub_data.args[0].name if sub_data.args else 'path' }}), None);
    {%- elif command_key == "file_delete" %}
    use std::fs;
    use std::io::ErrorKind;
    
    match fs::remove_file({{ sub_data.args[0].name if sub_data.args else 'path' }}) {
        Ok(_) => {
            println!("Deleted file: {}", {{ sub_data.args[0].name if sub_data.args else 'path' }});
            info("hooks", &format!("File deleted: {}", {{ sub_data.args[0].name if sub_data.args else 'path' }}), None);
        }
        Err(e) => {
            match e.kind() {
                ErrorKind::NotFound => {
                    warn("hooks", &format!("File not found: {}", {{ sub_data.args[0].name if sub_data.args else 'path' }}), None);
                    return Err(anyhow::anyhow!("File not found"));
                }
                ErrorKind::PermissionDenied => {
                    error("hooks", &format!("Permission denied: {}", {{ sub_data.args[0].name if sub_data.args else 'path' }}), None);
                    return Err(anyhow::anyhow!("Permission denied"));
                }
                _ => {
                    error("hooks", &format!("Error deleting file: {}", e), None);
                    return Err(e.into());
                }
            }
        }
    }
    {%- else %}
    println!("Executing {{ cmd_name }} {{ sub_name }} command...");
    {%- if sub_data.args %}
    {%- for arg in sub_data.args %}
    {%- if arg.nargs and arg.nargs == "*" %}
    println!("{{ arg.name }}: {:?}", {{ arg.name }});
    {%- else %}
    println!("{{ arg.name }}: {}", {{ arg.name }});
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    {%- if sub_data.options %}
    {%- for opt in sub_data.options %}
    {%- set var_name = "opt_" + opt.name if opt.name in ['verbose', 'config'] else opt.name %}
    println!("{{ opt.name }}: {:?}", {{ var_name }});
    {%- endfor %}
    {%- endif %}
    println!("Implement your logic here");
    {%- endif %}

    Ok(())
}
{%- endfor %}
{%- else %}

/// Hook function for '{{ cmd_name }}' command
pub fn on_{{ cmd_name | replace('-', '_') }}(
    {%- if cmd_data.args %}
    {%- for arg in cmd_data.args %}
    {%- if arg.nargs and arg.nargs == "*" %}
    {{ arg.name }}: Vec<&str>,
    {%- else %}
    {{ arg.name }}: &str,
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    {%- if cmd_data.options %}
    {%- for opt in cmd_data.options %}
    {%- set var_name = "opt_" + opt.name if opt.name in ['verbose', 'config'] else opt.name %}
    {%- if opt.type == 'bool' or opt.type == 'flag' %}
    {{ var_name }}: bool,
    {%- elif opt.type == 'int' %}
    {{ var_name }}: Option<i32>,
    {%- else %}
    {{ var_name }}: Option<&str>,
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    verbose: bool,
    config: Option<&str>
) -> Result<()> {
    // Set up logging context for this command
    let mut context: LogContext = HashMap::new();
    context.insert("command".to_string(), json!("{{ cmd_name }}"));
    {%- if cmd_data.args %}
    {%- for arg in cmd_data.args %}
    {%- if arg.nargs and arg.nargs == "*" %}
    context.insert("{{ arg.name }}".to_string(), json!({{ arg.name }}));
    {%- else %}
    context.insert("{{ arg.name }}".to_string(), json!({{ arg.name }}));
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    {%- if cmd_data.options %}
    {%- for opt in cmd_data.options %}
    {%- set var_name = "opt_" + opt.name if opt.name in ['verbose', 'config'] else opt.name %}
    context.insert("{{ opt.name }}".to_string(), json!({{ var_name }}));
    {%- endfor %}
    {%- endif %}
    context.insert("verbose".to_string(), json!(verbose));
    if let Some(cfg) = config {
        context.insert("config".to_string(), json!(cfg));
    }
    update_context(context);

    info("hooks", "Executing {{ cmd_name }} command", None);

    // TODO: Implement your business logic here
    // This is a placeholder implementation - replace with your actual logic
    {%- if cmd_name == "hello" %}
    let greeting = "Hello";
    {%- if cmd_data.args %}
    {%- for arg in cmd_data.args %}
    {%- if arg.name == "name" %}
    println!("{} {}", greeting, {{ arg.name }});
    {%- endif %}
    {%- endfor %}
    {%- else %}
    println!("{} World!", greeting);
    {%- endif %}
    {%- elif cmd_name == "fail" %}
    {%- if cmd_data.options %}
    {%- for opt in cmd_data.options %}
    {%- if opt.name == "code" %}
    let exit_code = {{ "opt_" + opt.name if opt.name in ['verbose', 'config'] else opt.name }}.unwrap_or(1);
    error("hooks", &format!("Command failed with exit code {}", exit_code), None);
    std::process::exit(exit_code);
    {%- endif %}
    {%- endfor %}
    {%- else %}
    error("hooks", "Command failed with exit code 1", None);
    std::process::exit(1);
    {%- endif %}
    {%- elif cmd_name == "echo" %}
    {%- if cmd_data.args %}
    {%- for arg in cmd_data.args %}
    {%- if arg.nargs and arg.nargs == "*" %}
    if !{{ arg.name }}.is_empty() {
        println!("{}", {{ arg.name }}.join(" "));
    }
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    {%- else %}
    println!("Executing {{ cmd_name }} command...");
    {%- if cmd_data.args %}
    {%- for arg in cmd_data.args %}
    {%- if arg.nargs and arg.nargs == "*" %}
    println!("{{ arg.name }}: {:?}", {{ arg.name }});
    {%- else %}
    println!("{{ arg.name }}: {}", {{ arg.name }});
    {%- endif %}
    {%- endfor %}
    {%- endif %}
    {%- if cmd_data.options %}
    {%- for opt in cmd_data.options %}
    {%- set var_name = "opt_" + opt.name if opt.name in ['verbose', 'config'] else opt.name %}
    println!("{{ opt.name }}: {:?}", {{ var_name }});
    {%- endfor %}
    {%- endif %}
    println!("Implement your logic here");
    {%- endif %}

    Ok(())
}
{%- endif %}
{%- endfor %}
{%- else %}
// No commands configured - add hook functions manually as needed

/// Example hook function
pub fn on_example_command(verbose: bool, config: Option<&str>) -> Result<()> {
    let mut context: LogContext = HashMap::new();
    context.insert("command".to_string(), json!("example"));
    context.insert("verbose".to_string(), json!(verbose));
    if let Some(cfg) = config {
        context.insert("config".to_string(), json!(cfg));
    }
    update_context(context);

    info("hooks", "Executing example command", None);
    println!("This is an example command. Edit src/hooks.rs to implement your logic.");
    Ok(())
}
{%- endif %}