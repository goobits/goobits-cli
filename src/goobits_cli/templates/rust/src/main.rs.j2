//! ╔══════════════════════════════════════════════════════════════════════════╗
//! ║                           AUTO-GENERATED FILE                               ║
//! ║                                                                              ║
//! ║  Generated by: goobits-cli v{{ version | default('1.0.0') }}                ║
//! ║  Generated from: {{ file_name | default('goobits.yaml') }}                  ║
//! ║  Generated on: {% now 'utc', '%Y-%m-%d %H:%M:%S' %}                         ║
//! ║                                                                              ║
//! ║  ⚠️  DO NOT EDIT THIS FILE MANUALLY                                         ║
//! ║  Changes will be overwritten on next generation                             ║
//! ║                                                                              ║
//! ║  To modify this CLI, edit the source configuration file                     ║
//! ║                                                                              ║
//! ╚══════════════════════════════════════════════════════════════════════════╝
//!
//! {{ cli.name if cli else command_name }} CLI - Rust Implementation
//! Generated from {{ file_name | default('goobits.yaml') }}

use clap::{Arg, ArgMatches, Command};
use std::process;
use anyhow::Result;
use serde_json::json;

mod logger;
mod hooks;

use logger::{setup_logging, info, error, set_context, create_command_context};

fn main() {
    // Initialize logging as early as possible
    if let Err(e) = setup_logging() {
        eprintln!("Failed to initialize logging: {}", e);
        process::exit(1);
    }

    info("main", "Starting {{ cli.name if cli else command_name }} CLI", None);

    let app = Command::new("{{ command_name }}")
        .about("{{ cli.tagline if cli and cli.tagline else (cli.description if cli and cli.description else 'CLI application') }}")
        .version("{{ version | default('1.0.0') }}")
        .subcommand_required(false)
        .arg_required_else_help(true)
        // Add global options
        .arg(Arg::new("verbose")
            .short('v')
            .long("verbose")
            .help("Enable verbose output")
            .action(clap::ArgAction::SetTrue)
            .global(true))
        .arg(Arg::new("config")
            .long("config")
            .help("Config file path")
            .value_name("PATH")
            .global(true));
    
    let app = build_cli(app);
    let matches = app.get_matches();
    
    if let Err(e) = handle_command(&matches) {
        logger::log_error("main", &e);
        process::exit(1);
    }

    info("main", "CLI execution completed successfully", None);
}

fn build_cli(app: Command) -> Command {
    let mut app = app;
    
    // Add commands from configuration
    {% if cli and cli.commands -%}
    {%- for cmd_name, cmd_data in cli.commands.items() %}
    {%- if cmd_data.subcommands %}
    // {{ cmd_name }} command group with subcommands
    app = app.subcommand(
        Command::new("{{ cmd_name }}")
            .about("{{ cmd_data.desc if cmd_data.desc else 'Command description' }}")
            .subcommand_required(true)
            .arg_required_else_help(true)
            {%- for sub_name, sub_data in cmd_data.subcommands.items() %}
            .subcommand(
                Command::new("{{ sub_name }}")
                    .about("{{ sub_data.desc if sub_data.desc else 'Subcommand description' }}")
                    {%- if sub_data.args %}
                    {%- for arg in sub_data.args %}
                    .arg(Arg::new("{{ arg.name }}")
                        .help("{{ arg.desc }}")
                        {%- if arg.nargs and arg.nargs == "*" %}
                        .num_args(0..)
                        {%- else %}
                        .required({{ 'true' if arg.required else 'false' }})
                        {%- endif %}
                        .value_name("{{ arg.name | upper }}"))
                    {%- endfor %}
                    {%- endif %}
                    {%- if sub_data.options %}
                    {%- for opt in sub_data.options %}
                    .arg(Arg::new("{{ opt.name }}")
                        .help("{{ opt.desc }}")
                        {%- if opt.short and opt.short != 'None' %}
                        .short('{{ opt.short }}')
                        {%- endif %}
                        .long("{{ opt.name }}")
                        {%- if opt.type == 'bool' or opt.type == 'flag' %}
                        .action(clap::ArgAction::SetTrue))
                        {%- elif opt.type == 'int' %}
                        .value_name("NUMBER"))
                        {%- else %}
                        .value_name("VALUE"))
                        {%- endif %}
                    {%- endfor %}
                    {%- endif %}
            )
            {%- endfor %}
    );
    {%- else %}
    // {{ cmd_name }} simple command
    app = app.subcommand(
        Command::new("{{ cmd_name }}")
            .about("{{ cmd_data.desc if cmd_data.desc else 'Command description' }}")
            {%- if cmd_data.args %}
            {%- for arg in cmd_data.args %}
            .arg(Arg::new("{{ arg.name }}")
                .help("{{ arg.desc }}")
                {%- if arg.nargs and arg.nargs == "*" %}
                .num_args(0..)
                {%- else %}
                .required({{ 'true' if arg.required else 'false' }})
                {%- endif %}
                .value_name("{{ arg.name | upper }}"))
            {%- endfor %}
            {%- endif %}
            {%- if cmd_data.options %}
            {%- for opt in cmd_data.options %}
            .arg(Arg::new("{{ opt.name }}")
                .help("{{ opt.desc }}")
                {%- if opt.short and opt.short != 'None' %}
                .short('{{ opt.short }}')
                {%- endif %}
                .long("{{ opt.name }}")
                {%- if opt.type == 'bool' or opt.type == 'flag' %}
                .action(clap::ArgAction::SetTrue))
                {%- elif opt.type == 'int' %}
                .value_name("NUMBER"))
                {%- else %}
                .value_name("VALUE"))
                {%- endif %}
            {%- endfor %}
            {%- endif %}
    );
    {%- endif %}
    {%- endfor %}
    {%- else %}
    // No commands configured
    {%- endif %}
    
    app
}

fn handle_command(matches: &ArgMatches) -> Result<()> {
    // Set global context for the command execution
    let verbose = matches.get_flag("verbose");
    let config = matches.get_one::<String>("config").map(|s| s.as_str());
    
    match matches.subcommand() {
        {%- if cli and cli.commands %}
        {%- for cmd_name, cmd_data in cli.commands.items() %}
        {%- if cmd_data.subcommands %}
        Some(("{{ cmd_name }}", sub_matches)) => {
            let context = create_command_context("{{ cmd_name }}", &[]);
            set_context(context);
            
            match sub_matches.subcommand() {
                {%- for sub_name, sub_data in cmd_data.subcommands.items() %}
                Some(("{{ sub_name }}", sub_sub_matches)) => {
                    // Extract parameters for {{ cmd_name }} {{ sub_name }}
                    {%- if sub_data.args %}
                    {%- for arg in sub_data.args %}
                    {%- if arg.nargs and arg.nargs == "*" %}
                    let {{ arg.name }}: Vec<&str> = sub_sub_matches.get_many::<String>("{{ arg.name }}")
                        .unwrap_or_default()
                        .map(|s| s.as_str())
                        .collect();
                    {%- else %}
                    let {{ arg.name }} = sub_sub_matches.get_one::<String>("{{ arg.name }}").map(|s| s.as_str()).unwrap_or("");
                    {%- endif %}
                    {%- endfor %}
                    {%- endif %}
                    {%- if sub_data.options %}
                    {%- for opt in sub_data.options %}
                    {%- set var_name = "opt_" + opt.name if opt.name in ['verbose', 'config'] else opt.name %}
                    {%- if opt.type == 'bool' or opt.type == 'flag' %}
                    let {{ var_name }} = sub_sub_matches.get_flag("{{ opt.name }}");
                    {%- elif opt.type == 'int' %}
                    let {{ var_name }}: Option<i32> = sub_sub_matches.get_one::<String>("{{ opt.name }}")
                        .and_then(|s| s.parse().ok());
                    {%- else %}
                    let {{ var_name }}: Option<&str> = sub_sub_matches.get_one::<String>("{{ opt.name }}").map(|s| s.as_str());
                    {%- endif %}
                    {%- endfor %}
                    {%- endif %}
                    
                    info("main", "Executing {{ cmd_name }} {{ sub_name }} command", None);
                    if let Err(e) = hooks::on_{{ cmd_name | replace('-', '_') }}_{{ sub_name | replace('-', '_') }}(
                        {%- if sub_data.args %}
                        {%- for arg in sub_data.args %}
                        {{ arg.name }},
                        {%- endfor %}
                        {%- endif %}
                        {%- if sub_data.options %}
                        {%- for opt in sub_data.options %}
                        {%- set var_name = "opt_" + opt.name if opt.name in ['verbose', 'config'] else opt.name %}
                        {{ var_name }},
                        {%- endfor %}
                        {%- endif %}
                        verbose,
                        config
                    ) {
                        error("main", &format!("Command {{ cmd_name }} {{ sub_name }} failed"), None);
                        return Err(e);
                    }
                    Ok(())
                }
                {%- endfor %}
                _ => {
                    error("main", "Unknown subcommand. Use --help for available options.", None);
                    process::exit(1);
                }
            }
        }
        {%- else %}
        Some(("{{ cmd_name }}", sub_matches)) => {
            let context = create_command_context("{{ cmd_name }}", &[]);
            set_context(context);
            
            // Extract parameters for {{ cmd_name }}
            {%- if cmd_data.args %}
            {%- for arg in cmd_data.args %}
            {%- if arg.nargs and arg.nargs == "*" %}
            let {{ arg.name }}: Vec<&str> = sub_matches.get_many::<String>("{{ arg.name }}")
                .unwrap_or_default()
                .map(|s| s.as_str())
                .collect();
            {%- else %}
            let {{ arg.name }} = sub_matches.get_one::<String>("{{ arg.name }}").map(|s| s.as_str()).unwrap_or("");
            {%- endif %}
            {%- endfor %}
            {%- endif %}
            {%- if cmd_data.options %}
            {%- for opt in cmd_data.options %}
            {%- set var_name = "opt_" + opt.name if opt.name in ['verbose', 'config'] else opt.name %}
            {%- if opt.type == 'bool' or opt.type == 'flag' %}
            let {{ var_name }} = sub_matches.get_flag("{{ opt.name }}");
            {%- elif opt.type == 'int' %}
            let {{ var_name }}: Option<i32> = sub_matches.get_one::<String>("{{ opt.name }}")
                .and_then(|s| s.parse().ok());
            {%- else %}
            let {{ var_name }}: Option<&str> = sub_matches.get_one::<String>("{{ opt.name }}").map(|s| s.as_str());
            {%- endif %}
            {%- endfor %}
            {%- endif %}
            
            info("main", "Executing {{ cmd_name }} command", None);
            if let Err(e) = hooks::on_{{ cmd_name | replace('-', '_') }}(
                {%- if cmd_data.args %}
                {%- for arg in cmd_data.args %}
                {{ arg.name }},
                {%- endfor %}
                {%- endif %}
                {%- if cmd_data.options %}
                {%- for opt in cmd_data.options %}
                {%- set var_name = "opt_" + opt.name if opt.name in ['verbose', 'config'] else opt.name %}
                {{ var_name }},
                {%- endfor %}
                {%- endif %}
                verbose,
                config
            ) {
                error("main", &format!("Command {{ cmd_name }} failed"), None);
                return Err(e);
            }
            Ok(())
        }
        {%- endif %}
        {%- endfor %}
        {%- endif %}
        _ => {
            info("main", "No command specified. Use --help for available commands.", None);
            Ok(())
        }
    }
}