/**
 * Error handling for {{ display_name }}
 * Auto-generated from {{ file_name }}
 */

use anyhow::Result;
use std::collections::HashMap;
use std::fmt;
use std::error::Error;
use thiserror::Error as ThisError;

/// Exit codes for different error types
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ExitCode {
    Success = 0,
    GeneralError = 1,
    Misuse = 2,
    ConfigError = 3,
    HookError = 4,
    PluginError = 5,
    DependencyError = 6,
    NetworkError = 7,
    Cancelled = 130,
}

impl ExitCode {
    /// Get the numeric exit code
    pub fn code(self) -> i32 {
        self as i32
    }

    /// Get a human-readable description
    pub fn description(self) -> &'static str {
        match self {
            ExitCode::Success => "Success",
            ExitCode::GeneralError => "General error",
            ExitCode::Misuse => "Command misuse",
            ExitCode::ConfigError => "Configuration error",
            ExitCode::HookError => "Hook execution error",
            ExitCode::PluginError => "Plugin error",
            ExitCode::DependencyError => "Dependency error",
            ExitCode::NetworkError => "Network error",
            ExitCode::Cancelled => "Operation cancelled",
        }
    }
}

/// Error severity levels
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum ErrorSeverity {
    Low,
    Medium,
    High,
    Critical,
}

impl fmt::Display for ErrorSeverity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            ErrorSeverity::Low => write!(f, "low"),
            ErrorSeverity::Medium => write!(f, "medium"),
            ErrorSeverity::High => write!(f, "high"),
            ErrorSeverity::Critical => write!(f, "critical"),
        }
    }
}

/// Context information for errors
#[derive(Debug, Clone)]
pub struct ErrorContext {
    pub command: Option<String>,
    pub subcommand: Option<String>,
    pub args: Vec<String>,
    pub options: HashMap<String, String>,
    pub working_directory: Option<std::path::PathBuf>,
    pub environment: HashMap<String, String>,
}

impl ErrorContext {
    pub fn new() -> Self {
        Self {
            command: None,
            subcommand: None,
            args: Vec::new(),
            options: HashMap::new(),
            working_directory: std::env::current_dir().ok(),
            environment: std::env::vars().collect(),
        }
    }

    pub fn with_command(mut self, command: String) -> Self {
        self.command = Some(command);
        self
    }

    pub fn with_subcommand(mut self, subcommand: String) -> Self {
        self.subcommand = Some(subcommand);
        self
    }

    pub fn with_args(mut self, args: Vec<String>) -> Self {
        self.args = args;
        self
    }

    pub fn with_option(mut self, key: String, value: String) -> Self {
        self.options.insert(key, value);
        self
    }
}

impl Default for ErrorContext {
    fn default() -> Self {
        Self::new()
    }
}

/// Main CLI error type
#[derive(ThisError, Debug)]
pub enum CLIError {
    #[error("Configuration error: {message}")]
    Config {
        message: String,
        config_path: Option<std::path::PathBuf>,
        config_section: Option<String>,
        #[source]
        source: Option<Box<dyn std::error::Error + Send + Sync>>,
    },

    #[error("Hook error ({hook_name}): {message}")]
    Hook {
        hook_name: String,
        message: String,
        hook_phase: Option<String>,
        #[source]
        source: Option<Box<dyn std::error::Error + Send + Sync>>,
    },

    #[error("Plugin error ({plugin_name}): {message}")]
    Plugin {
        plugin_name: String,
        message: String,
        plugin_version: Option<String>,
        #[source]
        source: Option<Box<dyn std::error::Error + Send + Sync>>,
    },

    #[error("Validation error: {field} = \"{value}\" - {message}")]
    Validation {
        field: String,
        value: String,
        message: String,
        constraint: Option<String>,
    },

    #[error("Dependency error ({dependency}): {message}")]
    Dependency {
        dependency: String,
        message: String,
        install_command: Option<String>,
        #[source]
        source: Option<Box<dyn std::error::Error + Send + Sync>>,
    },

    #[error("Network error: {message}")]
    Network {
        message: String,
        url: Option<String>,
        status_code: Option<u16>,
        #[source]
        source: Option<Box<dyn std::error::Error + Send + Sync>>,
    },

    #[error("Operation cancelled: {message}")]
    Cancelled { message: String },

    #[error("Command not found: {command}")]
    CommandNotFound {
        command: String,
        available_commands: Vec<String>,
        suggestions: Vec<String>,
    },

    #[error("IO error: {message}")]
    Io {
        message: String,
        path: Option<std::path::PathBuf>,
        #[source]
        source: std::io::Error,
    },

    #[error("Invalid format: {message}")]
    InvalidFormat {
        message: String,
        format_type: Option<String>,
        expected: Option<String>,
    },

    #[error("Validation failed: {message}")]
    ValidationFailed {
        message: String,
        field: Option<String>,
        value: Option<String>,
    },

    #[error("Write failed: {message}")]
    WriteFailed {
        message: String,
        path: Option<std::path::PathBuf>,
        #[source]
        source: Option<std::io::Error>,
    },

    #[error("Directory creation failed: {message}")]
    DirectoryCreationFailed {
        message: String,
        path: Option<std::path::PathBuf>,
        #[source]
        source: Option<std::io::Error>,
    },

    #[error("Exit with code {code}")]
    Exit {
        code: i32,
        message: Option<String>,
    },

    #[error("General error: {message}")]
    General {
        message: String,
        #[source]
        source: Option<Box<dyn std::error::Error + Send + Sync>>,
    },
}

/// Type alias for CLI results
pub type CliResult<T> = Result<T, CLIError>;

/// Type alias for command errors
pub type CommandError = CLIError;

/// Type alias for config errors
pub type ConfigError = CLIError;

/// Type alias for app errors
pub type AppError = CLIError;

impl CLIError {
    /// Get the appropriate exit code for this error
    pub fn exit_code(&self) -> ExitCode {
        match self {
            CLIError::Config { .. } => ExitCode::ConfigError,
            CLIError::Hook { .. } => ExitCode::HookError,
            CLIError::Plugin { .. } => ExitCode::PluginError,
            CLIError::Validation { .. } => ExitCode::Misuse,
            CLIError::Dependency { .. } => ExitCode::DependencyError,
            CLIError::Network { .. } => ExitCode::NetworkError,
            CLIError::Cancelled { .. } => ExitCode::Cancelled,
            CLIError::CommandNotFound { .. } => ExitCode::Misuse,
            CLIError::Io { .. } => ExitCode::GeneralError,
            CLIError::InvalidFormat { .. } => ExitCode::Misuse,
            CLIError::ValidationFailed { .. } => ExitCode::Misuse,
            CLIError::WriteFailed { .. } => ExitCode::GeneralError,
            CLIError::DirectoryCreationFailed { .. } => ExitCode::GeneralError,
            CLIError::Exit { code, .. } => match *code {
                0 => ExitCode::Success,
                1 => ExitCode::GeneralError,
                2 => ExitCode::Misuse,
                3 => ExitCode::ConfigError,
                4 => ExitCode::HookError,
                5 => ExitCode::PluginError,
                6 => ExitCode::DependencyError,
                7 => ExitCode::NetworkError,
                130 => ExitCode::Cancelled,
                _ => ExitCode::GeneralError,
            },
            CLIError::General { .. } => ExitCode::GeneralError,
        }
    }

    /// Get the error severity
    pub fn severity(&self) -> ErrorSeverity {
        match self {
            CLIError::Config { .. } => ErrorSeverity::High,
            CLIError::Hook { .. } => ErrorSeverity::Medium,
            CLIError::Plugin { .. } => ErrorSeverity::Medium,
            CLIError::Validation { .. } => ErrorSeverity::Low,
            CLIError::Dependency { .. } => ErrorSeverity::High,
            CLIError::Network { .. } => ErrorSeverity::Medium,
            CLIError::Cancelled { .. } => ErrorSeverity::Low,
            CLIError::CommandNotFound { .. } => ErrorSeverity::Low,
            CLIError::Io { .. } => ErrorSeverity::Medium,
            CLIError::InvalidFormat { .. } => ErrorSeverity::Low,
            CLIError::ValidationFailed { .. } => ErrorSeverity::Low,
            CLIError::WriteFailed { .. } => ErrorSeverity::Medium,
            CLIError::DirectoryCreationFailed { .. } => ErrorSeverity::Medium,
            CLIError::Exit { .. } => ErrorSeverity::Low,
            CLIError::General { .. } => ErrorSeverity::Medium,
        }
    }

    /// Get suggestions for fixing this error
    pub fn suggestions(&self) -> Vec<&str> {
        match self {
            CLIError::Config { .. } => vec![
                "Check the configuration file syntax",
                "Verify all required configuration values are set",
                "Run with --debug for more details",
            ],
            CLIError::Hook { .. } => vec![
                "Check the hook implementation",
                "Verify the hook file exists and is executable",
                "Run with --debug for more details",
            ],
            CLIError::Plugin { .. } => vec![
                "Check if the plugin is properly installed",
                "Verify plugin compatibility",
                "Try reinstalling the plugin",
            ],
            CLIError::Validation { .. } => vec![
                "Check the input format",
                "Refer to the help documentation",
                "Use --help for command usage",
            ],
            CLIError::Dependency { .. } => vec![
                "Install the missing dependency",
                "Check the installation documentation",
            ],
            CLIError::Network { .. } => vec![
                "Check your internet connection",
                "Verify the URL is correct",
                "Try again later",
            ],
            CLIError::Cancelled { .. } => vec!["Operation was cancelled by user"],
            CLIError::CommandNotFound { available_commands, .. } => {
                let mut suggestions = vec!["Use --help to see available commands"];
                if !available_commands.is_empty() {
                    suggestions.push("Available commands are listed above");
                }
                suggestions
            }
            CLIError::Io { .. } => vec![
                "Check file permissions",
                "Verify the path exists",
                "Ensure sufficient disk space",
            ],
            CLIError::InvalidFormat { .. } => vec![
                "Check the input format",
                "Refer to the documentation for examples",
            ],
            CLIError::ValidationFailed { .. } => vec![
                "Check the input values",
                "Ensure all required fields are provided",
                "Verify the value constraints",
            ],
            CLIError::WriteFailed { .. } => vec![
                "Check file permissions",
                "Ensure the directory exists",
                "Verify sufficient disk space",
            ],
            CLIError::DirectoryCreationFailed { .. } => vec![
                "Check directory permissions",
                "Ensure the parent directory exists",
                "Verify sufficient disk space",
            ],
            CLIError::Exit { .. } => vec!["Process exited with an error code"],
            CLIError::General { .. } => vec![
                "Run with --debug for more details",
                "Check the logs for more information",
            ],
        }
    }

    /// Create a config error
    pub fn config<S: Into<String>>(message: S) -> Self {
        CLIError::Config {
            message: message.into(),
            config_path: None,
            config_section: None,
            source: None,
        }
    }

    /// Create a hook error
    pub fn hook<S: Into<String>>(hook_name: S, message: S) -> Self {
        CLIError::Hook {
            hook_name: hook_name.into(),
            message: message.into(),
            hook_phase: None,
            source: None,
        }
    }

    /// Create a plugin error
    pub fn plugin<S: Into<String>>(plugin_name: S, message: S) -> Self {
        CLIError::Plugin {
            plugin_name: plugin_name.into(),
            message: message.into(),
            plugin_version: None,
            source: None,
        }
    }

    /// Create a validation error
    pub fn validation<S: Into<String>>(field: S, value: S, message: S) -> Self {
        CLIError::Validation {
            field: field.into(),
            value: value.into(),
            message: message.into(),
            constraint: None,
        }
    }

    /// Create a dependency error
    pub fn dependency<S: Into<String>>(dependency: S, message: S) -> Self {
        CLIError::Dependency {
            dependency: dependency.into(),
            message: message.into(),
            install_command: None,
            source: None,
        }
    }

    /// Create a network error
    pub fn network<S: Into<String>>(message: S) -> Self {
        CLIError::Network {
            message: message.into(),
            url: None,
            status_code: None,
            source: None,
        }
    }

    /// Create a cancelled error
    pub fn cancelled<S: Into<String>>(message: S) -> Self {
        CLIError::Cancelled {
            message: message.into(),
        }
    }

    /// Create a command not found error
    pub fn command_not_found<S: Into<String>>(command: S, available: Vec<String>) -> Self {
        let cmd = command.into();
        let suggestions = suggest_similar_commands(&cmd, &available);
        
        CLIError::CommandNotFound {
            command: cmd,
            available_commands: available,
            suggestions,
        }
    }

    /// Create a general error
    pub fn general<S: Into<String>>(message: S) -> Self {
        CLIError::General {
            message: message.into(),
            source: None,
        }
    }

    /// Create an IO error
    pub fn io<S: Into<String>>(message: S, source: std::io::Error) -> Self {
        CLIError::Io {
            message: message.into(),
            path: None,
            source,
        }
    }

    /// Create an invalid format error
    pub fn invalid_format<S: Into<String>>(message: S) -> Self {
        CLIError::InvalidFormat {
            message: message.into(),
            format_type: None,
            expected: None,
        }
    }

    /// Create a validation failed error
    pub fn validation_failed<S: Into<String>>(message: S) -> Self {
        CLIError::ValidationFailed {
            message: message.into(),
            field: None,
            value: None,
        }
    }

    /// Create a write failed error
    pub fn write_failed<S: Into<String>>(message: S) -> Self {
        CLIError::WriteFailed {
            message: message.into(),
            path: None,
            source: None,
        }
    }

    /// Create a directory creation failed error
    pub fn directory_creation_failed<S: Into<String>>(message: S) -> Self {
        CLIError::DirectoryCreationFailed {
            message: message.into(),
            path: None,
            source: None,
        }
    }

    /// Create an exit error
    pub fn exit(code: i32) -> Self {
        CLIError::Exit {
            code,
            message: None,
        }
    }

    /// Create an exit error with message
    pub fn exit_with_message<S: Into<String>>(code: i32, message: S) -> Self {
        CLIError::Exit {
            code,
            message: Some(message.into()),
        }
    }
}

/// Convert IO errors to CLI errors
impl From<std::io::Error> for CLIError {
    fn from(error: std::io::Error) -> Self {
        CLIError::Io {
            message: error.to_string(),
            path: None,
            source: error,
        }
    }
}

/// Error handling utilities
pub struct ErrorHandler {
    show_stack: bool,
    colorize: bool,
    context: Option<ErrorContext>,
}

impl ErrorHandler {
    pub fn new() -> Self {
        Self {
            show_stack: std::env::var("DEBUG").is_ok() || cfg!(debug_assertions),
            colorize: atty::is(atty::Stream::Stderr),
            context: None,
        }
    }

    pub fn with_context(mut self, context: ErrorContext) -> Self {
        self.context = Some(context);
        self
    }

    pub fn with_stack(mut self, show_stack: bool) -> Self {
        self.show_stack = show_stack;
        self
    }

    pub fn with_colors(mut self, colorize: bool) -> Self {
        self.colorize = colorize;
        self
    }

    /// Handle an error and exit with appropriate code
    pub fn handle_and_exit(&self, error: &CLIError) -> ! {
        self.display_error(error);
        std::process::exit(error.exit_code().code());
    }

    /// Display error without exiting
    pub fn display_error(&self, error: &CLIError) {
        if self.colorize {
            eprintln!("{} {}", 
                console::style("✗").red().bold(),
                console::style(error).red()
            );
        } else {
            eprintln!("✗ {}", error);
        }

        // Show suggestions
        let suggestions = error.suggestions();
        if !suggestions.is_empty() {
            if self.colorize {
                eprintln!("\n{}", console::style("Suggestions:").yellow().bold());
                for (i, suggestion) in suggestions.iter().enumerate() {
                    eprintln!("  {}. {}", 
                        console::style(i + 1).cyan(),
                        console::style(suggestion).white()
                    );
                }
            } else {
                eprintln!("\nSuggestions:");
                for (i, suggestion) in suggestions.iter().enumerate() {
                    eprintln!("  {}. {}", i + 1, suggestion);
                }
            }
        }

        // Show context if available and in debug mode
        if self.show_stack {
            if let Some(context) = &self.context {
                if self.colorize {
                    eprintln!("\n{}", console::style("Context:").yellow().bold());
                } else {
                    eprintln!("\nContext:");
                }

                if let Some(command) = &context.command {
                    eprintln!("  Command: {}", command);
                }
                if let Some(subcommand) = &context.subcommand {
                    eprintln!("  Subcommand: {}", subcommand);
                }
                if !context.args.is_empty() {
                    eprintln!("  Args: {:?}", context.args);
                }
                if let Some(wd) = &context.working_directory {
                    eprintln!("  Working Directory: {}", wd.display());
                }
            }

            // Show error chain
            let mut source = error.source();
            let mut depth = 0;
            while let Some(err) = source {
                depth += 1;
                if self.colorize {
                    eprintln!("  {}: {}", 
                        console::style(format!("Caused by [{}]", depth)).dim(),
                        console::style(err).white()
                    );
                } else {
                    eprintln!("  Caused by [{}]: {}", depth, err);
                }
                source = err.source();
            }
        }
    }
}

impl Default for ErrorHandler {
    fn default() -> Self {
        Self::new()
    }
}

/// Result type alias
pub type CLIResult<T> = Result<T, CLIError>;

/// Convenience functions for creating errors
pub fn config_error<S: Into<String>>(message: S) -> CLIError {
    CLIError::config(message)
}

pub fn hook_error<S: Into<String>>(hook_name: S, message: S) -> CLIError {
    CLIError::hook(hook_name, message)
}

pub fn plugin_error<S: Into<String>>(plugin_name: S, message: S) -> CLIError {
    CLIError::plugin(plugin_name, message)
}

pub fn validation_error<S: Into<String>>(field: S, value: S, message: S) -> CLIError {
    CLIError::validation(field, value, message)
}

pub fn dependency_error<S: Into<String>>(dependency: S, message: S) -> CLIError {
    CLIError::dependency(dependency, message)
}

pub fn network_error<S: Into<String>>(message: S) -> CLIError {
    CLIError::network(message)
}

pub fn cancelled_error<S: Into<String>>(message: S) -> CLIError {
    CLIError::cancelled(message)
}

pub fn general_error<S: Into<String>>(message: S) -> CLIError {
    CLIError::general(message)
}

pub fn invalid_format_error<S: Into<String>>(message: S) -> CLIError {
    CLIError::invalid_format(message)
}

pub fn validation_failed_error<S: Into<String>>(message: S) -> CLIError {
    CLIError::validation_failed(message)
}

pub fn write_failed_error<S: Into<String>>(message: S) -> CLIError {
    CLIError::write_failed(message)
}

pub fn directory_creation_failed_error<S: Into<String>>(message: S) -> CLIError {
    CLIError::directory_creation_failed(message)
}

pub fn exit_error(code: i32) -> CLIError {
    CLIError::exit(code)
}

/// Suggest similar commands using Levenshtein distance
fn suggest_similar_commands(input: &str, available: &[String]) -> Vec<String> {
    let mut suggestions = Vec::new();
    
    for cmd in available {
        let distance = levenshtein_distance(input, cmd);
        // Suggest commands with distance <= 2 and length difference <= 3
        if distance <= 2 && input.len().abs_diff(cmd.len()) <= 3 {
            suggestions.push(cmd.clone());
        }
    }
    
    // Sort by distance and return top 3
    suggestions.sort_by_key(|cmd| levenshtein_distance(input, cmd));
    suggestions.truncate(3);
    suggestions
}

/// Simple Levenshtein distance implementation
fn levenshtein_distance(s1: &str, s2: &str) -> usize {
    let len1 = s1.chars().count();
    let len2 = s2.chars().count();
    
    if len1 == 0 { return len2; }
    if len2 == 0 { return len1; }
    
    let mut matrix = vec![vec![0; len2 + 1]; len1 + 1];
    
    for i in 0..=len1 { matrix[i][0] = i; }
    for j in 0..=len2 { matrix[0][j] = j; }
    
    let s1_chars: Vec<char> = s1.chars().collect();
    let s2_chars: Vec<char> = s2.chars().collect();
    
    for i in 1..=len1 {
        for j in 1..=len2 {
            let cost = if s1_chars[i-1] == s2_chars[j-1] { 0 } else { 1 };
            matrix[i][j] = std::cmp::min(
                std::cmp::min(
                    matrix[i-1][j] + 1,      // deletion
                    matrix[i][j-1] + 1       // insertion
                ),
                matrix[i-1][j-1] + cost      // substitution
            );
        }
    }
    
    matrix[len1][len2]
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_exit_codes() {
        assert_eq!(ExitCode::Success.code(), 0);
        assert_eq!(ExitCode::GeneralError.code(), 1);
        assert_eq!(ExitCode::ConfigError.code(), 3);
    }

    #[test]
    fn test_error_creation() {
        let error = CLIError::config("Invalid configuration");
        assert_eq!(error.exit_code(), ExitCode::ConfigError);
        assert_eq!(error.severity(), ErrorSeverity::High);
    }

    #[test]
    fn test_command_suggestions() {
        let available = vec!["start".to_string(), "stop".to_string(), "status".to_string()];
        let suggestions = suggest_similar_commands("stat", &available);
        assert!(suggestions.contains(&"status".to_string()));
    }

    #[test]
    fn test_levenshtein_distance() {
        assert_eq!(levenshtein_distance("stat", "status"), 2);
        assert_eq!(levenshtein_distance("start", "stop"), 4);
        assert_eq!(levenshtein_distance("test", "test"), 0);
    }
}