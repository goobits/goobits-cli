/**
 * Configuration module for {{ display_name }}
 * Auto-generated from {{ file_name }}
 */

use crate::errors::{CliResult, ConfigError};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::path::PathBuf;

/// Application configuration
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AppConfig {
    /// General settings
    pub settings: Settings,
    /// Feature flags
    pub features: Features,
    /// User preferences
    pub preferences: Preferences,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Settings {
    /// Application version
    pub version: String,
    /// Enable automatic updates
    pub auto_update: bool,
    /// Log level (debug, info, warn, error)
    pub log_level: String,
    /// Configuration file format (yaml, json, toml)
    pub config_format: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Features {
    /// Enable colored output
    pub colored_output: bool,
    /// Show progress bars
    pub progress_bars: bool,
    /// Enable interactive prompts
    pub interactive_mode: bool,
    /// Use Unicode symbols
    pub unicode_symbols: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Preferences {
    /// Default editor for file editing
    pub editor: Option<String>,
    /// Default output format
    pub output_format: String,
    /// Custom aliases for commands
    pub aliases: HashMap<String, String>,
    /// User-specific settings
    pub custom: HashMap<String, String>,
}

impl Default for AppConfig {
    fn default() -> Self {
        let mut aliases = HashMap::new();
        let mut custom = HashMap::new();
        
        // Add some default aliases if defined in goobits.yaml
        {% for cmd_name, cmd_data in cli.commands.items() %}
        {% if cmd_data.alias %}
        aliases.insert("{{ cmd_data.alias }}".to_string(), "{{ cmd_name }}".to_string());
        {% endif %}
        {% endfor %}
        
        Self {
            settings: Settings {
                version: "{{ version | default('1.0.0') }}".to_string(),
                auto_update: false,
                log_level: "info".to_string(),
                config_format: "yaml".to_string(),
            },
            features: Features {
                colored_output: true,
                progress_bars: true,
                interactive_mode: true,
                unicode_symbols: true,
            },
            preferences: Preferences {
                editor: None,
                output_format: "human".to_string(),
                aliases,
                custom,
            },
        }
    }
}

impl AppConfig {
    /// Load configuration from multiple possible locations and formats
    pub fn load() -> Result<Self, ConfigError> {
        // Search for configuration files in order of preference
        let search_paths = Self::get_config_search_paths()?;
        
        for (path, format) in search_paths {
            if path.exists() {
                let content = std::fs::read_to_string(&path)
                    .map_err(|e| ConfigError::NotFound { 
                        path: path.clone() 
                    })?;
                
                let config = match format.as_str() {
                    "yaml" | "yml" => serde_yaml::from_str::<AppConfig>(&content)
                        .map_err(|e| ConfigError::InvalidFormat {
                            path: path.clone(),
                            reason: format!("YAML parsing error: {}", e),
                        })?,
                    "json" => serde_json::from_str::<AppConfig>(&content)
                        .map_err(|e| ConfigError::InvalidFormat {
                            path: path.clone(),
                            reason: format!("JSON parsing error: {}", e),
                        })?,
                    "toml" => toml::from_str::<AppConfig>(&content)
                        .map_err(|e| ConfigError::InvalidFormat {
                            path: path.clone(),
                            reason: format!("TOML parsing error: {}", e),
                        })?,
                    _ => {
                        return Err(ConfigError::InvalidFormat {
                            path: path.clone(),
                            reason: format!("Unsupported config format: {}", format),
                        });
                    }
                };
                
                // Validate the loaded configuration
                config.validate()?;
                
                return Ok(config);
            }
        }
        
        // No config file found, create default
        let config = Self::default();
        config.save().map_err(|e| match e {
            ConfigError::DirectoryCreationFailed { .. } => e,
            ConfigError::WriteFailed { .. } => e,
            _ => ConfigError::ValidationFailed {
                message: "Failed to create default configuration".to_string(),
            },
        })?;
        Ok(config)
    }
    
    /// Get search paths for configuration files in order of preference
    fn get_config_search_paths() -> Result<Vec<(PathBuf, String)>, ConfigError> {
        let mut paths = Vec::new();
        
        // 1. Current directory (highest priority)
        let current_dir = std::env::current_dir()
            .map_err(|e| ConfigError::ValidationFailed {
                message: format!("Cannot access current directory: {}", e),
            })?;
        paths.push((current_dir.join(".{{ package_name }}.yaml"), "yaml".to_string()));
        paths.push((current_dir.join(".{{ package_name }}.yml"), "yaml".to_string()));
        paths.push((current_dir.join(".{{ package_name }}.json"), "json".to_string()));
        paths.push((current_dir.join(".{{ package_name }}.toml"), "toml".to_string()));
        paths.push((current_dir.join("{{ package_name }}.yaml"), "yaml".to_string()));
        paths.push((current_dir.join("{{ package_name }}.yml"), "yaml".to_string()));
        paths.push((current_dir.join("{{ package_name }}.json"), "json".to_string()));
        paths.push((current_dir.join("{{ package_name }}.toml"), "toml".to_string()));
        
        // 2. User config directory
        let config_dir = Self::config_dir()
            .map_err(|e| ConfigError::ValidationFailed {
                message: format!("Cannot determine config directory: {}", e),
            })?;
        paths.push((config_dir.join("config.yaml"), "yaml".to_string()));
        paths.push((config_dir.join("config.yml"), "yaml".to_string()));
        paths.push((config_dir.join("config.json"), "json".to_string()));
        paths.push((config_dir.join("config.toml"), "toml".to_string()));
        
        // 3. XDG config directory (Linux/Unix)
        if let Ok(xdg_config) = std::env::var("XDG_CONFIG_HOME") {
            let xdg_dir = PathBuf::from(xdg_config).join("{{ package_name }}");
            paths.push((xdg_dir.join("config.yaml"), "yaml".to_string()));
            paths.push((xdg_dir.join("config.yml"), "yaml".to_string()));
            paths.push((xdg_dir.join("config.json"), "json".to_string()));
            paths.push((xdg_dir.join("config.toml"), "toml".to_string()));
        }
        
        // 4. Home directory RC files
        if let Some(home_dir) = dirs::home_dir() {
            paths.push((home_dir.join(".{{ package_name }}rc"), "yaml".to_string()));
            paths.push((home_dir.join(".{{ package_name }}rc.yaml"), "yaml".to_string()));
            paths.push((home_dir.join(".{{ package_name }}rc.yml"), "yaml".to_string()));
            paths.push((home_dir.join(".{{ package_name }}rc.json"), "json".to_string()));
            paths.push((home_dir.join(".{{ package_name }}rc.toml"), "toml".to_string()));
        }
        
        // 5. System-wide config (Unix-like systems)
        #[cfg(unix)]
        {
            paths.push((PathBuf::from("/etc/{{ package_name }}/config.yaml"), "yaml".to_string()));
            paths.push((PathBuf::from("/etc/{{ package_name }}/config.yml"), "yaml".to_string()));
            paths.push((PathBuf::from("/etc/{{ package_name }}/config.json"), "json".to_string()));
            paths.push((PathBuf::from("/etc/{{ package_name }}/config.toml"), "toml".to_string()));
        }
        
        Ok(paths)
    }
    
    /// Save configuration to file
    pub fn save(&self) -> Result<(), ConfigError> {
        // Validate before saving
        self.validate()?;
        
        let config_path = Self::config_file_path()?;
        
        // Ensure config directory exists
        if let Some(parent) = config_path.parent() {
            std::fs::create_dir_all(parent)
                .map_err(|e| ConfigError::DirectoryCreationFailed {
                    path: parent.to_path_buf(),
                    reason: e.to_string(),
                })?;
        }
        
        let content = serde_yaml::to_string(self)
            .map_err(|e| ConfigError::WriteFailed {
                path: config_path.clone(),
                reason: format!("Serialization failed: {}", e),
            })?;
        
        std::fs::write(&config_path, content)
            .map_err(|e| ConfigError::WriteFailed {
                path: config_path.clone(),
                reason: format!("File write failed: {}", e),
            })?;
        
        Ok(())
    }
    
    /// Get the path to the configuration file
    pub fn config_file_path() -> Result<PathBuf, ConfigError> {
        let config_dir = Self::config_dir()
            .map_err(|e| ConfigError::ValidationFailed {
                message: format!("Cannot determine config directory: {}", e),
            })?;
        Ok(config_dir.join("config.yaml"))
    }
    
    /// Get the configuration directory path
    pub fn config_dir() -> Result<PathBuf, ConfigError> {
        let home_dir = dirs::home_dir()
            .ok_or_else(|| ConfigError::ValidationFailed {
                message: "Could not determine home directory".to_string(),
            })?;
        
        Ok(home_dir.join(".config").join("{{ package_name }}"))
    }
    
    /// List all available configuration files (for debugging/info)
    pub fn list_config_files() -> Result<Vec<(PathBuf, String, bool)>, ConfigError> {
        let search_paths = Self::get_config_search_paths()?;
        let mut found_files = Vec::new();
        
        for (path, format) in search_paths {
            let exists = path.exists();
            found_files.push((path, format, exists));
        }
        
        Ok(found_files)
    }
    
    /// Get the configuration file that would be loaded (highest priority existing file)
    pub fn get_active_config_file() -> Result<Option<(PathBuf, String)>, ConfigError> {
        let search_paths = Self::get_config_search_paths()?;
        
        for (path, format) in search_paths {
            if path.exists() {
                return Ok(Some((path, format)));
            }
        }
        
        Ok(None)
    }
    
    /// Save configuration to file in the specified format
    pub fn save_as(&self, format: &str) -> Result<(), ConfigError> {
        // Validate before saving
        self.validate()?;
        
        let config_dir = Self::config_dir()?;
        std::fs::create_dir_all(&config_dir)
            .map_err(|e| ConfigError::DirectoryCreationFailed {
                path: config_dir.clone(),
                reason: e.to_string(),
            })?;
        
        let (filename, content) = match format {
            "yaml" | "yml" => {
                let content = serde_yaml::to_string(self)
                    .map_err(|e| ConfigError::WriteFailed {
                        path: config_dir.join("config.yaml"),
                        reason: format!("YAML serialization failed: {}", e),
                    })?;
                ("config.yaml", content)
            },
            "json" => {
                let content = serde_json::to_string_pretty(self)
                    .map_err(|e| ConfigError::WriteFailed {
                        path: config_dir.join("config.json"),
                        reason: format!("JSON serialization failed: {}", e),
                    })?;
                ("config.json", content)
            },
            "toml" => {
                let content = toml::to_string_pretty(self)
                    .map_err(|e| ConfigError::WriteFailed {
                        path: config_dir.join("config.toml"),
                        reason: format!("TOML serialization failed: {}", e),
                    })?;
                ("config.toml", content)
            },
            _ => {
                return Err(ConfigError::InvalidFormat {
                    path: config_dir.clone(),
                    reason: format!("Unsupported config format: {}", format),
                });
            }
        };
        
        let config_path = config_dir.join(filename);
        std::fs::write(&config_path, content)
            .map_err(|e| ConfigError::WriteFailed {
                path: config_path.clone(),
                reason: format!("File write failed: {}", e),
            })?;
        
        Ok(())
    }
    
    /// Get a custom setting by key
    pub fn get_custom(&self, key: &str) -> Option<&String> {
        self.preferences.custom.get(key)
    }
    
    /// Set a custom setting
    pub fn set_custom(&mut self, key: String, value: String) {
        self.preferences.custom.insert(key, value);
    }
    
    /// Get an alias for a command
    pub fn get_alias(&self, alias: &str) -> Option<&String> {
        self.preferences.aliases.get(alias)
    }
    
    /// Add a command alias
    pub fn add_alias(&mut self, alias: String, command: String) {
        self.preferences.aliases.insert(alias, command);
    }
    
    /// Remove a command alias
    pub fn remove_alias(&mut self, alias: &str) -> Option<String> {
        self.preferences.aliases.remove(alias)
    }
    
    /// Check if a feature is enabled
    pub fn is_feature_enabled(&self, feature: &str) -> bool {
        match feature {
            "colored_output" => self.features.colored_output,
            "progress_bars" => self.features.progress_bars,
            "interactive_mode" => self.features.interactive_mode,
            "unicode_symbols" => self.features.unicode_symbols,
            _ => false,
        }
    }
    
    /// Enable or disable a feature
    pub fn set_feature(&mut self, feature: &str, enabled: bool) -> Result<(), ConfigError> {
        match feature {
            "colored_output" => self.features.colored_output = enabled,
            "progress_bars" => self.features.progress_bars = enabled,
            "interactive_mode" => self.features.interactive_mode = enabled,
            "unicode_symbols" => self.features.unicode_symbols = enabled,
            _ => {
                return Err(ConfigError::InvalidValue {
                    key: "feature".to_string(),
                    value: feature.to_string(),
                    expected: "colored_output, progress_bars, interactive_mode, or unicode_symbols".to_string(),
                });
            }
        }
        Ok(())
    }
    
    /// Validate the configuration
    pub fn validate(&self) -> Result<(), ConfigError> {
        // Validate log level
        match self.settings.log_level.as_str() {
            "debug" | "info" | "warn" | "error" => {}
            _ => {
                return Err(ConfigError::InvalidValue {
                    key: "log_level".to_string(),
                    value: self.settings.log_level.clone(),
                    expected: "debug, info, warn, or error".to_string(),
                });
            }
        }
        
        // Validate output format
        match self.preferences.output_format.as_str() {
            "human" | "json" | "yaml" | "table" => {}
            _ => {
                return Err(ConfigError::InvalidValue {
                    key: "output_format".to_string(),
                    value: self.preferences.output_format.clone(),
                    expected: "human, json, yaml, or table".to_string(),
                });
            }
        }
        
        // Validate config format
        match self.settings.config_format.as_str() {
            "yaml" | "json" | "toml" => {}
            _ => {
                return Err(ConfigError::InvalidValue {
                    key: "config_format".to_string(),
                    value: self.settings.config_format.clone(),
                    expected: "yaml, json, or toml".to_string(),
                });
            }
        }
        
        // Validate version format (basic semantic version check)
        if !is_valid_semver(&self.settings.version) {
            return Err(ConfigError::InvalidValue {
                key: "version".to_string(),
                value: self.settings.version.clone(),
                expected: "semantic version (e.g., 1.0.0)".to_string(),
            });
        }
        
        // Validate editor if specified
        if let Some(editor) = &self.preferences.editor {
            if editor.is_empty() {
                return Err(ConfigError::InvalidValue {
                    key: "editor".to_string(),
                    value: editor.clone(),
                    expected: "non-empty editor command".to_string(),
                });
            }
        }
        
        Ok(())
    }
    
    /// Merge configuration from another source
    pub fn merge(&mut self, other: &AppConfig) -> Result<(), ConfigError> {
        // Validate the other config first
        other.validate()?;
        
        // Merge settings (other takes precedence)
        if other.settings.version != "{{ version | default('1.0.0') }}" {
            self.settings.version = other.settings.version.clone();
        }
        self.settings.auto_update = other.settings.auto_update;
        self.settings.log_level = other.settings.log_level.clone();
        self.settings.config_format = other.settings.config_format.clone();
        
        // Merge features
        self.features = other.features.clone();
        
        // Merge preferences (extend collections)
        if other.preferences.editor.is_some() {
            self.preferences.editor = other.preferences.editor.clone();
        }
        self.preferences.output_format = other.preferences.output_format.clone();
        
        // Merge aliases and custom settings (other takes precedence)
        for (key, value) in &other.preferences.aliases {
            self.preferences.aliases.insert(key.clone(), value.clone());
        }
        
        for (key, value) in &other.preferences.custom {
            self.preferences.custom.insert(key.clone(), value.clone());
        }
        
        // Validate the merged result
        self.validate()?;
        
        Ok(())
    }
    
    /// Reset configuration to defaults
    pub fn reset(&mut self) {
        *self = Self::default();
    }
    
    /// Export configuration for backup or transfer
    pub fn export(&self, format: &str) -> Result<String, ConfigError> {
        // Validate before export
        self.validate()?;
        
        match format {
            "yaml" | "yml" => {
                serde_yaml::to_string(self)
                    .map_err(|e| ConfigError::InvalidFormat {
                        path: PathBuf::from("export"),
                        reason: format!("YAML serialization failed: {}", e),
                    })
            }
            "json" => {
                serde_json::to_string_pretty(self)
                    .map_err(|e| ConfigError::InvalidFormat {
                        path: PathBuf::from("export"),
                        reason: format!("JSON serialization failed: {}", e),
                    })
            }
            "toml" => {
                toml::to_string_pretty(self)
                    .map_err(|e| ConfigError::InvalidFormat {
                        path: PathBuf::from("export"),
                        reason: format!("TOML serialization failed: {}", e),
                    })
            }
            _ => Err(ConfigError::InvalidFormat {
                path: PathBuf::from("export"),
                reason: format!("Unsupported export format: {}", format),
            })
        }
    }
    
    /// Import configuration from string
    pub fn import(&mut self, content: &str, format: &str) -> Result<(), ConfigError> {
        let imported_config = match format {
            "yaml" | "yml" => {
                serde_yaml::from_str::<AppConfig>(content)
                    .map_err(|e| ConfigError::InvalidFormat {
                        path: PathBuf::from("import"),
                        reason: format!("YAML parsing failed: {}", e),
                    })?
            }
            "json" => {
                serde_json::from_str::<AppConfig>(content)
                    .map_err(|e| ConfigError::InvalidFormat {
                        path: PathBuf::from("import"),
                        reason: format!("JSON parsing failed: {}", e),
                    })?
            }
            "toml" => {
                toml::from_str::<AppConfig>(content)
                    .map_err(|e| ConfigError::InvalidFormat {
                        path: PathBuf::from("import"),
                        reason: format!("TOML parsing failed: {}", e),
                    })?
            }
            _ => {
                return Err(ConfigError::InvalidFormat {
                    path: PathBuf::from("import"),
                    reason: format!("Unsupported import format: {}", format),
                });
            }
        };
        
        // Merge the imported configuration
        self.merge(&imported_config)?;
        
        Ok(())
    }
}

/// Helper function to validate semantic version strings
fn is_valid_semver(version: &str) -> bool {
    let parts: Vec<&str> = version.split('.').collect();
    if parts.len() != 3 {
        return false;
    }
    
    for part in parts {
        if part.parse::<u32>().is_err() {
            return false;
        }
    }
    
    true
}

#[cfg(test)]
mod tests {
    use super::*;
    use tempfile::TempDir;
    
    #[test]
    fn test_default_config() {
        let config = AppConfig::default();
        assert_eq!(config.settings.version, "{{ version | default('1.0.0') }}");
        assert!(config.features.colored_output);
        assert_eq!(config.preferences.output_format, "human");
        assert!(config.validate().is_ok());
    }
    
    #[test]
    fn test_config_validation() {
        let mut config = AppConfig::default();
        assert!(config.validate().is_ok());
        
        // Test invalid log level
        config.settings.log_level = "invalid".to_string();
        assert!(config.validate().is_err());
        
        // Fix and test invalid output format
        config.settings.log_level = "info".to_string();
        config.preferences.output_format = "invalid".to_string();
        assert!(config.validate().is_err());
        
        // Fix and test invalid version
        config.preferences.output_format = "human".to_string();
        config.settings.version = "not.a.version".to_string();
        assert!(config.validate().is_err());
    }
    
    #[test]
    fn test_feature_management() {
        let mut config = AppConfig::default();
        
        assert!(config.is_feature_enabled("colored_output"));
        assert!(config.set_feature("colored_output", false).is_ok());
        assert!(!config.is_feature_enabled("colored_output"));
        
        // Test invalid feature
        assert!(config.set_feature("invalid_feature", true).is_err());
    }
    
    #[test]
    fn test_alias_management() {
        let mut config = AppConfig::default();
        
        config.add_alias("h".to_string(), "help".to_string());
        assert_eq!(config.get_alias("h"), Some(&"help".to_string()));
        
        let removed = config.remove_alias("h");
        assert_eq!(removed, Some("help".to_string()));
        assert_eq!(config.get_alias("h"), None);
    }
    
    #[test]
    fn test_semver_validation() {
        assert!(is_valid_semver("1.0.0"));
        assert!(is_valid_semver("0.1.2"));
        assert!(is_valid_semver("10.20.30"));
        assert!(!is_valid_semver("1.0"));
        assert!(!is_valid_semver("1.0.0.0"));
        assert!(!is_valid_semver("1.a.0"));
        assert!(!is_valid_semver(""));
    }
    
    #[test]
    fn test_config_merge() {
        let mut config1 = AppConfig::default();
        let mut config2 = AppConfig::default();
        
        config2.settings.log_level = "debug".to_string();
        config2.features.colored_output = false;
        config2.add_alias("test".to_string(), "command".to_string());
        
        assert!(config1.merge(&config2).is_ok());
        assert_eq!(config1.settings.log_level, "debug");
        assert!(!config1.features.colored_output);
        assert_eq!(config1.get_alias("test"), Some(&"command".to_string()));
    }
    
    #[test]
    fn test_export_import() {
        let config = AppConfig::default();
        
        // Test YAML export/import
        let yaml_export = config.export("yaml").unwrap();
        let mut imported_config = AppConfig::default();
        imported_config.settings.log_level = "debug".to_string(); // Make it different
        
        assert!(imported_config.import(&yaml_export, "yaml").is_ok());
        // After import, it should be merged, so log_level might be overridden
        
        // Test JSON export/import
        let json_export = config.export("json").unwrap();
        let mut json_config = AppConfig::default();
        assert!(json_config.import(&json_export, "json").is_ok());
        
        // Test invalid format
        assert!(config.export("invalid").is_err());
        assert!(imported_config.import("invalid content", "yaml").is_err());
    }
}