/*!
Progress indicators and visual feedback helpers for {{ display_name }}
Generated by goobits-cli
*/

use std::sync::Arc;
use std::time::Duration;
use indicatif::{ProgressBar, ProgressStyle, MultiProgress, ProgressState, ProgressFinish};
use console::{style, Emoji};
use std::fmt::Write;

// Custom Error Types for Progress Operations
#[derive(Debug, thiserror::Error)]
pub enum ProgressError {
    #[error("Progress operation failed: {message}")]
    OperationFailed { message: String },
    
    #[error("Progress bar creation failed: {reason}")]
    CreationFailed { reason: String },
    
    #[error("Invalid progress configuration: {config}")]
    InvalidConfiguration { config: String },
}

// Emoji and styling constants
static CHECKMARK: Emoji<'_, '_> = Emoji("‚úÖ", "‚úì");
static CROSS: Emoji<'_, '_> = Emoji("‚ùå", "‚úó");
static WARNING: Emoji<'_, '_> = Emoji("‚ö†Ô∏è", "‚ö†");
static INFO: Emoji<'_, '_> = Emoji("‚ÑπÔ∏è", "i");
static SPINNER: Emoji<'_, '_> = Emoji("üîÑ", "‚ü≥");

/// Progress helper for creating and managing progress indicators
pub struct ProgressHelper {
    multi_progress: Arc<MultiProgress>,
    style_enabled: bool,
}

impl Default for ProgressHelper {
    fn default() -> Self {
        Self::new()
    }
}

impl ProgressHelper {
    /// Create a new progress helper with default configuration
    pub fn new() -> Self {
        Self {
            multi_progress: Arc::new(MultiProgress::new()),
            style_enabled: console::colors_enabled() && !atty::is(atty::Stream::Stdout),
        }
    }
    
    /// Create a new progress helper with styling disabled
    pub fn new_plain() -> Self {
        Self {
            multi_progress: Arc::new(MultiProgress::new()),
            style_enabled: false,
        }
    }
    
    /// Create a spinner with custom message and style
    pub fn spinner(&self, message: &str) -> ProgressBar {
        let pb = if self.style_enabled {
            let pb = self.multi_progress.add(ProgressBar::new_spinner());
            pb.set_style(
                ProgressStyle::with_template("{spinner:.blue} {msg}")
                    .unwrap()
                    .tick_strings(&["‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è"])
            );
            pb.set_message(message.to_string());
            pb.enable_steady_tick(Duration::from_millis(80));
            pb
        } else {
            let pb = ProgressBar::hidden();
            eprintln!("{} {}", SPINNER, message);
            pb
        };
        pb
    }
    
    /// Create a progress bar with known total
    pub fn progress_bar(&self, total: u64, message: &str) -> ProgressBar {
        let pb = if self.style_enabled {
            let pb = self.multi_progress.add(ProgressBar::new(total));
            pb.set_style(
                ProgressStyle::with_template(
                    "{msg:20} [{elapsed_precise}] [{wide_bar:.cyan/blue}] {pos:>7}/{len:7} ({percent}%) ETA: {eta}"
                )
                .unwrap()
                .with_key("eta", |state: &ProgressState, w: &mut dyn Write| {
                    write!(w, "{:.1}s", state.eta().as_secs_f64()).unwrap()
                })
                .progress_chars("##-")
            );
            pb.set_message(message.to_string());
            pb
        } else {
            let pb = ProgressBar::hidden();
            eprintln!("{}", message);
            pb
        };
        pb
    }
    
    /// Create a progress bar with unknown total (indeterminate)
    pub fn indeterminate_progress(&self, message: &str) -> ProgressBar {
        let pb = if self.style_enabled {
            let pb = self.multi_progress.add(ProgressBar::new_spinner());
            pb.set_style(
                ProgressStyle::with_template("{spinner:.green} {msg} [{elapsed_precise}]")
                    .unwrap()
                    .tick_strings(&["‚ñπ‚ñπ‚ñπ‚ñπ‚ñπ", "‚ñ∏‚ñπ‚ñπ‚ñπ‚ñπ", "‚ñπ‚ñ∏‚ñπ‚ñπ‚ñπ", "‚ñπ‚ñπ‚ñ∏‚ñπ‚ñπ", "‚ñπ‚ñπ‚ñπ‚ñ∏‚ñπ", "‚ñπ‚ñπ‚ñπ‚ñπ‚ñ∏"])
            );
            pb.set_message(message.to_string());
            pb.enable_steady_tick(Duration::from_millis(120));
            pb
        } else {
            let pb = ProgressBar::hidden();
            eprintln!("{}", message);
            pb
        };
        pb
    }
    
    /// Create a tree-style progress display for hierarchical operations
    pub fn tree_progress(&self, items: Vec<&str>) -> Vec<ProgressBar> {
        let mut bars = Vec::new();
        
        for (i, item) in items.iter().enumerate() {
            let is_last = i == items.len() - 1;
            let prefix = if is_last { "‚îî‚îÄ" } else { "‚îú‚îÄ" };
            
            let pb = if self.style_enabled {
                let pb = self.multi_progress.add(ProgressBar::new_spinner());
                pb.set_style(
                    {% raw %}ProgressStyle::with_template(&format!("{{spinner:.blue}} {} {{msg}}", prefix)){% endraw %}
                        .unwrap()
                        .tick_strings(&["‚†ã", "‚†ô", "‚†π", "‚†∏", "‚†º", "‚†¥", "‚†¶", "‚†ß", "‚†á", "‚†è"])
                );
                pb.set_message(item.to_string());
                pb.enable_steady_tick(Duration::from_millis(80));
                pb
            } else {
                let pb = ProgressBar::hidden();
                eprintln!("{} {}", prefix, item);
                pb
            };
            
            bars.push(pb);
        }
        
        bars
    }
    
    /// Finish a progress bar with success message
    pub fn finish_success(&self, pb: &ProgressBar, message: &str) {
        if self.style_enabled {
            pb.finish_with_message(format!("{} {}", CHECKMARK, message));
        } else {
            eprintln!("{} {}", CHECKMARK, message);
        }
    }
    
    /// Finish a progress bar with error message
    pub fn finish_error(&self, pb: &ProgressBar, message: &str) {
        if self.style_enabled {
            pb.finish_with_message(format!("{} {}", CROSS, message));
        } else {
            eprintln!("{} {}", CROSS, message);
        }
    }
    
    /// Finish a progress bar with warning message
    pub fn finish_warning(&self, pb: &ProgressBar, message: &str) {
        if self.style_enabled {
            pb.finish_with_message(format!("{} {}", WARNING, message));
        } else {
            eprintln!("{} {}", WARNING, message);
        }
    }
    
    /// Create a custom progress bar with specific style
    pub fn custom_progress(&self, total: u64, template: &str, message: &str) -> Result<ProgressBar, ProgressError> {
        let pb = if self.style_enabled {
            let pb = self.multi_progress.add(ProgressBar::new(total));
            let style = ProgressStyle::with_template(template)
                .map_err(|e| ProgressError::CreationFailed {
                    reason: format!("Invalid template: {}", e),
                })?;
            pb.set_style(style);
            pb.set_message(message.to_string());
            pb
        } else {
            let pb = ProgressBar::hidden();
            eprintln!("{}", message);
            pb
        };
        Ok(pb)
    }
    
    /// Clear all progress bars
    pub fn clear(&self) {
        self.multi_progress.clear().unwrap_or(());
    }
}

/// Convenience functions for common progress operations
impl ProgressHelper {
    /// Create a simple task progress with callback
    pub fn with_progress<F, R>(&self, total: u64, message: &str, mut task: F) -> R
    where
        F: FnMut(&ProgressBar) -> R,
    {
        let pb = self.progress_bar(total, message);
        let result = task(&pb);
        pb.finish();
        result
    }
    
    /// Create a spinner task with callback
    pub fn with_spinner<F, R>(&self, message: &str, mut task: F) -> R
    where
        F: FnMut(&ProgressBar) -> R,
    {
        let pb = self.spinner(message);
        let result = task(&pb);
        pb.finish_and_clear();
        result
    }
    
    /// Process items with progress bar
    pub fn process_items<T, F, R>(&self, items: Vec<T>, message: &str, mut processor: F) -> Vec<R>
    where
        F: FnMut(T, &ProgressBar) -> R,
    {
        let total = items.len() as u64;
        let pb = self.progress_bar(total, message);
        
        let results: Vec<R> = items
            .into_iter()
            .map(|item| {
                let result = processor(item, &pb);
                pb.inc(1);
                result
            })
            .collect();
        
        pb.finish();
        results
    }
}

/// Output helper functions for styled messages
pub mod output {
    use super::*;
    
    /// Print a success message
    pub fn success(message: &str) {
        if console::colors_enabled() {
            eprintln!("{} {}", style(CHECKMARK).green().bold(), style(message).green());
        } else {
            eprintln!("{} {}", CHECKMARK, message);
        }
    }
    
    /// Print an error message
    pub fn error(message: &str) {
        if console::colors_enabled() {
            eprintln!("{} {}", style(CROSS).red().bold(), style(message).red());
        } else {
            eprintln!("{} {}", CROSS, message);
        }
    }
    
    /// Print a warning message
    pub fn warning(message: &str) {
        if console::colors_enabled() {
            eprintln!("{} {}", style(WARNING).yellow().bold(), style(message).yellow());
        } else {
            eprintln!("{} {}", WARNING, message);
        }
    }
    
    /// Print an info message
    pub fn info(message: &str) {
        if console::colors_enabled() {
            eprintln!("{} {}", style(INFO).blue().bold(), style(message).blue());
        } else {
            eprintln!("{} {}", INFO, message);
        }
    }
    
    /// Print a key-value pair
    pub fn key_value(key: &str, value: &str) {
        if console::colors_enabled() {
            eprintln!("  {}: {}", style(key).cyan().bold(), style(value).white());
        } else {
            eprintln!("  {}: {}", key, value);
        }
    }
    
    /// Print a header/section title
    pub fn header(message: &str) {
        if console::colors_enabled() {
            eprintln!("\n{}", style(message).bold().underlined());
        } else {
            eprintln!("\n{}", message);
            eprintln!("{}", "=".repeat(message.len()));
        }
    }
    
    /// Print a subheader
    pub fn subheader(message: &str) {
        if console::colors_enabled() {
            eprintln!("\n{}", style(message).bold());
        } else {
            eprintln!("\n{}", message);
            eprintln!("{}", "-".repeat(message.len()));
        }
    }
    
    /// Print a bulleted list item
    pub fn bullet(message: &str) {
        if console::colors_enabled() {
            eprintln!("  {} {}", style("‚Ä¢").dim(), message);
        } else {
            eprintln!("  ‚Ä¢ {}", message);
        }
    }
    
    /// Print a numbered list item
    pub fn numbered(number: usize, message: &str) {
        if console::colors_enabled() {
            eprintln!("  {}. {}", style(number).cyan().bold(), message);
        } else {
            eprintln!("  {}. {}", number, message);
        }
    }
    
    /// Print a code block or command
    pub fn code(code: &str) {
        if console::colors_enabled() {
            eprintln!("  {}", style(code).on_black().white());
        } else {
            eprintln!("  > {}", code);
        }
    }
    
    /// Print a tree structure item
    pub fn tree_item(level: usize, is_last: bool, message: &str) {
        let prefix = "  ".repeat(level);
        let connector = if is_last { "‚îî‚îÄ" } else { "‚îú‚îÄ" };
        
        if console::colors_enabled() {
            eprintln!("{}{} {}", prefix, style(connector).dim(), message);
        } else {
            eprintln!("{}{} {}", prefix, connector, message);
        }
    }
}

/// Convenience macros for progress operations
#[macro_export]
macro_rules! with_spinner {
    ($helper:expr, $message:expr, $task:expr) => {
        $helper.with_spinner($message, |_pb| $task)
    };
}

#[macro_export]
macro_rules! with_progress {
    ($helper:expr, $total:expr, $message:expr, $task:expr) => {
        $helper.with_progress($total, $message, |_pb| $task)
    };
}

/// Default global progress helper instance
static mut GLOBAL_PROGRESS: Option<ProgressHelper> = None;
static INIT: std::sync::Once = std::sync::Once::new();

/// Get the global progress helper instance
pub fn get_progress_helper() -> &'static ProgressHelper {
    unsafe {
        INIT.call_once(|| {
            GLOBAL_PROGRESS = Some(ProgressHelper::new());
        });
        GLOBAL_PROGRESS.as_ref().unwrap()
    }
}

/// Initialize global progress helper with specific configuration
pub fn init_progress_helper(plain: bool) {
    unsafe {
        INIT.call_once(|| {
            GLOBAL_PROGRESS = Some(if plain {
                ProgressHelper::new_plain()
            } else {
                ProgressHelper::new()
            });
        });
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use std::thread;
    use std::time::Duration;
    
    #[test]
    fn test_progress_helper_creation() {
        let helper = ProgressHelper::new();
        assert!(helper.multi_progress.is_finished() == false);
    }
    
    #[test]
    fn test_spinner() {
        let helper = ProgressHelper::new_plain();
        let pb = helper.spinner("Testing spinner");
        thread::sleep(Duration::from_millis(100));
        helper.finish_success(&pb, "Spinner test completed");
    }
    
    #[test]
    fn test_progress_bar() {
        let helper = ProgressHelper::new_plain();
        let pb = helper.progress_bar(100, "Testing progress");
        
        for i in 0..100 {
            pb.inc(1);
            if i % 25 == 0 {
                thread::sleep(Duration::from_millis(10));
            }
        }
        
        helper.finish_success(&pb, "Progress test completed");
    }
    
    #[test]
    fn test_output_functions() {
        output::success("Success message test");
        output::error("Error message test");
        output::warning("Warning message test");
        output::info("Info message test");
        output::key_value("test_key", "test_value");
        output::header("Test Header");
        output::subheader("Test Subheader");
        output::bullet("Bullet point test");
        output::numbered(1, "Numbered item test");
        output::code("cargo build --release");
        output::tree_item(0, false, "Root item");
        output::tree_item(1, true, "Leaf item");
    }
}