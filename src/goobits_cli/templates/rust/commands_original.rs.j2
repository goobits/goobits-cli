/**
 * Commands module for {{ display_name }}
 * Auto-generated from {{ file_name }}
 */

use crate::errors::{CliResult, CommandError};
use crate::config::AppConfig;
use std::collections::HashMap;

/// Base trait for all commands
pub trait Command {
    /// Get the command name
    fn name(&self) -> &str;
    
    /// Get the command description
    fn description(&self) -> &str;
    
    /// Execute the command with given arguments
    fn execute(&self, args: &CommandArgs) -> CliResult<()>;
    
    /// Validate command arguments before execution
    fn validate(&self, args: &CommandArgs) -> CliResult<()> {
        // Default implementation - basic validation
        self.validate_required_args(args)?;
        self.validate_argument_choices(args)?;
        self.validate_option_choices(args)?;
        Ok(())
    }
    
    /// Validate required arguments
    fn validate_required_args(&self, _args: &CommandArgs) -> CliResult<()> {
        // Default implementation - no required args
        Ok(())
    }
    
    /// Validate argument choices (enum values)
    fn validate_argument_choices(&self, _args: &CommandArgs) -> CliResult<()> {
        // Default implementation - no choice validation
        Ok(())
    }
    
    /// Validate option choices
    fn validate_option_choices(&self, _args: &CommandArgs) -> CliResult<()> {
        // Default implementation - no choice validation
        Ok(())
    }
    
    /// Get command help text
    fn help(&self) -> String {
        format!("{}: {}", self.name(), self.description())
    }
    
    /// Check if command supports a specific feature
    fn supports_feature(&self, _feature: &str) -> bool {
        false
    }
}

/// Command arguments structure
#[derive(Debug, Clone)]
pub struct CommandArgs {
    /// Command name being executed
    pub command: String,
    /// Subcommand if applicable
    pub subcommand: Option<String>,
    /// Positional arguments
    pub args: Vec<String>,
    /// Flag and option values
    pub options: HashMap<String, String>,
    /// Application configuration
    pub config: AppConfig,
}

impl CommandArgs {
    /// Create new CommandArgs instance
    pub fn new(command: String, config: AppConfig) -> Self {
        Self {
            command,
            subcommand: None,
            args: Vec::new(),
            options: HashMap::new(),
            config,
        }
    }
    
    /// Get a positional argument by index
    pub fn get_arg(&self, index: usize) -> Option<&String> {
        self.args.get(index)
    }
    
    /// Get a required positional argument by index
    pub fn get_required_arg(&self, index: usize, name: &str) -> CliResult<&String> {
        self.get_arg(index).ok_or_else(|| CommandError::MissingArgument {
            arg: name.to_string(),
        }.into())
    }
    
    /// Get an option value by name
    pub fn get_option(&self, name: &str) -> Option<&String> {
        self.options.get(name)
    }
    
    /// Get a required option value by name
    pub fn get_required_option(&self, name: &str) -> CliResult<&String> {
        self.get_option(name).ok_or_else(|| CommandError::MissingArgument {
            arg: format!("--{}", name),
        }.into())
    }
    
    /// Check if a flag is set
    pub fn has_flag(&self, name: &str) -> bool {
        self.options.get(name).map(|v| v == "true").unwrap_or(false)
    }
    
    /// Get option as integer
    pub fn get_option_as_int(&self, name: &str) -> CliResult<Option<i32>> {
        match self.get_option(name) {
            Some(value) => {
                value.parse().map(Some).map_err(|_| CommandError::InvalidArgument {
                    arg: format!("--{}", name),
                    value: value.clone(),
                    expected: "integer".to_string(),
                }.into())
            }
            None => Ok(None),
        }
    }
    
    /// Get required option as integer
    pub fn get_required_option_as_int(&self, name: &str) -> CliResult<i32> {
        let value = self.get_required_option(name)?;
        value.parse().map_err(|_| CommandError::InvalidArgument {
            arg: format!("--{}", name),
            value: value.clone(),
            expected: "integer".to_string(),
        }.into())
    }
    
    /// Get option with default value
    pub fn get_option_or(&self, name: &str, default: &str) -> String {
        self.get_option(name).cloned().unwrap_or_else(|| default.to_string())
    }
    
    /// Validate argument against choices
    pub fn validate_arg_choices(&self, index: usize, name: &str, choices: &[&str]) -> CliResult<()> {
        if let Some(value) = self.get_arg(index) {
            if !choices.contains(&value.as_str()) {
                return Err(CommandError::InvalidArgument {
                    arg: name.to_string(),
                    value: value.clone(),
                    expected: format!("one of: {}", choices.join(", ")),
                }.into());
            }
        }
        Ok(())
    }
    
    /// Validate option against choices
    pub fn validate_option_choices(&self, name: &str, choices: &[&str]) -> CliResult<()> {
        if let Some(value) = self.get_option(name) {
            if !choices.contains(&value.as_str()) {
                return Err(CommandError::InvalidArgument {
                    arg: format!("--{}", name),
                    value: value.clone(),
                    expected: format!("one of: {}", choices.join(", ")),
                }.into());
            }
        }
        Ok(())
    }
}

/// Command registry for managing available commands
pub struct CommandRegistry {
    commands: HashMap<String, Box<dyn Command>>,
}

impl CommandRegistry {
    /// Create a new command registry
    pub fn new() -> Self {
        Self {
            commands: HashMap::new(),
        }
    }
    
    /// Register a command
    pub fn register<C: Command + 'static>(&mut self, command: C) -> CliResult<()> {
        let name = command.name().to_string();
        
        // Validate command name
        if name.is_empty() {
            return Err(CommandError::ValidationFailed {
                command: name,
                message: "Command name cannot be empty".to_string(),
            }.into());
        }
        
        // Check for duplicate registration
        if self.commands.contains_key(&name) {
            return Err(CommandError::ValidationFailed {
                command: name,
                message: "Command already registered".to_string(),
            }.into());
        }
        
        self.commands.insert(name, Box::new(command));
        Ok(())
    }
    
    /// Execute a command by name
    pub fn execute(&self, name: &str, args: &CommandArgs) -> CliResult<()> {
        let command = self.commands.get(name).ok_or_else(|| CommandError::NotFound {
            name: name.to_string(),
        })?;
        
        // Validate arguments first
        command.validate(args).map_err(|e| match e.downcast_ref::<CommandError>() {
            Some(CommandError::ValidationFailed { .. }) => e,
            _ => CommandError::ValidationFailed {
                command: name.to_string(),
                message: format!("Validation failed: {}", e),
            }.into(),
        })?;
        
        // Execute the command
        command.execute(args).map_err(|e| match e.downcast_ref::<CommandError>() {
            Some(CommandError::ExecutionFailed { .. }) => e,
            _ => CommandError::ExecutionFailed {
                command: name.to_string(),
                reason: e.to_string(),
            }.into(),
        })
    }
    
    /// Get available command names
    pub fn command_names(&self) -> Vec<&String> {
        self.commands.keys().collect()
    }
    
    /// Check if a command exists
    pub fn has_command(&self, name: &str) -> bool {
        self.commands.contains_key(name)
    }
    
    /// Get command by name
    pub fn get_command(&self, name: &str) -> Option<&dyn Command> {
        self.commands.get(name).map(|cmd| cmd.as_ref())
    }
    
    /// List all commands with descriptions
    pub fn list_commands(&self) -> Vec<(String, String)> {
        self.commands
            .values()
            .map(|cmd| (cmd.name().to_string(), cmd.description().to_string()))
            .collect()
    }
    
    /// Get help for a specific command
    pub fn get_command_help(&self, name: &str) -> CliResult<String> {
        let command = self.commands.get(name).ok_or_else(|| CommandError::NotFound {
            name: name.to_string(),
        })?;
        
        Ok(command.help())
    }
}

/// Built-in commands implementations
{% for cmd_name, cmd_data in cli.commands.items() %}
{% if not cmd_data.subcommands %}
pub struct {{ cmd_name | title | replace('-', '') }}Command;

impl {{ cmd_name | title | replace('-', '') }}Command {
    pub fn new() -> Self {
        Self
    }
}

impl Command for {{ cmd_name | title | replace('-', '') }}Command {
    fn name(&self) -> &str {
        "{{ cmd_name }}"
    }
    
    fn description(&self) -> &str {
        "{% if cmd_data.icon %}{{ cmd_data.icon }} {% endif %}{{ cmd_data.desc }}"
    }
    
    fn execute(&self, args: &CommandArgs) -> CliResult<()> {
        use crate::utils::output;
        
        output::info("ðŸš€ Executing {{ cmd_name }} command...");
        
        {% if cmd_data.args %}
        // Process positional arguments
        {% for arg in cmd_data.args %}
        {% if arg.required %}
        let {{ arg.name }} = args.get_required_arg({{ loop.index0 }}, "{{ arg.name }}")?;
        output::key_value("{{ arg.name }}", {{ arg.name }});
        {% else %}
        if let Some({{ arg.name }}) = args.get_arg({{ loop.index0 }}) {
            output::key_value("{{ arg.name }}", {{ arg.name }});
        }
        {% endif %}
        {% endfor %}
        {% endif %}
        
        {% if cmd_data.options %}
        // Process options
        {% for opt in cmd_data.options %}
        {% if opt.type == "flag" or opt.type == "bool" %}
        if args.has_flag("{{ opt.name }}") {
            output::key_value("{{ opt.name }}", "enabled");
        }
        {% elif opt.type == "int" %}
        if let Some({{ opt.name | replace('-', '_') }}) = args.get_option_as_int("{{ opt.name }}")? {
            output::key_value("{{ opt.name }}", &{{ opt.name | replace('-', '_') }}.to_string());
        }
        {% else %}
        if let Some({{ opt.name | replace('-', '_') }}) = args.get_option("{{ opt.name }}") {
            output::key_value("{{ opt.name }}", {{ opt.name | replace('-', '_') }});
        }
        {% endif %}
        {% endfor %}
        {% endif %}
        
        // TODO: Implement actual {{ cmd_name }} command logic here
        // This is a placeholder implementation
        
        output::success("{{ cmd_name | title }} command completed successfully!");
        Ok(())
    }
    
    fn validate(&self, args: &CommandArgs) -> CliResult<()> {
        // Call base validation first
        self.validate_required_args(args)?;
        self.validate_argument_choices(args)?;
        self.validate_option_choices(args)?;
        
        // Additional command-specific validation can go here
        Ok(())
    }
    
    {% if cmd_data.args %}
    fn validate_required_args(&self, args: &CommandArgs) -> CliResult<()> {
        {% for arg in cmd_data.args %}
        {% if arg.required %}
        args.get_required_arg({{ loop.index0 }}, "{{ arg.name }}")?;
        {% endif %}
        {% endfor %}
        Ok(())
    }
    
    fn validate_argument_choices(&self, args: &CommandArgs) -> CliResult<()> {
        {% for arg in cmd_data.args %}
        {% if arg.choices %}
        args.validate_arg_choices({{ loop.index0 }}, "{{ arg.name }}", &[{% for choice in arg.choices %}"{{ choice }}"{% if not loop.last %}, {% endif %}{% endfor %}])?;
        {% endif %}
        {% endfor %}
        Ok(())
    }
    {% endif %}
    
    {% if cmd_data.options %}
    fn validate_option_choices(&self, args: &CommandArgs) -> CliResult<()> {
        {% for opt in cmd_data.options %}
        {% if opt.choices %}
        args.validate_option_choices("{{ opt.name }}", &[{% for choice in opt.choices %}"{{ choice }}"{% if not loop.last %}, {% endif %}{% endfor %}])?;
        {% endif %}
        {% endfor %}
        Ok(())
    }
    {% endif %}
    
    fn help(&self) -> String {
        let mut help = format!("{}: {}\n", self.name(), self.description());
        
        {% if cmd_data.args %}
        help.push_str("\nArguments:\n");
        {% for arg in cmd_data.args %}
        help.push_str(&format!("  {}: {}{}\n", 
            "{{ arg.name }}", 
            "{{ arg.desc }}",
            {% if arg.required %}"{% else %}" (optional){% endif %}
        ));
        {% if arg.choices %}
        help.push_str(&format!("    Choices: {}\n", [{% for choice in arg.choices %}"{{ choice }}"{% if not loop.last %}, {% endif %}{% endfor %}].join(", ")));
        {% endif %}
        {% endfor %}
        {% endif %}
        
        {% if cmd_data.options %}
        help.push_str("\nOptions:\n");
        {% for opt in cmd_data.options %}
        help.push_str(&format!("  --{}{}: {}\n", 
            "{{ opt.name }}", 
            {% if opt.short %}", -{{ opt.short }}"{% else %}""{% endif %},
            "{{ opt.desc }}"
        ));
        {% if opt.choices %}
        help.push_str(&format!("    Choices: {}\n", [{% for choice in opt.choices %}"{{ choice }}"{% if not loop.last %}, {% endif %}{% endfor %}].join(", ")));
        {% endif %}
        {% if opt.default %}
        help.push_str(&format!("    Default: {}\n", "{{ opt.default }}"));
        {% endif %}
        {% endfor %}
        {% endif %}
        
        help
    }
    
    {% if cmd_data.features %}
    fn supports_feature(&self, feature: &str) -> bool {
        match feature {
            {% for feature in cmd_data.features %}
            "{{ feature }}" => true,
            {% endfor %}
            _ => false,
        }
    }
    {% endif %}
}

impl Default for {{ cmd_name | title | replace('-', '') }}Command {
    fn default() -> Self {
        Self::new()
    }
}
{% endif %}
{% endfor %}

/// Initialize and return command registry with all built-in commands
pub fn create_command_registry() -> CliResult<CommandRegistry> {
    let mut registry = CommandRegistry::new();
    
    {% for cmd_name, cmd_data in cli.commands.items() %}
    {% if not cmd_data.subcommands %}
    registry.register({{ cmd_name | title | replace('-', '') }}Command::new())?;
    {% endif %}
    {% endfor %}
    
    Ok(registry)
}

/// Execute a command with proper error handling and context
pub fn execute_command(registry: &CommandRegistry, command_name: &str, args: CommandArgs) -> CliResult<()> {
    // Add execution context to args if needed
    let enhanced_args = args;
    
    // Execute with comprehensive error handling
    registry.execute(command_name, &enhanced_args).map_err(|e| {
        // Add additional context or logging here if needed
        e
    })
}

/// Validate all registered commands at startup
pub fn validate_command_registry(registry: &CommandRegistry) -> CliResult<()> {
    let command_names = registry.command_names();
    
    if command_names.is_empty() {
        return Err(CommandError::ValidationFailed {
            command: "registry".to_string(),
            message: "No commands registered".to_string(),
        }.into());
    }
    
    // Validate each command can be retrieved
    for name in command_names {
        registry.get_command(name).ok_or_else(|| CommandError::NotFound {
            name: name.clone(),
        })?;
    }
    
    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_command_args() {
        let config = AppConfig::default();
        let mut args = CommandArgs::new("test".to_string(), config);
        args.args = vec!["arg1".to_string(), "arg2".to_string()];
        args.options.insert("verbose".to_string(), "true".to_string());
        args.options.insert("count".to_string(), "42".to_string());
        
        assert_eq!(args.get_arg(0), Some(&"arg1".to_string()));
        assert_eq!(args.get_arg(1), Some(&"arg2".to_string()));
        assert_eq!(args.get_arg(2), None);
        
        assert!(args.has_flag("verbose"));
        assert!(!args.has_flag("quiet"));
        
        assert_eq!(args.get_option_as_int("count").unwrap(), Some(42));
        assert_eq!(args.get_option_or("missing", "default"), "default");
        
        // Test required arg error
        assert!(args.get_required_arg(10, "missing").is_err());
        
        // Test validation
        assert!(args.validate_arg_choices(0, "arg1", &["arg1", "other"]).is_ok());
        assert!(args.validate_arg_choices(0, "arg1", &["other"]).is_err());
    }
    
    #[test]
    fn test_command_registry() {
        let registry = create_command_registry().unwrap();
        
        {% for cmd_name, cmd_data in cli.commands.items() %}
        {% if not cmd_data.subcommands %}
        assert!(registry.has_command("{{ cmd_name }}"));
        {% endif %}
        {% endfor %}
        
        let names = registry.command_names();
        assert!(!names.is_empty());
        
        // Test command execution with empty args would work
        let config = AppConfig::default();
        let args = CommandArgs::new("test".to_string(), config);
        
        // Test getting help for existing command
        {% for cmd_name, cmd_data in cli.commands.items() %}
        {% if not cmd_data.subcommands %}
        assert!(registry.get_command_help("{{ cmd_name }}").is_ok());
        break; // Test just one command
        {% endif %}
        {% endfor %}
        
        // Test non-existent command
        assert!(registry.get_command_help("nonexistent").is_err());
    }
    
    #[test]
    fn test_registry_validation() {
        let registry = create_command_registry().unwrap();
        assert!(validate_command_registry(&registry).is_ok());
        
        // Test empty registry
        let empty_registry = CommandRegistry::new();
        assert!(validate_command_registry(&empty_registry).is_err());
    }
    
    {% for cmd_name, cmd_data in cli.commands.items() %}
    {% if not cmd_data.subcommands %}
    #[test]
    fn test_{{ cmd_name | replace('-', '_') }}_command() {
        let command = {{ cmd_name | title | replace('-', '') }}Command::new();
        assert_eq!(command.name(), "{{ cmd_name }}");
        assert!(!command.description().is_empty());
        
        let config = AppConfig::default();
        let args = CommandArgs::new("{{ cmd_name }}".to_string(), config);
        
        // Basic validation should pass with empty args for optional commands
        // (Commands with required args would need specific test data)
        {% if not cmd_data.args or not cmd_data.args|selectattr("required")|list %}
        assert!(command.validate(&args).is_ok());
        {% endif %}
        
        // Help should be available
        assert!(!command.help().is_empty());
    }
    {% endif %}
    {% endfor %}
}