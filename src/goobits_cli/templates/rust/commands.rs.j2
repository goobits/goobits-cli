/**
 * Commands module for {{ display_name }}
 * Auto-generated from {{ file_name }}
 */

use crate::errors::{CliResult, CommandError, CLIError};
use crate::config::AppConfig;
use std::collections::HashMap;

/// Base trait for all commands
pub trait Command: Send + Sync {
    /// Get the command name
    fn name(&self) -> &str;
    
    /// Get the command description
    fn description(&self) -> &str;
    
    /// Execute the command with given arguments
    fn execute(&self, args: &CommandArgs) -> CliResult<()>;
    
    /// Validate command arguments before execution
    fn validate(&self, _args: &CommandArgs) -> CliResult<()> {
        // Default implementation - no validation
        Ok(())
    }
}

/// Command arguments structure
#[derive(Debug, Clone)]
pub struct CommandArgs {
    /// Command name being executed
    pub command: String,
    /// Subcommand if applicable
    pub subcommand: Option<String>,
    /// Positional arguments
    pub args: Vec<String>,
    /// Flag and option values
    pub options: HashMap<String, String>,
    /// Application configuration
    pub config: AppConfig,
}

impl CommandArgs {
    /// Get a positional argument by index
    pub fn get_arg(&self, index: usize) -> Option<&String> {
        self.args.get(index)
    }
    
    /// Get an option value by name
    pub fn get_option(&self, name: &str) -> Option<&String> {
        self.options.get(name)
    }
    
    /// Check if a flag is set
    pub fn has_flag(&self, name: &str) -> bool {
        self.options.get(name).map(|v| v == "true").unwrap_or(false)
    }
    
    /// Get option as integer
    pub fn get_option_as_int(&self, name: &str) -> Option<i32> {
        self.get_option(name)?.parse().ok()
    }
    
    /// Get option with default value
    pub fn get_option_or(&self, name: &str, default: &str) -> String {
        self.get_option(name).cloned().unwrap_or_else(|| default.to_string())
    }
}

/// Command registry for managing available commands
pub struct CommandRegistry {
    commands: HashMap<String, Box<dyn Command>>,
}

impl CommandRegistry {
    /// Create a new command registry
    pub fn new() -> Self {
        Self {
            commands: HashMap::new(),
        }
    }
    
    /// Register a command
    pub fn register<C: Command + 'static>(&mut self, command: C) {
        self.commands.insert(command.name().to_string(), Box::new(command));
    }
    
    /// Execute a command by name
    pub fn execute(&self, name: &str, args: &CommandArgs) -> CliResult<()> {
        if let Some(command) = self.commands.get(name) {
            command.validate(args)?;
            command.execute(args)
        } else {
            let available: Vec<String> = self.command_names().iter().map(|s| s.to_string()).collect();
            Err(CLIError::command_not_found(name, available))
        }
    }
    
    /// Get available command names
    pub fn command_names(&self) -> Vec<&String> {
        self.commands.keys().collect()
    }
    
    /// Check if a command exists
    pub fn has_command(&self, name: &str) -> bool {
        self.commands.contains_key(name)
    }
}

/// Built-in commands implementations
{% for cmd_name, cmd_data in cli.commands.items() %}
{% if not cmd_data.subcommands %}
pub struct {{ cmd_name | title | replace('-', '') }}Command;

impl Command for {{ cmd_name | title | replace('-', '') }}Command {
    fn name(&self) -> &str {
        "{{ cmd_name }}"
    }
    
    fn description(&self) -> &str {
        "{% if cmd_data.icon %}{{ cmd_data.icon }} {% endif %}{{ cmd_data.desc }}"
    }
    
    fn execute(&self, args: &CommandArgs) -> CliResult<()> {
        println!("ðŸš€ Executing {{ cmd_name }} command...");
        
        {% if cmd_data.args %}
        // Process positional arguments
        {% for arg in cmd_data.args %}
        {% if arg.required %}
        let {{ arg.name }} = args.get_arg({{ loop.index0 }})
            .ok_or_else(|| CLIError::validation("{{ arg.name }}", "", "Missing required argument"))?;
        println!("  {{ arg.name }}: {}", {{ arg.name }});
        {% else %}
        if let Some({{ arg.name }}) = args.get_arg({{ loop.index0 }}) {
            println!("  {{ arg.name }}: {}", {{ arg.name }});
        }
        {% endif %}
        {% endfor %}
        {% endif %}
        
        {% if cmd_data.options %}
        // Process options
        {% for opt in cmd_data.options %}
        {% if opt.type == "flag" or opt.type == "bool" %}
        if args.has_flag("{{ opt.name }}") {
            println!("  {{ opt.name }}: enabled");
        }
        {% elif opt.type == "int" %}
        if let Some({{ opt.name | replace('-', '_') }}) = args.get_option_as_int("{{ opt.name }}") {
            println!("  {{ opt.name }}: {}", {{ opt.name | replace('-', '_') }});
        }
        {% else %}
        if let Some({{ opt.name | replace('-', '_') }}) = args.get_option("{{ opt.name }}") {
            println!("  {{ opt.name }}: {}", {{ opt.name | replace('-', '_') }});
        }
        {% endif %}
        {% endfor %}
        {% endif %}
        
        // TODO: Implement actual {{ cmd_name }} command logic here
        // This is a placeholder implementation
        
        println!("âœ… {{ cmd_name | title }} command completed successfully!");
        Ok(())
    }
    
    fn validate(&self, args: &CommandArgs) -> CliResult<()> {
        {% if cmd_data.args %}
        // Validate required arguments
        {% for arg in cmd_data.args %}
        {% if arg.required %}
        if args.get_arg({{ loop.index0 }}).is_none() {
            return Err(CLIError::validation("{{ arg.name }}", "", "Missing required argument"));
        }
        {% endif %}
        {% if arg.choices %}
        if let Some(value) = args.get_arg({{ loop.index0 }}) {
            let valid_choices = vec![{% for choice in arg.choices %}"{{ choice }}"{% if not loop.last %}, {% endif %}{% endfor %}];
            if !valid_choices.contains(&value.as_str()) {
                return Err(CLIError::validation("{{ arg.name }}", value, format!("Invalid value. Valid choices: {}", valid_choices.join(", "))));
            }
        }
        {% endif %}
        {% endfor %}
        {% endif %}
        
        {% if cmd_data.options %}
        // Validate options
        {% for opt in cmd_data.options %}
        {% if opt.choices %}
        if let Some(value) = args.get_option("{{ opt.name }}") {
            let valid_choices = vec![{% for choice in opt.choices %}"{{ choice }}"{% if not loop.last %}, {% endif %}{% endfor %}];
            if !valid_choices.contains(&value.as_str()) {
                return Err(CLIError::validation("{{ opt.name }}", value, format!("Invalid value. Valid choices: {}", valid_choices.join(", "))));
            }
        }
        {% endif %}
        {% endfor %}
        {% endif %}
        
        Ok(())
    }
}
{% endif %}
{% endfor %}

/// Initialize and return command registry with all built-in commands
pub fn create_command_registry() -> CommandRegistry {
    let mut registry = CommandRegistry::new();
    
    {% for cmd_name, cmd_data in cli.commands.items() %}
    {% if not cmd_data.subcommands %}
    registry.register({{ cmd_name | title | replace('-', '') }}Command);
    {% endif %}
    {% endfor %}
    
    registry
}

#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_command_args() {
        let config = AppConfig::default();
        let mut options = HashMap::new();
        options.insert("verbose".to_string(), "true".to_string());
        options.insert("count".to_string(), "42".to_string());
        
        let args = CommandArgs {
            command: "test".to_string(),
            subcommand: None,
            args: vec!["arg1".to_string(), "arg2".to_string()],
            options,
            config,
        };
        
        assert_eq!(args.get_arg(0), Some(&"arg1".to_string()));
        assert_eq!(args.get_arg(1), Some(&"arg2".to_string()));
        assert_eq!(args.get_arg(2), None);
        
        assert!(args.has_flag("verbose"));
        assert!(!args.has_flag("quiet"));
        
        assert_eq!(args.get_option_as_int("count"), Some(42));
        assert_eq!(args.get_option_or("missing", "default"), "default");
    }
    
    #[test]
    fn test_command_registry() {
        let registry = create_command_registry();
        
        {% for cmd_name, cmd_data in cli.commands.items() %}
        {% if not cmd_data.subcommands %}
        assert!(registry.has_command("{{ cmd_name }}"));
        {% endif %}
        {% endfor %}
        
        let names = registry.command_names();
        assert!(!names.is_empty());
    }
}