#!/bin/bash
# Rust-specific setup script for {{ display_name }}
# Generated by goobits-cli

set -e  # Exit on error

# Configuration
PACKAGE_NAME="{{ package_name }}"
COMMAND_NAME="{{ command_name }}"
DISPLAY_NAME="{{ display_name }}"
VERSION="{{ version }}"
DESCRIPTION="{{ description }}"

# Color codes for output
RED='\033[0;31m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Logging functions
log_info() {
    echo -e "${BLUE}[INFO]${NC} $1"
}

log_success() {
    echo -e "${GREEN}[SUCCESS]${NC} $1"
}

log_warning() {
    echo -e "${YELLOW}[WARNING]${NC} $1"
}

log_error() {
    echo -e "${RED}[ERROR]${NC} $1"
}

# Check Rust version
check_rust_version() {
    local required_version="1.70.0"
    
    if ! command -v rustc &> /dev/null; then
        log_error "Rust is not installed. Please install Rust ${required_version} or higher."
        log_info "Visit https://rustup.rs/ to install Rust"
        exit 1
    fi
    
    local rust_version=$(rustc --version | cut -d ' ' -f 2)
    local required_major=$(echo "$required_version" | cut -d '.' -f 1)
    local required_minor=$(echo "$required_version" | cut -d '.' -f 2)
    local rust_major=$(echo "$rust_version" | cut -d '.' -f 1)
    local rust_minor=$(echo "$rust_version" | cut -d '.' -f 2)
    
    if [ "$rust_major" -lt "$required_major" ] || ([ "$rust_major" -eq "$required_major" ] && [ "$rust_minor" -lt "$required_minor" ]); then
        log_error "Rust version $rust_version is too old. Please upgrade to Rust ${required_version} or higher."
        log_info "Run: rustup update"
        exit 1
    fi
    
    log_success "Rust version $rust_version detected"
}

# Check Cargo version
check_cargo_version() {
    if ! command -v cargo &> /dev/null; then
        log_error "Cargo is not installed. Please install Cargo (should come with Rust)."
        exit 1
    fi
    
    local cargo_version=$(cargo --version | cut -d ' ' -f 2)
    log_success "Cargo version $cargo_version detected"
}

# Build the Rust project
build_project() {
    local build_mode="$1"
    
    if [ "$build_mode" == "dev" ]; then
        log_info "Building project in development mode..."
        cargo build || {
            log_error "Failed to build project in development mode"
            exit 1
        }
        log_success "Development build completed"
    else
        log_info "Building project in release mode..."
        cargo build --release || {
            log_error "Failed to build project in release mode"
            exit 1
        }
        log_success "Release build completed"
    fi
}

# Install binary to cargo bin directory
install_cargo_bin() {
    log_info "Installing $PACKAGE_NAME using cargo install..."
    
    cargo install --path . || {
        log_error "Failed to install using cargo install"
        return 1
    }
    
    log_success "Installed to cargo bin directory. You can now use '$COMMAND_NAME' from anywhere."
}

# Install globally from crates.io
install_global() {
    log_info "Installing $PACKAGE_NAME globally from crates.io..."
    
    cargo install "$PACKAGE_NAME" || {
        log_warning "Failed to install from crates.io. Package may not be published yet."
        log_info "Try using: ./setup.sh --dev for local development installation"
        return 1
    }
    
    log_success "Installed globally from crates.io. You can now use '$COMMAND_NAME' from anywhere."
}

# Create a development symlink
create_dev_link() {
    local binary_path="target/debug/$COMMAND_NAME"
    local cargo_bin_dir="$HOME/.cargo/bin"
    
    if [ ! -f "$binary_path" ]; then
        log_error "Development binary not found at $binary_path"
        log_info "Run the build first: cargo build"
        return 1
    fi
    
    # Create cargo bin directory if it doesn't exist
    mkdir -p "$cargo_bin_dir"
    
    # Create symlink
    local link_path="$cargo_bin_dir/$COMMAND_NAME"
    if [ -L "$link_path" ]; then
        rm "$link_path"
    elif [ -f "$link_path" ]; then
        log_warning "Existing binary found at $link_path, creating backup"
        mv "$link_path" "${link_path}.bak"
    fi
    
    local full_binary_path=$(pwd)/$binary_path
    ln -s "$full_binary_path" "$link_path" || {
        log_error "Failed to create symlink"
        return 1
    }
    
    log_success "Development link created. You can now use '$COMMAND_NAME' from anywhere."
    log_info "Binary is linked to: $full_binary_path"
}

# Run tests
run_tests() {
    log_info "Running tests..."
    
    cargo test || {
        log_warning "Some tests failed"
        return 1
    }
    
    log_success "All tests passed"
}

# Setup configuration directory
setup_config_dir() {
    local config_dir="$HOME/.config/$PACKAGE_NAME"
    
    if [ ! -d "$config_dir" ]; then
        log_info "Creating configuration directory..."
        mkdir -p "$config_dir"
        log_success "Configuration directory created at $config_dir"
    fi
}

# Generate shell completions
generate_completions() {
    local completions_dir="completions"
    
    if [ ! -d "$completions_dir" ]; then
        mkdir -p "$completions_dir"
    fi
    
    log_info "Generating shell completions..."
    
    # Build first if needed
    if [ ! -f "target/release/$COMMAND_NAME" ] && [ ! -f "target/debug/$COMMAND_NAME" ]; then
        cargo build
    fi
    
    local binary_path="target/debug/$COMMAND_NAME"
    if [ -f "target/release/$COMMAND_NAME" ]; then
        binary_path="target/release/$COMMAND_NAME"
    fi
    
    # Generate completions for different shells
    "$binary_path" --generate bash > "$completions_dir/$COMMAND_NAME.bash" 2>/dev/null || true
    "$binary_path" --generate zsh > "$completions_dir/_$COMMAND_NAME" 2>/dev/null || true
    "$binary_path" --generate fish > "$completions_dir/$COMMAND_NAME.fish" 2>/dev/null || true
    
    if [ -f "$completions_dir/$COMMAND_NAME.bash" ]; then
        log_success "Shell completions generated in $completions_dir/"
        log_info "To enable bash completions, add to your ~/.bashrc:"
        log_info "  source $(pwd)/$completions_dir/$COMMAND_NAME.bash"
    fi
}

# Check for required system dependencies
check_system_deps() {
    local missing_deps=()
    
    # Check for common system dependencies that Rust projects might need
    {% if installation and installation.extras and installation.extras.apt %}
    local apt_deps=({% for dep in installation.extras.apt %}"{{ dep }}"{% if not loop.last %} {% endif %}{% endfor %})
    
    for dep in "${apt_deps[@]}"; do
        if ! command -v "$dep" &> /dev/null && ! dpkg -l | grep -q "^ii  $dep "; then
            missing_deps+=("$dep")
        fi
    done
    
    if [ ${{ '{#' }}missing_deps[@]} -ne 0 ]; then
        log_warning "Missing system dependencies: ${missing_deps[*]}"
        log_info "Install with: sudo apt update && sudo apt install ${missing_deps[*]}"
    fi
    {% endif %}
}

# Main setup function
main() {
    echo ""
    echo "Setting up $DISPLAY_NAME..."
    echo "===================================="
    echo ""
    
    # Check prerequisites
    check_rust_version
    check_cargo_version
    check_system_deps
    
    # Determine installation mode
    local install_mode="release"
    local dev_mode=false
    local run_tests_flag=false
    local generate_completions_flag=false
    
    while [[ $# -gt 0 ]]; do
        case $1 in
            --dev|-d)
                install_mode="dev"
                dev_mode=true
                shift
                ;;
            --global|-g)
                install_global
                setup_config_dir
                exit 0
                ;;
            --test|-t)
                run_tests_flag=true
                shift
                ;;
            --completions|-c)
                generate_completions_flag=true
                shift
                ;;
            --help|-h)
                echo "Usage: $0 [OPTIONS]"
                echo ""
                echo "Options:"
                echo "  --dev, -d         Install in development mode with symlink"
                echo "  --global, -g      Install globally from crates.io"
                echo "  --test, -t        Run tests before installation"
                echo "  --completions, -c Generate shell completions"
                echo "  --help, -h        Show this help message"
                echo ""
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                exit 1
                ;;
        esac
    done
    
    # Run tests if requested
    if [ "$run_tests_flag" = true ]; then
        run_tests
    fi
    
    # Build the project
    build_project "$install_mode"
    
    # Setup configuration directory
    setup_config_dir
    
    # Generate completions if requested
    if [ "$generate_completions_flag" = true ]; then
        generate_completions
    fi
    
    # Install based on mode
    if [ "$dev_mode" = true ]; then
        create_dev_link
    else
        install_cargo_bin
    fi
    
    echo ""
    echo "===================================="
    log_success "Setup complete!"
    echo ""
    
    if [ "$dev_mode" = true ]; then
        echo "Development mode enabled. The CLI is linked to the debug build."
        echo "You can now use: $COMMAND_NAME"
        echo ""
        echo "To rebuild after changes: cargo build"
    else
        echo "Release build installed using cargo install."
        echo "You can now use: $COMMAND_NAME"
        echo ""
        echo "To rebuild: cargo build --release && cargo install --path ."
    fi
    
    echo "Configuration directory: ~/.config/$PACKAGE_NAME"
    
    if [ "$generate_completions_flag" = true ]; then
        echo "Shell completions available in: completions/"
    fi
    
    echo ""
}

# Run main function
main "$@"