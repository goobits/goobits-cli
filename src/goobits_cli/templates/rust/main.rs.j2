/**
 * Auto-generated from {{ file_name }}
 * Main CLI implementation for {{ display_name }}
 */

use anyhow::Context;
use clap::{Parser, Subcommand, CommandFactory};
use std::collections::HashMap;
use std::process;
use std::error::Error;

// Import error handling
mod errors;
use errors::{CliResult, CLIError, ExitCode};

// Import modules
mod config;
mod commands;
mod utils;

// Re-export for hook functions
pub use commands::{Command, CommandArgs};
pub use config::AppConfig;

// Import actual hook system
mod hooks;
use hooks::{HookRegistry, HookContext, ExecutionPhase};

// Import plugin system
mod plugins;
use plugins::{initialize_plugins, execute_plugin_command, cleanup_plugins};

// Import styling system
mod styling;
use styling::initialize_styling;

// Utils module already imported above

#[derive(Parser)]
#[command(name = "{{ command_name }}")]
#[command(about = "{{ cli.tagline if cli.tagline else description }}")]
#[command(long_about = "{{ cli.description if cli.description else description }}")]
#[command(version = "{{ version | default('1.0.0') }}")]
#[command(author = "{{ author | default('') }}")]
{% if cli and cli.enable_recursive_help %}
#[command(help_template = "{about}\n\n{usage-heading} {usage}\n\n{all-args}{after-help}")]
{% endif %}
struct Cli {
    {% if cli.options %}
    // Global options
    {% for option in cli.options %}
    {% if option.type == "flag" %}
    /// {{ option.desc }}
    #[arg(long = "{{ option.name }}"{% if option.short %}, short = '{{ option.short }}'{% endif %}{% if option.default %}, default_value_t = {{ option.default | lower }}{% endif %})]
    pub {{ option.name | replace('-', '_') }}: bool,
    {% elif option.type == "int" %}
    /// {{ option.desc }}
    #[arg(long = "{{ option.name }}"{% if option.short %}, short = '{{ option.short }}'{% endif %}{% if option.default %}, default_value_t = {{ option.default }}{% endif %})]
    pub {{ option.name | replace('-', '_') }}: i32,
    {% else %}
    /// {{ option.desc }}
    #[arg(long = "{{ option.name }}"{% if option.short %}, short = '{{ option.short }}'{% endif %}{% if option.default %}, default_value = "{{ option.default }}"{% endif %})]
    pub {{ option.name | replace('-', '_') }}: {% if option.required is not defined or option.required %}String{% else %}Option<String>{% endif %},
    {% endif %}
    {% endfor %}
    {% endif %}
    
    #[command(subcommand)]
    command: Option<Commands>,
}

#[derive(Subcommand)]
enum Commands {
    {% for cmd_name, cmd_data in cli.commands.items() %}
    {% if not cmd_data.subcommands %}
    /// {% if cmd_data.icon %}{{ cmd_data.icon }} {% endif %}{{ cmd_data.desc }}
    {{ cmd_name | title | replace('-', '') }} {
        {% if cmd_data.args %}
        {% for arg in cmd_data.args %}
        {% if arg.required %}
        /// {{ arg.desc }}
        {% if arg.choices %}
        #[arg(value_parser = clap::builder::PossibleValuesParser::new({{ arg.choices | tojson }}))]
        {% endif %}
        {{ arg.name }}: String,
        {% else %}
        /// {{ arg.desc }}
        {% if arg.choices %}
        #[arg(value_parser = clap::builder::PossibleValuesParser::new({{ arg.choices | tojson }}))]
        {% endif %}
        {{ arg.name }}: Option<String>,
        {% endif %}
        {% endfor %}
        {% endif %}
        
        {% if cmd_data.options %}
        {% for opt in cmd_data.options %}
        {% if opt.type == "flag" or opt.type == "bool" %}
        /// {{ opt.desc }}
        #[arg(long = "{{ opt.name }}"{% if opt.short %}, short = '{{ opt.short }}'{% endif %}{% if opt.default %}, default_value_t = {{ opt.default | lower }}{% endif %})]
        {{ opt.name | replace('-', '_') }}: bool,
        {% elif opt.type == "int" %}
        /// {{ opt.desc }}
        #[arg(long = "{{ opt.name }}"{% if opt.short %}, short = '{{ opt.short }}'{% endif %}{% if opt.default %}, default_value_t = {{ opt.default }}{% endif %})]
        {{ opt.name | replace('-', '_') }}: i32,
        {% else %}
        /// {{ opt.desc }}
        #[arg(long = "{{ opt.name }}"{% if opt.short %}, short = '{{ opt.short }}'{% endif %}{% if opt.default %}, default_value = "{{ opt.default }}"{% endif %})]
        {{ opt.name | replace('-', '_') }}: {% if opt.required is defined and opt.required %}String{% else %}Option<String>{% endif %},
        {% endif %}
        {% endfor %}
        {% endif %}
    },
    {% else %}
    /// {% if cmd_data.icon %}{{ cmd_data.icon }} {% endif %}{{ cmd_data.desc }}
    {{ cmd_name | title | replace('-', '') }} {
        #[command(subcommand)]
        subcommand: {{ cmd_name | title | replace('-', '') }}Subcommands,
    },
    {% endif %}
    {% endfor %}
    
    /// Shell completion management
    Completion {
        #[command(subcommand)]
        subcommand: CompletionCommands,
    },
    
    /// Configuration management
    Config {
        #[command(subcommand)]
        subcommand: ConfigCommands,
    },
    
    {% if cli and (cli.enable_upgrade_command is not defined or cli.enable_upgrade_command) %}
    /// Upgrade {{ display_name }} to the latest version
    Upgrade {
        /// Check for updates without installing
        #[arg(long)]
        check: bool,
        
        /// Install specific version
        #[arg(long)]
        version: Option<String>,
        
        /// Include pre-release versions
        #[arg(long)]
        pre: bool,
        
        /// Show what would be done without doing it
        #[arg(long)]
        dry_run: bool,
    },
    {% endif %}
    
    /// Internal completion command - called by shell completion scripts
    #[command(hide = true)]
    #[clap(name = "_completion")]
    InternalCompletion {
        /// Shell type (bash, zsh, fish)
        shell: String,
        
        /// Current command line
        current_line: String,
        
        /// Cursor position
        cursor_pos: Option<usize>,
        
        /// Debug completion engine
        #[arg(long)]
        debug: bool,
    },
}

{% for cmd_name, cmd_data in cli.commands.items() %}
{% if cmd_data.subcommands %}
#[derive(Subcommand)]
enum {{ cmd_name | title | replace('-', '') }}Subcommands {
    {% for subcmd_name, subcmd_data in cmd_data.subcommands.items() %}
    {% if subcmd_data.subcommands %}
    /// {% if subcmd_data.icon %}{{ subcmd_data.icon }} {% endif %}{{ subcmd_data.desc }}
    {{ subcmd_name | title | replace('-', '') }} {
        #[command(subcommand)]
        subcommand: {{ cmd_name | title | replace('-', '') }}{{ subcmd_name | title | replace('-', '') }}Subcommands,
    },
    {% else %}
    /// {% if subcmd_data.icon %}{{ subcmd_data.icon }} {% endif %}{{ subcmd_data.desc }}
    {{ subcmd_name | title | replace('-', '') }} {
        {% if subcmd_data.args %}
        {% for arg in subcmd_data.args %}
        {% if arg.required %}
        /// {{ arg.desc }}
        {% if arg.choices %}
        #[arg(value_parser = clap::builder::PossibleValuesParser::new({{ arg.choices | tojson }}))]
        {% endif %}
        {{ arg.name }}: String,
        {% else %}
        /// {{ arg.desc }}
        {% if arg.choices %}
        #[arg(value_parser = clap::builder::PossibleValuesParser::new({{ arg.choices | tojson }}))]
        {% endif %}
        {{ arg.name }}: Option<String>,
        {% endif %}
        {% endfor %}
        {% endif %}
        
        {% if subcmd_data.options %}
        {% for opt in subcmd_data.options %}
        {% if opt.type == "flag" or opt.type == "bool" %}
        /// {{ opt.desc }}
        #[arg(long = "{{ opt.name }}"{% if opt.short %}, short = '{{ opt.short }}'{% endif %}{% if opt.default %}, default_value_t = {{ opt.default | lower }}{% endif %})]
        {{ opt.name | replace('-', '_') }}: bool,
        {% elif opt.type == "int" %}
        /// {{ opt.desc }}
        #[arg(long = "{{ opt.name }}"{% if opt.short %}, short = '{{ opt.short }}'{% endif %}{% if opt.default %}, default_value_t = {{ opt.default }}{% endif %})]
        {{ opt.name | replace('-', '_') }}: i32,
        {% else %}
        /// {{ opt.desc }}
        #[arg(long = "{{ opt.name }}"{% if opt.short %}, short = '{{ opt.short }}'{% endif %}{% if opt.default %}, default_value = "{{ opt.default }}"{% endif %})]
        {{ opt.name | replace('-', '_') }}: {% if opt.required is defined and opt.required %}String{% else %}Option<String>{% endif %},
        {% endif %}
        {% endfor %}
        {% endif %}
    },
    {% endif %}
    {% endfor %}
}

{% for subcmd_name, subcmd_data in cmd_data.subcommands.items() %}
{% if subcmd_data.subcommands %}
#[derive(Subcommand)]
enum {{ cmd_name | title | replace('-', '') }}{{ subcmd_name | title | replace('-', '') }}Subcommands {
    {% for subsubcmd_name, subsubcmd_data in subcmd_data.subcommands.items() %}
    /// {% if subsubcmd_data.icon %}{{ subsubcmd_data.icon }} {% endif %}{{ subsubcmd_data.desc }}
    {{ subsubcmd_name | title | replace('-', '') }} {
        {% if subsubcmd_data.args %}
        {% for arg in subsubcmd_data.args %}
        {% if arg.required %}
        /// {{ arg.desc }}
        {% if arg.choices %}
        #[arg(value_parser = clap::builder::PossibleValuesParser::new({{ arg.choices | tojson }}))]
        {% endif %}
        {{ arg.name }}: String,
        {% else %}
        /// {{ arg.desc }}
        {% if arg.choices %}
        #[arg(value_parser = clap::builder::PossibleValuesParser::new({{ arg.choices | tojson }}))]
        {% endif %}
        {{ arg.name }}: Option<String>,
        {% endif %}
        {% endfor %}
        {% endif %}
        
        {% if subsubcmd_data.options %}
        {% for opt in subsubcmd_data.options %}
        {% if opt.type == "flag" or opt.type == "bool" %}
        /// {{ opt.desc }}
        #[arg(long = "{{ opt.name }}"{% if opt.short %}, short = '{{ opt.short }}'{% endif %}{% if opt.default %}, default_value_t = {{ opt.default | lower }}{% endif %})]
        {{ opt.name | replace('-', '_') }}: bool,
        {% elif opt.type == "int" %}
        /// {{ opt.desc }}
        #[arg(long = "{{ opt.name }}"{% if opt.short %}, short = '{{ opt.short }}'{% endif %}{% if opt.default %}, default_value_t = {{ opt.default }}{% endif %})]
        {{ opt.name | replace('-', '_') }}: i32,
        {% else %}
        /// {{ opt.desc }}
        #[arg(long = "{{ opt.name }}"{% if opt.short %}, short = '{{ opt.short }}'{% endif %}{% if opt.default %}, default_value = "{{ opt.default }}"{% endif %})]
        {{ opt.name | replace('-', '_') }}: {% if opt.required is defined and opt.required %}String{% else %}Option<String>{% endif %},
        {% endif %}
        {% endfor %}
        {% endif %}
    },
    {% endfor %}
}
{% endif %}
{% endfor %}
{% endif %}
{% endfor %}

#[derive(Subcommand)]
enum CompletionCommands {
    /// Generate completion script for a shell
    Generate {
        /// Shell to generate completions for
        #[arg(value_parser = clap::builder::PossibleValuesParser::new(["bash", "zsh", "fish", "powershell"]))]
        shell: String,
        
        /// Output the completion script to a file instead of stdout
        #[arg(long, short)]
        output: Option<String>,
        
        /// Enable verbose output
        #[arg(long, short)]
        verbose: bool,
    },
    
    /// Install completions for current user
    Install {
        /// Shell to install completions for
        #[arg(value_parser = clap::builder::PossibleValuesParser::new(["bash", "zsh", "fish", "powershell"]))]
        shell: String,
        
        /// Install system-wide instead of user-only
        #[arg(long)]
        system: bool,
        
        /// Force overwrite existing completions
        #[arg(long, short)]
        force: bool,
    },
    
    /// Show instructions for manual completion installation
    Instructions {
        /// Shell to show instructions for
        #[arg(value_parser = clap::builder::PossibleValuesParser::new(["bash", "zsh", "fish", "powershell"]))]
        shell: String,
        
        /// Show system-wide installation instructions
        #[arg(long)]
        system: bool,
    },
}

#[derive(Subcommand)]
enum ConfigCommands {
    /// Get configuration value
    Get {
        /// Configuration key to retrieve (optional, shows all if not specified)
        key: Option<String>,
        
        /// Output format
        #[arg(long, value_parser = clap::builder::PossibleValuesParser::new(["json", "yaml", "plain"]))]
        format: Option<String>,
    },
    
    /// Set configuration value
    Set {
        /// Configuration key to set
        key: String,
        
        /// Value to set
        value: String,
        
        /// Data type of the value
        #[arg(long, value_parser = clap::builder::PossibleValuesParser::new(["string", "int", "float", "bool"]))]
        value_type: Option<String>,
    },
    
    /// Reset configuration to defaults
    Reset {
        /// Specific key to reset (resets all if not specified)
        key: Option<String>,
        
        /// Skip confirmation prompt
        #[arg(long, short)]
        yes: bool,
    },
    
    /// Show configuration file path
    Path {
        /// Show directory path instead of file path
        #[arg(long)]
        dir: bool,
        
        /// Create the config file/directory if it doesn't exist
        #[arg(long)]
        create: bool,
    },
}

// Arguments structure for hook functions
#[derive(Debug, Clone)]
pub struct Args {
    pub command_name: String,
    {% if cli.options %}
    {% for option in cli.options %}
    pub {{ option.name | replace('-', '_') }}: {% if option.type == "flag" or option.type == "bool" %}bool{% elif option.type == "int" %}i32{% else %}{% if option.required is not defined or option.required %}String{% else %}Option<String>{% endif %}{% endif %},
    {% endfor %}
    {% endif %}
    pub raw_args: HashMap<String, String>,
}

{% if cli and (cli.enable_upgrade_command is not defined or cli.enable_upgrade_command) %}
fn handle_upgrade(check: bool, version: Option<String>, pre: bool, dry_run: bool) -> CliResult<()> {
    let package_name = "{{ package_name }}";
    let display_name = "{{ display_name }}";
    let current_version = env!("CARGO_PKG_VERSION");
    
    utils::output::info(&format!("Current version: {}", current_version));
    
    if check {
        utils::output::info(&format!("Checking for updates to {}...", display_name));
        utils::output::info("Update check not yet implemented. Run without --check to upgrade.");
        return Ok(());
    }
    
    if dry_run {
        let cmd = if let Some(ver) = version {
            format!("cargo install {} --version {}", package_name, ver)
        } else if pre {
            format!("cargo install {} --pre", package_name)
        } else {
            format!("cargo install {}", package_name)
        };
        utils::output::info(&format!("Dry run - would execute: {}", cmd));
        return Ok(());
    }
    
    utils::output::info(&format!("Upgrading {}...", display_name));
    
    let mut cmd = std::process::Command::new("cargo");
    cmd.args(&["install", package_name]);
    
    if let Some(ver) = version {
        cmd.args(&["--version", &ver]);
    } else if pre {
        cmd.arg("--pre");
    }
    
    let status = cmd.status()
        .map_err(|e| CLIError::hook("cargo install", &format!("Command execution failed: {}", e)))?;
    
    if status.success() {
        utils::output::success(&format!("{} upgraded successfully!", display_name));
        utils::output::info(&format!("Run '{} --version' to verify the new version.", "{{ command_name }}"));
    } else {
        return Err(CLIError::hook("cargo install", "Upgrade command failed"));
    }
    
    Ok(())
}
{% endif %}

/// Handle internal shell completion requests (called by completion scripts)
fn handle_internal_completion(shell: &str, current_line: &str, cursor_pos: Option<usize>, debug: bool) -> CliResult<()> {
    // Import completion engine at runtime
    mod completion_engine;
    
    let engine = completion_engine::CompletionEngine::new(None);
    let completions = engine.get_completions(shell, current_line, cursor_pos);
    
    // Output completions one per line
    for completion in completions {
        println!("{}", completion);
    }
    
    if debug && completions.is_empty() {
        eprintln!("No completions found");
    }
    
    Ok(())
}

fn main() {
    // Set up panic hook for better error reporting
    std::panic::set_hook(Box::new(|panic_info| {
        eprintln!("ðŸ’¥ {{ display_name }} encountered an unexpected error:");
        eprintln!("{}", panic_info);
        eprintln!("\nðŸ› This is likely a bug. Please report it at: {{ repository | default('https://github.com/your-org/your-repo') }}");
        process::exit(ExitCode::GeneralError as i32);
    }));

    if let Err(error) = run() {
        handle_application_error(&error);
    }
}

fn run() -> CliResult<()> {
    let cli = Cli::parse();
    
    // Initialize configuration and hook system
    let config = crate::config::AppConfig::load()
        .map_err(|e| CLIError::ValidationFailed {
            message: format!("Failed to load configuration: {}", e),
        })?;
    let config_dir = crate::config::AppConfig::config_dir()
        .map_err(|e| CLIError::Environment {
            message: format!("Could not determine configuration directory: {}", e),
        })?;
    
    // Initialize styling system
    initialize_styling(
        config.is_feature_enabled("colored_output"),
        config.is_feature_enabled("unicode_symbols")
    );
    
    hooks::initialize_hooks(&config_dir)
        .map_err(|e| CLIError::hook("system", &format!("Failed to initialize hooks in {}: {}", config_dir.display(), e)))?;
    initialize_plugins(&config)
        .map_err(|e| CLIError::plugin("system", &format!("Failed to initialize plugins: {}", e)))?;
    
    // Prepare common arguments structure
    let args = Args {
        command_name: "".to_string(), // Will be set per command
        {% if cli.options %}
        {% for option in cli.options %}
        {{ option.name | replace('-', '_') }}: cli.{{ option.name | replace('-', '_') }},
        {% endfor %}
        {% endif %}
        raw_args: HashMap::new(),
    };
    
    match cli.command {
        Some(command) => {
            match command {
                {% for cmd_name, cmd_data in cli.commands.items() %}
                {% if not cmd_data.subcommands %}
                Commands::{{ cmd_name | title | replace('-', '') }} { 
                    {% if cmd_data.args %}
                    {% for arg in cmd_data.args %}
                    {{ arg.name }},
                    {% endfor %}
                    {% endif %}
                    {% if cmd_data.options %}
                    {% for opt in cmd_data.options %}
                    {{ opt.name | replace('-', '_') }},
                    {% endfor %}
                    {% endif %}
                } => {
                    execute_command_with_hooks("{{ cmd_name }}", args.clone(), || {
                        execute_{{ cmd_name | replace('-', '_') }}_command(
                            {% if cmd_data.args %}
                            {% for arg in cmd_data.args %}
                            {% if arg.required %}
                            &{{ arg.name }},
                            {% else %}
                            {{ arg.name }}.as_deref(),
                            {% endif %}
                            {% endfor %}
                            {% endif %}
                            {% if cmd_data.options %}
                            {% for opt in cmd_data.options %}
                            {% if opt.type == "flag" or opt.type == "bool" %}
                            {{ opt.name | replace('-', '_') }},
                            {% elif opt.type == "int" %}
                            {{ opt.name | replace('-', '_') }},
                            {% else %}
                            {% if opt.required is defined and opt.required %}
                            &{{ opt.name | replace('-', '_') }},
                            {% else %}
                            {{ opt.name | replace('-', '_') }}.as_deref(),
                            {% endif %}
                            {% endif %}
                            {% endfor %}
                            {% endif %}
                        )
                    })?;
                }
                {% else %}
                Commands::{{ cmd_name | title | replace('-', '') }} { subcommand } => {
                    match subcommand {
                        {% for subcmd_name, subcmd_data in cmd_data.subcommands.items() %}
                        {{ cmd_name | title | replace('-', '') }}Subcommands::{{ subcmd_name | title | replace('-', '') }} {
                            {% if subcmd_data.args %}
                            {% for arg in subcmd_data.args %}
                            {{ arg.name }},
                            {% endfor %}
                            {% endif %}
                            {% if subcmd_data.options %}
                            {% for opt in subcmd_data.options %}
                            {{ opt.name | replace('-', '_') }},
                            {% endfor %}
                            {% endif %}
                        } => {
                            let mut cmd_args = args.clone();
                            cmd_args.command_name = "{{ subcmd_name }}".to_string();
                            
                            // Try to call hook, fallback to placeholder
                            match hooks::try_call_hook("{{ cmd_name }}_{{ subcmd_name }}", &cmd_args) {
                                Ok(_) => {}
                                Err(_) => {
                                    execute_{{ cmd_name | replace('-', '_') }}_{{ subcmd_name | replace('-', '_') }}_command(
                                        {% if subcmd_data.args %}
                                        {% for arg in subcmd_data.args %}
                                        {% if arg.required %}
                                        &{{ arg.name }},
                                        {% else %}
                                        {{ arg.name }}.as_deref(),
                                        {% endif %}
                                        {% endfor %}
                                        {% endif %}
                                        {% if subcmd_data.options %}
                                        {% for opt in subcmd_data.options %}
                                        {% if opt.type == "flag" or opt.type == "bool" %}
                                        {{ opt.name | replace('-', '_') }},
                                        {% elif opt.type == "int" %}
                                        {{ opt.name | replace('-', '_') }},
                                        {% else %}
                                        {% if opt.required is defined and opt.required %}
                                        &{{ opt.name | replace('-', '_') }},
                                        {% else %}
                                        {{ opt.name | replace('-', '_') }}.as_deref(),
                                        {% endif %}
                                        {% endif %}
                                        {% endfor %}
                                        {% endif %}
                                    )?;
                                }
                            }
                        }
                        {% endfor %}
                    }
                }
                {% endif %}
                {% endfor %}
                
                Commands::Completion { subcommand } => {
                    match subcommand {
                        CompletionCommands::Generate { shell, output, verbose } => {
                            handle_completion_generate(&shell, output.as_deref(), verbose)?;
                        }
                        CompletionCommands::Install { shell, system, force } => {
                            handle_completion_install(&shell, system, force)?;
                        }
                        CompletionCommands::Instructions { shell, system } => {
                            handle_completion_instructions(&shell, system)?;
                        }
                    }
                }
                
                Commands::Config { subcommand } => {
                    match subcommand {
                        ConfigCommands::Get { key, format } => {
                            handle_config_get(key.as_deref(), format.as_deref())?;
                        }
                        ConfigCommands::Set { key, value, value_type } => {
                            handle_config_set(&key, &value, value_type.as_deref())?;
                        }
                        ConfigCommands::Reset { key, yes } => {
                            handle_config_reset(key.as_deref(), yes)?;
                        }
                        ConfigCommands::Path { dir, create } => {
                            handle_config_path(dir, create)?;
                        }
                    }
                }
                
                {% if cli and (cli.enable_upgrade_command is not defined or cli.enable_upgrade_command) %}
                Commands::Upgrade { check, version, pre, dry_run } => {
                    handle_upgrade(check, version, pre, dry_run)?;
                }
                {% endif %}
                
                Commands::InternalCompletion { shell, current_line, cursor_pos, debug } => {
                    handle_internal_completion(&shell, &current_line, cursor_pos, debug)?;
                }
            }
        }
        None => {
            {% set has_default = namespace(value=false) %}
            {% for cmd_name, cmd_data in cli.commands.items() %}
            {% if cmd_data.is_default %}
            {% set has_default.value = true %}
            // Default command: {{ cmd_name }}
            let mut cmd_args = args.clone();
            cmd_args.command_name = "{{ cmd_name }}".to_string();
            
            match hooks::try_call_hook("{{ cmd_name }}", &cmd_args) {
                Ok(_) => {}
                Err(_) => {
                    execute_{{ cmd_name | replace('-', '_') }}_command(/* default args */)?;
                }
            }
            {% endif %}
            {% endfor %}
            {% if not has_default.value %}
            // No default command, show help
            let mut cmd = Cli::command();
            cmd.print_help().map_err(|e| CLIError::Application {
                message: "Failed to print help".to_string(),
                context: Some(e.to_string()),
            })?;
            println!();
            {% endif %}
        }
    }
    
    Ok(())
}

/// Execute a command with full hook lifecycle management
fn execute_command_with_hooks<F>(command_name: &str, args: Args, execute_fn: F) -> CliResult<()>
where
    F: FnOnce() -> CliResult<()>,
{
    // Prepare hook context
    let hook_context = HookContext::new(
        command_name.to_string(),
        None,
        vec![], // args would be populated from actual command arguments
        HashMap::new(), // options would be populated from actual command options
        ExecutionPhase::PreCommand,
    ).map_err(|e| CLIError::hook(
        command_name,
        &format!("Failed to create context: {}", e)
    ))?;
    
    // Execute pre-command hooks
    if let Err(e) = hooks::execute_command_hooks(command_name, ExecutionPhase::PreCommand, &hook_context) {
        let error_context = hook_context.with_error(&e.to_string());
        let _ = hooks::execute_command_hooks(command_name, ExecutionPhase::OnError, &error_context);
        return Err(CLIError::hook(
            command_name,
            &format!("Pre-command hook failed: {}", e)
        ));
    }
    
    // Execute the actual command
    let command_result = execute_fn();
    
    // Execute post-command hooks
    let post_context = HookContext::new(
        command_name.to_string(),
        None,
        vec![],
        HashMap::new(),
        if command_result.is_ok() { ExecutionPhase::OnSuccess } else { ExecutionPhase::OnError },
    ).map_err(|e| CLIError::hook(
        command_name,
        &format!("Failed to create post-command context: {}", e)
    ))?;
    
    match &command_result {
        Ok(_) => {
            let _ = hooks::execute_command_hooks(command_name, ExecutionPhase::PostCommand, &post_context);
            let _ = hooks::execute_command_hooks(command_name, ExecutionPhase::OnSuccess, &post_context);
        }
        Err(e) => {
            let error_context = post_context.with_error(&e.to_string());
            let _ = hooks::execute_command_hooks(command_name, ExecutionPhase::OnError, &error_context);
        }
    }
    
    command_result
}

{% for cmd_name, cmd_data in cli.commands.items() %}
{% if not cmd_data.subcommands %}
/// Execute {{ cmd_name }} command with proper error handling
fn execute_{{ cmd_name | replace('-', '_') }}_command(
    {% if cmd_data.args %}
    {% for arg in cmd_data.args %}
    {% if arg.required %}
    {{ arg.name }}: &str,
    {% else %}
    {{ arg.name }}: Option<&str>,
    {% endif %}
    {% endfor %}
    {% endif %}
    {% if cmd_data.options %}
    {% for opt in cmd_data.options %}
    {% if opt.type == "flag" or opt.type == "bool" %}
    {{ opt.name | replace('-', '_') }}: bool,
    {% elif opt.type == "int" %}
    {{ opt.name | replace('-', '_') }}: i32,
    {% else %}
    {% if opt.required is defined and opt.required %}
    {{ opt.name | replace('-', '_') }}: &str,
    {% else %}
    {{ opt.name | replace('-', '_') }}: Option<&str>,
    {% endif %}
    {% endif %}
    {% endfor %}
    {% endif %}
) -> CliResult<()> {
    {% if cmd_data.lifecycle == "managed" %}
    // Managed command - would need external command instance
    utils::output::info("ðŸ”§ Managed command '{{ cmd_name }}' requires external implementation");
    utils::output::info("   Implement {{ cmd_name | title }}Command struct with execute() method");
    
    return Err(CLIError::hook(
        "{{ cmd_name }}",
        "Managed command not implemented"
    ));
    {% else %}
    // Default command implementation with validation
    utils::output::info("ðŸš€ Executing {{ cmd_name }} command...");
    
    // Validate command arguments
    {% if cmd_data.args %}
    {% for arg in cmd_data.args %}
    {% if arg.required %}
    if {{ arg.name }}.is_empty() {
        return Err(CLIError::Command(errors::CommandError::MissingArgument {
            arg: "{{ arg.name }}".to_string(),
        }));
    }
    {% endif %}
    {% if arg.choices %}
    {
        let valid_choices = vec![{% for choice in arg.choices %}"{{ choice }}"{% if not loop.last %}, {% endif %}{% endfor %}];
        {% if arg.required %}
        if !valid_choices.contains(&{{ arg.name }}) {
            return Err(CLIError::Command(errors::CommandError::InvalidArgument {
                arg: "{{ arg.name }}".to_string(),
                value: {{ arg.name }}.to_string(),
                expected: format!("one of: {}", valid_choices.join(", ")),
            }));
        }
        {% else %}
        if let Some(value) = {{ arg.name }} {
            if !valid_choices.contains(&value) {
                return Err(CLIError::Command(errors::CommandError::InvalidArgument {
                    arg: "{{ arg.name }}".to_string(),
                    value: value.to_string(),
                    expected: format!("one of: {}", valid_choices.join(", ")),
                }));
            }
        }
        {% endif %}
    }
    {% endif %}
    {% endfor %}
    {% endif %}
    
    // Display command execution information
    {% if cmd_data.args %}
    {% for arg in cmd_data.args %}
    {% if arg.required %}
    utils::output::key_value("{{ arg.name }}", {{ arg.name }});
    {% else %}
    if let Some(value) = {{ arg.name }} {
        utils::output::key_value("{{ arg.name }}", value);
    }
    {% endif %}
    {% endfor %}
    {% endif %}
    {% if cmd_data.options %}
    {% for opt in cmd_data.options %}
    {% if opt.type == "flag" or opt.type == "bool" %}
    if {{ opt.name | replace('-', '_') }} {
        utils::output::key_value("{{ opt.name }}", "enabled");
    }
    {% elif opt.type == "int" %}
    utils::output::key_value("{{ opt.name }}", &{{ opt.name | replace('-', '_') }}.to_string());
    {% else %}
    {% if opt.required is defined and opt.required %}
    utils::output::key_value("{{ opt.name }}", {{ opt.name | replace('-', '_') }});
    {% else %}
    if let Some(value) = {{ opt.name | replace('-', '_') }} {
        utils::output::key_value("{{ opt.name }}", value);
    }
    {% endif %}
    {% endif %}
    {% endfor %}
    {% endif %}
    
    // TODO: Implement actual {{ cmd_name }} command logic here
    // This is a placeholder implementation
    
    utils::output::success("{{ cmd_name | title }} command completed successfully!");
    {% endif %}
    
    Ok(())
}
{% endif %}
{% endfor %}

/// Handle completion generate command
fn handle_completion_generate(shell: &str, output: Option<&str>, verbose: bool) -> CliResult<()> {
    use std::io::Write;
    
    if verbose {
        utils::output::info(&format!("Generating {} completion script...", shell));
    }
    
    // Generate completion script based on shell type
    let completion_script = match shell {
        "bash" => generate_bash_completion(),
        "zsh" => generate_zsh_completion(),
        "fish" => generate_fish_completion(),
        "powershell" => generate_powershell_completion(),
        _ => return Err(CLIError::Command(errors::CommandError::InvalidArgument {
            arg: "shell".to_string(),
            value: shell.to_string(),
            expected: "one of: bash, zsh, fish, powershell".to_string(),
        }))
    };
    
    match output {
        Some(file_path) => {
            // Write to file
            let mut file = std::fs::File::create(file_path)
                .map_err(|e| CLIError::Io(std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!("Failed to create output file '{}': {}", file_path, e)
                )))?;
            
            file.write_all(completion_script.as_bytes())
                .map_err(|e| CLIError::Io(std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!("Failed to write to output file '{}': {}", file_path, e)
                )))?;
            
            utils::output::success(&format!("Completion script written to: {}", file_path));
        }
        None => {
            // Write to stdout
            print!("{}", completion_script);
        }
    }
    
    Ok(())
}

/// Handle completion install command
fn handle_completion_install(shell: &str, system: bool, force: bool) -> CliResult<()> {
    use std::fs;
    use std::path::PathBuf;
    
    utils::output::info(&format!("Installing {} completions...", shell));
    
    // Determine completion paths based on shell and scope
    let (completion_dir, completion_file) = match shell {
        "bash" => {
            let dir = if system {
                PathBuf::from("/etc/bash_completion.d")
            } else {
                dirs::home_dir()
                    .ok_or_else(|| CLIError::Environment {
                        message: "Could not determine home directory".to_string(),
                    })?
                    .join(".local/share/bash-completion/completions")
            };
            (dir, format!("{}", "{{ command_name }}"))
        }
        "zsh" => {
            let dir = if system {
                PathBuf::from("/usr/local/share/zsh/site-functions")
            } else {
                dirs::home_dir()
                    .ok_or_else(|| CLIError::Environment {
                        message: "Could not determine home directory".to_string(),
                    })?
                    .join(".local/share/zsh/site-functions")
            };
            (dir, format!("_{}", "{{ command_name }}"))
        }
        "fish" => {
            let dir = if system {
                PathBuf::from("/usr/share/fish/completions")
            } else {
                dirs::home_dir()
                    .ok_or_else(|| CLIError::Environment {
                        message: "Could not determine home directory".to_string(),
                    })?
                    .join(".config/fish/completions")
            };
            (dir, format!("{}.fish", "{{ command_name }}"))
        }
        "powershell" => {
            return Err(CLIError::hook(
                "completion install",
                "PowerShell completion installation not supported on this platform"
            ));
        }
        _ => return Err(CLIError::Command(errors::CommandError::InvalidArgument {
            arg: "shell".to_string(),
            value: shell.to_string(),
            expected: "one of: bash, zsh, fish, powershell".to_string(),
        }))
    };
    
    let completion_path = completion_dir.join(&completion_file);
    
    // Check if completion already exists
    if completion_path.exists() && !force {
        return Err(CLIError::hook(
            "completion install",
            &format!(
                "Completion already exists at {}. Use --force to overwrite.",
                completion_path.display()
            )
        ));
    }
    
    // Create completion directory if it doesn't exist
    if let Some(parent) = completion_path.parent() {
        fs::create_dir_all(parent)
            .map_err(|e| CLIError::Io(std::io::Error::new(
                std::io::ErrorKind::Other,
                format!("Failed to create completion directory '{}': {}", parent.display(), e)
            )))?;
    }
    
    // Generate completion script
    let completion_script = match shell {
        "bash" => generate_bash_completion(),
        "zsh" => generate_zsh_completion(),
        "fish" => generate_fish_completion(),
        _ => unreachable!(),
    };
    
    // Write completion script
    fs::write(&completion_path, completion_script)
        .map_err(|e| CLIError::Io(std::io::Error::new(
            std::io::ErrorKind::Other,
            format!("Failed to write completion file '{}': {}", completion_path.display(), e)
        )))?;
    
    utils::output::success(&format!(
        "Completion installed at: {}",
        completion_path.display()
    ));
    
    // Provide activation instructions
    match shell {
        "bash" => {
            if !system {
                utils::output::info("Add the following to your ~/.bashrc:");
                utils::output::info(&format!(
                    "  source {}",
                    completion_path.display()
                ));
            }
        }
        "zsh" => {
            if !system {
                utils::output::info("Ensure ~/.local/share/zsh/site-functions is in your $fpath");
                utils::output::info("Add to ~/.zshrc if needed:");
                utils::output::info("  fpath=(~/.local/share/zsh/site-functions $fpath)");
            }
        }
        "fish" => {
            utils::output::info("Fish completions are automatically loaded");
        }
        _ => {}
    }
    
    Ok(())
}

/// Handle completion instructions command
fn handle_completion_instructions(shell: &str, system: bool) -> CliResult<()> {
    let scope = if system { "system-wide" } else { "user" };
    
    utils::output::info(&format!("Manual {} completion installation instructions ({})", shell, scope));
    println!();
    
    match shell {
        "bash" => {
            if system {
                println!("1. Generate completion script:");
                println!("   {} completion generate bash | sudo tee /etc/bash_completion.d/{}", "{{ command_name }}", "{{ command_name }}");
                println!();
                println!("2. Reload bash completions:");
                println!("   source /etc/bash_completion");
            } else {
                println!("1. Create completion directory:");
                println!("   mkdir -p ~/.local/share/bash-completion/completions");
                println!();
                println!("2. Generate completion script:");
                println!("   {} completion generate bash > ~/.local/share/bash-completion/completions/{}", "{{ command_name }}", "{{ command_name }}");
                println!();
                println!("3. Add to ~/.bashrc:");
                println!("   source ~/.local/share/bash-completion/completions/{}",  "{{ command_name }}");
            }
        }
        "zsh" => {
            if system {
                println!("1. Generate completion script:");
                println!("   {} completion generate zsh | sudo tee /usr/local/share/zsh/site-functions/_{}", "{{ command_name }}", "{{ command_name }}");
                println!();
                println!("2. Reload zsh completions:");
                println!("   autoload -U compinit && compinit");
            } else {
                println!("1. Create completion directory:");
                println!("   mkdir -p ~/.local/share/zsh/site-functions");
                println!();
                println!("2. Generate completion script:");
                println!("   {} completion generate zsh > ~/.local/share/zsh/site-functions/_{}", "{{ command_name }}", "{{ command_name }}");
                println!();
                println!("3. Add to ~/.zshrc (if not already present):");
                println!("   fpath=(~/.local/share/zsh/site-functions $fpath)");
                println!("   autoload -U compinit && compinit");
            }
        }
        "fish" => {
            if system {
                println!("1. Generate completion script:");
                println!("   {} completion generate fish | sudo tee /usr/share/fish/completions/{}.fish", "{{ command_name }}", "{{ command_name }}");
            } else {
                println!("1. Create completion directory:");
                println!("   mkdir -p ~/.config/fish/completions");
                println!();
                println!("2. Generate completion script:");
                println!("   {} completion generate fish > ~/.config/fish/completions/{}.fish", "{{ command_name }}", "{{ command_name }}");
            }
            println!();
            println!("Fish completions are automatically loaded when the shell starts.");
        }
        "powershell" => {
            println!("1. Generate completion script:");
            println!("   {} completion generate powershell > {}_completion.ps1", "{{ command_name }}", "{{ command_name }}");
            println!();
            println!("2. Add to PowerShell profile:");
            println!("   . ./{}_completion.ps1", "{{ command_name }}");
            println!();
            println!("Note: You may need to adjust ExecutionPolicy:");
            println!("   Set-ExecutionPolicy -ExecutionPolicy RemoteSigned -Scope CurrentUser");
        }
        _ => return Err(CLIError::Command(errors::CommandError::InvalidArgument {
            arg: "shell".to_string(),
            value: shell.to_string(),
            expected: "one of: bash, zsh, fish, powershell".to_string(),
        }))
    }
    
    println!();
    utils::output::info("After installation, restart your shell or source your profile to enable completions.");
    
    Ok(())
}

/// Handle config get command
fn handle_config_get(key: Option<&str>, format: Option<&str>) -> CliResult<()> {
    let config = crate::config::AppConfig::load()
        .map_err(|e| CLIError::ValidationFailed {
            message: format!("Failed to load configuration: {}", e),
        })?;
    
    let output_format = format.unwrap_or("plain");
    
    match key {
        Some(key_name) => {
            // Get specific key
            match config.get_value(key_name) {
                Some(value) => {
                    match output_format {
                        "json" => {
                            let json_value = serde_json::json!({key_name: value});
                            println!("{}", serde_json::to_string_pretty(&json_value)
                                .map_err(|e| CLIError::ValidationFailed {
                                    message: format!("Failed to format as JSON: {}", e),
                                })?);
                        }
                        "yaml" => {
                            let yaml_map = std::collections::HashMap::<String, serde_yaml::Value>::from([(key_name.to_string(), value.clone())]);
                            println!("{}", serde_yaml::to_string(&yaml_map)
                                .map_err(|e| CLIError::ValidationFailed {
                                    message: format!("Failed to format as YAML: {}", e),
                                })?);
                        }
                        "plain" | _ => {
                            println!("{}", value.as_str().unwrap_or(&value.to_string()));
                        }
                    }
                }
                None => {
                    return Err(CLIError::Config(errors::ConfigError::KeyNotFound {
                        key: key_name.to_string(),
                    }));
                }
            }
        }
        None => {
            // Get all configuration
            let all_config = config.to_map();
            
            match output_format {
                "json" => {
                    println!("{}", serde_json::to_string_pretty(&all_config)
                        .map_err(|e| CLIError::ValidationFailed {
                            message: format!("Failed to format as JSON: {}", e),
                        })?);
                }
                "yaml" => {
                    println!("{}", serde_yaml::to_string(&all_config)
                        .map_err(|e| CLIError::ValidationFailed {
                            message: format!("Failed to format as YAML: {}", e),
                        })?);
                }
                "plain" | _ => {
                    utils::output::info("Configuration values:");
                    for (key, value) in all_config {
                        utils::output::key_value(&key, &value.as_str().unwrap_or(&value.to_string()));
                    }
                }
            }
        }
    }
    
    Ok(())
}

/// Handle config set command
fn handle_config_set(key: &str, value: &str, value_type: Option<&str>) -> CliResult<()> {
    let mut config = crate::config::AppConfig::load()
        .map_err(|e| CLIError::ValidationFailed {
            message: format!("Failed to load configuration: {}", e),
        })?;
    
    // Parse value based on type
    let parsed_value = match value_type.unwrap_or("string") {
        "string" => serde_yaml::Value::String(value.to_string()),
        "int" => {
            let int_val: i64 = value.parse()
                .map_err(|_| CLIError::ValidationFailed {
                    message: format!("Invalid integer value: {}", value),
                })?;
            serde_yaml::Value::Number(serde_yaml::Number::from(int_val))
        }
        "float" => {
            let float_val: f64 = value.parse()
                .map_err(|_| CLIError::ValidationFailed {
                    message: format!("Invalid float value: {}", value),
                })?;
            serde_yaml::Value::Number(serde_yaml::Number::from(float_val))
        }
        "bool" => {
            let bool_val: bool = value.parse()
                .map_err(|_| CLIError::ValidationFailed {
                    message: format!("Invalid boolean value: {} (use true/false)", value),
                })?;
            serde_yaml::Value::Bool(bool_val)
        }
        _ => return Err(CLIError::ValidationFailed {
            message: format!("Invalid value type: {}", value_type.unwrap()),
        }),
    };
    
    // Set the value
    config.set_value(key, parsed_value)
        .map_err(|e| CLIError::ValidationFailed {
            message: format!("Failed to set configuration value: {}", e),
        })?;
    
    // Save the configuration
    config.save()
        .map_err(|e| CLIError::Config(errors::ConfigError::SaveFailed {
            message: format!("Failed to save configuration: {}", e),
        }))?;
    
    utils::output::success(&format!("Configuration value set: {} = {}", key, value));
    
    Ok(())
}

/// Handle config reset command
fn handle_config_reset(key: Option<&str>, yes: bool) -> CliResult<()> {
    let config_path = crate::config::AppConfig::config_path()
        .map_err(|e| CLIError::Environment {
            message: format!("Could not determine configuration path: {}", e),
        })?;
    
    match key {
        Some(key_name) => {
            // Reset specific key
            if !yes {
                // TODO: Add prompts helper and use confirmation
                println!("Reset configuration key '{}' to default value? [y/N]: ", key_name);
                let mut input = String::new();
                std::io::stdin().read_line(&mut input)
                    .map_err(|e| CLIError::Io(e))?;
                
                if !input.trim().to_lowercase().starts_with('y') {
                    utils::output::info("Reset cancelled.");
                    return Ok(());
                }
            }
            
            let mut config = crate::config::AppConfig::load()
                .map_err(|e| CLIError::ValidationFailed {
                    message: format!("Failed to load configuration: {}", e),
                })?;
            
            config.reset_key(key_name)
                .map_err(|e| CLIError::ValidationFailed {
                    message: format!("Failed to reset configuration key: {}", e),
                })?;
            
            config.save()
                .map_err(|e| CLIError::Config(errors::ConfigError::SaveFailed {
                    message: format!("Failed to save configuration: {}", e),
                }))?;
            
            utils::output::success(&format!("Configuration key '{}' reset to default", key_name));
        }
        None => {
            // Reset entire configuration
            if !yes {
                println!("Reset entire configuration to defaults? This will remove all custom settings. [y/N]: ");
                let mut input = String::new();
                std::io::stdin().read_line(&mut input)
                    .map_err(|e| CLIError::Io(e))?;
                
                if !input.trim().to_lowercase().starts_with('y') {
                    utils::output::info("Reset cancelled.");
                    return Ok(());
                }
            }
            
            // Remove config file to reset to defaults
            if config_path.exists() {
                std::fs::remove_file(&config_path)
                    .map_err(|e| CLIError::Io(std::io::Error::new(
                        std::io::ErrorKind::Other,
                        format!("Failed to remove configuration file '{}': {}", config_path.display(), e)
                    )))?;
            }
            
            utils::output::success("Configuration reset to defaults");
        }
    }
    
    Ok(())
}

/// Handle config path command
fn handle_config_path(dir: bool, create: bool) -> CliResult<()> {
    if dir {
        let config_dir = crate::config::AppConfig::config_dir()
            .map_err(|e| CLIError::Environment {
                message: format!("Could not determine configuration directory: {}", e),
            })?;
        
        if create && !config_dir.exists() {
            std::fs::create_dir_all(&config_dir)
                .map_err(|e| CLIError::Io(std::io::Error::new(
                    std::io::ErrorKind::Other,
                    format!("Failed to create configuration directory '{}': {}", config_dir.display(), e)
                )))?;
            utils::output::success(&format!("Created configuration directory: {}", config_dir.display()));
        }
        
        println!("{}", config_dir.display());
    } else {
        let config_path = crate::config::AppConfig::config_path()
            .map_err(|e| CLIError::Environment {
                message: format!("Could not determine configuration path: {}", e),
            })?;
        
        if create {
            // Create directory if needed
            if let Some(parent) = config_path.parent() {
                if !parent.exists() {
                    std::fs::create_dir_all(parent)
                        .map_err(|e| CLIError::Io(std::io::Error::new(
                            std::io::ErrorKind::Other,
                            format!("Failed to create configuration directory '{}': {}", parent.display(), e)
                        )))?;
                }
            }
            
            // Create config file if it doesn't exist
            if !config_path.exists() {
                let default_config = crate::config::AppConfig::default();
                default_config.save()
                    .map_err(|e| CLIError::Config(errors::ConfigError::SaveFailed {
                        message: format!("Failed to create configuration file: {}", e),
                    }))?;
                utils::output::success(&format!("Created configuration file: {}", config_path.display()));
            }
        }
        
        println!("{}", config_path.display());
    }
    
    Ok(())
}

// Helper functions for generating completion scripts
fn generate_bash_completion() -> String {
    {% raw %}format!(r#"#!/bin/bash
# Bash completion for {}
# Generated by goobits-cli

_{}_completion() {{
    local cur prev opts
    COMPREPLY=()
    cur="${{COMP_WORDS[COMP_CWORD]}}"
    prev="${{COMP_WORDS[COMP_CWORD-1]}}"
    
    # Get completions from the CLI
    local completions
    completions=$({} _completion bash "${{COMP_LINE}}" "${{COMP_POINT}}" 2>/dev/null)
    
    # Convert completions to array
    COMPREPLY=( $(compgen -W "${{completions}}" -- "${{cur}}") )
    
    return 0
}}

complete -F _{}_completion {}
"#{% endraw %}, "{{ command_name }}", "{{ command_name | replace('-', '_') }}", "{{ command_name }}", "{{ command_name | replace('-', '_') }}", "{{ command_name }}")
}

fn generate_zsh_completion() -> String {
    {% raw %}format!(r#"#compdef {}
# Zsh completion for {}
# Generated by goobits-cli

_{}_completion() {{
    local state line
    local -a completions
    
    # Get completions from the CLI
    completions=($({} _completion zsh "${{words[*]}}" "${{CURSOR}}" 2>/dev/null))
    
    # Provide completions
    compadd -a completions
}}

_{}_completion "$@"
"#{% endraw %}, "{{ command_name }}", "{{ command_name }}", "{{ command_name | replace('-', '_') }}", "{{ command_name }}", "{{ command_name | replace('-', '_') }}")
}

fn generate_fish_completion() -> String {
    {% raw %}format!(r#"# Fish completion for {}
# Generated by goobits-cli

complete -c {} -f -a "({} _completion fish (commandline -cp) (commandline -C) 2>/dev/null)"
"#{% endraw %}, "{{ command_name }}", "{{ command_name }}", "{{ command_name }}")
}

fn generate_powershell_completion() -> String {
    {% raw %}format!(r#"# PowerShell completion for {}
# Generated by goobits-cli

Register-ArgumentCompleter -Native -CommandName {} -ScriptBlock {{
    param($commandLine, $wordToComplete, $cursorPosition)
    
    try {{
        $completions = & {} _completion powershell $commandLine $cursorPosition 2>$null
        $completions | ForEach-Object {{
            [System.Management.Automation.CompletionResult]::new($_, $_, 'ParameterValue', $_)
        }}
    }} catch {{
        # Silently ignore errors
    }}
}}
"#{% endraw %}, "{{ command_name }}", "{{ command_name }}", "{{ command_name }}")
}

/// Handle application errors with appropriate formatting and exit codes
fn handle_application_error(error: &CLIError) {
    // Initialize styling if not already done (fallback)
    if std::panic::catch_unwind(|| styling::output()).is_err() {
        initialize_styling(true, true);
    }

    // Print user-friendly error message
    eprintln!("Error: {}", error);

    // In debug mode, also print the error chain
    #[cfg(debug_assertions)]
    {
        if let Some(source) = error.source() {
            eprintln!("\nCaused by:");
            let mut current = source;
            let mut depth = 0;
            loop {
                eprintln!("  {}: {}", depth, current);
                match current.source() {
                    Some(err) => current = err,
                    None => break,
                }
                depth += 1;
            }
        }
    }

    // Cleanup resources before exit
    if let Err(cleanup_error) = cleanup_plugins() {
        eprintln!("Warning: Failed to cleanup plugins: {}", cleanup_error);
    }

    // Exit with appropriate code
    let exit_code = ExitCode::from(error);
    process::exit(exit_code as i32);
}