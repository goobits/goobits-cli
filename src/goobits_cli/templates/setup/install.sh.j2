validate_pipx() {
    if [[ "$PIPX_AVAILABLE" != "true" ]]; then
        log_warning "pipx is not installed. Installing pipx is recommended for isolated Python applications."
        log_info "You can install pipx with: python3 -m pip install --user pipx"
        log_info "Or on macOS with Homebrew: brew install pipx"
        return 1
    fi
    
    log_success "pipx is available at $PIPX_PATH"
    return 0
}

# Installation functions
install_package() {
    local install_dev="$1"
    
    if [[ "$PIPX_AVAILABLE" == "true" ]]; then
        install_with_pipx "$install_dev"
    else
        install_with_pip "$install_dev"
    fi
}

install_with_pipx() {
    local install_dev="$1"
    
    if [[ "$install_dev" == "true" ]]; then
        log_info "Installing $DISPLAY_NAME in development mode with pipx..."
        (cd "$PROJECT_DIR" && pipx install --editable "$DEVELOPMENT_PATH" --force) &
        show_spinner $!
        wait $!
        
        if [[ $? -eq 0 ]]; then
            log_success "Development installation completed!"
            show_dev_success_message
        else
            log_error "Development installation failed"
            return 1
        fi
    else
        log_info "Installing $DISPLAY_NAME with pipx..."
        pipx install "$PYPI_NAME" --force &
        show_spinner $!
        wait $!
        
        if [[ $? -eq 0 ]]; then
            log_success "Installation completed!"
            show_install_success_message
        else
            log_error "Installation failed"
            return 1
        fi
    fi
}

install_with_pip() {
    local install_dev="$1"
    
    log_warning "Using pip instead of pipx (not recommended for applications)"
    
    if [[ "$install_dev" == "true" ]]; then
        log_info "Installing $DISPLAY_NAME in development mode with pip..."
        (cd "$PROJECT_DIR" && python3 -m pip install --editable "$DEVELOPMENT_PATH" --user) &
        show_spinner $!
        wait $!
        
        if [[ $? -eq 0 ]]; then
            log_success "Development installation completed!"
            show_dev_success_message
        else
            log_error "Development installation failed"
            return 1
        fi
    else
        log_info "Installing $DISPLAY_NAME with pip..."
        python3 -m pip install "$PYPI_NAME" --user &
        show_spinner $!
        wait $!
        
        if [[ $? -eq 0 ]]; then
            log_success "Installation completed!"
            show_install_success_message
        else
            log_error "Installation failed"
            return 1
        fi
    fi
}

upgrade_package() {
    if [[ "$PIPX_AVAILABLE" == "true" ]]; then
        # Check if package is installed via pipx
        if pipx list | grep -q "$PACKAGE_NAME"; then
            # Check if it's a local/development installation by looking at the package_or_url
            local package_info=$(pipx list --json 2>/dev/null)
            if echo "$package_info" | python3 -c "
import sys, json
try:
    data = json.load(sys.stdin)
    pkg_data = data.get('venvs', {}).get('$PACKAGE_NAME', {})
    pkg_url = pkg_data.get('metadata', {}).get('main_package', {}).get('package_or_url', '')
    # Check if it's a local path (not from PyPI)
    if pkg_url and not pkg_url.startswith('$PACKAGE_NAME') and '/' in pkg_url:
        sys.exit(0)  # It's a local installation
    else:
        sys.exit(1)  # It's from PyPI
except:
    sys.exit(1)
" 2>/dev/null; then
                if [[ "$TREE_MODE" == "true" ]]; then
                    tree_sub_node "info" "Detected local/development installation"
                    tree_sub_node "info" "Reinstalling from local directory..."
                else
                    log_info "Detected local/development installation."
                    log_info "Reinstalling from local directory to update dependencies..."
                fi
                
                # Capture output for tree mode
                local output
                if [[ "$TREE_MODE" == "true" ]]; then
                    output=$(pipx install --force --editable "$PROJECT_DIR" 2>&1)
                    local exit_code=$?
                    
                    # Parse output for version info
                    local version_info=$(echo "$output" | grep -E '(already at latest|installed|upgraded)' | head -1)
                    if [[ -n "$version_info" ]]; then
                        tree_sub_node "success" "$version_info" "true"
                    else
                        tree_sub_node "success" "Reinstalled successfully" "true"
                    fi
                else
                    pipx install --force --editable "$PROJECT_DIR" &
                    show_spinner $!
                    wait $!
                    local exit_code=$?
                fi
            else
                # Regular PyPI installation
                if [[ "$TREE_MODE" == "true" ]]; then
                    # Capture pipx upgrade output to parse version info
                    local output
                    output=$(pipx upgrade "$PACKAGE_NAME" 2>&1)
                    local exit_code=$?
                    
                    # Parse the output to extract version information
                    local version_info=$(echo "$output" | grep -E '(already at latest version|upgraded|installed)' | head -1)
                    if [[ -n "$version_info" ]]; then
                        # Clean up the version info message and truncate if too long
                        version_info=$(echo "$version_info" | sed 's/^[[:space:]]*//' | sed 's/[[:space:]]*$//' | cut -c1-50)
                        tree_sub_node "success" "$version_info" "true"
                    else
                        tree_sub_node "success" "Upgrade completed" "true"
                    fi
                else
                    log_info "Upgrading $DISPLAY_NAME with pipx..."
                    pipx upgrade "$PACKAGE_NAME" &
                    show_spinner $!
                    wait $!
                    local exit_code=$?
                fi
            fi
        else
            if [[ "$TREE_MODE" == "true" ]]; then
                tree_sub_node "error" "Package '$PACKAGE_NAME' not found in pipx installations" "true"
            else
                log_error "Package '$PACKAGE_NAME' not found in pipx installations."
                log_error "Please install first with: $0 install"
            fi
            return 1
        fi
    else
        if [[ "$TREE_MODE" == "true" ]]; then
            local output
            output=$(python3 -m pip install --upgrade "$PYPI_NAME" --user 2>&1)
            local exit_code=$?
            
            # Parse pip output for version info
            local version_info=$(echo "$output" | grep -E '(already satisfied|successfully installed)' | head -1)
            if [[ -n "$version_info" ]]; then
                tree_sub_node "success" "$(echo "$version_info" | sed 's/^[[:space:]]*//')" "true"
            else
                tree_sub_node "success" "Upgrade completed" "true"
            fi
        else
            log_info "Upgrading $DISPLAY_NAME with pip..."
            python3 -m pip install --upgrade "$PYPI_NAME" --user &
            show_spinner $!
            wait $!
            local exit_code=$?
        fi
    fi
    
    if [[ ${exit_code:-$?} -eq 0 ]]; then
        if [[ "$TREE_MODE" != "true" ]]; then
            log_success "Upgrade completed!"
        fi
        show_upgrade_success_message
    else
        if [[ "$TREE_MODE" == "true" ]]; then
            tree_sub_node "error" "Upgrade failed" "true"
        else
            log_error "Upgrade failed"
        fi
        return 1
    fi
}

uninstall_package() {
    if [[ "$PIPX_AVAILABLE" == "true" ]]; then
        log_info "Uninstalling $DISPLAY_NAME with pipx..."
        pipx uninstall "$PYPI_NAME" &
        show_spinner $!
        wait $!
    else
        log_info "Uninstalling $DISPLAY_NAME with pip..."
        python3 -m pip uninstall "$PYPI_NAME" -y &
        show_spinner $!
        wait $!
    fi
    
    if [[ $? -eq 0 ]]; then
        log_success "Uninstall completed!"
        show_uninstall_success_message
    else
        log_error "Uninstall failed"
        return 1
    fi
}

# Message display functions
show_install_success_message() {
    echo
    echo "{{ messages.install_success | default('Installation completed successfully!') }}"
    echo
}

show_dev_success_message() {
    echo
    echo "{{ messages.install_dev_success | default('Development installation completed successfully!') }}"
    echo
}

show_upgrade_success_message() {
    echo
    echo "{{ messages.upgrade_success | default('Upgrade completed successfully!') }}"
    echo
}

show_uninstall_success_message() {
    echo
    echo "{{ messages.uninstall_success | default('Uninstall completed successfully!') }}"
    echo
}

# Shell integration
setup_shell_integration() {
    if [[ "$SHELL_INTEGRATION" != "true" ]]; then
        return 0
    fi
    
    log_info "Setting up shell integration..."
    
    # Add alias to shell configuration files
    local shell_configs=("$HOME/.bashrc" "$HOME/.zshrc" "$HOME/.bash_profile" "$HOME/.profile")
    local alias_line="alias $SHELL_ALIAS='$COMMAND_NAME'"
    
    for config in "${shell_configs[@]}"; do
        if [[ -f "$config" ]] && ! grep -q "alias $SHELL_ALIAS=" "$config"; then
            echo "$alias_line" >> "$config"
            log_info "Added alias to $config"
        fi
    done
    
    log_success "Shell integration configured"
}