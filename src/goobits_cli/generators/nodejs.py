"""Node.js CLI generator implementation."""

import json
from pathlib import Path
from typing import List, Optional, Union, Dict
from jinja2 import Environment, FileSystemLoader, TemplateNotFound
import typer

from . import BaseGenerator
from ..schemas import ConfigSchema, GoobitsConfigSchema


class NodeJSGenerator(BaseGenerator):
    """CLI code generator for Node.js using Commander.js framework."""
    
    def __init__(self):
        """Initialize the Node.js generator with Jinja2 environment."""
        # Set up Jinja2 environment for Node.js templates
        template_dir = Path(__file__).parent.parent / "templates" / "nodejs"
        fallback_dir = Path(__file__).parent.parent / "templates"
        
        # Try nodejs subdirectory first, fallback to main templates
        if template_dir.exists():
            self.env = Environment(loader=FileSystemLoader([template_dir, fallback_dir]))
        else:
            # If nodejs subdirectory doesn't exist, use main templates dir
            self.env = Environment(loader=FileSystemLoader(fallback_dir))
            self.template_missing = True
        
        # Add custom filters (these may need Node.js specific versions later)
        def json_stringify(x):
            """Convert to JSON, handling Pydantic models."""
            if hasattr(x, 'model_dump'):
                return json.dumps(x.model_dump(), indent=2)
            elif hasattr(x, 'dict'):
                return json.dumps(x.dict(), indent=2)
            else:
                return json.dumps(x, indent=2)
        
        self.env.filters['json_stringify'] = json_stringify
        self.env.filters['escape_backticks'] = lambda x: x.replace('`', '\\`')
    
    def generate(self, config: Union[ConfigSchema, GoobitsConfigSchema], 
                 config_filename: str, version: Optional[str] = None) -> str:
        """
        Generate Node.js CLI code from configuration.
        
        Args:
            config: The configuration object
            config_filename: Name of the configuration file
            version: Optional version string
            
        Returns:
            Generated Node.js CLI code
        """
        # Extract metadata using base class helper
        metadata = self._extract_config_metadata(config)
        cli_config = metadata['cli_config']
        
        # Validate configuration
        if hasattr(config, 'package_name'):  # GoobitsConfigSchema
            if not cli_config:
                raise ValueError("No CLI configuration found")
        
        # Prepare context for template rendering
        context = {
            'cli': cli_config,
            'file_name': config_filename,
            'package_name': metadata['package_name'],
            'command_name': metadata['command_name'],
            'display_name': metadata['display_name'],
            'description': getattr(config, 'description', cli_config.description if cli_config else ''),
            'version': version or (cli_config.version if cli_config and hasattr(cli_config, 'version') else '1.0.0'),
            'installation': metadata['installation'],
            'hooks_path': metadata['hooks_path'],
        }
        
        # Try to load Node.js specific template
        try:
            template = self.env.get_template("index.js.j2")
            code = template.render(**context)
            return code
        except TemplateNotFound:
            # Provide helpful error message with template content
            return self._generate_fallback_code(context)
    
    def get_output_files(self) -> List[str]:
        """Return list of files this generator creates."""
        return [
            "index.js",
            "bin/cli.js",
            "package.json",
            "setup.sh",
            "scripts/postinstall.js",
            "lib/config.js",
            "README.md",
            ".gitignore"
        ]
    
    def get_default_output_path(self, package_name: str) -> str:
        """Get the default output path for Node.js CLI."""
        return "index.js"  # Main entry point for ES modules
    
    def _generate_fallback_code(self, context: dict) -> str:
        """Generate a basic Node.js CLI when templates are missing."""
        cli_config = context['cli']
        package_name = context['package_name'] or 'my-cli'
        command_name = context['command_name'] or package_name
        description = context['description'] or 'A CLI tool'
        version = context['version']
        
        # Generate a basic Commander.js CLI using ES modules
        code = f'''/**
 * Generated by goobits-cli
 * 
 * Note: Node.js templates are not yet installed.
 * This is a basic CLI structure. To get full functionality,
 * ensure Node.js templates are installed in:
 * src/goobits_cli/templates/nodejs/
 */

import {{ Command }} from 'commander';
import chalk from 'chalk';

const program = new Command();

program
  .name('{command_name}')
  .description('{description}')
  .version('{version}');

// Configuration from {context['file_name']}
const config = {json.dumps(cli_config.model_dump() if cli_config else {}, indent=2)};

'''
        
        # Add commands if available
        if cli_config and cli_config.commands:
            code += "// Commands\n"
            for cmd_name, cmd_data in cli_config.commands.items():
                code += f'''
program
  .command('{cmd_name}')
  .description('{cmd_data.desc}')'''
                
                # Add arguments
                if cmd_data.args:
                    for arg in cmd_data.args:
                        if arg.required:
                            arg_str = f'<{arg.name}>'
                        else:
                            arg_str = f'[{arg.name}]'
                        code += f'''
  .argument('{arg_str}', '{arg.desc}')'''
                
                # Add options
                if cmd_data.options:
                    for opt in cmd_data.options:
                        flags = f'-{opt.short}, --{opt.name}'
                        if opt.type != 'flag':
                            flags += f' <{opt.type}>'
                        code += f'''
  .option('{flags}', '{opt.desc}')'''
                
                code += f'''
  .action(('''
                if cmd_data.args:
                    code += ', '.join(arg.name for arg in cmd_data.args) + ', '
                code += f'''options) => {{
    console.log('Executing {cmd_name} command...');
    console.log('This is a placeholder. Implement your logic here.');
  }});
'''
        
        code += '''
// Main CLI function
export function cli() {
  program.parse(process.argv);
  
  // Show help if no command provided
  if (!process.argv.slice(2).length) {
    program.outputHelp();
  }
}

// Export for use as a module
export default cli;
'''
        
        return code
    
    
    
    def generate_all_files(self, config: Union[ConfigSchema, GoobitsConfigSchema], 
                          config_filename: str, version: Optional[str] = None) -> Dict[str, str]:
        """
        Generate all files needed for the Node.js CLI.
        
        Args:
            config: The configuration object
            config_filename: Name of the configuration file
            version: Optional version string
            
        Returns:
            Dictionary mapping file paths to their contents
        """
        # Extract metadata using base class helper
        metadata = self._extract_config_metadata(config)
        cli_config = metadata['cli_config']
        
        # Validate configuration
        if hasattr(config, 'package_name'):  # GoobitsConfigSchema
            if not cli_config:
                raise ValueError("No CLI configuration found")
        
        # Prepare context for template rendering
        context = {
            'cli': cli_config,
            'file_name': config_filename,
            'package_name': metadata['package_name'],
            'command_name': metadata['command_name'],
            'display_name': metadata['display_name'],
            'description': getattr(config, 'description', cli_config.description if cli_config else ''),
            'version': version or (cli_config.version if cli_config and hasattr(cli_config, 'version') else '1.0.0'),
            'installation': metadata['installation'],
            'hooks_path': metadata['hooks_path'],
        }
        
        files = {}
        
        # Generate main index.js file
        try:
            template = self.env.get_template("index.js.j2")
            files['index.js'] = template.render(**context)
        except TemplateNotFound:
            files['index.js'] = self._generate_fallback_code(context)
        
        # Generate bin/cli.js file
        try:
            template = self.env.get_template("bin/cli.js.j2")
            files['bin/cli.js'] = template.render(**context)
        except TemplateNotFound:
            # Fallback bin wrapper
            files['bin/cli.js'] = '''#!/usr/bin/env node
import { cli } from '../index.js';
cli();
'''
        
        # Generate package.json
        try:
            template = self.env.get_template("package.json.j2")
            files['package.json'] = template.render(**context)
        except TemplateNotFound:
            files['package.json'] = self._generate_package_json(context)
        
        # Generate setup script
        try:
            template = self.env.get_template("setup.sh.j2")
            files['setup.sh'] = template.render(**context)
        except TemplateNotFound:
            # Fallback to basic setup script
            files['setup.sh'] = f'''#!/bin/bash
echo "Setting up {context['display_name']}..."
npm install
chmod +x cli.js
echo "Setup complete!"
'''
        
        # Generate post-install script
        try:
            template = self.env.get_template("scripts/postinstall.js.j2")
            files['scripts/postinstall.js'] = template.render(**context)
        except TemplateNotFound:
            pass  # Post-install is optional
        
        # Generate config library
        try:
            template = self.env.get_template("lib/config.js.j2")
            files['lib/config.js'] = template.render(**context)
        except TemplateNotFound:
            pass  # Config library is optional
        
        # Generate README.md
        files['README.md'] = self._generate_readme(context)
        
        # Generate .gitignore
        files['.gitignore'] = self._generate_gitignore()
        
        return files
    
    def _generate_package_json(self, context: dict) -> str:
        """Generate package.json from context using template."""
        try:
            template = self.env.get_template("package.json.j2")
            return template.render(**context)
        except TemplateNotFound:
            # Fallback to basic package.json
            package_data = {
                "name": context['package_name'],
                "version": context['version'],
                "description": context['description'],
                "main": "index.js",
                "bin": {
                    context['command_name']: "./bin/cli.js"
                },
                "scripts": {
                    "test": "echo \"Error: no test specified\" && exit 1",
                    "build": "echo \"No build step required\"",
                    "start": "node index.js",
                    "postinstall": "node scripts/postinstall.js || true"
                },
                "keywords": ["cli"],
                "author": "",
                "license": "MIT",
                "type": "module",
                "dependencies": {
                    "commander": "^11.1.0",
                    "chalk": "^5.3.0"
                },
                "engines": {
                    "node": ">=14.0.0"
                }
            }
            
            # Add any npm packages from installation extras
            if context.get('installation') and hasattr(context['installation'], 'extras'):
                if hasattr(context['installation'].extras, 'npm'):
                    for package in context['installation'].extras.npm:
                        if '@' in package:
                            name, version = package.rsplit('@', 1)
                            package_data["dependencies"][name] = f"^{version}"
                        else:
                            package_data["dependencies"][package] = "latest"
        
        return json.dumps(package_data, indent=2)
    
    def _generate_readme(self, context: dict) -> str:
        """Generate README.md for the Node.js CLI."""
        return f"""# {context['display_name']}

{context['description']}

## Installation

### From npm (when published)
```bash
npm install -g {context['package_name']}
```

### For development
```bash
# Clone the repository
git clone <your-repo-url>
cd {context['package_name']}

# Install dependencies and link globally
npm install
npm link
```

## Usage

```bash
{context['command_name']} --help
```

## Commands

{self._generate_commands_documentation(context)}

## Configuration

Configuration is stored in:
- Linux/Unix: `~/.config/{context['package_name']}/config.json`
- macOS: `~/Library/Application Support/{context['package_name']}/config.json`
- Windows: `%APPDATA%\\{context['package_name']}\\config.json`

## Development

To run in development mode:
```bash
./setup.sh --dev
```

## License

MIT
"""
    
    def _generate_commands_documentation(self, context: dict) -> str:
        """Generate commands documentation for README."""
        cli_config = context.get('cli')
        if not cli_config or not hasattr(cli_config, 'commands'):
            return "No commands configured."
        
        commands_doc = []
        for cmd_name, cmd_data in cli_config.commands.items():
            cmd_desc = cmd_data.desc if hasattr(cmd_data, 'desc') else 'Command description'
            commands_doc.append(f"- `{cmd_name}` - {cmd_desc}")
            
            # Add subcommands if they exist
            if hasattr(cmd_data, 'subcommands') and cmd_data.subcommands:
                for sub_name, sub_data in cmd_data.subcommands.items():
                    sub_desc = sub_data.desc if hasattr(sub_data, 'desc') else 'Subcommand description'
                    commands_doc.append(f"  - `{cmd_name} {sub_name}` - {sub_desc}")
        
        return '\n'.join(commands_doc) if commands_doc else "No commands configured."
    
    def _generate_gitignore(self) -> str:
        """Generate .gitignore for Node.js project."""
        return """# Node.js
node_modules/
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.npm

# Environment variables
.env
.env.local
.env.development.local
.env.test.local
.env.production.local

# OS files
.DS_Store
Thumbs.db

# IDE files
.idea/
.vscode/
*.swp
*.swo

# Test coverage
coverage/
.nyc_output/

# Build outputs
dist/
build/

# Logs
logs/
*.log

# Config (keep local config private)
config.local.json
"""