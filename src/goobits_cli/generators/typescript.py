"""TypeScript CLI generator implementation."""

from pathlib import Path
from typing import Dict, List, Optional

from .nodejs import NodeJSGenerator
from ..schemas import ConfigSchema, GoobitsConfigSchema


class TypeScriptGenerator(NodeJSGenerator):
    """CLI code generator for TypeScript using Commander.js framework."""
    
    def __init__(self):
        """Initialize the TypeScript generator with TypeScript-specific templates."""
        super().__init__()
        
        # Override template directory to use TypeScript templates
        template_dir = Path(__file__).parent.parent / "templates" / "typescript"
        fallback_dir = Path(__file__).parent.parent / "templates"
        
        # Reinitialize environment with TypeScript templates
        from jinja2 import Environment, FileSystemLoader
        
        if template_dir.exists():
            self.env = Environment(loader=FileSystemLoader([template_dir, fallback_dir]))
            self.template_missing = False
        else:
            # If typescript subdirectory doesn't exist, fallback to nodejs templates
            nodejs_dir = Path(__file__).parent.parent / "templates" / "nodejs"
            if nodejs_dir.exists():
                self.env = Environment(loader=FileSystemLoader([nodejs_dir, fallback_dir]))
            else:
                self.env = Environment(loader=FileSystemLoader(fallback_dir))
            self.template_missing = True
        
        # Add TypeScript-specific filters
        self.env.filters['to_ts_type'] = self._to_typescript_type
        self.env.filters['json_stringify'] = lambda x: self._json_stringify(x)
        self.env.filters['escape_backticks'] = lambda x: x.replace('`', '\\`')
        self.env.filters['camelCase'] = self._to_camel_case
        self.env.filters['PascalCase'] = self._to_pascal_case
        self.env.filters['kebab-case'] = self._to_kebab_case
    
    def _to_typescript_type(self, python_type: str) -> str:
        """Convert Python type hints to TypeScript types."""
        type_map = {
            'str': 'string',
            'int': 'number',
            'float': 'number',
            'bool': 'boolean',
            'flag': 'boolean',
            'list': 'Array<any>',
            'dict': 'Record<string, any>',
            'any': 'any',
            'None': 'void',
        }
        return type_map.get(python_type, 'any')
    
    def _to_camel_case(self, text: str) -> str:
        """Convert text to camelCase."""
        if not text:
            return text
        # Split by various separators
        words = text.replace('-', '_').replace(' ', '_').split('_')
        # First word lowercase, rest title case
        return words[0].lower() + ''.join(word.capitalize() for word in words[1:])
    
    def _to_pascal_case(self, text: str) -> str:
        """Convert text to PascalCase."""
        if not text:
            return text
        # Split by various separators
        words = text.replace('-', '_').replace(' ', '_').split('_')
        # All words title case
        return ''.join(word.capitalize() for word in words)
    
    def _to_kebab_case(self, text: str) -> str:
        """Convert text to kebab-case."""
        if not text:
            return text
        # Replace underscores and spaces with hyphens, convert to lowercase
        return text.replace('_', '-').replace(' ', '-').lower()
    
    def get_output_files(self) -> List[str]:
        """Return list of files this generator creates."""
        files = super().get_output_files()
        # Add TypeScript-specific files
        files.extend([
            'tsconfig.json',
            '.eslintrc.json',
            '.prettierrc',
            'types/index.d.ts',
        ])
        # Update file extensions for TypeScript
        ts_files = []
        for file in files:
            if file.endswith('.js'):
                ts_files.append(file.replace('.js', '.ts'))
            else:
                ts_files.append(file)
        return ts_files
    
    def get_default_output_path(self, package_name: str) -> str:
        """Get the default output path for TypeScript projects."""
        return f"index.ts"
    
    def generate_all_files(self, config, config_filename: str, version: Optional[str] = None) -> Dict[str, str]:
        """Generate all files for a TypeScript CLI project."""
        files = {}
        
        # Prepare context for templates
        context = {
            'config': config,
            'cli': getattr(config, 'cli', None),
            'package_name': getattr(config, 'package_name', 'generated-cli'),
            'command_name': getattr(config, 'command_name', 'generated-cli'),
            'display_name': getattr(config, 'display_name', 'Generated CLI'),
            'description': getattr(config, 'description', 'A CLI generated by goobits'),
            'version': version or getattr(config, 'version', '1.0.0'),
            'file_name': config_filename,
            'installation': getattr(config, 'installation', None),
            'hooks_path': getattr(config, 'hooks_path', None),
            'dependencies': getattr(config, 'dependencies', None),
            'author': getattr(config, 'author', ''),
            'license': getattr(config, 'license', 'MIT'),
            'repository': getattr(config, 'repository', ''),
            'bugs_url': getattr(config, 'bugs_url', ''),
            'homepage': getattr(config, 'homepage', ''),
        }
        
        # Generate TypeScript source files
        try:
            template = self.env.get_template('index.ts.j2')
            files['index.ts'] = template.render(**context)
        except Exception:
            # Fallback if template missing
            files['index.ts'] = self._generate_fallback_typescript_code(context)
        
        try:
            template = self.env.get_template('bin/cli.ts.j2')
            files['bin/cli.ts'] = template.render(**context)
        except Exception:
            files['bin/cli.ts'] = '''#!/usr/bin/env node
import { cli } from '../index.js';
await cli();
'''
        
        try:
            template = self.env.get_template('package.json.j2')
            files['package.json'] = template.render(**context)
        except Exception:
            files['package.json'] = self._generate_typescript_package_json(context)
        
        try:
            template = self.env.get_template('tsconfig.json.j2')
            files['tsconfig.json'] = template.render(**context)
        except Exception:
            files['tsconfig.json'] = self._generate_tsconfig(context)
        
        try:
            template = self.env.get_template('setup.sh.j2')
            files['setup.sh'] = template.render(**context)
        except Exception:
            files['setup.sh'] = self._generate_typescript_setup_script(context)
        
        try:
            template = self.env.get_template('scripts/postinstall.js.j2')
            files['scripts/postinstall.js'] = template.render(**context)
        except Exception:
            files['scripts/postinstall.js'] = '''#!/usr/bin/env node
console.log("TypeScript CLI installed successfully!");
'''
        
        try:
            template = self.env.get_template('lib/config.ts.j2')
            files['lib/config.ts'] = template.render(**context)
        except Exception:
            files['lib/config.ts'] = self._generate_typescript_config_lib(context)
        
        # Generate ESLint configuration
        files['.eslintrc.json'] = self._generate_eslint_config()
        
        # Generate Prettier configuration
        files['.prettierrc'] = self._generate_prettier_config()
        
        # Generate type definitions
        files['types/index.d.ts'] = self._generate_type_definitions(config)
        
        # Generate README
        files['README.md'] = self._generate_readme(config, is_typescript=True)
        
        # Generate .gitignore
        files['.gitignore'] = self._generate_gitignore(is_typescript=True)
        
        # Generate test files for each command
        if hasattr(config, 'cli') and config.cli and hasattr(config.cli, 'commands'):
            for cmd_name, cmd_data in config.cli.commands.items():
                test_file = f'test/commands/{cmd_name}.test.ts'
                files[test_file] = self._render_command_test(cmd_name, cmd_data, config, config_filename)
        
        # Make executable files executable
        files['__executable__'] = ['bin/cli.ts', 'setup.sh']
        
        return files
    
    def _generate_eslint_config(self) -> str:
        """Generate ESLint configuration for TypeScript."""
        return '''{
  "parser": "@typescript-eslint/parser",
  "extends": [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended"
  ],
  "plugins": ["@typescript-eslint"],
  "env": {
    "node": true,
    "es2022": true
  },
  "parserOptions": {
    "ecmaVersion": 2022,
    "sourceType": "module",
    "project": "./tsconfig.json"
  },
  "rules": {
    "@typescript-eslint/explicit-function-return-type": "warn",
    "@typescript-eslint/no-explicit-any": "warn",
    "@typescript-eslint/no-unused-vars": ["error", { "argsIgnorePattern": "^_" }],
    "no-console": ["warn", { "allow": ["warn", "error", "debug"] }]
  }
}'''
    
    def _generate_prettier_config(self) -> str:
        """Generate Prettier configuration."""
        return '''{
  "semi": true,
  "trailingComma": "es5",
  "singleQuote": true,
  "printWidth": 100,
  "tabWidth": 2,
  "useTabs": false
}'''
    
    def _generate_type_definitions(self, config) -> str:
        """Generate TypeScript type definitions."""
        return '''/**
 * Type definitions for CLI hooks and extensions
 */

export interface CommandArgs {
  commandName: string;
  [key: string]: any;
}

export interface CommandHook {
  (args: CommandArgs): Promise<void> | void;
}

export interface ManagedCommand {
  execute(args: CommandArgs): Promise<any>;
  start?(args: CommandArgs): Promise<void>;
  stop?(args: CommandArgs): Promise<void>;
  restart?(args: CommandArgs): Promise<void>;
  status?(args: CommandArgs): Promise<void>;
}

export interface AppHooks {
  [key: string]: CommandHook | ManagedCommand;
}

declare module 'app_hooks' {
  const hooks: AppHooks;
  export = hooks;
}'''
    
    def _generate_gitignore(self, is_typescript: bool = False) -> str:
        """Generate .gitignore file with TypeScript-specific patterns."""
        base_gitignore = super()._generate_gitignore()
        if is_typescript:
            typescript_ignores = '''
# TypeScript
dist/
*.tsbuildinfo
.eslintcache

# TypeScript test coverage
coverage/
.nyc_output/
'''
            return base_gitignore + typescript_ignores
        return base_gitignore
    
    def _generate_readme(self, config, is_typescript: bool = False) -> str:
        """Generate README with TypeScript-specific instructions."""
        # Convert config to dict format expected by parent
        context = {
            'package_name': getattr(config, 'package_name', 'generated-cli'),
            'command_name': getattr(config, 'command_name', 'generated-cli'),
            'display_name': getattr(config, 'display_name', 'Generated CLI'),
            'description': getattr(config, 'description', 'A CLI generated by goobits'),
        }
        readme = super()._generate_readme(context)
        
        if is_typescript:
            # Replace JavaScript references with TypeScript
            readme = readme.replace('JavaScript', 'TypeScript')
            readme = readme.replace('.js', '.ts')
            readme = readme.replace('node index.js', 'npm start')
            
            # Add TypeScript-specific sections
            typescript_section = '''
## Development

This CLI is written in TypeScript. To work on the source code:

1. Install dependencies: `npm install`
2. Build the project: `npm run build`
3. Run in development mode: `npm run dev`
4. Run tests: `npm test`
5. Type check: `npm run typecheck`
6. Lint: `npm run lint`
7. Format code: `npm run format`

The compiled JavaScript files are in the `dist/` directory.
'''
            # Insert before the License section if it exists
            if '## License' in readme:
                readme = readme.replace('## License', typescript_section + '\n## License')
            else:
                readme += typescript_section
        
        return readme
    
    def _generate_fallback_typescript_code(self, context: dict) -> str:
        """Generate fallback TypeScript code when templates are missing."""
        return '''/**
 * Auto-generated TypeScript CLI
 */

import { Command } from 'commander';

const program: Command = new Command();

program
  .name('{}')
  .description('{}')
  .version('{}');

program.parse(process.argv);

export default program;
'''.format(
    context.get('command_name', 'cli'),
    context.get('description', 'A CLI tool'),
    context.get('version', '1.0.0')
)
    
    def _generate_typescript_package_json(self, context: dict) -> str:
        """Generate TypeScript package.json when template is missing."""
        import json
        package_json = {
            "name": context.get('package_name', 'generated-cli'),
            "version": context.get('version', '1.0.0'),
            "description": context.get('description', 'A CLI tool'),
            "main": "dist/index.js",
            "types": "dist/index.d.ts",
            "bin": {
                context.get('command_name', 'cli'): "./dist/bin/cli.js"
            },
            "scripts": {
                "build": "tsc",
                "start": "ts-node index.ts",
                "test": "node --loader ts-node/esm --test test/**/*.test.ts"
            },
            "dependencies": {
                "commander": "^11.1.0",
                "chalk": "^5.3.0"
            },
            "devDependencies": {
                "typescript": "^5.3.0",
                "@types/node": "^20.0.0",
                "ts-node": "^10.9.0"
            },
            "type": "module"
        }
        return json.dumps(package_json, indent=2)
    
    def _generate_tsconfig(self, context: dict) -> str:
        """Generate tsconfig.json when template is missing."""
        import json
        tsconfig = {
            "compilerOptions": {
                "target": "ES2022",
                "module": "NodeNext",
                "moduleResolution": "NodeNext",
                "outDir": "./dist",
                "strict": True,
                "esModuleInterop": True,
                "skipLibCheck": True
            },
            "include": ["index.ts", "bin/**/*.ts", "lib/**/*.ts"],
            "exclude": ["node_modules", "dist"]
        }
        return json.dumps(tsconfig, indent=2)
    
    def _generate_typescript_setup_script(self, context: dict) -> str:
        """Generate TypeScript setup script when template is missing."""
        return '''#!/bin/bash
echo "Setting up TypeScript CLI..."
npm install
npm run build
echo "TypeScript CLI setup complete!"
'''
    
    def _generate_typescript_config_lib(self, context: dict) -> str:
        """Generate TypeScript config library when template is missing."""
        return '''/**
 * Configuration management for TypeScript CLI
 */

export interface Config {
  [key: string]: any;
}

export function loadConfig(): Config {
  return {};
}
'''
    
    def _render_command_test(self, cmd_name: str, cmd_data: dict, config, config_filename: str) -> str:
        """Render a test file for a specific command."""
        try:
            template = self.env.get_template('test/commands/command.test.ts.j2')
            return template.render(
                cmd_name=cmd_name,
                cmd_data=cmd_data,
                config=config,
                cli=getattr(config, 'cli', None),
                package_name=getattr(config, 'package_name', 'generated-cli'),
                command_name=getattr(config, 'command_name', 'generated-cli'),
                display_name=getattr(config, 'display_name', 'Generated CLI'),
                file_name=config_filename,
            )
        except Exception:
            # Fallback to basic test if template is missing
            return f'''import {{ test }} from 'node:test';
import assert from 'node:assert';

test('{cmd_name} command', async () => {{
  // TODO: Implement test for {cmd_name} command
  assert.ok(true, 'Test not implemented yet');
}});
'''