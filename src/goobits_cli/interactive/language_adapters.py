"""
Language-Specific Interactive Adapters
======================================

This module contains the language-specific code generators for interactive mode,
extracted from the interactive_mode.j2 template.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List
from .interactive_framework import InteractiveConfig, REPLMode


class InteractiveAdapter(ABC):
    """Abstract base class for language-specific interactive adapters."""
    
    @abstractmethod
    def generate_code(self, config: InteractiveConfig) -> str:
        """Generate language-specific interactive mode code."""
        pass
    
    @abstractmethod
    def get_import_statements(self, config: InteractiveConfig) -> str:
        """Generate import statements for interactive mode."""
        pass
    
    @abstractmethod
    def get_repl_class(self, config: InteractiveConfig) -> str:
        """Generate REPL class implementation."""
        pass
    
    @abstractmethod
    def get_runner_function(self, config: InteractiveConfig) -> str:
        """Generate interactive mode runner function."""
        pass


class PythonInteractiveAdapter(InteractiveAdapter):
    """
    Python interactive adapter extracted from lines 27-363 and 1886-2013 of interactive_mode.j2.
    
    Generates Python interactive mode using cmd.Cmd base class with enhanced REPL features.
    """
    
    def generate_code(self, config: InteractiveConfig) -> str:
        """Generate complete Python interactive mode implementation."""
        
        imports = self.get_import_statements(config)
        repl_class = self.get_repl_class(config)
        runner_function = self.get_runner_function(config)
        
        return f'''#!/usr/bin/env python3
"""
Enhanced Interactive Mode for {config.project_name}

This module provides interactive REPL functionality with features:
{self._format_feature_list(config)}

Generated by Goobits Interactive Framework v3.0.1
"""

{imports}

{repl_class}

{runner_function}'''
    
    def get_import_statements(self, config: InteractiveConfig) -> str:
        """Generate Python import statements."""
        imports = [
            "import sys",
            "import os",
            "import json",
            "import cmd",
            "import inspect",
            "from typing import Dict, Any, Optional, List"
        ]
        
        # Add feature-specific imports
        if config.features.repl_enabled:
            imports.extend([
                "try:",
                "    from .repl_base import BasicREPL, SessionREPL, VariableREPL, PipelineREPL",
                "    REPL_AVAILABLE = True"
            ])
            
            if config.features.session_persistence:
                imports.append("    SESSION_AVAILABLE = True")
            
            if config.features.variables:
                imports.append("    VARIABLES_AVAILABLE = True")
                
            if config.features.pipelines:
                imports.append("    PIPELINES_AVAILABLE = True")
                
            imports.extend([
                "except ImportError:",
                "    # Fallback to basic interactive mode",
                "    REPL_AVAILABLE = False"
            ])
            
            if config.features.session_persistence:
                imports.append("    SESSION_AVAILABLE = False")
            
            if config.features.variables:
                imports.append("    VARIABLES_AVAILABLE = False")
                
            if config.features.pipelines:
                imports.append("    PIPELINES_AVAILABLE = False")
        
        # CLI and hooks imports
        imports.extend([
            "",
            "try:",
            f"    from .{config.command_name.replace('-', '_')}_cli import cli",
            "    from .hooks import *  # Import all hook functions",
            "except ImportError:",
            "    # Fallback imports",
            f"    from {config.command_name.replace('-', '_')}_cli import cli",
            "    try:",
            "        from hooks import *",
            "    except ImportError:",
            "        pass"
        ])
        
        return "\\n".join(imports)
    
    def get_repl_class(self, config: InteractiveConfig) -> str:
        """Generate Python REPL class."""
        class_name = self._get_class_name(config.project_name)
        
        if config.features.repl_enabled:
            base_class = self._get_python_base_class(config)
            return self._get_enhanced_repl_class(config, class_name, base_class)
        else:
            return self._get_fallback_repl_class(config, class_name)
    
    def get_runner_function(self, config: InteractiveConfig) -> str:
        """Generate Python runner function."""
        class_name = self._get_class_name(config.project_name)
        
        if config.features.repl_enabled:
            return f'''def run_enhanced_repl():
    """Run the enhanced REPL for {config.project_name}."""
    try:
        repl = {class_name}()
        repl.cmdloop()
    except KeyboardInterrupt:
        print("\\\\nExiting {config.project_name} REPL...")
        sys.exit(0)
    except Exception as e:
        print(f"Error in REPL: {{e}}")
        sys.exit(1)


def run_interactive():
    """Main entry point for interactive mode."""
    if REPL_AVAILABLE:
        run_enhanced_repl()
    else:
        # Fallback to basic interactive mode
        repl = {class_name}()
        repl.cmdloop()


if __name__ == "__main__":
    run_interactive()'''
        else:
            return f'''def run_interactive():
    """Run basic interactive mode for {config.project_name}."""
    try:
        repl = {class_name}()
        repl.cmdloop()
    except KeyboardInterrupt:
        print("\\\\nExiting {config.project_name} interactive mode...")
        sys.exit(0)
    except Exception as e:
        print(f"Error in interactive mode: {{e}}")
        sys.exit(1)


if __name__ == "__main__":
    run_interactive()'''
    
    def _get_class_name(self, project_name: str) -> str:
        """Generate Python class name from project name."""
        return project_name.replace('-', '').replace(' ', '').replace('_', '').title() + 'REPL'
    
    def _get_python_base_class(self, config: InteractiveConfig) -> str:
        """Determine Python base class based on features."""
        if config.features.pipelines:
            return "PipelineREPL if PIPELINES_AVAILABLE else (VariableREPL if VARIABLES_AVAILABLE else (SessionREPL if SESSION_AVAILABLE else (BasicREPL if REPL_AVAILABLE else object)))"
        elif config.features.variables:
            return "VariableREPL if VARIABLES_AVAILABLE else (SessionREPL if SESSION_AVAILABLE else (BasicREPL if REPL_AVAILABLE else object))"
        elif config.features.session_persistence:
            return "SessionREPL if SESSION_AVAILABLE else (BasicREPL if REPL_AVAILABLE else object)"
        else:
            return "BasicREPL if REPL_AVAILABLE else object"
    
    def _get_enhanced_repl_class(self, config: InteractiveConfig, class_name: str, base_class: str) -> str:
        """Generate enhanced REPL class with features."""
        feature_list_str = "', '".join(self._get_feature_names(config))
        
        return f'''class {class_name}({base_class}):
    """Enhanced REPL for {config.project_name} with advanced features."""
    
    def __init__(self, cli_config=None, smart_completion_enabled=True):
        """Initialize the enhanced REPL."""
        if REPL_AVAILABLE:
            {self._get_feature_init_code(config)}
            
            super().__init__(
                cli_config or {{}},
                {self._get_super_init_args(config)}
                smart_completion_enabled=smart_completion_enabled
            )
        else:
            super().__init__()
        
        feature_list = []
        if smart_completion_enabled:
            feature_list.append("Smart completion")
        {self._get_feature_display_code(config)}
        
        self.intro = (
            f"Welcome to {config.project_name} Enhanced REPL mode.\\\\n"
            f"Features: {{', '.join(feature_list)}}\\\\n"
            f"Type 'help' for commands, 'exit' to quit."
        )
    
    def handle_cli_command(self, command, args):
        """Handle CLI command execution with proper hook integration."""
        if not REPL_AVAILABLE:
            return self._fallback_handle_command(command, args)
        
        hook_name = command.get('hook_name', f"on_{{command['name'].replace('-', '_')}}")
        
        # Check if hook function exists in global scope
        if hook_name in globals():
            hook_func = globals()[hook_name]
            try:
                sig = inspect.signature(hook_func)
                
                # Try to bind arguments to function signature
                if len(sig.parameters) == 0:
                    result = hook_func()
                elif len(args) == 0:
                    result = hook_func()
                else:
                    try:
                        bound_args = sig.bind(*args)
                        bound_args.apply_defaults()
                        result = hook_func(*bound_args.args, **bound_args.kwargs)
                    except TypeError:
                        result = hook_func(args)
                
                if result is not None:
                    print(result)
                
            except Exception as e:
                print(f"Error executing {{hook_name}}: {{e}}")
                print(f"Arguments provided: {{args}}")
        else:
            print(f"Command '{{command['name']}}' executed successfully")
            print(f"To implement custom behavior, add '{{hook_name}}' function to hooks.py")
    
    def _fallback_handle_command(self, command, args):
        """Fallback command handling for basic mode."""
        print(f"Executing {{command['name']}} with args: {{args}}")
        print(f"To implement custom behavior, add hook function to hooks.py")'''
    
    def _get_fallback_repl_class(self, config: InteractiveConfig, class_name: str) -> str:
        """Generate fallback REPL class using cmd.Cmd."""
        commands_code = []
        for cmd in config.cli_commands:
            cmd_method = f"do_{cmd['name'].replace('-', '_')}"
            commands_code.append(f'''    def {cmd_method}(self, args):
        """Execute {cmd['name']} command."""
        args_list = args.split() if args else []
        print(f"Executing {cmd['name']} with args: {{args_list}}")
        # To implement custom behavior, add '{cmd['hook_name']}' function to hooks.py''')
        
        return f'''class {class_name}(cmd.Cmd):
    """Basic interactive mode for {config.project_name}."""
    
    intro = "Welcome to {config.project_name} interactive mode. Type 'help' for commands, 'exit' to quit."
    prompt = "{config.command_name}> "
    
    def __init__(self):
        """Initialize basic interactive mode."""
        super().__init__()
    
{chr(10).join(commands_code)}
    
    def do_exit(self, args):
        """Exit the interactive mode."""
        print("Goodbye!")
        return True
    
    def do_quit(self, args):
        """Exit the interactive mode."""
        return self.do_exit(args)'''
    
    def _get_feature_init_code(self, config: InteractiveConfig) -> str:
        """Generate feature initialization code."""
        init_code = []
        
        if config.features.pipelines:
            init_code.append(f'''pipeline_config = {{
                'enabled': True,
                'pipeline_templates': {str(config.features.pipeline_templates).lower()},
                'timeout': {config.features.pipeline_timeout}
            }}''')
        
        if config.features.variables:
            init_code.append(f'''variable_config = {{
                'enabled': True,
                'substitution': {str(config.features.variable_expansion).lower()},
                'max_variables': {config.features.max_variables}
            }}''')
        
        if config.features.session_persistence:
            session_dir = f"'{config.features.session_directory}'" if config.features.session_directory else "None"
            init_code.append(f'''session_config = {{
                'auto_save': {str(config.features.auto_save).lower()},
                'max_sessions': {config.features.max_sessions},
                'session_directory': {session_dir},
                'auto_load_last': {str(config.features.auto_load_last).lower()},
                'max_history': {config.features.max_history}
            }}''')
        
        return "\\n            ".join(init_code)
    
    def _get_super_init_args(self, config: InteractiveConfig) -> str:
        """Generate super().__init__ arguments."""
        args = []
        
        if config.features.pipelines:
            args.append("pipeline_config=pipeline_config")
        
        if config.features.variables:
            args.append("variable_config=variable_config")
        
        if config.features.session_persistence:
            args.append("session_config=session_config")
        
        if args:
            return ", ".join(args) + ",\\n                "
        return ""
    
    def _get_feature_display_code(self, config: InteractiveConfig) -> str:
        """Generate feature display code."""
        display_code = []
        
        if config.features.pipelines:
            display_code.append('        if PIPELINES_AVAILABLE:\\n            feature_list.append("Pipeline operations")')
        
        if config.features.variables:
            display_code.append('        if VARIABLES_AVAILABLE:\\n            feature_list.append("Variable management")')
        
        if config.features.session_persistence:
            display_code.append('        if SESSION_AVAILABLE:\\n            feature_list.append("Session persistence")')
        
        return "\\n".join(display_code)
    
    def _get_feature_names(self, config: InteractiveConfig) -> List[str]:
        """Get list of feature names for display."""
        features = []
        if config.features.smart_completion:
            features.append("Smart completion")
        if config.features.pipelines:
            features.append("Pipeline operations")
        if config.features.variables:
            features.append("Variable management")
        if config.features.session_persistence:
            features.append("Session persistence")
        return features
    
    def _format_feature_list(self, config: InteractiveConfig) -> str:
        """Format feature list for documentation."""
        features = self._get_feature_names(config)
        if features:
            return "\\n".join(f"- {feature}" for feature in features)
        return "- Basic interactive mode"


class NodeJSInteractiveAdapter(InteractiveAdapter):
    """
    Node.js interactive adapter extracted from lines 364-1404 of interactive_mode.j2.
    
    Generates Node.js interactive mode using readline interface with async/await support.
    """
    
    def generate_code(self, config: InteractiveConfig) -> str:
        """Generate complete Node.js interactive mode implementation."""
        
        imports = self.get_import_statements(config)
        repl_class = self.get_repl_class(config)
        runner_function = self.get_runner_function(config)
        
        return f'''/**
 * Enhanced Interactive Mode for {config.project_name}
 * Generated by Goobits Interactive Framework v3.0.1
 */

{imports}

{repl_class}

{runner_function}'''
    
    def get_import_statements(self, config: InteractiveConfig) -> str:
        """Generate Node.js import statements."""
        return '''const readline = require('readline');
const { EventEmitter } = require('events');

// Try to load enhanced REPL features
let REPL_AVAILABLE = false;
let SESSION_AVAILABLE = false;
let VARIABLES_AVAILABLE = false;
let PIPELINES_AVAILABLE = false;

try {
    const { BasicREPL, SessionREPL, VariableREPL, PipelineREPL } = require('./repl-base');
    REPL_AVAILABLE = true;
    SESSION_AVAILABLE = true;
    VARIABLES_AVAILABLE = true;
    PIPELINES_AVAILABLE = true;
} catch (error) {
    // Fallback to basic interactive mode
    console.warn('Enhanced REPL features not available, using basic mode');
}

// Load CLI and hooks
let cli, hooks = {};
try {
    cli = require('./cli');
    hooks = require('./hooks');
} catch (error) {
    console.warn('Could not load CLI or hooks:', error.message);
}'''
    
    def get_repl_class(self, config: InteractiveConfig) -> str:
        """Generate Node.js REPL class."""
        class_name = self._get_class_name(config.project_name)
        
        return f'''class {class_name} extends EventEmitter {{
    constructor(options = {{}}) {{
        super();
        this.options = {{
            smartCompletion: true,
            ...options
        }};
        
        this.rl = readline.createInterface({{
            input: process.stdin,
            output: process.stdout,
            prompt: '{config.command_name}> ',
            completer: this.completer.bind(this)
        }});
        
        this.features = [];
        if (this.options.smartCompletion) {{
            this.features.push('Smart completion');
        }}
        
        {self._get_nodejs_feature_init(config)}
        
        this.setupEventHandlers();
    }}
    
    setupEventHandlers() {{
        this.rl.on('line', (input) => {{
            this.handleCommand(input.trim());
        }});
        
        this.rl.on('close', () => {{
            console.log('\\\\nGoodbye!');
            process.exit(0);
        }});
        
        process.on('SIGINT', () => {{
            console.log('\\\\nUse "exit" or "quit" to leave the REPL');
            this.rl.prompt();
        }});
    }}
    
    async handleCommand(input) {{
        if (!input) {{
            this.rl.prompt();
            return;
        }}
        
        const [command, ...args] = input.split(' ');
        
        // Handle built-in commands
        if (command === 'exit' || command === 'quit') {{
            this.rl.close();
            return;
        }}
        
        if (command === 'help') {{
            this.showHelp();
            this.rl.prompt();
            return;
        }}
        
        // Try to execute CLI command
        await this.executeCliCommand(command, args);
        this.rl.prompt();
    }}
    
    async executeCliCommand(command, args) {{
        const hookName = `on_${{command.replace(/-/g, '_')}}`;
        
        if (hooks[hookName] && typeof hooks[hookName] === 'function') {{
            try {{
                const result = await hooks[hookName](...args);
                if (result !== undefined) {{
                    console.log(result);
                }}
            }} catch (error) {{
                console.error(`Error executing ${{hookName}}:`, error.message);
            }}
        }} else {{
            console.log(`Command '${{command}}' executed successfully`);
            console.log(`To implement custom behavior, add '${{hookName}}' function to hooks.js`);
        }}
    }}
    
    completer(line) {{
        const completions = ['help', 'exit', 'quit'];
        
        // Add CLI commands if available
        if (cli && cli.commands) {{
            completions.push(...Object.keys(cli.commands));
        }}
        
        const hits = completions.filter((c) => c.startsWith(line));
        return [hits.length ? hits : completions, line];
    }}
    
    showHelp() {{
        console.log(`Welcome to {config.project_name} Interactive Mode`);
        console.log(`Features: ${{this.features.join(', ')}}`);
        console.log('');
        console.log('Available commands:');
        console.log('  help    - Show this help message');
        console.log('  exit    - Exit interactive mode');
        console.log('  quit    - Exit interactive mode');
        
        if (cli && cli.commands) {{
            Object.entries(cli.commands).forEach(([name, cmd]) => {{
                console.log(`  ${{name.padEnd(8)}} - ${{cmd.description || 'No description'}}`);
            }});
        }}
    }}
    
    start() {{
        console.log(`Welcome to {config.project_name} Interactive Mode`);
        console.log(`Features: ${{this.features.join(', ')}}`);
        console.log("Type 'help' for commands, 'exit' to quit.");
        this.rl.prompt();
    }}
}}'''
    
    def get_runner_function(self, config: InteractiveConfig) -> str:
        """Generate Node.js runner function."""
        class_name = self._get_class_name(config.project_name)
        
        return f'''function runInteractive() {{
    const repl = new {class_name}();
    repl.start();
}}

if (require.main === module) {{
    runInteractive();
}}

module.exports = {{ {class_name}, runInteractive }};'''
    
    def _get_class_name(self, project_name: str) -> str:
        """Generate Node.js class name from project name."""
        return project_name.replace('-', '').replace(' ', '').replace('_', '').title() + 'Interactive'
    
    def _get_nodejs_feature_init(self, config: InteractiveConfig) -> str:
        """Generate Node.js feature initialization code."""
        feature_code = []
        
        if config.features.session_persistence:
            feature_code.append("        if (SESSION_AVAILABLE) {\\n            this.features.push('Session persistence');\\n        }")
        
        if config.features.variables:
            feature_code.append("        if (VARIABLES_AVAILABLE) {\\n            this.features.push('Variable management');\\n        }")
        
        if config.features.pipelines:
            feature_code.append("        if (PIPELINES_AVAILABLE) {\\n            this.features.push('Pipeline operations');\\n        }")
        
        return "\\n".join(feature_code)


class TypeScriptInteractiveAdapter(InteractiveAdapter):
    """
    TypeScript interactive adapter extracted from lines 1405-1685 of interactive_mode.j2.
    
    Generates TypeScript interactive mode with proper type definitions and async support.
    """
    
    def generate_code(self, config: InteractiveConfig) -> str:
        """Generate complete TypeScript interactive mode implementation."""
        
        imports = self.get_import_statements(config)
        repl_class = self.get_repl_class(config)
        runner_function = self.get_runner_function(config)
        
        return f'''/**
 * Enhanced Interactive Mode for {config.project_name}
 * Generated by Goobits Interactive Framework v3.0.1
 */

{imports}

{repl_class}

{runner_function}'''
    
    def get_import_statements(self, config: InteractiveConfig) -> str:
        """Generate TypeScript import statements."""
        return '''import * as readline from 'readline';
import { EventEmitter } from 'events';

// Enhanced REPL feature interfaces
interface REPLOptions {
    smartCompletion?: boolean;
    sessionConfig?: SessionConfig;
    variableConfig?: VariableConfig;
    pipelineConfig?: PipelineConfig;
}

interface SessionConfig {
    autoSave?: boolean;
    maxSessions?: number;
    sessionDirectory?: string;
    autoLoadLast?: boolean;
    maxHistory?: number;
}

interface VariableConfig {
    substitution?: boolean;
    maxVariables?: number;
}

interface PipelineConfig {
    templates?: boolean;
    timeout?: number;
}

// Try to load enhanced REPL features
let REPL_AVAILABLE = false;
let SESSION_AVAILABLE = false;
let VARIABLES_AVAILABLE = false;
let PIPELINES_AVAILABLE = false;

try {
    const replBase = require('./repl-base');
    REPL_AVAILABLE = true;
    SESSION_AVAILABLE = true;
    VARIABLES_AVAILABLE = true;
    PIPELINES_AVAILABLE = true;
} catch (error) {
    console.warn('Enhanced REPL features not available, using basic mode');
}

// Load CLI and hooks
let cli: any;
let hooks: Record<string, Function> = {};
try {
    cli = require('./cli');
    hooks = require('./hooks');
} catch (error) {
    console.warn('Could not load CLI or hooks:', (error as Error).message);
}'''
    
    def get_repl_class(self, config: InteractiveConfig) -> str:
        """Generate TypeScript REPL class."""
        class_name = self._get_class_name(config.project_name)
        
        return f'''export class {class_name} extends EventEmitter {{
    private rl: readline.Interface;
    private options: REPLOptions;
    private features: string[];
    
    constructor(options: REPLOptions = {{}}) {{
        super();
        this.options = {{
            smartCompletion: true,
            ...options
        }};
        
        this.rl = readline.createInterface({{
            input: process.stdin,
            output: process.stdout,
            prompt: '{config.command_name}> ',
            completer: this.completer.bind(this)
        }});
        
        this.features = [];
        if (this.options.smartCompletion) {{
            this.features.push('Smart completion');
        }}
        
        {self._get_typescript_feature_init(config)}
        
        this.setupEventHandlers();
    }}
    
    private setupEventHandlers(): void {{
        this.rl.on('line', (input: string) => {{
            this.handleCommand(input.trim());
        }});
        
        this.rl.on('close', () => {{
            console.log('\\\\nGoodbye!');
            process.exit(0);
        }});
        
        process.on('SIGINT', () => {{
            console.log('\\\\nUse "exit" or "quit" to leave the REPL');
            this.rl.prompt();
        }});
    }}
    
    private async handleCommand(input: string): Promise<void> {{
        if (!input) {{
            this.rl.prompt();
            return;
        }}
        
        const [command, ...args] = input.split(' ');
        
        // Handle built-in commands
        if (command === 'exit' || command === 'quit') {{
            this.rl.close();
            return;
        }}
        
        if (command === 'help') {{
            this.showHelp();
            this.rl.prompt();
            return;
        }}
        
        // Try to execute CLI command
        await this.executeCliCommand(command, args);
        this.rl.prompt();
    }}
    
    private async executeCliCommand(command: string, args: string[]): Promise<void> {{
        const hookName = `on_${{command.replace(/-/g, '_')}}`;
        
        if (hooks[hookName] && typeof hooks[hookName] === 'function') {{
            try {{
                const result = await hooks[hookName](...args);
                if (result !== undefined) {{
                    console.log(result);
                }}
            }} catch (error) {{
                console.error(`Error executing ${{hookName}}:`, (error as Error).message);
            }}
        }} else {{
            console.log(`Command '${{command}}' executed successfully`);
            console.log(`To implement custom behavior, add '${{hookName}}' function to hooks.ts`);
        }}
    }}
    
    private completer(line: string): [string[], string] {{
        const completions = ['help', 'exit', 'quit'];
        
        // Add CLI commands if available
        if (cli?.commands) {{
            completions.push(...Object.keys(cli.commands));
        }}
        
        const hits = completions.filter((c) => c.startsWith(line));
        return [hits.length ? hits : completions, line];
    }}
    
    private showHelp(): void {{
        console.log(`Welcome to {config.project_name} Interactive Mode`);
        console.log(`Features: ${{this.features.join(', ')}}`);
        console.log('');
        console.log('Available commands:');
        console.log('  help    - Show this help message');
        console.log('  exit    - Exit interactive mode');
        console.log('  quit    - Exit interactive mode');
        
        if (cli?.commands) {{
            Object.entries(cli.commands).forEach(([name, cmd]: [string, any]) => {{
                console.log(`  ${{name.padEnd(8)}} - ${{cmd.description || 'No description'}}`);
            }});
        }}
    }}
    
    public start(): void {{
        console.log(`Welcome to {config.project_name} Interactive Mode`);
        console.log(`Features: ${{this.features.join(', ')}}`);
        console.log("Type 'help' for commands, 'exit' to quit.");
        this.rl.prompt();
    }}
}}'''
    
    def get_runner_function(self, config: InteractiveConfig) -> str:
        """Generate TypeScript runner function."""
        class_name = self._get_class_name(config.project_name)
        
        return f'''export function runInteractive(): void {{
    const repl = new {class_name}();
    repl.start();
}}

if (require.main === module) {{
    runInteractive();
}}'''
    
    def _get_class_name(self, project_name: str) -> str:
        """Generate TypeScript class name from project name."""
        return project_name.replace('-', '').replace(' ', '').replace('_', '').title() + 'Interactive'
    
    def _get_typescript_feature_init(self, config: InteractiveConfig) -> str:
        """Generate TypeScript feature initialization code."""
        feature_code = []
        
        if config.features.session_persistence:
            feature_code.append("        if (SESSION_AVAILABLE) {\\n            this.features.push('Session persistence');\\n        }")
        
        if config.features.variables:
            feature_code.append("        if (VARIABLES_AVAILABLE) {\\n            this.features.push('Variable management');\\n        }")
        
        if config.features.pipelines:
            feature_code.append("        if (PIPELINES_AVAILABLE) {\\n            this.features.push('Pipeline operations');\\n        }")
        
        return "\\n".join(feature_code)


class RustInteractiveAdapter(InteractiveAdapter):
    """
    Rust interactive adapter extracted from lines 1686-1885 of interactive_mode.j2.
    
    Generates Rust interactive mode using rustyline for REPL functionality.
    """
    
    def generate_code(self, config: InteractiveConfig) -> str:
        """Generate complete Rust interactive mode implementation."""
        
        imports = self.get_import_statements(config)
        repl_struct = self.get_repl_class(config)
        runner_function = self.get_runner_function(config)
        
        return f'''//! Enhanced Interactive Mode for {config.project_name}
//! Generated by Goobits Interactive Framework v3.0.1

{imports}

{repl_struct}

{runner_function}'''
    
    def get_import_statements(self, config: InteractiveConfig) -> str:
        """Generate Rust import statements."""
        return '''use std::collections::HashMap;
use std::io::{self, Write};

// Try to use enhanced REPL features
#[cfg(feature = "enhanced-repl")]
use repl_base::{BasicREPL, SessionREPL, VariableREPL, PipelineREPL};

// Rustyline for REPL functionality
#[cfg(feature = "rustyline")]
use rustyline::{Editor, Result as RustyResult};
#[cfg(feature = "rustyline")]
use rustyline::error::ReadlineError;

// CLI and hooks
use crate::cli::Cli;
use crate::hooks;'''
    
    def get_repl_class(self, config: InteractiveConfig) -> str:
        """Generate Rust REPL struct."""
        struct_name = self._get_struct_name(config.project_name)
        
        return f'''pub struct {struct_name} {{
    #[cfg(feature = "rustyline")]
    editor: Editor<()>,
    features: Vec<String>,
    prompt: String,
}}

impl {struct_name} {{
    pub fn new() -> Self {{
        #[cfg(feature = "rustyline")]
        let mut editor = Editor::<()>::new();
        
        let mut features = Vec::new();
        features.push("Basic interactive mode".to_string());
        
        {self._get_rust_feature_init(config)}
        
        Self {{
            #[cfg(feature = "rustyline")]
            editor,
            features,
            prompt: "{config.command_name}> ".to_string(),
        }}
    }}
    
    pub fn start(&mut self) -> Result<(), Box<dyn std::error::Error>> {{
        println!("Welcome to {config.project_name} Interactive Mode");
        println!("Features: {{}}", self.features.join(", "));
        println!("Type 'help' for commands, 'exit' to quit.");
        
        loop {{
            #[cfg(feature = "rustyline")]
            {{
                match self.editor.readline(&self.prompt) {{
                    Ok(line) => {{
                        let line = line.trim();
                        if line.is_empty() {{
                            continue;
                        }}
                        
                        self.editor.add_history_entry(line);
                        
                        if self.handle_command(line)? {{
                            break;
                        }}
                    }},
                    Err(ReadlineError::Interrupted) => {{
                        println!("Use 'exit' or 'quit' to leave the REPL");
                        continue;
                    }},
                    Err(ReadlineError::Eof) => {{
                        println!("Goodbye!");
                        break;
                    }},
                    Err(err) => {{
                        eprintln!("Error: {{}}", err);
                        break;
                    }}
                }}
            }}
            
            #[cfg(not(feature = "rustyline"))]
            {{
                print!("{{}}", self.prompt);
                io::stdout().flush()?;
                
                let mut input = String::new();
                io::stdin().read_line(&mut input)?;
                let input = input.trim();
                
                if input.is_empty() {{
                    continue;
                }}
                
                if self.handle_command(input)? {{
                    break;
                }}
            }}
        }}
        
        Ok(())
    }}
    
    fn handle_command(&mut self, input: &str) -> Result<bool, Box<dyn std::error::Error>> {{
        let mut parts = input.split_whitespace();
        let command = parts.next().unwrap_or("");
        let args: Vec<&str> = parts.collect();
        
        match command {{
            "exit" | "quit" => {{
                println!("Goodbye!");
                return Ok(true);
            }},
            "help" => {{
                self.show_help();
            }},
            _ => {{
                self.execute_cli_command(command, &args)?;
            }}
        }}
        
        Ok(false)
    }}
    
    fn execute_cli_command(&self, command: &str, args: &[&str]) -> Result<(), Box<dyn std::error::Error>> {{
        let hook_name = format!("on_{{}}", command.replace('-', "_"));
        
        // Try to execute hook function
        match hook_name.as_str() {{
            // Add specific hook matches here based on CLI commands
            _ => {{
                println!("Command '{{}}' executed successfully", command);
                println!("To implement custom behavior, add '{{}}' function to hooks.rs", hook_name);
            }}
        }}
        
        Ok(())
    }}
    
    fn show_help(&self) {{
        println!("Welcome to {config.project_name} Interactive Mode");
        println!("Features: {{}}", self.features.join(", "));
        println!();
        println!("Available commands:");
        println!("  help    - Show this help message");
        println!("  exit    - Exit interactive mode");
        println!("  quit    - Exit interactive mode");
        
        // Add CLI-specific commands here
        println!();
        println!("CLI commands will be available based on your configuration.");
    }}
}}

impl Default for {struct_name} {{
    fn default() -> Self {{
        Self::new()
    }}
}}'''
    
    def get_runner_function(self, config: InteractiveConfig) -> str:
        """Generate Rust runner function."""
        struct_name = self._get_struct_name(config.project_name)
        
        return f'''pub fn run_interactive() -> Result<(), Box<dyn std::error::Error>> {{
    let mut repl = {struct_name}::new();
    repl.start()
}}

#[cfg(feature = "binary")]
fn main() -> Result<(), Box<dyn std::error::Error>> {{
    run_interactive()
}}'''
    
    def _get_struct_name(self, project_name: str) -> str:
        """Generate Rust struct name from project name."""
        return project_name.replace('-', '').replace(' ', '').replace('_', '').title() + 'Interactive'
    
    def _get_rust_feature_init(self, config: InteractiveConfig) -> str:
        """Generate Rust feature initialization code."""
        feature_code = []
        
        if config.features.smart_completion:
            feature_code.append('        features.push("Smart completion".to_string());')
        
        if config.features.session_persistence:
            feature_code.append('        #[cfg(feature = "enhanced-repl")]\\n        features.push("Session persistence".to_string());')
        
        if config.features.variables:
            feature_code.append('        #[cfg(feature = "enhanced-repl")]\\n        features.push("Variable management".to_string());')
        
        if config.features.pipelines:
            feature_code.append('        #[cfg(feature = "enhanced-repl")]\\n        features.push("Pipeline operations".to_string());')
        
        return "\\n".join(feature_code)