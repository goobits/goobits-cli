"""
Language Adapters
================

Language-specific completion adapters extracted from completion templates.
Each adapter generates completion integration code for its target language.
"""

from abc import ABC, abstractmethod
from typing import Dict, Any, List
from .completion_manager import ShellType


class CompletionAdapter(ABC):
    """Base class for language-specific completion adapters."""
    
    def __init__(self, language: str):
        self.language = language
    
    @abstractmethod
    def generate_manager_code(self, config: Dict[str, Any]) -> str:
        """Generate completion manager code for the language."""
        pass
    
    @abstractmethod
    def generate_engine_code(self, config: Dict[str, Any]) -> str:
        """Generate completion engine code for the language."""
        pass


class PythonCompletionAdapter(CompletionAdapter):
    """Python completion adapter."""
    
    def __init__(self):
        super().__init__('python')
    
    def generate_manager_code(self, config: Dict[str, Any]) -> str:
        """Generate Python completion manager code."""
        project_name = config.get('project', {}).get('name', 'CLI')
        cli_name = project_name.lower().replace(' ', '-')
        
        lines = [
            '"""',
            f'Shell completion management for {project_name}',
            'Generated by Goobits CLI Framework',
            '"""',
            '',
            'import os',
            'import sys',
            'from pathlib import Path',
            'from typing import Dict, List, Optional',
            '',
            'class CompletionManager:',
            '    """Advanced shell completion manager"""',
            '    ',
            f'    def __init__(self, cli_name: str = "{cli_name}"):',
            '        self.cli_name = cli_name',
            '        self.script_name = cli_name',
            '    ',
            '    def generate_bash_completion(self) -> str:',
            '        """Generate bash completion script."""',
            '        return f"""# Bash completion for {self.cli_name}',
            '',
            '_{self.cli_name.replace("-", "_")}_completion() {',
            '    local cur prev words cword',
            '    _init_completion || return',
            '    ',
            '    # Add your completion logic here',
            '    COMPREPLY=($(compgen -W "help version" -- "$cur"))',
            '}',
            '',
            'complete -F _{self.cli_name.replace("-", "_")}_completion {self.cli_name}',
            '"""',
            '    ',
            '    def generate_zsh_completion(self) -> str:',
            '        """Generate zsh completion script."""',
            '        return f"""#compdef {self.cli_name}',
            '',
            '_{self.cli_name.replace("-", "_")}() {',
            '    local context curcontext="$curcontext" state line',
            '    typeset -A opt_args',
            '    ',
            '    _arguments -C \\',
            '        "1: :_command_names" \\',
            '        "*::arg:->args"',
            '    ',
            '    case $state in',
            '        args)',
            '            # Add command-specific completion here',
            '            ;;',
            '    esac',
            '}',
            '',
            '_{self.cli_name.replace("-", "_")} "$@"',
            '"""',
            '    ',
            '    def install_completion(self, shell: str = "bash") -> bool:',
            '        """Install completion for the specified shell."""',
            '        if shell == "bash":',
            '            script = self.generate_bash_completion()',
            '            install_path = Path.home() / ".local/share/bash-completion/completions" / self.cli_name',
            '        elif shell == "zsh":',
            '            script = self.generate_zsh_completion()',
            '            install_path = Path.home() / ".local/share/zsh/site-functions" / f"_{self.cli_name}"',
            '        else:',
            '            return False',
            '        ',
            '        try:',
            '            install_path.parent.mkdir(parents=True, exist_ok=True)',
            '            install_path.write_text(script)',
            '            return True',
            '        except (OSError, PermissionError):',
            '            return False',
            '    ',
            '    def get_completion_status(self) -> Dict[str, bool]:',
            '        """Check which shell completions are installed."""',
            '        bash_path = Path.home() / ".local/share/bash-completion/completions" / self.cli_name',
            '        zsh_path = Path.home() / ".local/share/zsh/site-functions" / f"_{self.cli_name}"',
            '        ',
            '        return {',
            '            "bash": bash_path.exists(),',
            '            "zsh": zsh_path.exists()',
            '        }'
        ]
        
        return '\n'.join(lines)
    
    def generate_engine_code(self, config: Dict[str, Any]) -> str:
        """Generate Python completion engine code."""
        project_name = config.get('project', {}).get('name', 'CLI')
        commands = config.get('commands', {})
        
        lines = [
            '"""',
            f'Completion engine for {project_name}',
            'Generated by Goobits CLI Framework',
            '"""',
            '',
            'import os',
            'import sys',
            'from typing import List, Dict, Any, Optional',
            '',
            'class CompletionEngine:',
            '    """Intelligent completion engine"""',
            '    ',
            '    def __init__(self, commands: Dict[str, Any]):',
            '        self.commands = commands',
            '    ',
            '    def complete(self, line: str, cursor_pos: Optional[int] = None) -> List[str]:',
            '        """Generate completions for the given command line."""',
            '        if cursor_pos is None:',
            '            cursor_pos = len(line)',
            '        ',
            '        words = line.split()',
            '        if not words:',
            '            return list(self.commands.keys())',
            '        ',
            '        # Skip the CLI name',
            '        if len(words) > 1:',
            '            words = words[1:]',
            '        else:',
            '            return list(self.commands.keys())',
            '        ',
            '        current_word = words[-1] if words else ""',
            '        ',
            '        # Complete commands',
            '        if len(words) <= 1:',
            '            return [cmd for cmd in self.commands.keys() if cmd.startswith(current_word)]',
            '        ',
            '        return []',
            '    ',
            '    def complete_option(self, command: str, current_word: str) -> List[str]:',
            '        """Complete options for a specific command."""',
            '        if command not in self.commands:',
            '            return []',
            '        ',
            '        cmd_data = self.commands[command]',
            '        options = []',
            '        ',
            '        for opt in cmd_data.get("options", []):',
            '            opt_name = opt.get("name", "")',
            '            if opt_name.startswith(current_word):',
            '                options.append(opt_name)',
            '        ',
            '        return options',
            '    ',
            '    def get_command_help(self, command: str) -> str:',
            '        """Get help text for a command."""',
            '        if command in self.commands:',
            '            return self.commands[command].get("description", "No description available")',
            '        return "Unknown command"'
        ]
        
        return '\n'.join(lines)


class NodeJSCompletionAdapter(CompletionAdapter):
    """Node.js completion adapter."""
    
    def __init__(self):
        super().__init__('nodejs')
    
    def generate_manager_code(self, config: Dict[str, Any]) -> str:
        """Generate Node.js completion manager code."""
        project_name = config.get('project', {}).get('name', 'CLI')
        cli_name = project_name.lower().replace(' ', '-')
        
        lines = [
            '/**',
            f' * Shell completion management for {project_name}',
            ' * Generated by Goobits CLI Framework',
            ' */',
            '',
            'import fs from \'fs\';',
            'import path from \'path\';',
            'import os from \'os\';',
            '',
            'export class CompletionManager {',
            '    constructor(cliName = "' + cli_name + '") {',
            '        this.cliName = cliName;',
            '        this.scriptName = cliName;',
            '    }',
            '',
            '    generateBashCompletion() {',
            '        return `# Bash completion for ${this.cliName}',
            '',
            '_${this.cliName.replace(/-/g, "_")}_completion() {',
            '    local cur prev words cword',
            '    _init_completion || return',
            '    ',
            '    # Add your completion logic here',
            '    COMPREPLY=($(compgen -W "help version" -- "$cur"))',
            '}',
            '',
            'complete -F _${this.cliName.replace(/-/g, "_")}_completion ${this.cliName}',
            '`;',
            '    }',
            '',
            '    generateZshCompletion() {',
            '        return `#compdef ${this.cliName}',
            '',
            '_${this.cliName.replace(/-/g, "_")}() {',
            '    local context curcontext="$curcontext" state line',
            '    typeset -A opt_args',
            '    ',
            '    _arguments -C \\\\',
            '        "1: :_command_names" \\\\',
            '        "*::arg:->args"',
            '    ',
            '    case $state in',
            '        args)',
            '            # Add command-specific completion here',
            '            ;;',
            '    esac',
            '}',
            '',
            '_${this.cliName.replace(/-/g, "_")} "$@"',
            '`;',
            '    }',
            '',
            '    async installCompletion(shell = "bash") {',
            '        let script, installPath;',
            '        ',
            '        if (shell === "bash") {',
            '            script = this.generateBashCompletion();',
            '            installPath = path.join(os.homedir(), ".local/share/bash-completion/completions", this.cliName);',
            '        } else if (shell === "zsh") {',
            '            script = this.generateZshCompletion();',
            '            installPath = path.join(os.homedir(), ".local/share/zsh/site-functions", `_${this.cliName}`);',
            '        } else {',
            '            return false;',
            '        }',
            '        ',
            '        try {',
            '            await fs.promises.mkdir(path.dirname(installPath), { recursive: true });',
            '            await fs.promises.writeFile(installPath, script);',
            '            return true;',
            '        } catch (error) {',
            '            return false;',
            '        }',
            '    }',
            '',
            '    async getCompletionStatus() {',
            '        const bashPath = path.join(os.homedir(), ".local/share/bash-completion/completions", this.cliName);',
            '        const zshPath = path.join(os.homedir(), ".local/share/zsh/site-functions", `_${this.cliName}`);',
            '        ',
            '        const checkFile = async (filePath) => {',
            '            try {',
            '                await fs.promises.access(filePath);',
            '                return true;',
            '            } catch {',
            '                return false;',
            '            }',
            '        };',
            '        ',
            '        return {',
            '            bash: await checkFile(bashPath),',
            '            zsh: await checkFile(zshPath)',
            '        };',
            '    }',
            '}'
        ]
        
        return '\n'.join(lines)
    
    def generate_engine_code(self, config: Dict[str, Any]) -> str:
        """Generate Node.js completion engine code."""
        project_name = config.get('project', {}).get('name', 'CLI')
        
        lines = [
            '/**',
            f' * Completion engine for {project_name}',
            ' * Generated by Goobits CLI Framework',
            ' */',
            '',
            'export class CompletionEngine {',
            '    constructor(commands) {',
            '        this.commands = commands;',
            '    }',
            '',
            '    complete(line, cursorPos = null) {',
            '        if (cursorPos === null) {',
            '            cursorPos = line.length;',
            '        }',
            '        ',
            '        const words = line.split(/\\s+/);',
            '        if (words.length === 0) {',
            '            return Object.keys(this.commands);',
            '        }',
            '        ',
            '        // Skip the CLI name',
            '        const commandWords = words.length > 1 ? words.slice(1) : [];',
            '        const currentWord = commandWords[commandWords.length - 1] || "";',
            '        ',
            '        // Complete commands',
            '        if (commandWords.length <= 1) {',
            '            return Object.keys(this.commands)',
            '                .filter(cmd => cmd.startsWith(currentWord));',
            '        }',
            '        ',
            '        return [];',
            '    }',
            '',
            '    completeOption(command, currentWord) {',
            '        if (!this.commands[command]) {',
            '            return [];',
            '        }',
            '        ',
            '        const cmdData = this.commands[command];',
            '        const options = [];',
            '        ',
            '        for (const opt of (cmdData.options || [])) {',
            '            const optName = opt.name || "";',
            '            if (optName.startsWith(currentWord)) {',
            '                options.push(optName);',
            '            }',
            '        }',
            '        ',
            '        return options;',
            '    }',
            '',
            '    getCommandHelp(command) {',
            '        if (this.commands[command]) {',
            '            return this.commands[command].description || "No description available";',
            '        }',
            '        return "Unknown command";',
            '    }',
            '}'
        ]
        
        return '\n'.join(lines)


class TypeScriptCompletionAdapter(CompletionAdapter):
    """TypeScript completion adapter."""
    
    def __init__(self):
        super().__init__('typescript')
    
    def generate_manager_code(self, config: Dict[str, Any]) -> str:
        """Generate TypeScript completion manager code."""
        project_name = config.get('project', {}).get('name', 'CLI')
        cli_name = project_name.lower().replace(' ', '-')
        
        lines = [
            '/**',
            f' * Shell completion management for {project_name}',
            ' * Generated by Goobits CLI Framework',
            ' */',
            '',
            'import * as fs from \'fs\';',
            'import * as path from \'path\';',
            'import * as os from \'os\';',
            '',
            'export class CompletionManager {',
            '    private cliName: string;',
            '    private scriptName: string;',
            '',
            '    constructor(cliName: string = "' + cli_name + '") {',
            '        this.cliName = cliName;',
            '        this.scriptName = cliName;',
            '    }',
            '',
            '    generateBashCompletion(): string {',
            '        return `# Bash completion for ${this.cliName}',
            '',
            '_${this.cliName.replace(/-/g, "_")}_completion() {',
            '    local cur prev words cword',
            '    _init_completion || return',
            '    ',
            '    # Add your completion logic here',
            '    COMPREPLY=($(compgen -W "help version" -- "$cur"))',
            '}',
            '',
            'complete -F _${this.cliName.replace(/-/g, "_")}_completion ${this.cliName}',
            '`;',
            '    }',
            '',
            '    generateZshCompletion(): string {',
            '        return `#compdef ${this.cliName}',
            '',
            '_${this.cliName.replace(/-/g, "_")}() {',
            '    local context curcontext="$curcontext" state line',
            '    typeset -A opt_args',
            '    ',
            '    _arguments -C \\\\',
            '        "1: :_command_names" \\\\',
            '        "*::arg:->args"',
            '    ',
            '    case $state in',
            '        args)',
            '            # Add command-specific completion here',
            '            ;;',
            '    esac',
            '}',
            '',
            '_${this.cliName.replace(/-/g, "_")} "$@"',
            '`;',
            '    }',
            '',
            '    async installCompletion(shell: string = "bash"): Promise<boolean> {',
            '        let script: string;',
            '        let installPath: string;',
            '        ',
            '        if (shell === "bash") {',
            '            script = this.generateBashCompletion();',
            '            installPath = path.join(os.homedir(), ".local/share/bash-completion/completions", this.cliName);',
            '        } else if (shell === "zsh") {',
            '            script = this.generateZshCompletion();',
            '            installPath = path.join(os.homedir(), ".local/share/zsh/site-functions", `_${this.cliName}`);',
            '        } else {',
            '            return false;',
            '        }',
            '        ',
            '        try {',
            '            await fs.promises.mkdir(path.dirname(installPath), { recursive: true });',
            '            await fs.promises.writeFile(installPath, script);',
            '            return true;',
            '        } catch (error) {',
            '            return false;',
            '        }',
            '    }',
            '',
            '    async getCompletionStatus(): Promise<{ [key: string]: boolean }> {',
            '        const bashPath = path.join(os.homedir(), ".local/share/bash-completion/completions", this.cliName);',
            '        const zshPath = path.join(os.homedir(), ".local/share/zsh/site-functions", `_${this.cliName}`);',
            '        ',
            '        const checkFile = async (filePath: string): Promise<boolean> => {',
            '            try {',
            '                await fs.promises.access(filePath);',
            '                return true;',
            '            } catch {',
            '                return false;',
            '            }',
            '        };',
            '        ',
            '        return {',
            '            bash: await checkFile(bashPath),',
            '            zsh: await checkFile(zshPath)',
            '        };',
            '    }',
            '}'
        ]
        
        return '\n'.join(lines)
    
    def generate_engine_code(self, config: Dict[str, Any]) -> str:
        """Generate TypeScript completion engine code."""
        project_name = config.get('project', {}).get('name', 'CLI')
        
        lines = [
            '/**',
            f' * Completion engine for {project_name}',
            ' * Generated by Goobits CLI Framework',
            ' */',
            '',
            'interface CommandData {',
            '    description?: string;',
            '    options?: Array<{ name?: string; description?: string; }>;',
            '}',
            '',
            'export class CompletionEngine {',
            '    private commands: { [key: string]: CommandData };',
            '',
            '    constructor(commands: { [key: string]: CommandData }) {',
            '        this.commands = commands;',
            '    }',
            '',
            '    complete(line: string, cursorPos: number | null = null): string[] {',
            '        if (cursorPos === null) {',
            '            cursorPos = line.length;',
            '        }',
            '        ',
            '        const words = line.split(/\\s+/);',
            '        if (words.length === 0) {',
            '            return Object.keys(this.commands);',
            '        }',
            '        ',
            '        // Skip the CLI name',
            '        const commandWords = words.length > 1 ? words.slice(1) : [];',
            '        const currentWord = commandWords[commandWords.length - 1] || "";',
            '        ',
            '        // Complete commands',
            '        if (commandWords.length <= 1) {',
            '            return Object.keys(this.commands)',
            '                .filter(cmd => cmd.startsWith(currentWord));',
            '        }',
            '        ',
            '        return [];',
            '    }',
            '',
            '    completeOption(command: string, currentWord: string): string[] {',
            '        if (!this.commands[command]) {',
            '            return [];',
            '        }',
            '        ',
            '        const cmdData = this.commands[command];',
            '        const options: string[] = [];',
            '        ',
            '        for (const opt of (cmdData.options || [])) {',
            '            const optName = opt.name || "";',
            '            if (optName.startsWith(currentWord)) {',
            '                options.push(optName);',
            '            }',
            '        }',
            '        ',
            '        return options;',
            '    }',
            '',
            '    getCommandHelp(command: string): string {',
            '        if (this.commands[command]) {',
            '            return this.commands[command].description || "No description available";',
            '        }',
            '        return "Unknown command";',
            '    }',
            '}'
        ]
        
        return '\n'.join(lines)


class RustCompletionAdapter(CompletionAdapter):
    """Rust completion adapter."""
    
    def __init__(self):
        super().__init__('rust')
    
    def generate_manager_code(self, config: Dict[str, Any]) -> str:
        """Generate Rust completion manager code."""
        project_name = config.get('project', {}).get('name', 'CLI')
        cli_name = project_name.lower().replace(' ', '-')
        
        lines = [
            '//! Shell completion management',
            '//!',
            f'//! Completion system for {project_name}',
            '//! Generated by Goobits CLI Framework',
            '',
            'use std::fs;',
            'use std::path::PathBuf;',
            'use std::env;',
            '',
            'pub struct CompletionManager {',
            '    cli_name: String,',
            '}',
            '',
            'impl CompletionManager {',
            f'    pub fn new() -> Self {{',
            '        Self {',
            f'            cli_name: "{cli_name}".to_string(),',
            '        }',
            '    }',
            '',
            '    pub fn with_name(cli_name: impl Into<String>) -> Self {',
            '        Self {',
            '            cli_name: cli_name.into(),',
            '        }',
            '    }',
            '',
            '    pub fn generate_bash_completion(&self) -> String {',
            '        format!(',
            '            r#"# Bash completion for {}',
            '',
            '_{}_completion() {{',
            '    local cur prev words cword',
            '    _init_completion || return',
            '    ',
            '    # Add your completion logic here',
            '    COMPREPLY=($(compgen -W "help version" -- "$cur"))',
            '}}',
            '',
            'complete -F _{}_completion {}',
            '"#,',
            '            self.cli_name,',
            '            self.cli_name.replace("-", "_"),',
            '            self.cli_name.replace("-", "_"),',
            '            self.cli_name',
            '        )',
            '    }',
            '',
            '    pub fn generate_zsh_completion(&self) -> String {',
            '        format!(',
            '            r#"#compdef {}',
            '',
            '_{} () {{',
            '    local context curcontext="$curcontext" state line',
            '    typeset -A opt_args',
            '    ',
            '    _arguments -C \\',
            '        "1: :_command_names" \\',
            '        "*::arg:->args"',
            '    ',
            '    case $state in',
            '        args)',
            '            # Add command-specific completion here',
            '            ;;',
            '    esac',
            '}}',
            '',
            '_{} "$@"',
            '"#,',
            '            self.cli_name,',
            '            self.cli_name.replace("-", "_"),',
            '            self.cli_name.replace("-", "_")',
            '        )',
            '    }',
            '',
            '    pub fn install_completion(&self, shell: &str) -> Result<(), Box<dyn std::error::Error>> {',
            '        let (script, install_path) = match shell {',
            '            "bash" => {',
            '                let script = self.generate_bash_completion();',
            '                let mut path = env::var("HOME")?;',
            '                path.push_str("/.local/share/bash-completion/completions/");',
            '                path.push_str(&self.cli_name);',
            '                (script, PathBuf::from(path))',
            '            },',
            '            "zsh" => {',
            '                let script = self.generate_zsh_completion();',
            '                let mut path = env::var("HOME")?;',
            '                path.push_str("/.local/share/zsh/site-functions/_");',
            '                path.push_str(&self.cli_name);',
            '                (script, PathBuf::from(path))',
            '            },',
            '            _ => return Err("Unsupported shell".into()),',
            '        };',
            '        ',
            '        if let Some(parent) = install_path.parent() {',
            '            fs::create_dir_all(parent)?;',
            '        }',
            '        ',
            '        fs::write(install_path, script)?;',
            '        Ok(())',
            '    }',
            '}',
            '',
            'impl Default for CompletionManager {',
            '    fn default() -> Self {',
            '        Self::new()',
            '    }',
            '}'
        ]
        
        return '\n'.join(lines)
    
    def generate_engine_code(self, config: Dict[str, Any]) -> str:
        """Generate Rust completion engine code.""" 
        project_name = config.get('project', {}).get('name', 'CLI')
        
        lines = [
            '//! Completion engine',
            '//!',
            f'//! Intelligent completion for {project_name}',
            '//! Generated by Goobits CLI Framework',
            '',
            'use std::collections::HashMap;',
            '',
            '#[derive(Debug, Clone)]',
            'pub struct CompletionEngine {',
            '    commands: HashMap<String, CommandData>,',
            '}',
            '',
            '#[derive(Debug, Clone)]',
            'pub struct CommandData {',
            '    pub description: String,',
            '    pub options: Vec<OptionData>,',
            '}',
            '',
            '#[derive(Debug, Clone)]',
            'pub struct OptionData {',
            '    pub name: String,',
            '    pub description: String,',
            '}',
            '',
            'impl CompletionEngine {',
            '    pub fn new(commands: HashMap<String, CommandData>) -> Self {',
            '        Self { commands }',
            '    }',
            '',
            '    pub fn complete(&self, line: &str, cursor_pos: Option<usize>) -> Vec<String> {',
            '        let cursor_pos = cursor_pos.unwrap_or(line.len());',
            '        ',
            '        let words: Vec<&str> = line.split_whitespace().collect();',
            '        if words.is_empty() {',
            '            return self.commands.keys().cloned().collect();',
            '        }',
            '        ',
            '        // Skip the CLI name',
            '        let command_words: Vec<&str> = if words.len() > 1 {',
            '            words[1..].to_vec()',
            '        } else {',
            '            vec![]',
            '        };',
            '        ',
            '        let current_word = command_words.last().unwrap_or(&"");',
            '        ',
            '        // Complete commands',
            '        if command_words.len() <= 1 {',
            '            return self.commands',
            '                .keys()',
            '                .filter(|cmd| cmd.starts_with(current_word))',
            '                .cloned()',
            '                .collect();',
            '        }',
            '        ',
            '        vec![]',
            '    }',
            '',
            '    pub fn complete_option(&self, command: &str, current_word: &str) -> Vec<String> {',
            '        if let Some(cmd_data) = self.commands.get(command) {',
            '            cmd_data.options',
            '                .iter()',
            '                .map(|opt| &opt.name)',
            '                .filter(|name| name.starts_with(current_word))',
            '                .cloned()',
            '                .collect()',
            '        } else {',
            '            vec![]',
            '        }',
            '    }',
            '',
            '    pub fn get_command_help(&self, command: &str) -> String {',
            '        if let Some(cmd_data) = self.commands.get(command) {',
            '            cmd_data.description.clone()',
            '        } else {',
            '            "Unknown command".to_string()',
            '        }',
            '    }',
            '}'
        ]
        
        return '\n'.join(lines)