# Hook Interface Schema
# Defines patterns for user logic injection across all 4 languages
# Agent A - Code Structure Patterns

schema_version: "1.0.0"
description: "Universal hook system patterns for user-defined logic"

# Hook Function Pattern
hook_function:
  description: "How user-defined functions are called by the framework"
  
  common_properties:
    - name: "string"             # Hook function name
    - phase: "string"            # When hook is called
    - async: "boolean"           # Async execution support
    - return_type: "any"         # Expected return value
    
  naming_conventions:
    pattern: "on_{command_name}[_{subcommand}]"
    examples:
      - "on_build"               # Simple command
      - "on_config_get"          # Subcommand
      - "on_daemon_start"        # Nested subcommand
      
  language_syntax:
    python:
      pattern: "def on_command_name(**kwargs)"
      example: |
        def on_build(config_path=None, output_dir=None, **kwargs):
            """Handle build command"""
            print(f"Building from {config_path}")
            return True
            
    nodejs:
      pattern: "export async function onCommandName(args)"
      example: |
        export async function onBuild(args) {
            console.log(`Building from ${args.configPath}`);
            return true;
        }
        
    typescript:
      pattern: "export async function onCommandName(args: Args): Promise<Result>"
      example: |
        export async function onBuild(args: BuildArgs): Promise<boolean> {
            console.log(`Building from ${args.configPath}`);
            return true;
        }
        
    rust:
      pattern: "pub fn on_command_name(args: &Args) -> Result<()>"
      example: |
        pub fn on_build(args: &BuildArgs) -> Result<()> {
            println!("Building from {:?}", args.config_path);
            Ok(())
        }

# Hook Registration Pattern
hook_registration:
  description: "How hooks are discovered and registered"
  
  common_methods:
    file_based:
      description: "Hooks defined in specific files"
      files:
        python: "cli_hooks.py"
        nodejs: "src/hooks.js"
        typescript: "src/hooks.ts"
        rust: "src/hooks.rs"
        
    dynamic:
      description: "Runtime hook registration"
      supported: ["nodejs", "typescript"]
      
    compile_time:
      description: "Hooks resolved at compile time"
      supported: ["rust"]
      
  discovery_patterns:
    python:
      - "Import cli_hooks module"
      - "Use getattr() to find functions"
      - "Fallback to default behavior"
      
    nodejs:
      - "Dynamic import() of hooks file"
      - "Check exported functions"
      - "Async function support"
      
    typescript:
      - "Type-safe import with interfaces"
      - "Compile-time validation"
      - "Async/Promise support"
      
    rust:
      - "Module import at compile time"
      - "Function references in registry"
      - "Result<T> error handling"

# Parameter Passing Pattern
parameter_passing:
  description: "How arguments are passed to hook functions"
  
  common_patterns:
    kwargs_style:
      languages: ["python"]
      description: "Keyword arguments with **kwargs"
      benefits:
        - "Flexible parameter addition"
        - "Backward compatibility"
        - "Optional parameter handling"
        
    object_style:
      languages: ["nodejs", "typescript"]
      description: "Single args object"
      benefits:
        - "Named parameters"
        - "Easy destructuring"
        - "Type safety (TypeScript)"
        
    struct_style:
      languages: ["rust"]
      description: "Reference to args struct"
      benefits:
        - "Zero-copy efficiency"
        - "Strong typing"
        - "Pattern matching"
        
  parameter_contents:
    command_args:
      - "Positional arguments"
      - "Named options/flags"
      - "Global options"
      
    context_info:
      - "Command name"
      - "Working directory"
      - "Environment variables"
      
    framework_helpers:
      python: "Click context object"
      nodejs: "Program instance"
      typescript: "Typed context"
      rust: "HookContext struct"

# Return Value Pattern
return_values:
  description: "What hooks can return and how it affects execution"
  
  common_patterns:
    success_indicator:
      type: "boolean"
      true_meaning: "Command succeeded"
      false_meaning: "Command failed (exit with error)"
      
    result_object:
      type: "object"
      properties:
        - "success: boolean"
        - "message: string"
        - "data: any"
        
    error_handling:
      python: "Raise exception or return False"
      nodejs: "Throw error or return false"
      typescript: "Result<T, E> pattern or throw"
      rust: "Result<T, Error> with ? operator"
      
  language_specifics:
    python:
      - "None implies success"
      - "sys.exit() for immediate exit"
      - "Click exceptions for formatted errors"
      
    nodejs:
      - "Promise rejection for async errors"
      - "process.exit() for immediate exit"
      - "Undefined implies success"
      
    typescript:
      - "Type-safe Result<T, E> pattern"
      - "Never type for exhaustive checks"
      - "Custom error types"
      
    rust:
      - "Result<(), Error> standard"
      - "? operator for propagation"
      - "Custom error types with Display"

# Hook Context Pattern
hook_context:
  description: "Additional context provided to hooks"
  
  common_properties:
    - command_info:
        - "name: string"
        - "description: string"
        - "version: string"
        
    - execution_info:
        - "cwd: string"
        - "timestamp: datetime"
        - "user: string"
        
    - cli_state:
        - "config: object"
        - "plugins: array"
        - "debug_mode: boolean"
        
  language_implementations:
    python:
      access: "Via ctx parameter or globals"
      example: "@click.pass_context"
      
    nodejs:
      access: "Via this binding or closure"
      example: "function.bind(context)"
      
    typescript:
      access: "Via typed context parameter"
      example: "context: CommandContext"
      
    rust:
      access: "Via HookContext struct"
      example: "&HookContext parameter"

# Lifecycle Hooks Pattern
lifecycle_hooks:
  description: "Hooks called at specific CLI lifecycle points"
  
  common_hooks:
    pre_command:
      description: "Before any command runs"
      use_cases:
        - "Setup/initialization"
        - "Authentication"
        - "Logging"
        
    post_command:
      description: "After command completes"
      use_cases:
        - "Cleanup"
        - "Metrics collection"
        - "State persistence"
        
    on_error:
      description: "When command fails"
      use_cases:
        - "Error reporting"
        - "Rollback operations"
        - "User notification"
        
  language_support:
    python: "Via decorators and context managers"
    nodejs: "Via event emitters or middleware"
    typescript: "Via typed middleware chain"
    rust: "Via trait implementations"

# Plugin System Pattern
plugin_system:
  description: "Dynamic extension loading (where applicable)"
  
  supported_languages: ["nodejs", "rust"]
  partial_support: ["python", "typescript"]
  
  common_patterns:
    discovery:
      - "Scan plugin directories"
      - "Load from package.json"
      - "Registry-based lookup"
      
    interface:
      - "register(program) function"
      - "Metadata export"
      - "Version compatibility"
      
    lifecycle:
      - "Load at startup"
      - "Initialize with context"
      - "Cleanup on exit"
      
  language_specifics:
    nodejs:
      location: "~/.config/{cli}/plugins/"
      format: "CommonJS or ESM modules"
      api: "Export register function"
      
    rust:
      location: "Compiled into binary or dylib"
      format: "Rust crate or dynamic library"
      api: "Plugin trait implementation"
      
    python:
      location: "Python path or plugins/"
      format: "Python modules"
      api: "Entry point or convention"
      
    typescript:
      location: "Same as nodejs with types"
      format: "TypeScript/JavaScript modules"
      api: "Typed plugin interface"

# Best Practices
best_practices:
  - "Keep hook names consistent with command names"
  - "Always handle missing hooks gracefully"
  - "Provide clear error messages for hook failures"
  - "Document expected parameters and return values"
  - "Use async/await for I/O operations where supported"
  - "Validate inputs before processing"
  - "Return meaningful error information"

# Integration Notes
integration_notes:
  - "Hook names are derived from command names automatically"
  - "All languages support both sync and async patterns (except Python prefers sync)"
  - "Error handling patterns preserve language idioms"
  - "Plugin systems are optional and degrade gracefully"