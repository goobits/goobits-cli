"""
Consolidated CLI generated by Goobits Universal Template System
This file combines multiple Python modules into a single executable.
"""

# === Content from config.py ===

"""
Configuration management for Goobits CLI Framework
"""

import os
import json
import yaml
from pathlib import Path
from typing import Dict, Any, Optional
from dataclasses import dataclass, asdict

@dataclass
class Config:
    """Configuration data structure."""

    # Default configuration values    # Add your configuration fields here
    debug: bool = False
    output_format: str = "text"
class ConfigManager:
    """Manages configuration loading and saving."""

    def __init__(self, config_file: Optional[str] = None):
        self.config_file = config_file or self._get_default_config_path()
        self.config = Config()
        self.load_config()

    def _get_default_config_path(self) -> str:
        """Get the default configuration file path."""
        config_dir = Path.home() / ".config" / "goobits-cli-framework"
        config_dir.mkdir(parents=True, exist_ok=True)
        return str(config_dir / "config.yaml")

    def load_config(self) -> None:
        """Load configuration from file and environment variables."""
        # Load from config file if it exists
        if os.path.exists(self.config_file):
            try:
                with open(self.config_file, 'r') as f:
                    if self.config_file.endswith('.json'):
                        data = json.load(f)
                    else:
                        data = yaml.safe_load(f)

                if data:
                    for key, value in data.items():
                        if hasattr(self.config, key):
                            setattr(self.config, key, value)
            except Exception as e:
                print(f"Warning: Failed to load config file {self.config_file}: {e}")

        # Override with environment variables
        env_prefix = "GOOBITS_CLI_FRAMEWORK_"
        for key in asdict(self.config).keys():
            env_key = f"{env_prefix}{key.upper()}"
            if env_key in os.environ:
                value = os.environ[env_key]
                # Convert string values to appropriate types
                if hasattr(self.config, key):
                    current_value = getattr(self.config, key)
                    if isinstance(current_value, bool):
                        value = value.lower() in ('true', '1', 'yes', 'on')
                    elif isinstance(current_value, int):
                        value = int(value)
                    elif isinstance(current_value, float):
                        value = float(value)
                    setattr(self.config, key, value)

    def save_config(self) -> None:
        """Save current configuration to file."""
        try:
            config_path = Path(self.config_file)
            config_path.parent.mkdir(parents=True, exist_ok=True)

            with open(self.config_file, 'w') as f:
                yaml.dump(asdict(self.config), f, default_flow_style=False)
        except Exception as e:
            print(f"Error: Failed to save config file {self.config_file}: {e}")

    def get(self, key: str, default: Any = None) -> Any:
        """Get a configuration value."""
        return getattr(self.config, key, default)

    def set(self, key: str, value: Any) -> None:
        """Set a configuration value."""
        if hasattr(self.config, key):
            setattr(self.config, key, value)
        else:
            raise KeyError(f"Unknown configuration key: {key}")

    def to_dict(self) -> Dict[str, Any]:
        """Convert configuration to dictionary."""
        return asdict(self.config)

# Global configuration instance
_config_manager = None

def get_config() -> ConfigManager:
    """Get the global configuration manager instance."""
    global _config_manager
    if _config_manager is None:
        _config_manager = ConfigManager()
    return _config_manager


# === Content from completion.py ===

"""
Shell completion engine for Goobits CLI Framework
"""

import os
import sys
from typing import List, Dict, Any

class CompletionEngine:
    """Handles shell completion for CLI commands."""

    def __init__(self, cli_schema: Dict[str, Any]):
        self.cli_schema = cli_schema

    def generate_bash_completion(self) -> str:
        """Generate shell completion script."""
        script = '''
# Bash completion for Goobits CLI

_Goobits_CLI_completions()
{
    local cur prev words cword
    COMPREPLY=()
    cur="${COMP_WORDS[COMP_CWORD]}"
    prev="${COMP_WORDS[COMP_CWORD-1]}"

    # Global options
    local global_opts="--help -h --version"

    # Subcommands
    local subcommands=" build init serve"

    case $COMP_CWORD in
        1)
            COMPREPLY=($(compgen -W "$subcommands $global_opts" -- "$cur"))
            ;;
        *)
            case "${words[1]}" in
                build)
                    local build_opts="--help -h --output-dir -o --output --backup --universal-templates"
                    COMPREPLY=($(compgen -W "$build_opts" -- "$cur"))
                    ;;
                init)
                    local init_opts="--help -h --template -t --force"
                    COMPREPLY=($(compgen -W "$init_opts" -- "$cur"))
                    ;;
                serve)
                    local serve_opts="--help -h --host --port -p"
                    COMPREPLY=($(compgen -W "$serve_opts" -- "$cur"))
                    ;;
            esac
            ;;
    esac
}

complete -F _Goobits_CLI_completions goobits
'''
        return script

    def generate_zsh_completion(self) -> str:
        """Generate shell completion script."""
        script = '''
# Zsh completion for Goobits CLI

_goobits() {
    local context state line

    _arguments -C \\
        '(--help -h){--help,-h}[Show help information]' \\
        '(--version)--version[Show version information]' \\
        '1: :_goobits_commands' \\
        '*::arg:->args'

    case $state in
        args)
            case $words[1] in
                build)
                    _arguments \\
                        '(--help -h){--help,-h}[Show help information]' \\
                        '(--output-dir -o){--output-dir,-o}[Output directory]' \\
                        '(--output){--output}[Output filename for generated CLI]' \\
                        '(--backup){--backup}[Create backup files]' \\
                        '(--universal-templates){--universal-templates}[Use Universal Template System]' \\
                        '1:config_path:_files'
                    ;;
                init)
                    _arguments \\
                        '(--help -h){--help,-h}[Show help information]' \\
                        '(--template -t){--template,-t}[Template type]' \\
                        '(--force){--force}[Overwrite existing goobits.yaml file]' \\
                        '1:project_name:_files'
                    ;;
                serve)
                    _arguments \\
                        '(--help -h){--help,-h}[Show help information]' \\
                        '(--host){--host}[Host to bind the server to]' \\
                        '(--port -p){--port,-p}[Port to run the server on]' \\
                        '1:directory:_files'
                    ;;
            esac
            ;;
    esac
}

_goobits_commands() {
    local commands
    commands=(
        'build:Build CLI and setup scripts from goobits.yaml configuration'
        'init:Create initial goobits.yaml template'
        'serve:Serve local PyPI-compatible package index'
    )
    _describe 'commands' commands
}

_goobits "$@"
'''
        return script

    def generate_fish_completion(self) -> str:
        """Generate shell completion script."""
        script = '''
# Global options
complete -c goobits -f
complete -c goobits -s h -l help -d "Show help information"
complete -c goobits -l version -d "Show version information"

# Subcommands
complete -c goobits -n "__fish_use_subcommand" -a "build" -d "Build CLI and setup scripts from goobits.yaml configuration"
complete -c goobits -n "__fish_seen_subcommand_from build" -l output-dir -s o -d "Output directory (defaults to same directory as config file)"
complete -c goobits -n "__fish_seen_subcommand_from build" -l output -d "Output filename for generated CLI (defaults to 'generated_cli.py')"
complete -c goobits -n "__fish_seen_subcommand_from build" -l backup -d "Create backup files (.bak) when overwriting existing files"
complete -c goobits -n "__fish_seen_subcommand_from build" -l universal-templates -d "Use Universal Template System (experimental)"
complete -c goobits -n "__fish_use_subcommand" -a "init" -d "Create initial goobits.yaml template"
complete -c goobits -n "__fish_seen_subcommand_from init" -l template -s t -d "Template type"
complete -c goobits -n "__fish_seen_subcommand_from init" -l force -d "Overwrite existing goobits.yaml file"
complete -c goobits -n "__fish_use_subcommand" -a "serve" -d "Serve local PyPI-compatible package index"
complete -c goobits -n "__fish_seen_subcommand_from serve" -l host -d "Host to bind the server to"
complete -c goobits -n "__fish_seen_subcommand_from serve" -l port -s p -d "Port to run the server on"
'''
        return script

    def install_completion(self, shell: str = None) -> bool:
        """Install completion script for the specified shell."""
        if shell is None:
            shell = os.environ.get('SHELL', '').split('/')[-1]

        if shell == 'bash':
            script = self.generate_bash_completion()
            completion_dir = os.path.expanduser('~/.bash_completion.d')
        elif shell == 'zsh':
            script = self.generate_zsh_completion()
            completion_dir = os.path.expanduser('~/.zsh/completions')
        elif shell == 'fish':
            script = self.generate_fish_completion()
            completion_dir = os.path.expanduser('~/.config/fish/completions')
        else:
            print(f"Unsupported shell: {shell}")
            return False

        try:
            os.makedirs(completion_dir, exist_ok=True)
            filename = f'Goobits CLI.{shell}'
            if shell == 'bash':
                filename = f'Goobits CLI'

            filepath = os.path.join(completion_dir, filename)
            with open(filepath, 'w') as f:
                f.write(script)

            print(f"Completion script installed: {filepath}")
            if shell == 'bash':
                print("Please restart your terminal or run: source ~/.bashrc")
            elif shell == 'zsh':
                print("Please restart your terminal or add to ~/.zshrc: fpath=(~/.zsh/completions $fpath)")

            return True
        except Exception as e:
            print(f"Failed to install completion: {e}")
            return False


# === Content from errors.py ===

"""
Error handling utilities for Goobits CLI Framework
"""

import sys
import traceback
from typing import Optional, Any, Dict
from enum import Enum

class ExitCode(Enum):
    """Standard exit codes for the CLI."""
    SUCCESS = 0
    GENERAL_ERROR = 1
    USAGE_ERROR = 2
    CONFIG_ERROR = 3
    NETWORK_ERROR = 4
    PERMISSION_ERROR = 5
    FILE_NOT_FOUND = 6

class CliError(Exception):
    """Base exception class for CLI errors."""

    def __init__(self, message: str, exit_code: ExitCode = ExitCode.GENERAL_ERROR,
                 details: Optional[Dict[str, Any]] = None):
        super().__init__(message)
        self.message = message
        self.exit_code = exit_code
        self.details = details or {}

class UsageError(CliError):
    """Raised when command usage is incorrect."""

    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):
        super().__init__(message, ExitCode.USAGE_ERROR, details)

class ConfigError(CliError):
    """Raised when configuration is invalid or missing."""

    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):
        super().__init__(message, ExitCode.CONFIG_ERROR, details)

class NetworkError(CliError):
    """Raised when network operations fail."""

    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):
        super().__init__(message, ExitCode.NETWORK_ERROR, details)

class PermissionError(CliError):
    """Raised when permission is denied."""

    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):
        super().__init__(message, ExitCode.PERMISSION_ERROR, details)

class FileNotFoundError(CliError):
    """Raised when a required file is not found."""

    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):
        super().__init__(message, ExitCode.FILE_NOT_FOUND, details)

class ErrorHandler:
    """Centralized error handling for the CLI."""

    def __init__(self, debug: bool = False, verbose: bool = False):
        self.debug = debug
        self.verbose = verbose or debug  # verbose includes debug functionality

    def handle_error(self, error: Exception, context: Optional[str] = None) -> None:
        """
        Handle an error and exit the program with appropriate code.

        Args:
            error: The exception that occurred
            context: Optional context information
        """
        if isinstance(error, CliError):
            self._handle_cli_error(error, context)
        else:
            self._handle_unexpected_error(error, context)

    def _handle_cli_error(self, error: CliError, context: Optional[str] = None) -> None:
        """Handle a known CLI error."""
        message = f"Error: {error.message}"
        if context:
            message = f"{context}: {message}"

        print(message, file=sys.stderr)

        if self.verbose and error.details:
            print("Additional details:", file=sys.stderr)
            for key, value in error.details.items():
                print(f"  {key}: {value}", file=sys.stderr)

        if self.verbose:
            traceback.print_exc()

        sys.exit(error.exit_code.value)

    def _handle_unexpected_error(self, error: Exception, context: Optional[str] = None) -> None:
        """Handle an unexpected error."""
        message = f"Unexpected error: {str(error)}"
        if context:
            message = f"{context}: {message}"

        print(message, file=sys.stderr)

        if self.verbose:
            traceback.print_exc()
        else:
            print("Run with --verbose for more details", file=sys.stderr)

        sys.exit(ExitCode.GENERAL_ERROR.value)

    def warn(self, message: str, details: Optional[Dict[str, Any]] = None) -> None:
        """Issue a warning without exiting."""
        print(f"Warning: {message}", file=sys.stderr)

        if self.verbose and details:
            for key, value in details.items():
                print(f"  {key}: {value}", file=sys.stderr)

def handle_keyboard_interrupt():
    """Handle Ctrl+C gracefully."""
    print("\nOperation cancelled by user", file=sys.stderr)
    sys.exit(ExitCode.GENERAL_ERROR.value)

# Global error handler instance
_error_handler = None

def get_error_handler() -> ErrorHandler:
    """Get the global error handler instance."""
    global _error_handler
    if _error_handler is None:
        _error_handler = ErrorHandler()
    return _error_handler

def set_error_handler(handler: ErrorHandler) -> None:
    """Set the global error handler instance."""
    global _error_handler
    _error_handler = handler


# === Content from hooks.py ===

"""
Hook system interface for Goobits CLI Framework

This module defines the interface between the generated CLI and user-defined hooks.
Users should implement hook functions in app_hooks.py to provide business logic.
"""

import importlib
import inspect
import sys
from typing import Any, Callable, Dict, Optional
from pathlib import Path

class HookManager:
    """Manages loading and execution of user-defined hooks."""

    def __init__(self, hooks_module_name: str = "app_hooks"):
        self.hooks_module_name = hooks_module_name
        self.hooks_module = None
        self.hooks_cache: Dict[str, Callable] = {}
        self.load_hooks()

    def load_hooks(self) -> None:
        """Load the hooks module."""
        try:
            # Try to import the hooks module
            self.hooks_module = importlib.import_module(self.hooks_module_name)

            # Cache all hook functions
            for name, obj in inspect.getmembers(self.hooks_module):
                if (inspect.isfunction(obj) and
                    name.startswith('on_') and
                    not name.startswith('_')):
                    self.hooks_cache[name] = obj

        except ImportError:
            # Hooks module doesn't exist yet
            self.hooks_module = None
            self.hooks_cache = {}

    def reload_hooks(self) -> None:
        """Reload the hooks module (useful for development)."""
        if self.hooks_module:
            importlib.reload(self.hooks_module)
        else:
            self.load_hooks()

    def has_hook(self, hook_name: str) -> bool:
        """Check if a hook function exists."""
        return hook_name in self.hooks_cache

    def execute_hook(self, hook_name: str, *args, **kwargs) -> Any:
        """
        Execute a hook function.

        Args:
            hook_name: Name of the hook function
            *args: Positional arguments to pass to the hook
            **kwargs: Keyword arguments to pass to the hook

        Returns:
            The return value of the hook function

        Raises:
            HookNotFoundError: If the hook doesn't exist
            Exception: Any exception raised by the hook
        """
        if not self.has_hook(hook_name):
            raise HookNotFoundError(f"Hook '{hook_name}' not found")

        hook_func = self.hooks_cache[hook_name]

        try:
            return hook_func(*args, **kwargs)
        except Exception as e:
            # Re-raise with additional context
            raise HookExecutionError(f"Error executing hook '{hook_name}': {str(e)}") from e

    def get_hook_signature(self, hook_name: str) -> Optional[inspect.Signature]:
        """Get the signature of a hook function."""
        if hook_name in self.hooks_cache:
            return inspect.signature(self.hooks_cache[hook_name])
        return None

    def list_hooks(self) -> Dict[str, str]:
        """
        List all available hooks with their docstrings.

        Returns:
            Dictionary mapping hook names to their docstrings
        """
        hooks_info = {}
        for name, func in self.hooks_cache.items():
            docstring = inspect.getdoc(func) or "No description available"
            hooks_info[name] = docstring
        return hooks_info

    def generate_hooks_template(self) -> str:
        """Generate a template hooks file for the user."""
        template = f'''"""
Hook implementations for Goobits CLI Framework

This file contains the business logic for your CLI commands.
Implement the hook functions below to handle your CLI commands.

Each command in your CLI corresponds to a hook function named 'on_<command_name>'.
Command names with hyphens are converted to underscores.

Example:
- Command 'hello-world' -> Hook function 'on_hello_world'
- Command 'status' -> Hook function 'on_status'
"""

# Import any modules you need here
import sys
import os
def on_build(config_path, output_dir=None, output=None, backup=None, universal_templates=None):
    """
    Build CLI and setup scripts from goobits.yaml configuration

    Args:        config_path (str): Path to goobits.yaml file (defaults to ./goobits.yaml)        output_dir (str): üìÅ Output directory (defaults to same directory as config file)        output (str): üìù Output filename for generated CLI (defaults to 'generated_cli.py')        backup (str): üíæ Create backup files (.bak) when overwriting existing files        universal_templates (str): üß™ Use Universal Template System (experimental)    """
    # TODO: Implement your business logic here
    print(f"Hook on_build called")    print(f"Arguments:config_path={config_path}")    print(f"Options:output_dir={output_dir}, output={output}, backup={backup}, universal_templates={universal_templates}")
    # Return 0 for success, non-zero for error
    return 0
def on_init(project_name, template=None, force=None):
    """
    Create initial goobits.yaml template

    Args:        project_name (str): Name of the project (optional)        template (str): üéØ Template type        force (str): üî• Overwrite existing goobits.yaml file    """
    # TODO: Implement your business logic here
    print(f"Hook on_init called")    print(f"Arguments:project_name={project_name}")    print(f"Options:template={template}, force={force}")
    # Return 0 for success, non-zero for error
    return 0
def on_serve(directory, host=None, port=None):
    """
    Serve local PyPI-compatible package index

    Args:        directory (str): Directory containing packages to serve        host (str): üåç Host to bind the server to        port (str): üîå Port to run the server on    """
    # TODO: Implement your business logic here
    print(f"Hook on_serve called")    print(f"Arguments:directory={directory}")    print(f"Options:host={host}, port={port}")
    # Return 0 for success, non-zero for error
    return 0
# Add any utility functions or classes here
'''
        return template

class HookNotFoundError(Exception):
    """Raised when a requested hook function is not found."""
    pass

class HookExecutionError(Exception):
    """Raised when a hook function execution fails."""
    pass

# Global hook manager instance
_hook_manager = None

def get_hook_manager() -> HookManager:
    """Get the global hook manager instance."""
    global _hook_manager
    if _hook_manager is None:
        _hook_manager = HookManager()
    return _hook_manager

def execute_hook(hook_name: str, *args, **kwargs) -> Any:
    """Convenience function to execute a hook."""
    return get_hook_manager().execute_hook(hook_name, *args, **kwargs)

def has_hook(hook_name: str) -> bool:
    """Convenience function to check if a hook exists."""
    return get_hook_manager().has_hook(hook_name)


# === Main CLI Content ===

#!/usr/bin/env python3
"""
Goobits CLI Framework - Build professional command-line tools with YAML configuration
Generated by Goobits CLI Framework
"""

import click
import sys
from typing import Any
try:
    from .hooks import execute_hook, has_hook
except ImportError:
    # Hooks not implemented yet
    pass
@click.group(
    name="Goobits CLI",
    help="Transform simple YAML configuration into rich terminal applications with setup scripts, dependency management, and cross-platform compatibility.",
    context_settings={"help_option_names": ["-h", "--help"]}
)
@click.version_option(version="1.2.0")
@click.option(
    "--verbose", "-v",
    help="Enable verbose output with detailed error messages and stack traces",
    is_flag=True,)
def cli(verbose):
    """Transform simple YAML configuration into rich terminal applications with setup scripts, dependency management, and cross-platform compatibility."""
    pass
@cli.command(name="build", help="Build CLI and setup scripts from goobits.yaml configuration")
@click.argument("config_path", required=False)
@click.option(
    "--output-dir", "-o",
    help="üìÅ Output directory (defaults to same directory as config file)",)
@click.option(
    "--output",
    help="üìù Output filename for generated CLI (defaults to 'generated_cli.py')",)
@click.option(
    "--backup",
    help="üíæ Create backup files (.bak) when overwriting existing files",
    is_flag=True,)
@click.option(
    "--universal-templates",
    help="üß™ Use Universal Template System (experimental)",
    is_flag=True,)
def build_command(config_path, output_dir, output, backup, universal_templates):
    """Build CLI and setup scripts from goobits.yaml configuration"""
    try:
        # Initialize error handler with verbose flag from global options
        ctx = click.get_current_context()
        verbose_flag = ctx.find_root().params.get('verbose', False)
        error_handler = ErrorHandler(verbose=verbose_flag)
        set_error_handler(error_handler)

        # Call the hook function if it exists
        hook_name = "on_build"
        if hook_name in globals():
            hook_func = globals()[hook_name]
            hook_func(config_path, output_dir, output, backup, universal_templates)
        else:
            click.echo(f"Hook function '{hook_name}' not implemented")
            sys.exit(1)
    except Exception as e:
        # Use error handler for proper verbose output
        try:
            error_handler = get_error_handler()
            error_handler.handle_error(e, "Command execution")
        except ImportError:
            click.echo(f"Error: {e}", err=True)
            # Try to get verbose flag again for fallback
            try:
                ctx = click.get_current_context()
                verbose_fallback = ctx.find_root().params.get('verbose', False)
                if verbose_fallback:
                    import traceback
                    traceback.print_exc()
            except:
                pass
            sys.exit(1)
@cli.command(name="init", help="Create initial goobits.yaml template")
@click.argument("project_name", required=False)
@click.option(
    "--template", "-t",
    help="üéØ Template type",    default='basic',)
@click.option(
    "--force",
    help="üî• Overwrite existing goobits.yaml file",
    is_flag=True,)
def init_command(project_name, template, force):
    """Create initial goobits.yaml template"""
    try:
        # Initialize error handler with verbose flag from global options
        ctx = click.get_current_context()
        verbose_flag = ctx.find_root().params.get('verbose', False)
        error_handler = ErrorHandler(verbose=verbose_flag)
        set_error_handler(error_handler)

        # Call the hook function if it exists
        hook_name = "on_init"
        if hook_name in globals():
            hook_func = globals()[hook_name]
            hook_func(project_name, template, force)
        else:
            click.echo(f"Hook function '{hook_name}' not implemented")
            sys.exit(1)
    except Exception as e:
        # Use error handler for proper verbose output
        try:
            error_handler = get_error_handler()
            error_handler.handle_error(e, "Command execution")
        except ImportError:
            click.echo(f"Error: {e}", err=True)
            # Try to get verbose flag again for fallback
            try:
                ctx = click.get_current_context()
                verbose_fallback = ctx.find_root().params.get('verbose', False)
                if verbose_fallback:
                    import traceback
                    traceback.print_exc()
            except:
                pass
            sys.exit(1)
@cli.command(name="serve", help="Serve local PyPI-compatible package index")
@click.argument("directory")
@click.option(
    "--host",
    help="üåç Host to bind the server to",    default='localhost',)
@click.option(
    "--port", "-p",
    help="üîå Port to run the server on",    default=8080,)
def serve_command(directory, host, port):
    """Serve local PyPI-compatible package index"""
    try:
        # Initialize error handler with verbose flag from global options
        ctx = click.get_current_context()
        verbose_flag = ctx.find_root().params.get('verbose', False)
        error_handler = ErrorHandler(verbose=verbose_flag)
        set_error_handler(error_handler)

        # Call the hook function if it exists
        hook_name = "on_serve"
        if hook_name in globals():
            hook_func = globals()[hook_name]
            hook_func(directory, host, port)
        else:
            click.echo(f"Hook function '{hook_name}' not implemented")
            sys.exit(1)
    except Exception as e:
        # Use error handler for proper verbose output
        try:
            error_handler = get_error_handler()
            error_handler.handle_error(e, "Command execution")
        except ImportError:
            click.echo(f"Error: {e}", err=True)
            # Try to get verbose flag again for fallback
            try:
                ctx = click.get_current_context()
                verbose_fallback = ctx.find_root().params.get('verbose', False)
                if verbose_fallback:
                    import traceback
                    traceback.print_exc()
            except:
                pass
            sys.exit(1)
if __name__ == "__main__":
    cli()