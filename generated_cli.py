#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Goobits CLI Framework - Build professional command-line tools with YAML configuration
Generated by Goobits CLI Framework v

This is a consolidated Python CLI file with all utilities embedded.
Generated from: goobits.yaml
"""

import sys
import os
import json
import yaml
import traceback
from pathlib import Path
from typing import Any, Dict, Optional, List, Union
from datetime import datetime
from contextlib import contextmanager
import rich_click as click
# ============================================================================
# EMBEDDED LOGGER
# ============================================================================

class ColoredFormatter(__import__('logging').Formatter):
    """Custom formatter with color support."""
    
    COLORS = {
        'DEBUG': '\033[36m',    # Cyan
        'INFO': '\033[32m',     # Green
        'WARNING': '\033[33m',  # Yellow
        'ERROR': '\033[31m',    # Red
        'CRITICAL': '\033[35m', # Magenta
    }
    RESET = '\033[0m'
    
    def format(self, record):
        log_color = self.COLORS.get(record.levelname, self.RESET)
        record.levelname = f"{log_color}{record.levelname}{self.RESET}"
        return super().format(record)

def setup_logging(level=__import__('logging').INFO, log_file=None):
    """Configure logging for the CLI."""
    handlers = []
    
    # Console handler with colors
    logging = __import__('logging')
    console_handler = logging.StreamHandler()
    console_handler.setFormatter(ColoredFormatter(
        '%(asctime)s - %(levelname)s - %(message)s',
        datefmt='%Y-%m-%d %H:%M:%S'
    ))
    handlers.append(console_handler)
    
    # File handler if specified
    if log_file:
        file_handler = logging.FileHandler(log_file)
        file_handler.setFormatter(logging.Formatter(
            '%(asctime)s - %(levelname)s - %(name)s - %(message)s'
        ))
        handlers.append(file_handler)
    
    logging.basicConfig(
        level=level,
        handlers=handlers
    )

logger = __import__('logging').getLogger(__name__)

# ============================================================================
# EMBEDDED CONFIG MANAGER
# ============================================================================

class ConfigManager:
    """Manage CLI configuration."""
    
    def __init__(self, config_file: Optional[Path] = None):
        """Initialize configuration manager."""
        if config_file is None:
            config_dir = Path.home() / '.config' / 'goobits'
            config_dir.mkdir(parents=True, exist_ok=True)
            config_file = config_dir / 'config.yaml'
        
        self.config_file = Path(config_file)
        self.config = self._load_config()
    
    def _load_config(self) -> Dict[str, Any]:
        """Load configuration from file."""
        if self.config_file.exists():
            try:
                with open(self.config_file, 'r') as f:
                    return yaml.safe_load(f) or {}
            except Exception as e:
                logger.warning(f"Failed to load config: {e}")
                return {}
        return {}
    
    def save_config(self) -> bool:
        """Save configuration to file."""
        try:
            with open(self.config_file, 'w') as f:
                yaml.safe_dump(self.config, f, default_flow_style=False)
            return True
        except Exception as e:
            logger.error(f"Failed to save config: {e}")
            return False
    
    def get(self, key: str, default: Any = None) -> Any:
        """Get configuration value."""
        keys = key.split('.')
        value = self.config
        for k in keys:
            if isinstance(value, dict):
                value = value.get(k)
                if value is None:
                    return default
            else:
                return default
        return value
    
    def set(self, key: str, value: Any):
        """Set configuration value."""
        keys = key.split('.')
        config = self.config
        for k in keys[:-1]:
            if k not in config:
                config[k] = {}
            config = config[k]
        config[keys[-1]] = value

# ============================================================================
# EMBEDDED ERROR HANDLER
# ============================================================================

class CLIError(Exception):
    """Base exception for CLI errors."""
    exit_code = 1

class UsageError(CLIError):
    """Exception for usage errors."""
    exit_code = 2

class ConfigError(CLIError):
    """Exception for configuration errors."""
    exit_code = 3

def handle_error(error: Exception, verbose: bool = False):
    """Handle CLI errors consistently."""
    if isinstance(error, CLIError):
        logger.error(str(error))
        if verbose:
            logger.debug(traceback.format_exc())
        sys.exit(error.exit_code)
    else:
        logger.error(f"Unexpected error: {error}")
        if verbose:
            logger.debug(traceback.format_exc())
        else:
            logger.info("Run with --verbose for more details")
        sys.exit(1)

# ============================================================================
# CLI CONTEXT
# ============================================================================

class CLIContext:
    """Shared context for CLI commands."""
    
    def __init__(self, config: ConfigManager, verbose: bool = False, debug: bool = False):
        self.config = config
        self.verbose = verbose
        self.debug = debug
        
        # Setup logging based on verbosity
        logging = __import__('logging')
        if debug:
            setup_logging(logging.DEBUG)
        elif verbose:
            setup_logging(logging.INFO)
        else:
            setup_logging(logging.WARNING)

# ============================================================================
# HOOK SYSTEM
# ============================================================================

def load_hooks():
    """Load user-defined hooks."""
    try:
        import cli_hooks
        return cli_hooks
    except ImportError:
        # Check if this is self-hosting (framework building itself)
        try:
            from goobits_cli import main as goobits_main
            # If we can import main, this is the framework building itself - suppress warnings
            return None  
        except ImportError:
            # Only show warning if not in help mode
            if '--help' not in sys.argv and '-h' not in sys.argv:
                logger.warning("No cli_hooks.py found. Please create one with your command implementations.")
                logger.warning("Example:")
                logger.warning("  def on_b(ctx, **kwargs):")
                logger.warning("      print('Command implementation')")
            return None

hooks = load_hooks()

# ============================================================================
# CLI COMMANDS
# ============================================================================

@click.group(context_settings={'help_option_names': ['-h', '--help']})
@click.version_option(version='3.0.1', prog_name='goobits')
@click.option('--verbose', '-v', is_flag=True, help='Enable verbose output')
@click.option('--debug', is_flag=True, help='Enable debug output')
@click.option('--config', type=click.Path(), help='Path to config file')
@click.pass_context
def cli(ctx, verbose, debug, config):
    """Build professional command-line tools with YAML configuration

üöÄ Quick Start
   mkdir my-cli && cd my-cli - Create new project directory
   goobits init - Generate initial goobits.yaml
   goobits build - Create CLI and setup scripts
   ./setup.sh install --dev - Install for development

üí° Core Commands
   build - üî® Generate CLI and setup scripts from goobits.yaml
   serve - üåê Serve local PyPI-compatible package index
   init - üÜï Create initial goobits.yaml template

üîß Development Workflow
   1. Edit goobits.yaml - Define your CLI structure
   2. goobits build - Generate implementation files
   3. Edit cli_hooks.py - Add your business logic


üìö For detailed help on a command, run: [green]goobits [COMMAND][/green] [#ff79c6]--help[/#ff79c6]
"""
    config_path = Path(config) if config else None
    config_manager = ConfigManager(config_path)
    ctx.obj = CLIContext(config_manager, verbose, debug)

@cli.command('build')
@click.argument('config_path', type=click.STRING)
@click.option('--output-dir', '-o', default=None, help='üìÅ Output directory (defaults to same directory as config file)')
@click.option('--output', default=None, help="üìù Output filename for generated CLI (defaults to 'generated_cli.py')")
@click.option('--backup', default=None, help='üíæ Create backup files (.bak) when overwriting existing files')
@click.pass_obj
def build(ctx, config_path, output_dir, output, backup):
    """Build CLI and setup scripts from goobits.yaml configuration"""
    try:
        # Check if this is self-hosting case  
        is_self_hosting = False
        try:
            from goobits_cli import main as goobits_main
            is_self_hosting = True
        except ImportError:
            pass
            
        if hooks and hasattr(hooks, 'on_build'):
            kwargs = {                'config_path': config_path,
                'output_dir': output_dir,
                'output': output,
                'backup': backup,
}
            hooks.on_build(ctx=ctx, **kwargs)
        elif is_self_hosting:
            # Self-hosting: call main.py implementation directly
            from goobits_cli.main import build as main_build
            from pathlib import Path
            
            # Handle build command arguments
            main_build(
                config_path=Path(config_path) if config_path else None,                output_dir=Path(output_dir) if output_dir else None,                output=output,                backup=bool(backup),            )
        else:
            logger.error(f"Hook 'on_build' not implemented in cli_hooks.py")
            sys.exit(1)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.command('init')
@click.argument('project_name', type=click.STRING)
@click.option('--template', '-t', default='basic', help='üéØ Template type')
@click.option('--force', default=None, help='üî• Overwrite existing goobits.yaml file')
@click.pass_obj
def init(ctx, project_name, template, force):
    """Create initial goobits.yaml template"""
    try:
        # Check if this is self-hosting case  
        is_self_hosting = False
        try:
            from goobits_cli import main as goobits_main
            is_self_hosting = True
        except ImportError:
            pass
            
        if hooks and hasattr(hooks, 'on_init'):
            kwargs = {                'project_name': project_name,
                'template': template,
                'force': force,
}
            hooks.on_init(ctx=ctx, **kwargs)
        elif is_self_hosting:
            # Self-hosting: call main.py implementation directly
            from goobits_cli.main import init as main_init
            from pathlib import Path
            
            # Handle other commands - call with converted arguments
            main_init(                project_name=project_name,
                template=template,
                force=force,
            )
        else:
            logger.error(f"Hook 'on_init' not implemented in cli_hooks.py")
            sys.exit(1)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.command('serve')
@click.argument('directory', type=click.STRING)
@click.option('--host', default='localhost', help='üåç Host to bind the server to')
@click.option('--port', '-p', default=8080, help='üîå Port to run the server on')
@click.pass_obj
def serve(ctx, directory, host, port):
    """Serve local PyPI-compatible package index"""
    try:
        # Check if this is self-hosting case  
        is_self_hosting = False
        try:
            from goobits_cli import main as goobits_main
            is_self_hosting = True
        except ImportError:
            pass
            
        if hooks and hasattr(hooks, 'on_serve'):
            kwargs = {                'directory': directory,
                'host': host,
                'port': port,
}
            hooks.on_serve(ctx=ctx, **kwargs)
        elif is_self_hosting:
            # Self-hosting: call main.py implementation directly
            from goobits_cli.main import serve as main_serve
            from pathlib import Path
            
            # Handle other commands - call with converted arguments
            main_serve(                directory=directory,
                host=host,
                port=port,
            )
        else:
            logger.error(f"Hook 'on_serve' not implemented in cli_hooks.py")
            sys.exit(1)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.command('validate')
@click.argument('config_path', type=click.STRING)
@click.option('--verbose', '-v', default=None, help='üìã Show detailed validation information')
@click.pass_obj
def validate(ctx, config_path, verbose):
    """Validate goobits.yaml configuration without generating files"""
    try:
        # Check if this is self-hosting case  
        is_self_hosting = False
        try:
            from goobits_cli import main as goobits_main
            is_self_hosting = True
        except ImportError:
            pass
            
        if hooks and hasattr(hooks, 'on_validate'):
            kwargs = {                'config_path': config_path,
                'verbose': verbose,
}
            hooks.on_validate(ctx=ctx, **kwargs)
        elif is_self_hosting:
            # Self-hosting: call main.py implementation directly
            from goobits_cli.main import validate as main_validate
            from pathlib import Path
            
            # Handle other commands - call with converted arguments
            main_validate(                config_path=config_path,
                verbose=verbose,
            )
        else:
            logger.error(f"Hook 'on_validate' not implemented in cli_hooks.py")
            sys.exit(1)
    except Exception as e:
        handle_error(e, ctx.verbose)
@cli.command('migrate')
@click.argument('path', type=click.STRING)
@click.option('--backup', default=True, help='üíæ Create backup files (.bak)')
@click.option('--dry-run', default=None, help='üëÅÔ∏è Show changes without applying them')
@click.option('--pattern', default='*.yaml', help='üîç File pattern for directory migration')
@click.pass_obj
def migrate(ctx, path, backup, dry_run, pattern):
    """Migrate YAML configurations to 3.0.0 format"""
    try:
        # Check if this is self-hosting case  
        is_self_hosting = False
        try:
            from goobits_cli import main as goobits_main
            is_self_hosting = True
        except ImportError:
            pass
            
        if hooks and hasattr(hooks, 'on_migrate'):
            kwargs = {                'path': path,
                'backup': backup,
                'dry_run': dry_run,
                'pattern': pattern,
}
            hooks.on_migrate(ctx=ctx, **kwargs)
        elif is_self_hosting:
            # Self-hosting: call main.py implementation directly
            from goobits_cli.main import migrate as main_migrate
            from pathlib import Path
            
            # Handle other commands - call with converted arguments
            main_migrate(                path=path,
                backup=backup,
                dry_run=dry_run,
                pattern=pattern,
            )
        else:
            logger.error(f"Hook 'on_migrate' not implemented in cli_hooks.py")
            sys.exit(1)
    except Exception as e:
        handle_error(e, ctx.verbose)

# ============================================================================
# INTERACTIVE MODE (if enabled)
# ============================================================================
# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

def main():
    """Main entry point for the CLI."""
    import sys
    
    # Add spacing before command output (except when output is redirected)
    if sys.stdout.isatty():
        print()  # Empty line before
    
    try:
        cli(prog_name='goobits')
    except Exception as e:
        handle_error(e, '--verbose' in sys.argv or '--debug' in sys.argv)
    finally:
        # Add spacing after command output (except when output is redirected)
        if sys.stdout.isatty():
            print()  # Empty line after

if __name__ == '__main__':
    main()